<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watchmen1992&#39;s Blog</title>
  
  <subtitle>锦瑟年华当与书香为度，是为不负天地人生。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-05T03:12:59.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>XiaoHua WANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python日志处理</title>
    <link href="http://yoursite.com/2018/12/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/python%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/05/编程语言/Python/基础知识/python日志处理/</id>
    <published>2018-12-05T03:12:59.000Z</published>
    <updated>2018-12-05T03:12:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.cnblogs.com/yyds/p/6901864.html" target="_blank" rel="noopener">Python之日志处理（logging模块）</a></li><li><a href="https://docs.python.org/3/library/logging.html?highlight=logging#module-logging" target="_blank" rel="noopener">官方文档</a></li></ul><h1 id="日志相关概念"><a href="#日志相关概念" class="headerlink" title="日志相关概念"></a>日志相关概念</h1><p>日志是一种可以追踪某些软件运行时所发生事件的方法。软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情。一个事件可以用一个可包含可选变量数据的消息来描述。此外，事件也有重要性的概念，这个重要性也可以被称为严重性级别（level）。</p><p><strong>总结重点：</strong></p><ul><li>追踪记录程序运行时发生的事件</li><li>实现：在代码中调用日志处理方法</li><li>事件有严重性级别</li></ul><h2 id="日志作用"><a href="#日志作用" class="headerlink" title="日志作用"></a>日志作用</h2><p>通过对log进行分析，可以</p><ol><li>方便用户了解系统或软件、应用的运行情况；</li><li>如果你的应用log足够丰富，也可以分析以往用户的操作行为、类型喜好、地域分布或其他更多信息；</li><li>如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。</li></ol><p>简单来讲就是：我们通过记录和分析日志可以了解一个系统或软件程序运行情况是否正常，也可以在应用程序出现故障时快速定位问题。</p><p>比如，做运维的同学，在接收到报警或各种问题反馈后，进行问题排查时通常都会先去看各种日志，大部分问题都可以在日志中找到答案。</p><p>再比如，做开发的同学，可以通过IDE控制台上输出的各种日志进行程序调试。</p><p>对于运维老司机或者有经验的开发人员，可以快速的通过日志定位到问题的根源。可见，日志的重要性不可小觑。</p><p>如果应用的日志信息足够详细和丰富，还可以用来做用户行为分析，如：分析用户的操作行为、类型洗好、地域分布以及其它更多的信息，由此可以实现改进业务、提高商业利益。</p><p><strong>日志作用简单总结：</strong></p><ul><li>程序调试</li><li>了解软件程序<strong><code>运行状况</code></strong>是否正常</li><li>软件程序运行故障时<strong><code>定位问题及分析问题</code></strong></li><li>用户行为分析，并以此改进业务等</li></ul><h2 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h2><p>在软件开发阶段或部署开发环境时，为了尽可能详细的查看应用程序的运行状态来保证上线后的稳定性，我们需要把该应用程序所有的运行日志全部记录下来进行分析，这是非常耗费机器性能的。当应用程序在生产环境正式部署时，我们通常只记录应用程序的异常信息、错误信息等，这样既可以减小服务器的I/O压力，也可以避免我们在排查故障时被淹没在日志的海洋里。</p><p>那么，怎样才能在不改动应用程序代码的情况下实现在不同的环境记录不同详细程度的日志呢？这就是日志等级的作用了，我们通过配置文件指定我们需要的日志等级就可以了。</p><p>不同的应用程序所定义的日志等级可能会有所差别，分的详细点的会包含以下几个等级：</p><ul><li>DEBUG</li><li>INFO</li><li>NOTICE</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li><li>ALERT</li><li>EMERGENCY</li></ul><h2 id="日志字段信息与日志格式"><a href="#日志字段信息与日志格式" class="headerlink" title="日志字段信息与日志格式"></a>日志字段信息与日志格式</h2><p>一条日志信息对应的是一个<strong><code>需要关注的事件</code></strong>的发生，因此通常需要包括以下几个内容：</p><ul><li><p>事件的严重程度（日志级别）</p></li><li><p>事件发生时间</p></li><li>事件发生位置</li><li>事件内容</li></ul><p>上面这些都是一条日志记录中可能包含的字段信息，当然还可以包括一些其他信息，如进程ID、进程名称、线程ID、线程名称等。</p><p><strong>日志格式</strong>就是用来<strong>定义</strong>一条日志记录中<strong>包含哪些字段</strong>及其组合顺序及方式，且日志格式通常都是可以自定义的。</p><p><strong>注意：</strong>输出一条日志时，日志内容和日志级别是需要开发人员明确指定的。对于而其它字段信息，只需要是否显示在日志中就可以了。</p><h2 id="日志功能实现"><a href="#日志功能实现" class="headerlink" title="日志功能实现"></a>日志功能实现</h2><p>几乎所有开发语言都会内置日志相关功能，或者会有比较优秀的第三方库来提供日志操作功能，比如：log4j，log4php等。它们功能强大、使用简单。Python自身也提供了一个用于记录日志的标准库模块-logging。</p><h1 id="python日志处理基本概念"><a href="#python日志处理基本概念" class="headerlink" title="python日志处理基本概念"></a>python日志处理基本概念</h1><p>我们在Python中一般使用logging模块实现日志功能，因此我们在这里说的python日志处理实际上是logging模块相关内容。</p><p>logging模块是Python的一个标准库模块，由标准库模块提供日志记录API的关键好处是所有Python模块都可以使用这个日志记录功能。所以，你的应用日志可以将你自己的日志信息与来自第三方模块的信息整合起来。</p><h2 id="logging模块支持日志级别"><a href="#logging模块支持日志级别" class="headerlink" title="logging模块支持日志级别"></a>logging模块支持日志级别</h2><p>logging模块并不支持我们上面说的所有级别，它默认定义了以下几个日志等级</p><table><thead><tr><th>日志等级（level）</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>最详细的日志信息，典型应用场景是 问题诊断</td></tr><tr><td>INFO</td><td>信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作</td></tr><tr><td>WARNING</td><td>当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的</td></tr><tr><td>ERROR</td><td>由于一个更严重的问题导致某些功能不能正常运行时记录的信息</td></tr><tr><td>CRITICAL</td><td>当发生严重错误，导致应用程序不能继续运行时记录的信息</td></tr></tbody></table><p>开发应用程序或部署开发环境时，可以使用DEBUG或INFO级别的日志获取尽可能详细的日志信息来进行开发或部署调试；</p><p>应用上线或部署生产环境时，应该使用WARNING或ERROR或CRITICAL级别的日志来降低机器的I/O压力和提高获取错误日志信息的效率。日志级别的指定通常都是在应用程序的配置文件中进行指定的。</p><p><strong>说明：</strong></p><ul><li>上面列表中的日志等级是从上到下依次升高的，即：DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL，而日志的信息量是依次减少的；</li><li>当为某个应用程序指定一个日志级别后，应用程序会记录所有日志级别<strong><code>大于或等于</code></strong>指定日志级别的日志信息，而不是仅仅记录指定级别的日志信息，nginx、php等应用程序以及这里python的logging模块都是这样的。同样，logging模块也可以指定日志记录器的日志级别，只有级别大于或等于该指定日志级别的日志记录才会被输出，小于该等级的日志记录将会被丢弃。</li></ul><h2 id="logging模块的两种实现方式"><a href="#logging模块的两种实现方式" class="headerlink" title="logging模块的两种实现方式"></a>logging模块的两种实现方式</h2><p>logging模块提供了两种记录日志的方式：</p><ul><li>第一种方式是使用logging提供的<strong><code>模块级别的函数</code></strong></li><li>第二种方式是使用Logging日志系统的<strong><code>四大组件</code></strong></li></ul><p><strong>logging模块定义的模块级别常用函数</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>logging.debug(msg, <em>args, *</em>kwargs)</td><td>创建一条严重级别为DEBUG的日志记录</td></tr><tr><td>logging.info(msg, <em>args, *</em>kwargs)</td><td>创建一条严重级别为INFO的日志记录</td></tr><tr><td>logging.warning(msg, <em>args, *</em>kwargs)</td><td>创建一条严重级别为WARNING的日志记录</td></tr><tr><td>logging.error(msg, <em>args, *</em>kwargs)</td><td>创建一条严重级别为ERROR的日志记录</td></tr><tr><td>logging.critical(msg, <em>args, *</em>kwargs)</td><td>创建一条严重级别为CRITICAL的日志记录</td></tr><tr><td>logging.log(level, <em>args, *</em>kwargs)</td><td>创建一条严重级别为level的日志记录</td></tr><tr><td>logging.basicConfig(**kwargs)</td><td>对root logger进行一次性配置</td></tr></tbody></table><p>其中<code>logging.basicConfig(**kwargs)</code>函数用于指定“要记录的日志级别”、“日志格式”、“日志输出位置”、“日志文件的打开模式”等信息，其他几个都是用于记录各个级别日志的函数。</p><p><strong>logging模块日志系统的四大组件</strong></p><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td>loggers</td><td>提供应用程序代码直接使用的接口</td></tr><tr><td>handlers</td><td>用于将日志记录发送到指定的目的位置进行输出</td></tr><tr><td>filters</td><td>提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略）</td></tr><tr><td>formatters</td><td>用于控制日志信息的最终输出格式</td></tr></tbody></table><p><strong>说明：</strong> logging模块提供的模块级别的那些函数实际上也是通过这几个组件的相关实现类来记录日志的，只是在创建这些类的实例时设置了一些默认值。</p><h2 id="实现方式1-使用logging提供的模块级别函数记录日志"><a href="#实现方式1-使用logging提供的模块级别函数记录日志" class="headerlink" title="实现方式1-使用logging提供的模块级别函数记录日志"></a>实现方式1-使用logging提供的模块级别函数记录日志</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging.debug(&quot;debug log&quot;)</span><br><span class="line">logging.info(&quot;info log&quot;)</span><br><span class="line">logging.warning(&quot;warning log&quot;)</span><br><span class="line">logging.error(&quot;error log&quot;)</span><br><span class="line">logging.critical(&quot;critical log&quot;)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING:root:warning log</span><br><span class="line">ERROR:root:error log</span><br><span class="line">CRITICAL:root:critical log</span><br></pre></td></tr></table></figure><p>这里需要注意的是：logging模块提供的<strong><code>日志记录函数</code></strong>所使用的日志器设置的日志级别是<code>WARNING</code>，因此只有<code>WARNING</code>级别的日志记录以及大于它的<code>ERROR</code>和<code>CRITICAL</code>级别的日志记录被输出了，而小于它的<code>DEBUG</code>和<code>INFO</code>级别的日志记录被丢弃了。</p><p>几个注意事项：</p><ul><li><p>默认的输出格式为：<strong><code>日志级别:日志器名称:日志内容</code></strong></p><p>之所以会这样输出，是因为logging模块提供的日志记录函数所使用的日志器设置的日志格式默认是BASIC_FORMAT，其值为：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;%(levelname)s:%(name)s:%(message)s&quot;</span><br></pre></td></tr></table></figure></li><li><p>日志记录函数所使用的<strong>日志器</strong>设置的<strong>处理器</strong>所指定的日志输出位置默认为:<code>sys.stderr</code></p></li><li><p>日志器（Logger）是有层级关系的，上面调用的logging模块级别的函数所使用的日志器是<code>RootLogger</code>类的实例，其名称为’root’，它是处于日志器层级关系最顶层的日志器，且该实例是以单例模式存在的。</p></li><li><p>源码实现：</p><p>查看这些日志记录函数的实现代码，可以发现：当我们没有提供任何配置信息的时候，这些函数都会去调用<code>logging.basicConfig(**kwargs)</code>方法，且不会向该方法传递任何参数。继续查看<code>basicConfig()</code>方法的代码就可以找到上面这些问题的答案了。</p></li><li><p>如何修改默认配置</p><p>在我们调用上面这些日志记录函数之前，手动调用一下basicConfig()方法，把我们想设置的内容以参数的形式传递进去就可以了</p><p>在我们需要将日志内容从控制台输出重定向到文件时需要修改配置</p></li></ul><h3 id="logging-basicConfig-函数"><a href="#logging-basicConfig-函数" class="headerlink" title="logging.basicConfig()函数"></a>logging.basicConfig()函数</h3><p>该方法用于为logging日志系统做一些基本配置，方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(**kwargs)</span><br></pre></td></tr></table></figure><p>该函数可接收的关键字参数如下：</p><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td>filename</td><td>指定日志输出目标文件的文件名，指定该设置项后日志就不会被输出到控制台了</td></tr><tr><td>filemode</td><td>指定日志文件的打开模式，默认为’a’。需要注意的是，该选项要在filename指定时才有效</td></tr><tr><td>format</td><td>指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段下面会列出。</td></tr><tr><td>datefmt</td><td>指定日期/时间格式。需要注意的是，该选项要在format中包含时间字段%(asctime)s时才有效</td></tr><tr><td>level</td><td>指定日志器的日志级别</td></tr><tr><td>stream</td><td>指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 <code>ValueError</code>异常</td></tr><tr><td>style</td><td>Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为’%’、’{‘和’$’，默认为’%’</td></tr><tr><td>handlers</td><td>Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。</td></tr></tbody></table><p>logging模块中定义好的可以用于format格式字符串中的字段：</p><table><thead><tr><th>字段/属性名称</th><th>使用格式</th><th>描述</th></tr></thead><tbody><tr><td>asctime</td><td>%(asctime)s</td><td>日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896</td></tr><tr><td>created</td><td>%(created)f</td><td>日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值</td></tr><tr><td>relativeCreated</td><td>%(relativeCreated)d</td><td>日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的）</td></tr><tr><td>msecs</td><td>%(msecs)d</td><td>日志事件发生事件的毫秒部分</td></tr><tr><td>levelname</td><td>%(levelname)s</td><td>该日志记录的文字形式的日志级别（’DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’）</td></tr><tr><td>levelno</td><td>%(levelno)s</td><td>该日志记录的数字形式的日志级别（10, 20, 30, 40, 50）</td></tr><tr><td>name</td><td>%(name)s</td><td>所使用的<strong>日志器名称</strong>，默认是’root’，因为默认使用的是 rootLogger</td></tr><tr><td>message</td><td>%(message)s</td><td>日志记录的文本内容，通过 <code>msg % args</code>计算得到的</td></tr><tr><td>pathname</td><td>%(pathname)s</td><td>调用日志记录函数的源码文件的全路径</td></tr><tr><td>filename</td><td>%(filename)s</td><td>pathname的文件名部分，包含文件后缀</td></tr><tr><td>module</td><td>%(module)s</td><td>filename的名称部分，不包含后缀</td></tr><tr><td>lineno</td><td>%(lineno)d</td><td>调用日志记录函数的源代码所在的行号</td></tr><tr><td>funcName</td><td>%(funcName)s</td><td>调用日志记录函数的函数名</td></tr><tr><td>process</td><td>%(process)d</td><td>进程ID</td></tr><tr><td>processName</td><td>%(processName)s</td><td>进程名称，Python 3.1新增</td></tr><tr><td>thread</td><td>%(thread)d</td><td>线程ID</td></tr><tr><td>threadName</td><td>%(thread)s</td><td>线程名称</td></tr></tbody></table><h3 id="实际配置案例"><a href="#实际配置案例" class="headerlink" title="实际配置案例"></a>实际配置案例</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">import time</span><br><span class="line">from os import path</span><br><span class="line"></span><br><span class="line"># 定义日志文件名称格式</span><br><span class="line">base_log_name = path.abspath(path.dirname(path.dirname(__file__))) + &apos;/logs/&apos; + &quot;dcache.log&quot; + &quot;-&quot;</span><br><span class="line">info_log_filename = base_log_name + time.strftime(&apos;%Y-%m-%d-%H&apos;) + &quot;-&quot; + time.strftime(&apos;%H&apos;)</span><br><span class="line">error_log_filename = base_log_name + &quot;error.log&quot;</span><br><span class="line">warn_log_filename = base_log_name + &quot;warn.log&quot;</span><br><span class="line"></span><br><span class="line"># 定义日志的输出格式</span><br><span class="line">log_format = &quot;%(asctime)s - %(levelname)s - %(pathname)s[line:%(lineno)d] - %(message)s&quot;</span><br><span class="line">logging.basicConfig(filename=info_log_filename,level=logging.DEBUG,format=log_format)</span><br><span class="line"></span><br><span class="line"># 日志记录，第一种方式来源方式2，下面会将</span><br><span class="line">log = logging.getLogger(&apos;root&apos;)</span><br><span class="line">log.info(&quot;info log&quot;)</span><br><span class="line">或者</span><br><span class="line">logging.info(&quot;info log&quot;)</span><br></pre></td></tr></table></figure><p>在这里使用了以下字段：</p><ul><li>asctime    事件发生的时间</li><li>levelname 事件的等级</li><li>pathname 产生事件的文件的绝对路径</li><li>lineno 调用日志记录函数的源代码所在的行号</li><li>message 日志记录的文本内容</li></ul><p>日志的输出格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-12-07 11:10:33,546 - INFO - /Users/wangxiaohua/PycharmProjects/dcache/lib/logger.py[line:35] - info log</span><br></pre></td></tr></table></figure><h2 id="实现方式2-使用四大组件记录日志"><a href="#实现方式2-使用四大组件记录日志" class="headerlink" title="实现方式2-使用四大组件记录日志"></a>实现方式2-使用四大组件记录日志</h2><h3 id="logging模块的四大组件"><a href="#logging模块的四大组件" class="headerlink" title="logging模块的四大组件"></a>logging模块的四大组件</h3><table><thead><tr><th>组件名称</th><th>对应类名</th><th>功能描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供了应用程序可一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将logger创建的日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filter</td><td>提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table><p>logging模块就是通过这些组件来完成日志处理的，上面所使用的logging模块级别的函数也是通过这些组件对应的类来实现的。 </p><p><strong>这些组件之间的关系描述：</strong></p><ul><li>日志器/记录器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等；</li><li>不同的处理器（handler）可以将日志输出到不同的位置；</li><li>日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置；</li><li>每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志；</li><li>每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。</li></ul><p>简单点说就是：<strong>日志器（logger）是入口</strong>，真正干活儿的是处理器（handler），处理器（handler）还可以通过过滤器（filter）和格式器（formatter）对要输出的日志内容做过滤和格式化等处理操作。</p><h3 id="四大组件相关类及其常用方法"><a href="#四大组件相关类及其常用方法" class="headerlink" title="四大组件相关类及其常用方法"></a>四大组件相关类及其常用方法</h3><p>下面介绍下与logging四大组件相关的类：Logger, Handler, Filter, Formatter。</p><h4 id="logger类"><a href="#logger类" class="headerlink" title="logger类"></a>logger类</h4><p>Logger对象，也就是日志器有3个任务要做：</p><ul><li><p>向应用程序代码暴露几个方法，使应用程序可以在运行时记录日志消息；</p></li><li><p>基于日志严重等级（默认的过滤设施）或filter对象来决定要对哪些日志进行后续处理；</p><p>也就是说logger日志器这一层就会对日志做初步的过滤</p></li><li><p>将日志消息传送给所有感兴趣的日志handlers。</p></li></ul><p>Logger对象最常用的方法分为两类：<strong><code>配置方法 和 消息发送方法</code></strong></p><p><strong>常用配置方法：</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Logger.setLevel()</td><td>设置日志器将会处理的日志消息的最低严重级别</td></tr><tr><td>Logger.addHandler() 和 Logger.removeHandler()</td><td>为该logger对象添加 和 移除一个handler对象</td></tr><tr><td>Logger.addFilter() 和 Logger.removeFilter()</td><td>为该logger对象添加 和 移除一个filter对象</td></tr></tbody></table><p>关于Logger.setLevel()方法的说明：</p><blockquote><p>内建等级中，级别最低的是DEBUG，级别最高的是CRITICAL。例如setLevel(logging.INFO)，此时函数参数为INFO，那么该logger将只会处理INFO、WARNING、ERROR和CRITICAL级别的日志，而DEBUG级别的消息将会被忽略/丢弃。</p></blockquote><p>logger对象配置完成后，可以使用下面的方法来创建日志记录：</p><p><strong>常用消息发送方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Logger.debug(), Logger.info(), Logger.warning(), Logger.error(), Logger.critical()</td><td>创建一个与它们的方法名对应等级的日志记录</td></tr><tr><td>Logger.exception()</td><td>创建一个类似于Logger.error()的日志消息</td></tr><tr><td>Logger.log()</td><td>需要获取一个明确的日志level参数来创建一个日志记录</td></tr></tbody></table><p>说明：</p><blockquote><ul><li>Logger.exception()与Logger.error()的区别在于：Logger.exception()将会输出堆栈追踪信息，另外通常只是在一个exception handler中调用该方法。</li><li>Logger.log()的用法为：logging.log(logging.ERROR,”log message”)</li><li>Logger.log()与Logger.debug()、Logger.info()等方法相比，虽然需要多传一个level参数，显得不是那么方便，但是当需要记录自定义level的日志时还是需要该方法来完成。</li></ul></blockquote><p>如何得到一个Logger对象呢？一种方式是通过Logger类的实例化方法创建一个Logger类的实例，但是我们通常都是用第二种方式–logging.getLogger()方法。</p><p>logging.getLogger()方法有一个可选参数name，该参数表示将要返回的日志器的名称标识，如果不提供该参数，则其值为’root’。若以相同的name参数值多次调用getLogger()方法，将会返回指向同一个logger对象的引用。</p><h5 id="关于logger的层级结构与有效等级的说明"><a href="#关于logger的层级结构与有效等级的说明" class="headerlink" title="关于logger的层级结构与有效等级的说明"></a>关于logger的层级结构与有效等级的说明</h5><ul><li>logger的名称是一个以’.’分割的层级结构，每个’.’后面的logger都是’.’前面的logger的children，例如，有一个名称为 foo 的logger，其它名称分别为 foo.bar, foo.bar.baz 和 foo.bam都是 foo 的后代。</li><li>logger有一个”有效等级（effective level）”的概念。如果一个logger上没有被明确设置一个level，那么该logger就是使用它parent的level;如果它的parent也没有明确设置level则继续向上查找parent的parent的有效level，依次类推，直到找到个一个明确设置了level的祖先为止。需要说明的是，root logger总是会有一个明确的level设置（默认为 WARNING）。当决定是否去处理一个已发生的事件时，logger的有效等级将会被用来决定是否将该事件传递给该logger的handlers进行处理。</li><li>child loggers在完成对日志消息的处理后，默认会将日志消息传递给与它们的祖先loggers相关的handlers。因此，我们不必为一个应用程序中所使用的所有loggers定义和配置handlers，只需要为一个顶层的logger配置handlers，然后按照需要创建child loggers就可足够了。我们也可以通过将一个logger的propagate属性设置为False来关闭这种传递机制。</li></ul><p>也就是说：四大组件是一种分层的架构，不管是父logger还是子logger，只要是logger，都是在handler层级之上的，所以child logger处理之后，会把消息传递给父logger的handler</p><h4 id="Handler类"><a href="#Handler类" class="headerlink" title="Handler类"></a>Handler类</h4><p>Handler对象的作用是（基于日志消息的level）将消息分发到handler指定的位置（文件、网络、邮件等）。Logger对象可以通过addHandler()方法为自己添加0个或者更多个handler对象。比如，一个应用程序可能想要实现以下几个日志需求：</p><ul><li>1）把所有日志都发送到一个日志文件中；</li><li>2）把所有严重级别大于等于error的日志发送到stdout（标准输出）；</li><li>3）把所有严重级别为critical的日志发送到一个email邮件地址。<br>这种场景就需要3个不同的handlers，每个handler负责发送一个特定严重级别的日志到一个特定的位置。</li></ul><p>一个handler中只有非常少数的方法是需要应用开发人员去关心的。对于使用内建handler对象的应用开发人员来说，似乎唯一相关的handler方法就是下面这几个配置方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Handler.setLevel()</td><td>设置handler将会处理的日志消息的最低严重级别</td></tr><tr><td>Handler.setFormatter()</td><td>为handler设置一个格式器对象</td></tr><tr><td>Handler.addFilter() 和 Handler.removeFilter()</td><td>为handler添加 和 删除一个过滤器对象</td></tr></tbody></table><p>需要说明的是，应用程序代码不应该直接实例化和使用Handler实例。因为Handler是一个基类，它只定义了所有handlers都应该有的接口，同时提供了一些子类可以直接使用或覆盖的默认行为。下面是一些常用的Handler：</p><table><thead><tr><th>Handler</th><th>描述</th></tr></thead><tbody><tr><td>logging.StreamHandler</td><td>将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。</td></tr><tr><td>logging.FileHandler</td><td>将日志消息发送到磁盘文件，默认情况下文件大小会无限增长</td></tr><tr><td>logging.handlers.RotatingFileHandler</td><td>将日志消息发送到磁盘文件，并支持日志文件按大小切割</td></tr><tr><td>logging.hanlders.TimedRotatingFileHandler</td><td>将日志消息发送到磁盘文件，并支持日志文件按时间切割</td></tr><tr><td>logging.handlers.HTTPHandler</td><td>将日志消息以GET或POST的方式发送给一个HTTP服务器</td></tr><tr><td>logging.handlers.SMTPHandler</td><td>将日志消息发送给一个指定的email地址</td></tr><tr><td>logging.NullHandler</td><td>该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免’No handlers could be found for logger XXX’信息的出现。</td></tr></tbody></table><h4 id="Formater类"><a href="#Formater类" class="headerlink" title="Formater类"></a>Formater类</h4><p>Formater对象用于配置日志信息的顺序、结构和内容。</p><p>与logging.Handler基类不同的是，应用代码可以直接实例化Formatter类。另外，如果你的应用程序需要一些特殊的处理行为，也可以实现一个Formatter的子类来完成。</p><p>Formatter类的构造方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.Formatter.__init__(fmt=None, datefmt=None, style=&apos;%&apos;)</span><br></pre></td></tr></table></figure><p>可见，该构造方法接收3个可选参数：</p><ul><li>fmt：指定消息格式化字符串，如果不指定该参数则默认使用message的原始值</li><li>datefmt：指定日期格式字符串，如果不指定该参数则默认使用”%Y-%m-%d %H:%M:%S”</li><li>style：Python 3.2新增的参数，可取值为 ‘%’, ‘{‘和 ‘$’，如果不指定该参数则默认使用’%’</li></ul><h4 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h4><p>Filter可以被Handler和Logger用来做比level更细粒度的、更复杂的过滤功能。Filter是一个过滤器基类，它只允许某个logger层级下的日志事件通过过滤。该类定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class logging.Filter(name=&apos;&apos;)</span><br><span class="line">    filter(record)</span><br></pre></td></tr></table></figure><p>比如，一个filter实例化时传递的name参数值为’A.B’，那么该filter实例将只允许名称为类似如下规则的loggers产生的日志记录通过过滤：’A.B’，’A.B,C’，’A.B.C.D’，’A.B.D’，而名称为’A.BB’, ‘B.A.B’的loggers产生的日志则会被过滤掉。如果name的值为空字符串，则允许所有的日志事件通过过滤。</p><p>filter方法用于具体控制传递的record记录是否能通过过滤，如果该方法返回值为0表示不能通过过滤，返回值为非0表示可以通过过滤。</p><p><strong>说明：</strong></p><blockquote><ul><li>如果有需要，也可以在filter(record)方法内部改变该record，比如添加、删除或修改一些属性。</li><li>我们还可以通过filter做一些统计工作，比如可以计算下被一个特殊的logger或handler所处理的record数量等。</li></ul></blockquote><h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><p><strong>需求：</strong></p><p>生成2个日志文件</p><ol><li><p>普通日志文件：</p><ul><li>日志级别：INFO及以上级别</li><li>格式：dcache.log | 之前文件：dcache.log.2018-12-09</li><li>日志轮询：所有级别的日志相对来说会比较大，因此按天分割，每天输出一个日志文件，保留30天</li></ul></li><li><p>error日志：</p><ul><li>日志级别：Error及CRITICAL级别</li><li>格式：dcache-error.log | 之前文件：dcache-error.log.2018-12-09</li><li>日志轮询：error日志不会太大，因此每7天生成一个新的文件，保留4个文件</li></ul></li></ol><p><strong>分析：</strong></p><ul><li><p>要记录INFO级别机器以上的日志，因此日志器的有效level需要设置为最低级别–INFO;</p></li><li><p>日志需要被发送到2个不同的目的地，因此需要为日志器设置2个handler，并且这3个目的地都是磁盘文件，因此这3个handler都是与FileHandler相关的</p></li><li>这里使用统一的内容格式，因此handler分别格式器设置一致，不需要额外区分</li><li>日志按照时间进行分割，因此需要用logging.handlers.TimedRotatingFileHandler; 而不是使用FileHandler;</li></ul><p><strong>代码实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">import logging.handlers</span><br><span class="line">from os import path</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">生成2个日志文件</span><br><span class="line">1. 普通日志文件：</span><br><span class="line">    - 日志级别：INFO及以上级别</span><br><span class="line">    - 格式：dcache.log | 之前文件：dcache.log.2018-12-09</span><br><span class="line">    - 日志轮询：按天分割，每天输出一个日志文件，保留30天</span><br><span class="line"></span><br><span class="line">2. error日志：</span><br><span class="line">    - 日志级别：Error及CRITICAL级别</span><br><span class="line">    - 格式：dcache-error.log | 之前文件：dcache-error.log.2018-12-09</span><br><span class="line">    - 日志轮询：为防止文件过大，每7天生成一个新的文件，保留7个文件</span><br><span class="line">    </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">## 定义日志文件名称格式</span><br><span class="line">base_log_name = path.abspath(path.dirname(path.dirname(__file__))) + &apos;/logs/&apos; + &quot;dcache&quot;</span><br><span class="line">info_log_filename = base_log_name + &quot;.log&quot;</span><br><span class="line">error_log_filename = base_log_name + &quot;-error.log&quot;</span><br><span class="line"></span><br><span class="line"># 定义日志内容的输出格式</span><br><span class="line">log_format = &quot;%(asctime)s - %(levelname)s - %(pathname)s[line:%(lineno)d] - %(message)s&quot;</span><br><span class="line"></span><br><span class="line"># 定义日志处理器(实例化一个日志处理器对象)</span><br><span class="line">logger = logging.getLogger(&apos;root&apos;)</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"># 定义handlers</span><br><span class="line">info_handler = logging.handlers.TimedRotatingFileHandler(info_log_filename, when=&apos;midnight&apos;, interval=1,backupCount=30, atTime=datetime.time(0, 0, 0, 0))</span><br><span class="line">info_handler.suffix = &quot;%Y-%m-%d&quot;</span><br><span class="line">info_handler.setLevel(logging.INFO)</span><br><span class="line">info_handler.setFormatter(logging.Formatter(log_format))</span><br><span class="line"></span><br><span class="line">error_handler = logging.handlers.TimedRotatingFileHandler(error_log_filename, when=&apos;midnight&apos;, interval=7,backupCount=4, atTime=datetime.time(0, 0, 0, 0))</span><br><span class="line">error_handler.suffix = &quot;%Y-%m-%d&quot;</span><br><span class="line">error_handler.setLevel(logging.ERROR)</span><br><span class="line">error_handler.setFormatter(logging.Formatter(log_format))</span><br><span class="line"></span><br><span class="line"># 日志器添加handlers</span><br><span class="line">logger.addHandler(info_handler)</span><br><span class="line">logger.addHandler(error_handler)</span><br><span class="line"></span><br><span class="line"># test</span><br><span class="line">logger.debug(&apos;debug message&apos;)</span><br><span class="line">logger.info(&apos;info message&apos;)</span><br><span class="line">logger.warning(&apos;warning message&apos;)</span><br><span class="line">logger.error(&apos;error message&apos;)</span><br><span class="line">logger.critical(&apos;critical message&apos;)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>interval表示的是：多少个指定时间内，当前的日志文件没有新的内容被写入进来，再去创建新文件，而不是时间一到就去创建新文件。每次每隔一小时输出一个文件的功能使用TimedRotatingFileHandler的方式实现不了。</li><li>因此要每小时一个文件的这种功能，需要我们想办法去实现</li></ul>]]></content>
    
    <summary type="html">
    
      python日志处理
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="python日志处理" scheme="http://yoursite.com/tags/python%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>运维思想</title>
    <link href="http://yoursite.com/2018/12/04/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E6%80%9D%E6%83%B3/%E8%BF%90%E7%BB%B4%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2018/12/04/IT科学技术知识体系结构-Linux运维方向/运维思想/运维思想/</id>
    <published>2018-12-04T01:47:52.000Z</published>
    <updated>2018-12-04T01:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="产品思维指导工作"><a href="#产品思维指导工作" class="headerlink" title="产品思维指导工作"></a>产品思维指导工作</h1><h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><ul><li>站在远处、高处分析这件事对不对</li><li>所负责的工作产出是一个产品，自己本身也是一个产品</li><li>如何确定目标：主谓宾方法论，未来十年，什么是不变的</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>不关注合理性，只讨论必要性</li><li>目标–&gt;路径–&gt;资源（目标管理本质其实是资源管理）</li></ul><h2 id="运营"><a href="#运营" class="headerlink" title="运营"></a>运营</h2><ul><li>把目标分解成没人每天每件事</li></ul><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><h2 id="效率（每天的工作）"><a href="#效率（每天的工作）" class="headerlink" title="效率（每天的工作）"></a>效率（每天的工作）</h2><ul><li>流程</li><li>规范</li><li>框架</li></ul><h2 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h2>]]></content>
    
    <summary type="html">
    
      运维思想
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="运维思想" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="运维思想" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>day14-前端技术</title>
    <link href="http://yoursite.com/2018/11/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day14-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/11/28/编程语言/Python/老男孩视频学习笔记/day14-前端技术/</id>
    <published>2018-11-28T15:31:09.000Z</published>
    <updated>2018-11-28T15:31:09.000Z</updated>
    
    <summary type="html">
    
      day14-前端技术
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>day09-进程线程协程</title>
    <link href="http://yoursite.com/2018/11/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day09-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/11/28/编程语言/Python/老男孩视频学习笔记/day09-进程线程协程/</id>
    <published>2018-11-28T15:24:56.000Z</published>
    <updated>2018-11-28T15:24:56.000Z</updated>
    
    <summary type="html">
    
      day09-进程线程协程
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>day08-socket编程</title>
    <link href="http://yoursite.com/2018/11/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day08-socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/11/28/编程语言/Python/老男孩视频学习笔记/day08-socket编程/</id>
    <published>2018-11-28T14:52:56.000Z</published>
    <updated>2018-11-28T14:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day08目录"><a href="#day08目录" class="headerlink" title="day08目录"></a>day08目录</h1><ul><li>08-03 通过socket实现减半的ssh</li><li><p>08-04 通过socket结束大数据</p></li><li><p>08-06 通过socket接收大数据</p></li><li><p>08-06 通过socket实现文件发送</p></li><li>08-07 socket粘包问题解决</li><li><p>08-09 socketservr使用</p></li><li><p>08-10 socketservr使用2</p></li></ul>]]></content>
    
    <summary type="html">
    
      day08-socket编程
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>day07-面向对象编程进阶及异常处理</title>
    <link href="http://yoursite.com/2018/08/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/08/31/编程语言/Python/老男孩视频学习笔记/day07-面向对象编程进阶及异常处理/</id>
    <published>2018-08-31T13:30:09.000Z</published>
    <updated>2018-08-31T13:30:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节讲解内容：</p><p>面向对象高级语法部分</p><ul><li>静态方法、类方法、属性方法</li><li>类的特殊方法</li><li>反射</li></ul><p>异常处理</p><p>socket开发基础</p><hr><h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><p>通过@staticmethod装饰器即可把其装饰的方法变为一个静态方法。</p><p>什么是静态方法呢？其实不难理解，普通的方法，可以在实例化后直接调用，并且在方法里可以通过self.调用实例变量或类变量，但静态方法是不可以访问实例变量或类变量的，一个不能访问实例变量和类变量的方法，其实相当于跟类本身已经没什么关系了，它与类唯一的关联就是需要通过类名来调用这个方法</p><p>总结：</p><ul><li>使用了静态方法之后，这个方法不能访问变量，只能被直接调用</li><li>把这个方法和类关联取消，因此self参数不再有效（默认会自动传self）</li><li>被静态化之后的方法的作用就只是相当于是一个单纯的函数，调用不了类的变量，调用不了实例的变量</li><li>因为，在这种情况下，如果还是需要使用参数，进行调用相关的方法，那么需要把实例或者属性传递进去</li><li>一般情况下，我们传递进去都会是一个实例，而不是一个属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">传递单个属性：</span><br><span class="line">class Dog(object):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">    @staticmethod</span><br><span class="line">    def eat(self):</span><br><span class="line">        # print (&quot;&#123;name&#125; is eating &#123;food&#125;...&quot;.format(name=self.name,food=food))</span><br><span class="line">        print (&quot;&#123;name&#125; is eating ...&quot;.format(name=self))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d1 = Dog(&quot;wxh&quot;)</span><br><span class="line"></span><br><span class="line">d1.eat(&quot;wxh&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">传递实例对象：</span><br><span class="line">class Dog(object):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">    @staticmethod</span><br><span class="line">    def eat(self):</span><br><span class="line">        # print (&quot;&#123;name&#125; is eating &#123;food&#125;...&quot;.format(name=self.name,food=food))</span><br><span class="line">        print (&quot;&#123;name&#125; is eating ...&quot;.format(name=self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d1 = Dog(&quot;wxh&quot;)</span><br><span class="line"></span><br><span class="line">d1.eat(d1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行后输出如下所示：</span><br><span class="line">sdd is eating ...</span><br></pre></td></tr></table></figure><h1 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h1><p>类方法中，只能访问类变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    name = &quot;gegege&quot;</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    # @staticmethod</span><br><span class="line">    @classmethod</span><br><span class="line">    def eat(self):</span><br><span class="line">        # print (&quot;&#123;name&#125; is eating &#123;food&#125;...&quot;.format(name=self.name,food=food))</span><br><span class="line">        print (&quot;&#123;name&#125; is eating ...&quot;.format(name=self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d1 = Dog(&quot;wxh&quot;)</span><br><span class="line"></span><br><span class="line">d1.eat()</span><br><span class="line"></span><br><span class="line">执行后输出如下：</span><br><span class="line">gegege is eating ...</span><br></pre></td></tr></table></figure><h1 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h1><h2 id="属性方法详解"><a href="#属性方法详解" class="headerlink" title="属性方法详解"></a>属性方法详解</h2><p>把一个方法变成静态的属性 ，因此，在调用的时候，不能再通过()调用 </p><p>这个时候就涉及到2个操作</p><ul><li>将方法变成属性</li><li>对这个属性赋值</li></ul><p>对属性赋值，不能直接像传参数一样操作了，需要使用eat.setter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    name = &quot;gegege&quot;</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def eat(self):</span><br><span class="line">        # print (&quot;&#123;name&#125; is eating &#123;food&#125;...&quot;.format(name=self.name,food=food))</span><br><span class="line">        print (&quot;&#123;name&#125; is eating ...&quot;.format(name=self.name))</span><br><span class="line">    @eat.setter</span><br><span class="line">    def eat(self,food):</span><br><span class="line">        print (&quot;set to food: &#123;food&#125;&quot;.format(food=food))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d1 = Dog(&quot;wxh&quot;)</span><br><span class="line"> </span><br><span class="line">d1.eat</span><br><span class="line">d1.eat = &quot;arg&quot;</span><br><span class="line">d1.eat</span><br><span class="line"></span><br><span class="line">执行后输出如下：</span><br><span class="line">wxh is eating ...</span><br><span class="line">set to food: arg</span><br><span class="line">wxh is eating ...</span><br></pre></td></tr></table></figure><p>通过上面我们可以看到，这个值并没有真正赋值进去，因此在再次调用的时候，输出的还是原来的值（赋值之前的值）。</p><p>因此@eat.setter下面这个方法只是执行了一系列的动作，根本没有存到某个地方</p><p>修改之后的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    name = &quot;gegege&quot;</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__food = None</span><br><span class="line"></span><br><span class="line">    # @staticmethod</span><br><span class="line">    # @classmethod</span><br><span class="line">    @property</span><br><span class="line">    def eat(self):</span><br><span class="line">        # print (&quot;&#123;name&#125; is eating &#123;food&#125;...&quot;.format(name=self.name,food=food))</span><br><span class="line">        print (&quot;&#123;name&#125; is eating &#123;food&#125;...&quot;.format(name=self.name,food=self.__food))</span><br><span class="line">    @eat.setter</span><br><span class="line">    def eat(self,food):</span><br><span class="line">        print (&quot;set to food: &#123;food&#125;&quot;.format(food=food))</span><br><span class="line">        self.__food = food</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d1 = Dog(&quot;wxh&quot;)</span><br><span class="line"></span><br><span class="line">d1.eat</span><br><span class="line">d1.eat = &quot;arg&quot;</span><br><span class="line">d1.eat</span><br><span class="line"></span><br><span class="line">执行后输出如下：</span><br><span class="line">wxh is eating None...</span><br><span class="line">set to food: arg</span><br><span class="line">wxh is eating arg...</span><br></pre></td></tr></table></figure><p>要删除的话，添加删除方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@eat.deleter</span><br><span class="line">def eat(self):</span><br><span class="line">    del self.__food</span><br><span class="line">    print (&quot;删除完毕&quot;)</span><br></pre></td></tr></table></figure><p>删除这个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del d1.eat</span><br></pre></td></tr></table></figure><h2 id="属性方法的使用场景"><a href="#属性方法的使用场景" class="headerlink" title="属性方法的使用场景"></a>属性方法的使用场景</h2><p>了解了属性方法的编写规则之后，需要知道它的应用场景。</p><p>我们在定义这个属性方法的时候，不需要传入参数等就能获取一个明确的输出，因此适用于比如我们想知道一个事物的当前状态，但是这个状态可能会牵涉到很多其他的操作，但是对于我们用户而言，我只需要知道一个结果就可以了，因此在这种情况下就可以使用属性方法。</p><p>比如 ，你想知道一个航班当前的状态，是到达了、延迟了、取消了、还是已经飞走了， 想知道这种状态你必须经历以下几步:</p><p>\1. 连接航空公司API查询</p><p>\2. 对查询结果进行解析 （可能是json、xml等等）</p><p>\3. 返回结果给你的用户</p><p>因此这个status属性的值是一系列动作后才得到的结果，所以你每次调用时，其实它都要经过一系列的动作才返回你结果，但这些动作过程不需要用户关心， 用户只需要调用这个属性就可以。背后的连接api，对结果解析等操作全部被隐藏了。</p><h1 id="类的特殊成员方法"><a href="#类的特殊成员方法" class="headerlink" title="类的特殊成员方法"></a>类的特殊成员方法</h1><h2 id="doc-类的描述信息"><a href="#doc-类的描述信息" class="headerlink" title="__doc__-类的描述信息"></a><code>__doc__</code>-类的描述信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    &quot;&quot;&quot; 描述类信息，这是用于看片的神奇 &quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">    def func(self):</span><br><span class="line">        pass</span><br><span class="line"> </span><br><span class="line">print Foo.__doc__</span><br><span class="line">#输出：类的描述信息</span><br></pre></td></tr></table></figure><h2 id="module-和-class"><a href="#module-和-class" class="headerlink" title="__module__ 和  __class__"></a><code>__module__</code> 和  <code>__class__</code></h2><p><code>__module__</code> 表示当前操作的对象在那个模块</p><p><code>__class__</code>     表示当前操作的对象的类是什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;wupeiqi&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from lib.aa import C</span><br><span class="line"></span><br><span class="line">obj = C()</span><br><span class="line">print obj.__module__  # 输出 lib.aa，即：输出模块</span><br><span class="line">print obj.__class__      # 输出 lib.aa.C，即：输出类</span><br></pre></td></tr></table></figure><h2 id="init-构造方法"><a href="#init-构造方法" class="headerlink" title="__init__ -构造方法"></a><code>__init__</code> -构造方法</h2><p>构造方法，通过类创建对象时，自动触发执行。</p><h2 id="del-析构方法"><a href="#del-析构方法" class="headerlink" title="__del__-析构方法"></a><code>__del__</code>-析构方法</h2><p>析构方法，当对象在内存中被释放时，自动触发执行。</p><blockquote><p>注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的</p></blockquote><h2 id="call-对象后面加括号，触发执行。"><a href="#call-对象后面加括号，触发执行。" class="headerlink" title="__call__ -对象后面加括号，触发执行。"></a><code>__call__</code> -对象后面加括号，触发执行。</h2><blockquote><p>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 <strong>call</strong> 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line"> </span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">     </span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line"> </span><br><span class="line">        print &apos;__call__&apos;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">obj = Foo() # 执行 __init__</span><br><span class="line">obj()       # 执行 __call__</span><br></pre></td></tr></table></figure><h2 id="dict-查看类或对象中的所有成员"><a href="#dict-查看类或对象中的所有成员" class="headerlink" title="__dict__ -查看类或对象中的所有成员 　　"></a><code>__dict__</code> -查看类或对象中的所有成员 　　</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Province:</span><br><span class="line"> </span><br><span class="line">    country = &apos;China&apos;</span><br><span class="line"> </span><br><span class="line">    def __init__(self, name, count):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.count = count</span><br><span class="line"> </span><br><span class="line">    def func(self, *args, **kwargs):</span><br><span class="line">        print &apos;func&apos;</span><br><span class="line"> </span><br><span class="line"># 获取类的成员，即：静态字段、方法、</span><br><span class="line">print Province.__dict__</span><br><span class="line"># 输出：&#123;&apos;country&apos;: &apos;China&apos;, &apos;__module__&apos;: &apos;__main__&apos;, &apos;func&apos;: &lt;function func at 0x10be30f50&gt;, &apos;__init__&apos;: &lt;function __init__ at 0x10be30ed8&gt;, &apos;__doc__&apos;: None&#125;</span><br><span class="line"> </span><br><span class="line">obj1 = Province(&apos;HeBei&apos;,10000)</span><br><span class="line">print obj1.__dict__</span><br><span class="line"># 获取 对象obj1 的成员</span><br><span class="line"># 输出：&#123;&apos;count&apos;: 10000, &apos;name&apos;: &apos;HeBei&apos;&#125;</span><br><span class="line"> </span><br><span class="line">obj2 = Province(&apos;HeNan&apos;, 3888)</span><br><span class="line">print obj2.__dict__</span><br><span class="line"># 获取 对象obj1 的成员</span><br><span class="line"># 输出：&#123;&apos;count&apos;: 3888, &apos;name&apos;: &apos;HeNan&apos;&#125;</span><br></pre></td></tr></table></figure><h2 id="str-输出方法返回值"><a href="#str-输出方法返回值" class="headerlink" title="__str__-输出方法返回值"></a><code>__str__</code>-输出方法返回值</h2><p>如果一个类中定义了<strong>str</strong>方法，那么在打印 对象 时，默认输出该方法的返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line"> </span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &apos;alex li&apos;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">obj = Foo()</span><br><span class="line">print obj</span><br><span class="line"># 输出：alex li</span><br></pre></td></tr></table></figure><h2 id="new-metaclass"><a href="#new-metaclass" class="headerlink" title="__new__ \ __metaclass__"></a><code>__new__ \ __metaclass</code>__</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">f = Foo(&quot;alex&quot;)</span><br></pre></td></tr></table></figure><p>上述代码中，obj 是通过 Foo 类实例化的对象，其实，不仅 obj 是一个对象，Foo类本身也是一个对象，因为在<strong>Python中一切事物都是对象</strong>。</p><p>如果按照一切事物都是对象的理论：obj对象是通过执行Foo类的构造方法创建，那么Foo类对象应该也是通过执行某个类的 构造方法 创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print type(f) # 输出：&lt;class &apos;__main__.Foo&apos;&gt;     表示，obj 对象由Foo类创建</span><br><span class="line">print type(Foo) # 输出：&lt;type &apos;type&apos;&gt;              表示，Foo类对象由 type 类创建</span><br></pre></td></tr></table></figure><p>所以，<strong>f对象是Foo类的一个实例</strong>，<strong>Foo类对象是 type 类的一个实例</strong>，即：Foo类对象 是通过type类的构造方法创建。</p><p>那么，创建类就可以有两种方式：</p><ul><li><p>普通方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">  </span><br><span class="line">    def func(self):</span><br><span class="line">        print &apos;hello alex&apos;</span><br></pre></td></tr></table></figure></li><li><p>特殊方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func(self):</span><br><span class="line">    print &apos;hello wupeiqi&apos;</span><br><span class="line">  </span><br><span class="line">Foo = type(&apos;Foo&apos;,(object,), &#123;&apos;func&apos;: func&#125;)</span><br><span class="line">#type第一个参数：类名</span><br><span class="line">#type第二个参数：当前类的基类</span><br><span class="line">#type第三个参数：类的成员</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def func(self):</span><br><span class="line">    print(&quot;hello %s&quot;%self.name)</span><br><span class="line"></span><br><span class="line">def __init__(self,name,age):</span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = age</span><br><span class="line">Foo = type(&apos;Foo&apos;,(object,),&#123;&apos;func&apos;:func,&apos;__init__&apos;:__init__&#125;)</span><br><span class="line"></span><br><span class="line">f = Foo(&quot;jack&quot;,22)</span><br><span class="line">f.func()</span><br></pre></td></tr></table></figure></li></ul><p>那么问题来了，类默认是由 type 类实例化产生，type类中如何实现的创建类？类又是如何创建对象？</p><p>答：类中有一个属性 <strong>metaclass</strong>，其用来表示该类由 谁 来实例化创建，所以，我们可以为 <strong>metaclass</strong> 设置一个type类的派生类，从而查看 类 创建的过程</p><p>类的生成 调用 顺序依次是 <strong>new</strong> –&gt; <strong>init</strong> –&gt; <strong>call</strong></p><p> metaclass 详解文章：<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a> 得票最高那个答案写的非常好</p><h1 id="类的一些额外操作"><a href="#类的一些额外操作" class="headerlink" title="类的一些额外操作"></a>类的一些额外操作</h1><h2 id="isinstance-obj-cls-检查是否是某个类的对象"><a href="#isinstance-obj-cls-检查是否是某个类的对象" class="headerlink" title="isinstance(obj, cls)- 检查是否是某个类的对象"></a>isinstance(obj, cls)- 检查是否是某个类的对象</h2><p>检查是否obj是否是类 cls 的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">obj = Foo()</span><br><span class="line"> </span><br><span class="line">isinstance(obj, Foo)</span><br></pre></td></tr></table></figure><h2 id="issubclass-sub-super-检查是否是某个类的子类"><a href="#issubclass-sub-super-检查是否是某个类的子类" class="headerlink" title="issubclass(sub, super)-检查是否是某个类的子类"></a>issubclass(sub, super)-检查是否是某个类的子类</h2><p>检查sub类是否是 super 类的派生类/子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">class Bar(Foo):</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">issubclass(Bar, Foo)</span><br></pre></td></tr></table></figure><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>通过反射，传入字符，获取相对应的对象的内存地址，获取了之后就可以直接调用。</p><p>通过hasattr去判断是否存在在类中，如果存在则通过getattr去获取它并调用</p><p>因此，最简单的书写格式应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = xxx() # 实例化出一个对象</span><br><span class="line">choice = input(&quot;&gt;&gt;:&quot;).strip()</span><br><span class="line">if hasattr(d,choice):</span><br><span class="line">    func = getattr(d,choice)</span><br><span class="line">    func(这里输入参数调用)</span><br></pre></td></tr></table></figure><p>总结如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line"> </span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;wupeiqi&apos;</span><br><span class="line"> </span><br><span class="line">    def func(self):</span><br><span class="line">        return &apos;func&apos;</span><br><span class="line"> </span><br><span class="line">obj = Foo()</span><br><span class="line"> </span><br><span class="line"># #### 检查是否含有成员 ####</span><br><span class="line">hasattr(obj, &apos;name&apos;)</span><br><span class="line">hasattr(obj, &apos;func&apos;)</span><br><span class="line"> </span><br><span class="line"># #### 获取成员 ####</span><br><span class="line">getattr(obj, &apos;name&apos;)</span><br><span class="line">getattr(obj, &apos;func&apos;)</span><br><span class="line"> </span><br><span class="line"># #### 设置成员 ####</span><br><span class="line">setattr(obj, &apos;age&apos;, 18)</span><br><span class="line">setattr(obj, &apos;show&apos;, lambda num: num + 1)</span><br><span class="line"> </span><br><span class="line"># #### 删除成员 ####</span><br><span class="line">delattr(obj, &apos;name&apos;)</span><br><span class="line">delattr(obj, &apos;func&apos;)</span><br></pre></td></tr></table></figure><p>反射：</p><ul><li>hasattr(obj,name_str)：判断一个对象里面是否有对应的字符串的方法或属性</li><li>getattr(obj,name_str)：根据字符串去获取obj对象里的对应的方法的内存地址 </li><li>setattr(obj,’y’,z)：setattr(x, ‘y’, v) is equivalent to ``x.y = v’’。通过字符串去设置一个新的属性</li><li>delattr(obj,name_str)： 删除属性</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>做异常处理的原因：虽然程序出错了，但是我不想让用户看到这个错误信息。我已经预料到，程序可能会出这种错，出了这种错误，代表什么意思。这个时候，我就可以做一些预处理，提前做好预防，说如果出现指定的错误，我就输出我认为自定义的输出信息</p><p>默认情况下，出现异常之后，整个程序就会奔溃</p><p>下面我们写一段测试代码</p><h2 id="一次抓一个错误异常"><a href="#一次抓一个错误异常" class="headerlink" title="一次抓一个错误异常"></a>一次抓一个错误异常</h2><p>异常处理之前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Man(object):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def old(self):</span><br><span class="line">        print (&quot;&#123;name&#125; is &#123;age&#125; years old...&quot;.format(name=self.name,age=self.age))</span><br><span class="line"></span><br><span class="line">man1 = Man(&quot;wxh&quot;,26,&quot;df&quot;)</span><br></pre></td></tr></table></figure><p>执行之后的输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/wangxiaohua/PycharmProjects/python14/day07/exce.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    man1 = Man(&quot;wxh&quot;,26,&quot;df&quot;)</span><br><span class="line">TypeError: __init__() takes 3 positional arguments but 4 were given</span><br></pre></td></tr></table></figure><p>异常处理之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Man(object):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def old(self):</span><br><span class="line">        print (&quot;&#123;name&#125; is &#123;age&#125; years old...&quot;.format(name=self.name,age=self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    man1 = Man(&quot;wxh&quot;,26,&quot;df&quot;)</span><br><span class="line">except TypeError as e:</span><br><span class="line">    print (&quot;参数数量输入错误： &quot;,e)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print (&quot;未知错误&quot;,e)</span><br></pre></td></tr></table></figure><p>执行之后的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数数量输入错误：  __init__() takes 3 positional arguments but 4 were given</span><br></pre></td></tr></table></figure><h2 id="一次抓所有错误异常"><a href="#一次抓所有错误异常" class="headerlink" title="一次抓所有错误异常"></a>一次抓所有错误异常</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">man1 = Man(&quot;wxh&quot;,26)</span><br><span class="line">try:</span><br><span class="line">    man1.old(&quot;df&quot;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print (&quot;出错了&quot;,e)</span><br></pre></td></tr></table></figure><p>需要注意的是，这种操作一般不用</p><h2 id="else和finally用法"><a href="#else和finally用法" class="headerlink" title="else和finally用法"></a>else和finally用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    man1.old(&quot;df&quot;)</span><br><span class="line">except TypeError as e:</span><br><span class="line">    print (&quot;位置参数错误：&quot;,e)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print (&quot;未知错误&quot;,e)</span><br><span class="line">else: </span><br><span class="line">    print (&quot;一切正常时执行&quot;)</span><br><span class="line">finally:</span><br><span class="line">    print (&quot;不管有错没错都执行&quot;)</span><br></pre></td></tr></table></figure><p>注意，如果代码本身有错误，都没办法执行的话，是抓不到错误异常的，因为上面抓取错误异常指的是在代码执行时出现的异常</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>例如在MySQL中，它就是自己定义的异常，例如在连接超时的时候就会报错：MySQLConnectionFailed。</p><p>那么，我们也是可以自己定义这些异常的。</p><p><strong>格式： raise 异常名称(‘异常描述’)</strong></p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class WxhException(Exception):</span><br><span class="line">    def __init__(self,message):</span><br><span class="line">        super(LengthError,self).__init__()</span><br><span class="line">        self.message = message</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.message</span><br><span class="line">try:</span><br><span class="line">    raise WxhException(&quot;数据库连接失败&quot;)</span><br><span class="line">except WxhException as e:</span><br><span class="line">    print (e)</span><br></pre></td></tr></table></figure><p>自己写的异常需要我们自己去触发，它不会自动触发。</p><p>会自动触发的异常只有标准异常。</p><p>自己写的异常，系统不知道它的存在，也就是说系统不知道走到哪一步应该触发它，因为所有的逻辑都是我们认为的去判断的。</p><p><strong>自定义触发</strong></p><p>使用raise的语法去触发</p><p>raise WxhException(“数据库连接失败”)。括号中的输入是<strong>异常描述</strong>，<strong>同时也是参数</strong>，传入到这个类的构造方法当中</p><p>接下来，通过下面的内容去打印 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">except WxhException as e:</span><br><span class="line">    print (e)</span><br></pre></td></tr></table></figure><p>注意，这里就相当于是直接打印这个类，而不是对象，所以需要使用到<code>__str__</code>方法。</p><p>注意，在这里，下面的这2行代码可以不用写，但是不能写成别的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def __str__(self):</span><br><span class="line">    return self.message</span><br></pre></td></tr></table></figure><p>因此，自定义的这个异常类继承了Exception这个基类的异常，这个基类的异常在里面已经定义好了，只要你打印，它就会自动的把这个值给它打印出来，传什么就打印什么。</p><p>在这里，print(e)就相当于直接打印这个实例，因此需要def <code>__str__</code>方法的存在</p><p>逻辑顺序：</p><ol><li><p>在try中定义代码，如果符合条件，则使用raise手动的<strong>产生异常</strong>，异常的内容就是括号中的内容</p></li><li><p>接下来，使用exception去抓取这个异常</p></li><li><p>在exception的处理模块中，一般直接使用print（）语法将事先定义好的描述信息输出</p></li></ol><h1 id="python的单例模式"><a href="#python的单例模式" class="headerlink" title="python的单例模式"></a>python的单例模式</h1><p>作者：geekpy</p><p>链接：<a href="https://www.jianshu.com/p/ec6589e02e2f" target="_blank" rel="noopener">https://www.jianshu.com/p/ec6589e02e2f</a></p><p>來源：简书</p><p>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p><p>单例模式是设计模式中逻辑最简单，最容易理解的一个模式，简单到只需要一句话就可以理解，即“保证只有一个对象实例的模式”。问题的关键在于实现起来并没有想象的那么简单。不过我们还是先来讨论下为什么需要这个模式吧。</p><p>我们首先来看看单例模式的使用场景，然后再来分析为什么需要单例模式。</p><ul><li>Python的logger就是一个单例模式，用以日志记录</li><li>Windows的资源管理器是一个单例模式</li><li>线程池，数据库连接池等资源池一般也用单例模式</li><li>网站计数器</li></ul><p>从这些使用场景我们可以总结下什么情况下需要单例模式：</p><ol><li>当每个实例都会占用资源，而且实例初始化会影响性能，这个时候就可以考虑使用单例模式，它给我们带来的好处是只有一个实例占用资源，并且只需初始化一次；</li><li>当有同步需要的时候，可以通过一个实例来进行同步控制，比如对某个共享文件（如日志文件）的控制，对计数器的同步控制等，这种情况下由于只有一个实例，所以不用担心同步问题。</li></ol><p>当然所有使用单例模式的前提是我们的确用一个实例就可以搞定要解决的问题，而不需要多个实例，如果每个实例都需要维护自己的状态，这种情况下单例模式肯定是不适用的。<br> 接下来看看如何使用Python来实现一个单例模式。</p><p><strong>最开始</strong>的想法很简单，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    __instance = None</span><br><span class="line">    def __new__(cls, *args, **kwargs):  # 这里不能使用__init__，因为__init__是在instance已经生成以后才去调用的</span><br><span class="line">        if cls.__instance is None:</span><br><span class="line">            cls.__instance = super(Singleton, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">        return cls.__instance</span><br><span class="line"></span><br><span class="line">s1 = Singleton()</span><br><span class="line">s2 = Singleton()</span><br><span class="line">print (s1)</span><br><span class="line">print (s2)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Singleton object at 0x109cd39e8&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x109cd39e8&gt;</span><br></pre></td></tr></table></figure><p>可以看出两次创建对象，结果返回的是同一个对象实例，我们再让我们的例子更接近真实的使用场景来看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    __instance = None</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if cls.__instance is None:</span><br><span class="line">            cls.__instance = super(Singleton, cls).__new__(cls)</span><br><span class="line">        return cls.__instance</span><br><span class="line"></span><br><span class="line">    def __int__(self, status_number):</span><br><span class="line">        self.status_number = status_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Singleton(2)</span><br><span class="line">s2 = Singleton(5)</span><br><span class="line">print (s1)</span><br><span class="line">print (s2)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Singleton object at 0x10af2d1d0&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x10af2d1d0&gt;</span><br></pre></td></tr></table></figure><p>不过这个例子中有一个问题我们没有解决，那就是多线程的问题，当有多个线程同时去初始化对象时，就很可能同时判断__instance is None，从而进入初始化instance的代码中。所以为了解决这个问题，我们必须通过同步锁来解决这个问题。以下例子来自<a href="https://link.jianshu.com/?t=http://xiaorui.cc/2016/04/10/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BF%9D%E6%8C%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%94%AF%E4%B8%80/" target="_blank" rel="noopener">xiaorui</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">try:</span><br><span class="line">    from synchronize import make_synchronized</span><br><span class="line">except ImportError:</span><br><span class="line">    def make_synchronized(func):</span><br><span class="line">        import threading</span><br><span class="line">        func.__lock__ = threading.Lock()</span><br><span class="line"></span><br><span class="line">        def synced_func(*args, **kws):</span><br><span class="line">            with func.__lock__:</span><br><span class="line">                return func(*args, **kws)</span><br><span class="line"></span><br><span class="line">        return synced_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line">    instance = None</span><br><span class="line"></span><br><span class="line">    @make_synchronized</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if cls.instance is None:</span><br><span class="line">            cls.instance = object.__new__(cls, *args, **kwargs)</span><br><span class="line">        return cls.instance</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.blog = &quot;xiaorui.cc&quot;</span><br><span class="line"></span><br><span class="line">    def go(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def worker():</span><br><span class="line">    e = Singleton()</span><br><span class="line">    print id(e)</span><br><span class="line">    e.go()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    e1 = Singleton()</span><br><span class="line">    e2 = Singleton()</span><br><span class="line">    e1.blog = 123</span><br><span class="line">    print e1.blog</span><br><span class="line">    print e2.blog</span><br><span class="line">    print id(e1)</span><br><span class="line">    print id(e2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    test()</span><br><span class="line">    task = []</span><br><span class="line">    for one in range(30):</span><br><span class="line">        t = threading.Thread(target=worker)</span><br><span class="line">        task.append(t)</span><br><span class="line"></span><br><span class="line">    for one in task:</span><br><span class="line">        one.start()</span><br><span class="line"></span><br><span class="line">    for one in task:</span><br><span class="line">        one.join()</span><br></pre></td></tr></table></figure><p>至此我们的单例模式实现代码已经接近完美了，不过我们是否可以更简单地使用单例模式呢？答案是有的，接下来就看看如何更简单地使用单例模式。</p><p>在Python的官方网站给了两个例子是用装饰符来修饰类，从而使得类变成了单例模式，使得我们可以通过更加简单的方式去实现单例模式<br> 例子：（这里只给出一个例子，因为更简单，另外一个大家可以看官网<a href="https://link.jianshu.com?t=https://wiki.python.org/moin/PythonDecoratorLibrary#Singleton" target="_blank" rel="noopener">Singleton</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def singleton(cls):</span><br><span class="line">    instance = cls()</span><br><span class="line">    instance.__call__ = lambda: instance</span><br><span class="line">    return instance</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Sample use</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class Highlander:</span><br><span class="line">    x = 100</span><br><span class="line">    # Of course you can have any attributes or methods you like.</span><br><span class="line"></span><br><span class="line">Highlander() is Highlander() is Highlander #=&gt; True</span><br><span class="line">id(Highlander()) == id(Highlander) #=&gt; True</span><br><span class="line">Highlander().x == Highlander.x == 100 #=&gt; True</span><br><span class="line">Highlander.x = 50</span><br><span class="line">Highlander().x == Highlander.x == 50 #=&gt; True</span><br></pre></td></tr></table></figure><p>这里简单解释下：</p><ol><li>在定义class Highlander的时候已经执行完所有singleton装饰器中的代码，得到了一个instance，所以这之后所有对Highlander的调用实际上是在调用instance的<em><em>call</em></em> 方法。</li><li>我们通过lambda函数定义了<em><em>call</em></em>方法让它始终返回instance，因此Highlander()和Highlander都返回instance</li><li>同时由于在类定义代码执行时就已经创建了instance，所以后续不论是多线程还是单线程，在调用Highlander时都是在调用instance的<em><em>call</em></em>方法，也就无需同步了。<br> 最后我想说的是这种方法简直碉堡了～～～</li></ol><h1 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h1><h3 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h3><p>在介绍logging模块的日志流处理流程之前，我们先来介绍下logging模块的四大组件：</p><table><thead><tr><th>组件名称</th><th>对应类名</th><th>功能描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供了应用程序可一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将logger创建的日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filter</td><td>提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table><p>logging模块就是通过这些组件来完成日志处理的，上面所使用的logging模块级别的函数也是通过这些组件对应的类来实现的。</p><h5 id="这些组件之间的关系描述："><a href="#这些组件之间的关系描述：" class="headerlink" title="这些组件之间的关系描述："></a>这些组件之间的关系描述：</h5><ul><li>日志器/记录器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等；</li><li>不同的处理器（handler）可以将日志输出到不同的位置；</li><li>日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置；</li><li>每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志；</li><li>每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。</li></ul><p>简单点说就是：<strong>日志器（logger）是入口</strong>，真正干活儿的是处理器（handler），处理器（handler）还可以通过过滤器（filter）和格式器（formatter）对要输出的日志内容做过滤和格式化等处理操作。</p><h1 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h1><h1 id="socket网络编程"><a href="#socket网络编程" class="headerlink" title="socket网络编程"></a>socket网络编程</h1><p>socket是将tcp的操作封装起来了，隐藏了tcp底层的很多复杂的实现过程</p><p>socket是对上层协议的封装</p><p>socket不光支持tcp/ip，还支持udp</p><p>socket只干两件事【收发数据】</p><ul><li>send</li><li>Receive </li></ul><p>socket会把三次握手这些东西都封装好</p><p>下面是伪代码</p><p>注意：先要有接收端，相当于服务端</p><p>发送端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import socket </span><br><span class="line">socket.TCP/IP  # 定义操作的协议类型</span><br><span class="line">connect(a.ip，a.port)</span><br><span class="line">socket.send(hello)</span><br><span class="line">socket.recv()</span><br><span class="line">socket.close()</span><br></pre></td></tr></table></figure><p>接收端/服务端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">socket.TCP/IP  #声明类型</span><br><span class="line">listen(0.0.0.0,6969)#一台机器上可能存在多个网卡，因此要指定ip地址和端口，同时也是唯一定位一个节点</span><br><span class="line">waiting()</span><br><span class="line">recv()</span><br><span class="line">send()</span><br><span class="line"></span><br><span class="line">服务器端不需要close</span><br></pre></td></tr></table></figure><p>客户端的流程</p><ol><li>导入socket</li><li>定义socket类型</li><li>连接远程机器</li><li>开始发送数据</li><li>接收数据</li><li>关闭socket</li></ol><p>client端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 声明socket类型，同时生成socket连接对象</span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((&apos;localhost&apos;,6969))</span><br><span class="line"></span><br><span class="line">client.send(b&quot;hello,world&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = client.recv(1024)</span><br><span class="line">print (&quot;recv: &quot;,data )</span><br><span class="line"></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure><p>server端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind((&apos;localhost&apos;,6969))</span><br><span class="line">server.listen()</span><br><span class="line">print (&quot;dd&quot;)</span><br><span class="line">conn,addr = server.accept()</span><br><span class="line">print (conn)</span><br><span class="line">print (addr)</span><br><span class="line"></span><br><span class="line">print (&quot;dd&quot;)</span><br><span class="line">data = conn.recv(1024)</span><br><span class="line"></span><br><span class="line">print (&quot;recv:&quot;,data)</span><br><span class="line">conn.send(data.upper())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.close()</span><br></pre></td></tr></table></figure><p>bytes类型 只能接受ascii里面的数据类型</p><p>上面的是不能传输中文的，我们需要传输中文的时候，就需要encode成为一个byte（encode将其转成ascii里面支持的格式）</p><p>解析使用decode</p><p>在socket中，所有的数据传输都需要使用这个bytes格式</p>]]></content>
    
    <summary type="html">
    
      day07-面向对象编程进阶及异常处理
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu更改apt源</title>
    <link href="http://yoursite.com/2018/08/28/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/ubuntu%E6%9B%B4%E6%94%B9apt%E6%BA%90/"/>
    <id>http://yoursite.com/2018/08/28/IT科学技术知识体系结构-Linux运维方向/Linux基础知识/Linux系统管理/ubuntu更改apt源/</id>
    <published>2018-08-28T06:17:44.000Z</published>
    <updated>2018-08-28T06:17:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在安装完ubuntu之后，我们一般都需要将apt源替换为阿里云等国内软件源站点，以便提高响应速度。</p><p>这里使用的是Ubuntu18.04发行版本</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>其实Ubuntu18.04版之前的任一版更改apt源为国内源方法早就有了，内容大同小异，我们应当掌握其规律了，其实每一版内容不同的地方就是版本号（或者官方一点的说：系统代号），所以我们先了解下新版本的系统代号：</p><p>使用如下命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -c</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:/etc/apt$ lsb_release -c</span><br><span class="line">Codename:bionic</span><br></pre></td></tr></table></figure><p>我们可以看到新版本的Ubuntu系统代号为bionic</p><p>同样的我们也可以得到之前任意版本的系统代号：</p><ul><li>Ubuntu 12.04 (LTS)代号为precise。</li><li>Ubuntu 14.04 (LTS)代号为trusty。</li><li>Ubuntu 15.04 代号为vivid。</li><li>Ubuntu 15.10 代号为wily。</li><li>Ubuntu 16.04 (LTS)代号为xenial。</li></ul><p>所以这也就解释了为什么我们百度出来的那么多方案里面内容不尽相同的原因，因为他们更改apt安装源时用的系统不一样。</p><p>下面开始实际操作</p><hr><h1 id="备份源文件"><a href="#备份源文件" class="headerlink" title="备份源文件"></a>备份源文件</h1><p>我们要修改的文件是sources.list，它在目录/etc/apt/下，sources.list是包管理工具apt所用的<strong><code>记录软件包仓库</code></strong>位置的配置文件，同样类型的还有位于 同目录下sources.list.d文件下的各种.list后缀的各文件。</p><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h1 id="编辑源文件内容"><a href="#编辑源文件内容" class="headerlink" title="编辑源文件内容"></a>编辑源文件内容</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>将原有的内容注释或删除掉，添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>配置格式说明：</p><p>我们可以看到sources.list文件的条目都是有格式的（通过上面的内容大家也看的出来），一般有如下形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://site.example.com/debian distribution component1 component2 component3</span><br><span class="line">deb-src http://site.example.com/debian distribution component1 component2 component3</span><br></pre></td></tr></table></figure><p>后面几个参数是对软件包的分类（Ubuntu下是main， restricted，universe ，multiverse这四个）</p><h1 id="补充-etc-apt-sources-list-详解"><a href="#补充-etc-apt-sources-list-详解" class="headerlink" title="补充-/etc/apt/sources.list 详解"></a>补充-/etc/apt/sources.list 详解</h1><p><code>/etc/apt/sources.list</code> 是包管理工具 <code>apt</code> 所用的记录软件包仓库位置的配置文件，同样的还有位于 <code>/etc/apt/sources.list.d/*.list</code> 的各文件。</p><p><code>sources.list</code> 文件中的条目一般都有如下所示的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://site.example.com/debian distribution component1 component2 component3</span><br><span class="line">deb-src http://site.example.com/debian distribution component1 component2 component3</span><br></pre></td></tr></table></figure><h2 id="档案类型-Archive-type"><a href="#档案类型-Archive-type" class="headerlink" title="档案类型 (Archive type)"></a>档案类型 (Archive type)</h2><p>条目的第一个词 <code>deb</code> 或是 <code>deb-src</code> 表明了所获取的软件包档案类型。</p><p>其中：</p><ul><li><p><strong>deb</strong></p><p>档案类型为二进制预编译软件包，一般我们所用的档案类型。</p></li><li><p><strong>deb-src</strong></p><p>档案类型为用于编译二进制软件包的源代码。</p></li></ul><h2 id="仓库地址-Repository-URL"><a href="#仓库地址-Repository-URL" class="headerlink" title="仓库地址 (Repository URL)"></a>仓库地址 (Repository URL)</h2><p>条目的第二个词则是软件包所在仓库的地址。我们可以更换仓库地址为其他地理位置更靠近自己的镜像来提高下载速度。</p><p>常用镜像地址列表：</p><ul><li><p><strong>Debian</strong></p><p><a href="https://www.debian.org/mirror/list" target="_blank" rel="noopener">https://www.debian.org/mirror/list</a></p></li><li><p><strong>Ubuntu</strong></p><p><a href="http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/源列表</a></p></li></ul><h2 id="发行版-Distribution"><a href="#发行版-Distribution" class="headerlink" title="发行版 (Distribution)"></a>发行版 (Distribution)</h2><p>跟在仓库地址后的是发行版。发行版有两种分类方法，一类是发行版的具体代号，如 <code>xenial</code>,<code>trusty</code>, <code>precise</code> 等；还有一类则是发行版的发行类型，如<code>oldstable</code>, <code>stable</code>, <code>testing</code> 和 <code>unstable</code>。</p><p>另外，在发行版后还可能有进一步的指定，如 <code>xenial-updates</code>, <code>trusty-security</code>, <code>stable-backports</code> 等。</p><h2 id="软件包分类-Component"><a href="#软件包分类-Component" class="headerlink" title="软件包分类 (Component)"></a>软件包分类 (Component)</h2><p>跟在发行版之后的就是软件包的具体分类了，可以有一个或多个。</p><p>不同的 Linux 发行版对软件有着不同的分类，如：</p><h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h3><ul><li><p><strong>main</strong></p><p>包含符合 <a href="https://www.debian.org/social_contract#guidelines" target="_blank" rel="noopener">DFSG</a> 指导原则的自由软件包，而且这些软件包不依赖不符合该指导原则的软件包。这些软件包被视为 Debian 发型版的一部分。</p></li><li><p><strong>contrib</strong></p><p>包含符合 <a href="https://www.debian.org/social_contract#guidelines" target="_blank" rel="noopener">DFSG</a> 指导原则的自由软件包，不过这些软件包依赖不在 <em>main</em> 分类中的软件包。</p></li><li><p><strong>non-free</strong></p><p>包含不符合 <a href="https://www.debian.org/social_contract#guidelines" target="_blank" rel="noopener">DFSG</a> 指导原则的非自由软件包。</p></li></ul><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><ul><li><p><strong>main</strong></p><p>官方支持的<a href="http://www.ubuntu.com/about/about-ubuntu/our-philosophy" target="_blank" rel="noopener">自由</a>软件。</p></li><li><p><strong>restricted</strong></p><p>官方支持的非完全<a href="http://www.ubuntu.com/about/about-ubuntu/our-philosophy" target="_blank" rel="noopener">自由</a>的软件。</p></li><li><p><strong>universe</strong></p><p>社区维护的自由软件。</p></li><li><p><strong>multiverse</strong></p><p>非自由软件。</p></li></ul><p>Ubuntu 对软件包的分类可以用下表来表示（参考自 <a href="https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#Package_classification_and_support" target="_blank" rel="noopener">Wikipedia</a>）：</p><table><thead><tr><th></th><th>自由软件</th><th>非自由软件</th></tr></thead><tbody><tr><td>官方支持的</td><td>Main</td><td>Restricted</td></tr><tr><td>非官方支持的</td><td>Universe</td><td>Multiverse</td></tr></tbody></table><h1 id="补充-update和upgrade"><a href="#补充-update和upgrade" class="headerlink" title="补充-update和upgrade"></a>补充-update和upgrade</h1><p>每个LINUX的发行版，比如ubuntu、centos等，都会维护一个自己的软件仓库，我们常用的几乎所有软件都在这里面。这里面的软件绝对安全，而且绝对的能正常安装。</p><p>在UBUNTU下，我们维护一个源列表，源列表里面都是一些网址信息，这每一条网址就是一个源，这个地址指向的数据标识着这台源服务器上有哪些软件可以安装使用。</p><p>编辑源命令：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.<span class="keyword">list</span></span><br></pre></td></tr></table></figure><p>在这个文件里加入或者注释（加#）掉一些源后，保存。这时候，我们的源列表里指向的软件就会增加或减少一部分。</p><p>获得最近的软件包的列表:(列表中包含一些包的信息，比如这个包是否更新过)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>这个命令，会访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。软件包管理器里看到的软件列表，都是通过update命令更新的。</p><p>update后，可能需要upgrade一下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>这个命令，会把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。如果你的软件都是最新版本，会提示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。</span><br></pre></td></tr></table></figure><p><strong>总而言之，update是更新软件列表，upgrade是更新软件。</strong></p><p>注意：一般在执行 sudo apt-get upgrade 命令之前需要先执行一下 sudo apt-get update；这其实和windows下的软件检测更新是一样的，需要更新的会帮你自动更新并安装好</p><p>apt-get update 命令会同步使用者端和APT服务器的RPM 索引清单（package list），APT 服务器的RPM 索引清单置于base 资料夹内，使用者端电脑取得base 资料夹内的bz2 RPM 索引清单压缩档后，会将其解压置放于/var/state/apt/lists/，而使用者使用apt-get install 或apt-get dist-upgrade 指令的时候，就会将这个资料夹内的资料和使用者端电脑内的RPM 资料库比对，如此一来就可以知道那些RPM 已安装、未安装、或是可以升级的。</p>]]></content>
    
    <summary type="html">
    
      ubuntu更改apt源
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="Linux基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Linux系统管理" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>DNS记录类型简介</title>
    <link href="http://yoursite.com/2018/08/28/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/DNS/DNS%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/08/28/IT科学技术知识体系结构-Linux运维方向/网络知识/DNS/DNS记录类型简介/</id>
    <published>2018-08-28T03:54:17.000Z</published>
    <updated>2018-08-28T03:54:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>DNS：（Domain Name System，域名系统），因特网上作为域名和<a href="http://baike.baidu.com/view/3930.htm" target="_blank" rel="noopener">IP地址</a>相互映射的一个<a href="http://baike.baidu.com/view/68389.htm" target="_blank" rel="noopener">分布式数据库</a>，能够使用户更方便的访问<a href="http://baike.baidu.com/view/6825.htm" target="_blank" rel="noopener">互联网</a>，而不用去记住能够被机器直接读取的IP数串。通过<a href="http://baike.baidu.com/view/23880.htm" target="_blank" rel="noopener">主机</a>名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。使用端口号53。</p><p>DNS服务器：用于对域名进行解析的域名解析服务器。</p><p>DNS代理：用于代理域名服务器，对客户端的查询请求进行响应（一般是本地查找，查找不到再向代理的服务器转发客户端的查询请求）</p><h1 id="dns记录类型介绍"><a href="#dns记录类型介绍" class="headerlink" title="dns记录类型介绍"></a>dns记录类型介绍</h1><h2 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h2><p>说明：WEB服务器的IP指向</p><p>A （Address）记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置域名的子域名。通俗来说A记录就是服务器的IP,域名绑定A记录就是告诉DNS,当你输入域名的时候给你引导向设置在DNS的A记录所对应的服务器。 </p><p>简单的说，A记录是指定域名对应的IP地址。</p><h2 id="AAAA记录"><a href="#AAAA记录" class="headerlink" title="AAAA记录"></a>AAAA记录</h2><p>作用同A记录，只不过该记录是将域名解析到一个指定的<strong>IPV6</strong>的IP上</p><h2 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h2><p>通常称别名解析。可以将注册的不同域名都转到一个域名记录上，由这个域名记录统一解析管理</p><p>这种记录允许您将多个名字映射到同一台计算机。 通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。 它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。 这两个别名的全称就是“www.mydomain.com”和“mail.mydomain.com”。实际上他们都指向“host.mydomain.com”。</p><p>同样的方法可以用于当您拥有多个域名需要指向同一服务器IP，此时您就可以将一个域名做A记录指向服务器IP然后将其他的域名做别名到之前做A记录的域名上，那么当您的服务器IP地址变更时您就可以不必麻烦的一个一个域名更改指向了 只需要更改做A记录的那个域名其他做别名的那些域名的指向也将自动更改到新的IP地址上了。</p><h2 id="NS记录"><a href="#NS记录" class="headerlink" title="NS记录"></a>NS记录</h2><p>解析服务器记录，用来表明由哪台服务器对该域名进行解析。</p><p>这里的NS记录只对子域名生效。</p><p>例如用户希望由12.34.56.78这台服务器解析news.mydomain.com，则需要设置news.mydomain.com的NS记录。 </p><p>说明： </p><ul><li>“优先级”中的数字越小表示级别越高； </li><li>“IP地址/主机名”中既可以填写IP地址，也可以填写像ns.mydomain.com这样的主机地址，但必须保证该主机地址有效。如，将 news.mydomain.com的NS记录指向到ns.mydomain.com，在设置NS记录的同时还需要设置ns.mydomain.com的 指向，否则NS记录将无法正常解析； </li><li>NS记录优先于A记录。即，如果一个主机地址同时存在NS记录和A记录，则A记录不生效。这里的NS记录只对子域名生效。</li></ul><h2 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h2><p>MX（Mail Exchanger）记录是邮件交换记录，它指向一个邮件服务器，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器。例如，当Internet上的某用户要发一封信给 user@mydomain.com 时，该用户的邮件系统通过DNS查找mydomain.com这个域名的MX记录，如果MX记录存在， 用户计算机就将邮件发送到MX记录所指定的邮件服务器上。</p><hr><p>其他的记录类型涉及到的时候再详细补充</p>]]></content>
    
    <summary type="html">
    
      DNS记录类型简介
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="网络知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
      <category term="DNS" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/DNS/"/>
    
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu设置ssh服务</title>
    <link href="http://yoursite.com/2018/08/26/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/ubuntu%E8%AE%BE%E7%BD%AEssh%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/08/26/IT科学技术知识体系结构-Linux运维方向/Linux基础知识/Linux系统管理/ubuntu设置ssh服务/</id>
    <published>2018-08-26T09:49:54.000Z</published>
    <updated>2018-08-26T09:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，安装完ubuntu之后，操作系统不会像centos一样会自动把openssh-server给安装上，也就是说，在系统安装完毕之后，我们还需要进行额外的操作，才能通过ssh的方式远程访问我们的ubuntu系统。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>SSH分客户端openssh-client和openssh-server</p><p>如果你只是想登陆别的机器，那么只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。</p><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>在命令行中使用如下命令进行安装</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>ssh-server配置文件位于/etc/ssh/sshd_config，在这里可以定义SSH的服务端口，默认端口是22，你可以自己定义成其他端口号。</p><p>通过修改配置文件/etc/ssh/sshd_config，可以进行修改ssh登录端口、禁止root登录等一系列操作，修改端口可以防止被端口扫描。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>默认情况下，安装完毕之后将会自动启动，我们可用用过ps来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -elf | grep sshd</span><br></pre></td></tr></table></figure><p>如果没有启动的话，我们执行以下命令启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      ubuntu设置ssh服务
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="Linux基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Linux系统管理" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/08/23/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker/Docker%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/08/23/IT科学技术知识体系结构-Linux运维方向/虚拟化/Docker/Docker入门与实践/</id>
    <published>2018-08-23T09:42:27.000Z</published>
    <updated>2018-08-23T09:42:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li>书籍：《Docker技术入门与实战 第2版》</li></ul><hr><h1 id="第1章-基础知识"><a href="#第1章-基础知识" class="headerlink" title="第1章 基础知识"></a>第1章 基础知识</h1><h2 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h2><h3 id="有关虚拟化"><a href="#有关虚拟化" class="headerlink" title="有关虚拟化"></a>有关虚拟化</h3><p>虚拟化技术是一个通用的概念，在不同领域有不同的理解，在计算领域，一般指的是计算虚拟化（computing Virtualization），或通常说的服务器虚拟化。</p><p>维基百科定义如下：“虚拟化是一种资源管理技术”，是将计算机的各种实体资源，例如服务器、网络、内存及存储等，予以抽象，转换后呈现出来的，打破实体结构间的不可切割的障碍，使用户可以比原来的组态更好的方式来应用这些资源</p><p>传统来看，虚拟化既可以通过硬件模拟来实现（xen、esxi等），也可以通过操作系统软件来实现（KVM等）。而容器技术则更为优雅，它充分利用了操作系统本身已有的机制和特性，可以实现远超传统虚拟机的轻量级虚拟化。因此，有人甚至把它称为“新一代的虚拟化”技术，并将<strong>基于容器打造的云平台亲切地称之为“容器云”</strong></p><h3 id="什么docker"><a href="#什么docker" class="headerlink" title="什么docker"></a>什么docker</h3><p>Docker的构想是要实现“build,ship and run any app,anywhere”,即通过对应用程序的封装、分发、部署、运行生命周期。达到应用组件，“一次封装，到处运行”的目的。这里的应用组件，既可以是一个web应用、一个编译环境、也可以是一套数据库平台服务，甚至是一个操作系统或者集群</p><p>可以说，Docker首次为应用的开发、运行和部署提供了“一站式”的实用解决方案</p><p>IBM DeveloperWorks网站关于容器技术的描述十分准确：“容器技术有效地将由单个操作系统管理的资源划分到孤立的组中，以更好的在孤立的组之间平衡有冲突的资源使用需求”</p><p>总结：Docker是一项容器技术，是一个开源项目</p><h3 id="从LXC从到Docker"><a href="#从LXC从到Docker" class="headerlink" title="从LXC从到Docker"></a>从LXC从到Docker</h3><p>Docker技术的主要实现参考的是Linux容器技术（Linux Containers LXC）</p><p>在LXC的基础之上，Docker进一步优化了容器的使用体验，让它进入了寻常百姓家。</p><p>优化项目：</p><p>首先，Docker提供了各种容器管理工具（如分发、版本、移植等），让用户无需关注底层的操作，可以简单明了地管理和使用容器。</p><p>其次，docker引入了<strong>分层文件系统构建和高效的镜像机制</strong>，降低了迁移难度极大地提升了用户体验。用户操作docker就像操作应用自身一样简单。</p><h3 id="使用Docker的好处"><a href="#使用Docker的好处" class="headerlink" title="使用Docker的好处"></a>使用Docker的好处</h3><p>在云时代，开发者创建的应用需要要很方便的在网络上传播，也就是说，应用必须要脱离底层物理硬件的限制，同时必须是“任何时间，任何地点”都可获取的。因此，开发者需要一种新型的创建分布式应用程序的方式，<strong>快速分发和部署</strong>，这正是docker所能够提供的最大优势。</p><p>举例来说，如果要部署LAMP平台，需要分别部署mysql，apache，php等，然后再进行一系列的配置，这样的配置非常繁琐并且容易出错。并且如果需要服务器迁移，往往需要重新部署。</p><p>docker提供了一种更为聪明的方式，通过容器来打包应用。解耦应用和运行平台。这意味着在进行应用迁移的时候，只需要再新的机器上面再启动容器就可以了，不需要再进行重新部署等操作。无论服务器是否是同一类型的平台架构。这节约了大量的时间，并降低了部署过程出现问题的风险。</p><h3 id="Docker在开发和运维中的优势"><a href="#Docker在开发和运维中的优势" class="headerlink" title="Docker在开发和运维中的优势"></a>Docker在开发和运维中的优势</h3><p>具体来说，Docker在开发和运维过程中，具有如下几个方面的优势：</p><ul><li>更快速的交付和部署</li></ul><p>使用镜像来快速构建一套标准环境，</p><ul><li>更高效的资源利用</li></ul><p>docker容器不需要额外的虚拟化管理程序支持，它是内核级别的虚拟化，可以实现更高的性能</p><ul><li>更轻松的迁移和扩展</li></ul><p>docker容器几乎可以在任何的平台上运行，包括物理机，虚拟机，公有云，私有云，个人电脑，服务器等。</p><ul><li>更简单的更新管理</li></ul><p>使用dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作，并且所有的修改都是以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</p><h3 id="Docker与虚拟机的比较"><a href="#Docker与虚拟机的比较" class="headerlink" title="Docker与虚拟机的比较"></a>Docker与虚拟机的比较</h3><ul><li><p>docker容器很快，启动和停止可以在秒级实现，而传统的虚拟机方式需要数分钟</p></li><li><p>docker容器对系统资源的需求很少，一台主机可以同时运行数千个docker容器</p></li><li><p>docker通过类似git设计理念的操作来方便用户获取，分发和应用镜像，存储复用，增量更新。</p></li><li><p>docker通过dockerfile支持灵活的自动化创建和部署机制，提高工作效率，使流程标准化。</p></li></ul><h3 id="Docker和核心价值"><a href="#Docker和核心价值" class="headerlink" title="Docker和核心价值"></a>Docker和核心价值</h3><p>docker的核心价值在于，他很有可能改变传统的软件“交付”方式和运行方式。传统的交付源码或者交付软件的方式的最大问题在于，软件运行期间所“依赖的环境”是无法控制的、不能标准化的，IT人员常常需要耗费很多精力来解决因为“依赖的环境”而导致软件运行出现的各种问题。</p><p>而docker将<strong>软件与其“依赖的环境”打包在一起</strong>，以镜像的方式交付，让软件运行在“标准的环境中”，这非常符合云计算的要求。这种变革一旦被IT人员接受，可能会对产业链带来很大的冲击，我们熟悉的apt-get、yum是否会逐渐被docker pull取代？</p><p>从这一点可以毫不夸张的说，docker是革命性的，它重新定义了软件开发、测试、交付和部署的流程。我们交付的不再是代码、配置文件、数据库定义等。而是整个应用程序运行环境：“OS+各种中间件、类库+应用程序代码”</p><p>有了标准化的运行环境，再加上对CPU、内存、磁盘、网络等动态资源的限制，docker构造了一个“轻量级虚拟环境”，传统虚拟机的绝大多数使用场景可以被docker取代，这将给IT基础设施带来一次更大的冲击；传统虚拟化（KVM、XEN、VMWare）将会何去何从？此外，docker秒级创建/删除虚拟机以及<strong>动态调整资源</strong>的能力，也非常契合云计算的“实例水平扩展”、“资源动态调整”的需求，docker很有可能成为云计算的基石。</p><h3 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h3><p>通过上面的介绍，可以总结出以下几个使用docker的场景</p><ul><li><p>业务高峰期通过启动大量容器进行横向扩展</p></li><li><p>应用需要经常迁移或者多环境运行</p></li></ul><h2 id="核心概念-名词解释"><a href="#核心概念-名词解释" class="headerlink" title="核心概念/名词解释"></a>核心概念/名词解释</h2><p>只有理解了这三个核心概念，才能顺利的理解Docker容器的整个生命周期。</p><p>docker的大部分操作都围绕着它的三个核心概念：<strong>镜像、容器和仓库</strong>展开。因此准确把握这三大核心概念对于掌握docker技术尤为重要。</p><h3 id="三剑客之镜像-Image"><a href="#三剑客之镜像-Image" class="headerlink" title="三剑客之镜像-Image"></a>三剑客之镜像-Image</h3><p>Docker镜像类似<strong>虚拟机镜像</strong>，可以将它理解为一个<strong>只读的模板</strong>。例如，一个镜像可以包含一个基本的操作系统环境，里面仅安装了apache应用程序（或者其他需要的程序），这个时候，可以把它称之为一个apache镜像。</p><p>镜像是创建Docker容器的基础。通过<strong>版本管理和增量的文件系统</strong>，Docker提供了一套十分简单的机制来<strong>创建和更新删除</strong>现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并且直接使用</p><p>功能总结</p><ul><li><p>只读的模板（包含OS+应用）</p></li><li><p>版本管理和增量文件系统的机制在其之上</p></li><li><p>操作：自行创建或网上下载、更新、删除</p></li></ul><h3 id="三剑客之容器-Container"><a href="#三剑客之容器-Container" class="headerlink" title="三剑客之容器-Container"></a>三剑客之容器-Container</h3><p>我们可以将Docker的容器理解为一种轻量级的沙盒（sanbox）。</p><p>Docker利用容器来<strong>运行和隔离</strong>应用（镜像）。</p><p>容器是从镜像创建的应用运行实例，可以将指定的镜像<strong>启动、开始、停止、删除</strong>。而这些容器都是彼此相互隔离的，互不可见的。【容器是镜像的隔离运行单元】</p><p>每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止都十分快速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。</p><p>每个容器都是一个操作系统实例</p><p><strong>容器的功能</strong></p><ul><li>通过容器打包运行应用</li></ul><p>解耦应用和运行平台。这意味着在进行应用迁移的时候，只需要再新的机器上面再启动容器就可以了，不需要再进行重新部署等操作。无论服务器是否是同一类型的平台架构。</p><ul><li>隔离应用</li></ul><p><strong>容器的组成结构</strong></p><ul><li><p>上层：实际应用</p></li><li><p>下层：操作系统环境（主要是内核+函数库）</p></li></ul><h3 id="三剑客之仓库-Repository"><a href="#三剑客之仓库-Repository" class="headerlink" title="三剑客之仓库-Repository"></a>三剑客之仓库-Repository</h3><p>docker仓库类似于代码仓库，它是docker集中存放镜像文件的场所</p><p>需要注意docker仓库和仓库注册服务器（Registry）的区别。</p><ul><li><p>仓库注册服务器是存放仓库的地方，其中往往存放着多个仓库。</p></li><li><p>每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的tag（标签）来进行区分。</p></li></ul><p>根据所存储的镜像公开与否，Docker仓库可以分为两种形式。目前，最大公开仓库是官方提供的docker Hub，其中存放了数量庞大的镜像供用户下载。国内不少云服务提供商（时速云，阿里云等）也提供了仓库的本地源，可以提供稳定的国内访问</p><p>docker也支持用户在本地网络内创建一个只能自己访问的私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到指定的公有或者私有仓库有。这样用户下次在另外一台机器上使用该镜像时，只需要将其从仓库上pull下来就可以。</p><h3 id="Docker-EE和Docker-CE"><a href="#Docker-EE和Docker-CE" class="headerlink" title="Docker-EE和Docker-CE"></a>Docker-EE和Docker-CE</h3><p>Docker Engine改为Docker CE（社区版）, Docker Community Edition</p><p>Docker Data Center改为Docker EE（企业版）, Docker Enterprise Edition</p><p>在Docker三个定价层增加了额外的支付产品和支持</p><p>Docker社区版（CE）是为了开发人员或小团队创建基于容器的应用,与团队成员分享和自动化的开发管道。docker-ce提供了简单的安装和快速的安装，以便可以立即开始开发。docker-ce集成和优化，基础设施。 </p><p>Docker企业版（EE）是专为企业的发展和IT团队建立谁。docker-ee为企业提供最安全的容器平台，以应用为中心的平台。</p><h1 id="第2章-安装配置"><a href="#第2章-安装配置" class="headerlink" title="第2章 安装配置"></a>第2章 安装配置</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>docker目前只能运行在64为平台上，并且要求内核版本不低于3.10，实际上内核越新越好，过低的内核版本容易造成功能不稳定。</p><h3 id="centos环境下安装docker"><a href="#centos环境下安装docker" class="headerlink" title="centos环境下安装docker"></a>centos环境下安装docker</h3><p>安装依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \ device-mapper-persistent-data \lvm2</span><br></pre></td></tr></table></figure><p>添加yum源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum-config-manager \ --add-repo \</span><br><span class="line">https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>安装docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum -y install docker-ce</span><br></pre></td></tr></table></figure><h3 id="ubuntu环境安装docker"><a href="#ubuntu环境安装docker" class="headerlink" title="ubuntu环境安装docker"></a>ubuntu环境安装docker</h3><p><strong>卸载老旧版本的docker</strong></p><p>Older versions of Docker were called <code>docker</code> or <code>docker-engine</code>. If these are installed, uninstall them:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><p><strong>安装软件源</strong></p><ol><li><p>Update the <code>apt</code> package index:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>Install packages to allow <code>apt</code> to use a repository over HTTPS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>Add Docker’s official GPG key:</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>Verify that you now have the key with the fingerprint <code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code>, by searching for the last 8 characters of the fingerprint.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"></span><br><span class="line">pub   4096R/0EBFCD88 2017-02-22</span><br><span class="line">      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid                  Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   4096R/F273FCD8 2017-02-22</span><br></pre></td></tr></table></figure><ol><li>Use the following command to set up the <strong>stable</strong> repository. You always need the <strong>stable</strong> repository, even if you want to install builds from the <strong>edge</strong> or <strong>test</strong> repositories as well. To add the <strong>edge</strong> or <strong>test</strong> repository, add the word <code>edge</code> or <code>test</code> (or both) after the word <code>stable</code> in the commands below.</li></ol><blockquote><p><strong>Note</strong>: The <code>lsb_release -cs</code> sub-command below returns the name of your Ubuntu distribution, such as <code>xenial</code>. Sometimes, in a distribution like Linux Mint, you might have to change <code>$(lsb_release -cs)</code> to your parent Ubuntu distribution. For example, if you are using <code>Linux Mint Rafaela</code>, you could use <code>trusty</code>.</p></blockquote><ul><li>x86_64 / amd64</li><li>armhf</li><li>IBM Power (ppc64le)</li><li>IBM Z (s390x)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure><p><strong>安装docker-ce</strong></p><p>Install the latest version of Docker CE, or go to the next step to install a specific version. Any existing installation of Docker is replaced.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><p>On production systems, you should install a specific version of Docker CE instead of always using the latest. This output is truncated. List the available versions.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">docker-ce | 17.09.0~ce-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages</span><br></pre></td></tr></table></figure><p>我这里的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"> docker-ce | 18.06.1~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br><span class="line"> docker-ce | 18.06.0~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br><span class="line"> docker-ce | 18.03.1~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br></pre></td></tr></table></figure><p>The contents of the list depend upon which repositories are enabled. Choose a specific version to install. The second column is the version string. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by an equals sign (<code>=</code>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce=&lt;VERSION&gt;</span><br></pre></td></tr></table></figure><p>The Docker daemon starts automatically.</p><ol><li><p>Verify that Docker CE is installed correctly by running the <code>hello-world</code> image.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure></li></ol><p><strong>配置开机自启动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p><strong>卸载docker</strong></p><ol><li><p>Uninstall the Docker CE package:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure></li><li><p>Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure></li></ol><p>You must delete any edited configuration files manually.</p><h2 id="配置Docker服务"><a href="#配置Docker服务" class="headerlink" title="配置Docker服务"></a>配置Docker服务</h2><h3 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a><strong>权限配置</strong></h3><p>为了避免每次使用docker命令都需要sudo使用特权身份，可以将当前用户加入安装中自动创建的docker用户组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker [username]</span><br></pre></td></tr></table></figure><p>关于这部分的内容-查看：<a href="https://docs.docker.com/v17.09/engine/installation/linux/linux-postinstall/" target="_blank" rel="noopener">Post-installation steps for Linux</a></p><p>后续需要单独写一篇文章写docker的启动权限问题</p><h3 id="配置文件不存在问题"><a href="#配置文件不存在问题" class="headerlink" title="配置文件不存在问题"></a><strong>配置文件不存在问题</strong></h3><p>docker服务的默认配置文件为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu中：/etc/default/docker</span><br><span class="line">centos中：/etc/sysconfig/docker</span><br></pre></td></tr></table></figure><p>在该配置文件中，我们可以通过修改其中的<strong>DOCKER_OPTS</strong>来修改服务<strong>启动的参数</strong></p><p>但是实际情况，安装完docker之后，是没有改配置文件的</p><p>因此在docker的高版本之后，配置文件变成了：/etc/docker/key.json</p><p>官方参考配置文档：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd//#daemon-configuration-file</a></p><h2 id="cd-启动Docker服务"><a href="#cd-启动Docker服务" class="headerlink" title="cd 启动Docker服务"></a>cd 启动Docker服务</h2><p> 在Centos 7 中，我们可以使用如下命令启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># systemctl enable  docker</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload     #加载配置</span><br></pre></td></tr></table></figure><h1 id="第3章-使用Docker镜像"><a href="#第3章-使用Docker镜像" class="headerlink" title="第3章 使用Docker镜像"></a>第3章 使用Docker镜像</h1><p>镜像（image）是Docker三大核心概念中最为重要的，自Docker诞生之日起，“镜像”就是相关社区最为热门的关键词。</p><p>docker运行容器前需要本地存在对应的镜像，如果镜像没有保存在本地，docker会尝试先从默认镜像仓库下载（默认使用docker Hub公共注册服务器中的仓库），用户也可以通过配置，使用自定义的镜像仓库。</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>镜像是运行容器的前提，官方的docker Hub网站已经提供了数十万个镜像供大家开放下载。</p><p>可以使用docker pull命令直接从docker Hub 镜像源来下载镜像。该命令的格式为docker pull NAME[:TAG]。其中，NAME是镜像仓库的名称（用来区分镜像），TAG是镜像的标签（往往用来表示版本信息）。例如：ubuntu系统是NAME，14.04是TAG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure><hr><p><strong>注意：</strong></p><p>如果不显性的制定TAG，该命令会自动选择latest标签，这会下载仓库中最新版本的镜像。</p><p>镜像的latest标签意味着该镜像的内容会跟踪最新的非稳定版本而发布，内部是不稳定的。</p><p>在生产环境中禁止忽略镜像的标签信息或者使用默认的latest标签</p><hr><h3 id="镜像的分层特性"><a href="#镜像的分层特性" class="headerlink" title="镜像的分层特性"></a>镜像的分层特性</h3><p>镜像文件一般由若干层（layer）构成，每一层都有一个唯一的id（完整的id有256比特，由64个十六进制字符组成）。</p><p>使用docker pull命令下载时会获取并输出镜像的各层信息。<strong>当不同的镜像包括相同的层时，本地仅存储该层的一份内容，减少了需要的存储空间。</strong></p><h3 id="镜像的重名问题"><a href="#镜像的重名问题" class="headerlink" title="镜像的重名问题"></a>镜像的重名问题</h3><p>在使用不同的镜像仓库时，可能会出现镜像重名的情况？</p><p>严格来讲，镜像的仓库名称中还应该添加仓库地址（即仓库注册服务器（Registry））的地址作为前缀，默认我们使用的是docker Hub的服务，该前缀可以忽略不写。</p><p>例如：docker pull ubuntu:14.04 命令相当于docker pull registry.hub.docker.com/ubuntu:14.04命令。</p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>下载镜像到本地之后，即可随时使用该镜像，例如利用该镜像创建一个容器，在其中运行bash应用，执行ping localhost命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master yum.repos.d]# docker run -it ubuntu:14.04 bash</span><br></pre></td></tr></table></figure><h2 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h2><h3 id="使用images命令列出镜像"><a href="#使用images命令列出镜像" class="headerlink" title="使用images命令列出镜像"></a>使用images命令列出镜像</h3><p>使用docker images命令可以列出本地主机上已有镜像的基本信息。、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker images</span><br></pre></td></tr></table></figure><p>在列出的信息中，可以看到以下几个字段信息：</p><ul><li><p>来自于哪个仓库           REPOSITORY</p></li><li><p>镜像的TAG（标签）信息，标签知识标记，并不能识别镜像内容</p></li><li><p>镜像的ID（唯一标识镜像）。IMAGE ID</p></li><li><p>创建时间        CREATED</p></li><li><p>镜像大小               SIZE</p></li></ul><p>其中镜像的ID信息十分重要，它唯一标识了镜像。在使用镜像ID的时候，一般可以使用该ID的前若干个字符组成的可区分串来替代完整的ID。</p><p>镜像大小信息只是标识该镜像的逻辑体积的大小，实际上由于相同的镜像层本地只会存储一份，物理上占用的存储空间会小于各镜像的逻辑体积之和。</p><p>images支持的的选项参数：</p><ul><li><p>-a    –all=true|false         列出所有的镜像文件（包括临时文件），默认为否</p></li><li><p>–digests=true|false          列出镜像的数字摘要值，默认为否</p></li><li><p>-f    –filter=[]                过滤列出的镜像</p></li><li><p>…..</p></li></ul><p>具体可以通过man docker-images 进行查看。</p><h3 id="使用tag命令添加镜像标签"><a href="#使用tag命令添加镜像标签" class="headerlink" title="使用tag命令添加镜像标签"></a>使用tag命令添加镜像标签</h3><p>为了方便在后续的工作中使用特定镜像，还可以使用docker tag命令来为本地镜像任意添加新的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker tag ubuntu:14.04 ubuntu:my14.04</span><br></pre></td></tr></table></figure><p>  注意：docker tag命令添加的标签实际上起到了类似链接的作用</p><h3 id="使用inspect命令查看详细信息"><a href="#使用inspect命令查看详细信息" class="headerlink" title="使用inspect命令查看详细信息"></a>使用inspect命令查看详细信息</h3><p>使用docker inspect命令可以获取该镜像的详细信息，包括制作者，使用架构，各层的数字摘要等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker inspect ubuntu:14.04</span><br></pre></td></tr></table></figure><p>返回的是一个JSON格式的消息，如果我们只要其中一项内容时，可以使用参数-f来指定，例如，获取镜像的Architecture参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker inspect ubuntu:14.04 -f &#123;&#123;&quot;.Architecture&quot;&#125;&#125;</span><br><span class="line">amd64</span><br></pre></td></tr></table></figure><h3 id="使用history命令查看镜像历史"><a href="#使用history命令查看镜像历史" class="headerlink" title="使用history命令查看镜像历史"></a>使用history命令查看镜像历史</h3><p>既然镜像由多个层组成，那么怎么知道各个层的内容具体是什么呢？这时候可以使用history子命令，该命令将列出各层的创建信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker history ubuntu:14.04</span><br><span class="line"></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line"></span><br><span class="line">a35e70164dfb        12 days ago         /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;do…   7B                  </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c sed -i &apos;s/^#\s(deb.universe)$…   2.76kB              </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c rm -rf /var/lib/apt/lists/*          0B                  </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /…   195kB               </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c #(nop) ADD file:3900b83a46e97708a…   222MB</span><br></pre></td></tr></table></figure><h2 id="搜寻镜像"><a href="#搜寻镜像" class="headerlink" title="搜寻镜像"></a>搜寻镜像</h2><p>使用docker search命令来搜索源端仓库中共享的镜像，默认搜索官方仓库中的镜像。</p><p>用法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search TERM</span><br></pre></td></tr></table></figure><p>支持的主要参数为：</p><ul><li><p>–automated=true|false：仅显示自动创建的镜像，默认为否。</p></li><li><p>–no-trubc=true|false：输出信息不截断显示，默认为否</p></li><li><p>-s     –starts=X：指定仅显示评价为指定星级以上的镜像，默认为0，即输出所有的镜像。</p></li></ul><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><h3 id="使用标签删除镜像"><a href="#使用标签删除镜像" class="headerlink" title="使用标签删除镜像"></a>使用标签删除镜像</h3><p>使用docker rmi命令可以删除镜像，命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi IMAGE [IMAGE…]</span><br><span class="line"></span><br><span class="line">其中IMAGE可以为标签或ID,例如：ubuntu:my14.04</span><br></pre></td></tr></table></figure><p>注意：当同一个镜像拥有多个标签的时候，docker rmi命令只是删除该镜像多个标签中的制定标签而已，并不影响镜像文件。因此上述操作相当于只是删除了镜像a35e70164dfb的一个标签而已。</p><p>但是，当镜像只是剩下一个标签的时候，此时再使用docker rmi 命令会彻底删除镜像。</p><h3 id="使用镜像ID删除镜像"><a href="#使用镜像ID删除镜像" class="headerlink" title="使用镜像ID删除镜像"></a>使用镜像ID删除镜像</h3><p>当使用docker rmi（remove image）命令，并且后面跟上镜像的ID（也可以是能进行区分的部分ID串前缀）时，会先尝试删除所有指向该镜像，然后再删除该镜像文件本身</p><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi xxxx(ID)</span><br></pre></td></tr></table></figure><p>注意：使用该命令可以彻底将该镜像删除，而不是只是删除对应的标签，请务必注意。</p><hr><p>注意：</p><p>当有该镜像创建的容器存在时，镜像文件默认是无法被删除的</p><p>试图删除该镜像，docker会提示有容器正在运行，无法删除</p><p>如果要强行删除镜像，可以使用-f参数</p><hr><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>创建镜像的方法主要有三种：</p><ul><li><p>基于已有镜像的容器创建</p></li><li><p>基于本地模板导入</p></li><li><p>基于dockerfile创建</p></li></ul><h3 id="基于已有镜像的容器创建"><a href="#基于已有镜像的容器创建" class="headerlink" title="基于已有镜像的容器创建"></a>基于已有镜像的容器创建</h3><p>当运行一个容器后，内部发生了变化，我们可以把这个发生了变化的容器做成一个新的镜像。</p><p>该方法主要是通过docker commit命令。</p><p>命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [options] container [repository[:tag]]</span><br></pre></td></tr></table></figure><p>主要选项包括：</p><ul><li><p>-a     –author=””：作者信息</p></li><li><p>-c     –change=[]：提交的时候之心dockerfile指令，</p></li><li><p>-m   –message=””：提交消息</p></li><li><p>-p    –pause=true     提交时暂停容器运行</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -it ubuntu:14.04 /bin/bash</span><br><span class="line"></span><br><span class="line">root@fdbe2f28b1d6:/# touch test</span><br><span class="line"></span><br><span class="line">root@fdbe2f28b1d6:/# exit</span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line">[root@master ~]# docker commit -m &quot;add a new file&quot; -a &quot;wxh&quot; fdbe2f28b1d6 test:0.1</span><br><span class="line"></span><br><span class="line">sha256:cd9c21826184f9e65e11644f826fb97918d40d469aa5e3fd8827cbcac19351ed</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker images 查看</span><br></pre></td></tr></table></figure><p>I’m just </p><h3 id="基于本地模板导入"><a href="#基于本地模板导入" class="headerlink" title="基于本地模板导入"></a>基于本地模板导入</h3><p>这部分不常用，详见书籍《docker技术入门与实践》-p32</p><h3 id="基于dockerfile创建"><a href="#基于dockerfile创建" class="headerlink" title="基于dockerfile创建"></a>基于dockerfile创建</h3><h5 id="官方案例"><a href="#官方案例" class="headerlink" title="官方案例"></a>官方案例</h5><p>下面是docker官方案例，有一定的代表性</p><p>链接地址：<a href="https://docs.docker.com/v17.09/get-started/part2/#dockerfile" target="_blank" rel="noopener">https://docs.docker.com/v17.09/get-started/part2/#dockerfile</a></p><p><code>Dockerfile</code> will define what goes on in the environment inside your container. Access to resources like networking interfaces and disk drives is virtualized inside this environment, which is isolated from the rest of your system, so you have to map ports to the outside world, and be specific about what files you want to “copy in” to that environment. However, after doing that, you can expect that the build of your app defined in this <code>Dockerfile</code> will behave exactly the same wherever it runs.</p><p><strong><code>Dockerfile</code></strong></p><p>Create an empty directory. Change directories (<code>cd</code>) into the new directory, create a file called <code>Dockerfile</code>, copy-and-paste the following content into that file, and save it. Take note of the comments that explain each statement in your new Dockerfile.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to /app</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at /app</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>Are you behind a proxy server?</p><p>Proxy servers can block connections to your web app once it’s up and running. If you are behind a proxy server, add the following lines to your Dockerfile, using the <code>ENV</code> command to specify the host and port for your proxy servers:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; # Set proxy server, replace host:port with values for your servers</span><br><span class="line">&gt; ENV http_proxy host:port</span><br><span class="line">&gt; ENV https_proxy host:port</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Add these lines before the call to <code>pip</code> so that the installation succeeds.</p></blockquote><p>This <code>Dockerfile</code> refers to a couple of files we haven’t created yet, namely <code>app.py</code> and <code>requirements.txt</code>. Let’s create those next.</p><p><strong>The app itself</strong></p><p>Create two more files, <code>requirements.txt</code> and <code>app.py</code>, and put them in the same folder with the <code>Dockerfile</code>. This completes our app, which as you can see is quite simple. When the above <code>Dockerfile</code> is built into an image, <code>app.py</code> and <code>requirements.txt</code> will be present because of that <code>Dockerfile</code>’s <code>ADD</code> command, and the output from <code>app.py</code> will be accessible over HTTP thanks to the <code>EXPOSE</code>command.</p><p><strong>requirements.txt</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p><strong>app.py</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure><p>Now we see that <code>pip install -r requirements.txt</code> installs the Flask and Redis libraries for Python, and the app prints the environment variable <code>NAME</code>, as well as the output of a call to <code>socket.gethostname()</code>. Finally, because Redis isn’t running (as we’ve only installed the Python library, and not Redis itself), we should expect that the attempt to use it here will fail and produce the error message.</p><blockquote><p><strong>Note</strong>: Accessing the name of the host when inside a container retrieves the container ID, which is like the process ID for a running executable.</p></blockquote><p>That’s it! You don’t need Python or anything in <code>requirements.txt</code> on your system, nor will building or running this image install them on your system. It doesn’t seem like you’ve really set up an environment with Python and Flask, but you have.</p><p><strong>Build the app</strong></p><p>We are ready to build the app. Make sure you are still at the top level of your new directory. Here’s what <code>ls</code> should show:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Dockerfileapp.pyrequirements.txt</span><br></pre></td></tr></table></figure><p>Now run the build command. This creates a Docker image, which we’re going to tag using <code>-t</code> so it has a friendly name.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .</span><br></pre></td></tr></table></figure><p>Where is your built image? It’s in your machine’s local Docker image registry:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">REPOSITORY            TAG                 IMAGE ID</span><br><span class="line">friendlyhello         latest              326387cea398</span><br></pre></td></tr></table></figure><p><strong>Run the app</strong></p><p>Run the app, mapping your machine’s port 4000 to the container’s published port 80 using <code>-p</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure><p>You should see a message that Python is serving your app at <code>http://0.0.0.0:80</code>. But that message is coming from inside the container, which doesn’t know you mapped port 80 of that container to 4000, making the correct URL <code>http://localhost:4000</code>.</p><p>Go to that URL in a web browser to see the display content served up on a web page.</p><p>Now let’s run the app in the background, in detached mode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure><p>You get the long container ID for your app and then are kicked back to your terminal. Your container is running in the background. You can also see the abbreviated container ID with <code>docker container ls</code> (and both work interchangeably when running commands):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED</span><br><span class="line">1fa4ab2cf395        friendlyhello       &quot;python app.py&quot;     28 seconds ago</span><br></pre></td></tr></table></figure><p>You’ll see that <code>CONTAINER ID</code> matches what’s on <code>http://localhost:4000</code>.</p><p>Now use <code>docker container stop</code> to end the process, using the <code>CONTAINER ID</code>, like so:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop 1fa4ab2cf395</span><br></pre></td></tr></table></figure><h2 id="载入和导出镜像"><a href="#载入和导出镜像" class="headerlink" title="载入和导出镜像"></a>载入和导出镜像</h2><p>用户可以使用docker save和docker load命令来存出和载入镜像</p><h3 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h3><p>如果要导出镜像到本地文件，可以使用docker save命令。例如导出本地的ubunt:14.04镜像为ubuntu_14.04.tar。如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker save -o ubuntu:14.04.tar ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h3><p>可以使用docker load将导出的tar文件再导入到本地的镜像库，例如从上述文件导入镜像到本地镜像列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker load --input ubuntu\:14.04.tar</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker load &lt; ubuntu\:14.04.tar</span><br></pre></td></tr></table></figure><p>该命令将导入镜像及其相关的元数据信息（包括标签等）。导入成功之后，可以使用docker images命令进行查看。</p><h2 id="上传和下载镜像"><a href="#上传和下载镜像" class="headerlink" title="上传和下载镜像"></a>上传和下载镜像</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>首先在docker hub网站完成注册</p><p>可以通过执行 <strong>docker login</strong> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><p>你可以通过 <strong>docker logout</strong> 退出登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:~$ sudo docker login</span><br><span class="line">[sudo] password for wxh:</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">Username: watchmen1992</span><br><span class="line">Password:</span><br><span class="line">WARNING! Your password will be stored unencrypted in /home/wxh/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">wxh@wxh-ThinkPad-E570:~$</span><br></pre></td></tr></table></figure><h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>可以使用docker push命令上传镜像到仓库，默认上传到docker Hub官方仓库（需要在前面进行登录）</p><p>在进行上传之前，我们需要将指定的image镜像打上tag标签</p><p>命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag image username/repository:tag</span><br><span class="line">docker push NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</span><br></pre></td></tr></table></figure><p>例如这里是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:~/.docker$ sudo docker images</span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">friendlyhello              latest              028a0a8d1a73        18 hours ago        132MB</span><br><span class="line">python                     2.7-slim            40792d8a2d6d        4 weeks ago         120MB</span><br><span class="line">hello-world                latest              2cb0d9787c4d        7 weeks ago         1.85kB</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker tag friendlyhello watchmen1992/get_started:part1</span><br></pre></td></tr></table></figure><p>然后push上传</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:~/.docker$ sudo docker push watchmen1992/get_started:part1</span><br><span class="line">The push refers to repository [docker.io/watchmen1992/get_started]</span><br><span class="line">88d851af045c: Pushed</span><br><span class="line">aa5497e6a355: Pushed</span><br><span class="line">d4f7cf378376: Pushed</span><br><span class="line">1ea4f6a807ba: Mounted from library/python</span><br><span class="line">fda4dc055a55: Mounted from library/python</span><br><span class="line">e8fc09a140cf: Mounted from library/python</span><br><span class="line">cdb3f9544e4c: Mounted from library/python</span><br><span class="line">part1: digest: sha256:ded675c46615053ef0a655b163228e50a0e58172003f78f319dad46ee09dac9a size: 1788</span><br></pre></td></tr></table></figure><p>上传之后，我们在docker hub的页面就可以看到新增内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 username/repository:tag</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:~/.docker$ sudo docker run  -p 4000:80 watchmen1992/get_started:part1</span><br><span class="line"></span><br><span class="line">[sudo] password for wxh:</span><br><span class="line"> * Serving Flask app &quot;app&quot; (lazy loading)</span><br><span class="line"> * Environment: production</span><br><span class="line">   WARNING: Do not use the development server in a production environment.</span><br><span class="line">   Use a production WSGI server instead.</span><br><span class="line"> * Debug mode: off</span><br><span class="line"> * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)</span><br><span class="line"></span><br><span class="line">192.168.101.72 - - [30/Aug/2018 03:32:34] &quot;GET / HTTP/1.1&quot; 200 -</span><br></pre></td></tr></table></figure><p>在上传之后，我们就能直接调用仓库的镜像去启动容器</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><h1 id="第4章-使用Docker容器"><a href="#第4章-使用Docker容器" class="headerlink" title="第4章 使用Docker容器"></a>第4章 使用Docker容器</h1><p>容器是docker的另一个和细腻概念。简单来说，容器是镜像的一个运行实例。所不同的是，镜像是静态的只读文件，而容器带有运行时需要的可写文件层。</p><h2 id="创建启动容器"><a href="#创建启动容器" class="headerlink" title="创建启动容器"></a>创建启动容器</h2><h3 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h3><p>使用docker create命令新建一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：docker create -it ubuntu:latest</span><br></pre></td></tr></table></figure><p>注意：使用该命令新建的容器<strong>处于停止状态</strong>，可以使用docker start命令来启动它。</p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>使用docker start 命令来启动一个已经创建的容器，例如启动刚创建的ubuntu容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start af</span><br></pre></td></tr></table></figure><h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><p>除了创建容器后通过start命令来启动，也可以直接新建并启动容器。</p><p>所需要的命令主要为:docker run。等价于先执行docker create命令，再执行docker start命令</p><p>例如，下面的命令输出一个“hello world”之后容器终止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run ubuntu:14.04 /bin/echo &quot;hello,world&quot;</span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure><p>当利用docker run命令来创建并启动容器时，docker在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库中下载</li><li>利用镜像创建一个容器，并启动该容器</li><li>分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中</li><li>从网桥的地址池配置一个IP地址给容器</li><li>执行用户执行的应用程序</li><li>执行完毕后容器被自动终止</li></ul><p>下面命令启动一个bash终端，允许用户进行交互</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -it ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure><p>-t选项让docker分配一个伪终端，并绑定到容器的标准输入上，一则让容器的标准输入保持打开。更多的命令可以通过 man docker-run进行查看。</p><hr><p>注意：</p><p>对于所创建的bash容器，当使用exit命令退出之后，容器就自动处于退出状态了，这是因为对于docker容器来说，当运行的应用退出之后，容器也就没有继续运行的必要了</p><hr><h3 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h3><p>更多的时候，需要让docker容器在后台以守护态（daemonized）形式运行。此时可以添加-d参数来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d  ubuntu:14.04 /bin/bash -c &quot;while true;do echo hello,world;sleep 1;done&quot;</span><br></pre></td></tr></table></figure><p>此时，要获取容器的输出信息，可以使用如下的docker logs命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker logs 9e7</span><br></pre></td></tr></table></figure><p>退出错误代码</p><ul><li><p>125         docker daemon执行出错，例如指定了不支持的docker命令参数</p></li><li><p>126         所指定命令无法执行，例如权限出错</p></li><li><p>127         容器内命令无法找到</p></li></ul><p>当命令执行出错时，会默认返回错误码</p><h3 id="容器参数"><a href="#容器参数" class="headerlink" title="容器参数"></a>容器参数</h3><p>详见书籍《docker技术从入门到实践》p35-37</p><ul><li><p>–rm  容器在终止后会立刻删除</p></li><li><p>-d           守护态启动，注意—rm和-d不能同时使用</p></li></ul><h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用docker stop来终止一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令格式为：docker stop -t|--time[=10]</span><br></pre></td></tr></table></figure><p>该命令首先向容器发送SIGTERM信号，等待一段超时时间（默认为10秒）后，再发送SIGKILL信号来终止容器</p><p>当容器中指定的应用终结时，容器也会自动终止。</p><p>处于终止状态的容器，可以通过start命令来重新启动</p><p>此外，docker restart 命令会将一个运行态的容器先终止，然后再重新启动它</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><h3 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h3><p>这种方法，同一时间只能有一个活动窗口。不建议</p><h3 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h3><p>通过exec命令对容器执行操作是最为推荐的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker start 9e708d44e39a</span><br><span class="line">9e708d44e39a</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker exec -it 9e7 /bin/bash</span><br><span class="line">root@9e708d44e39a:/#</span><br></pre></td></tr></table></figure><p>比较常用的参数有：</p><ul><li><p>-i            –interactive=true|false             打开标准输入接受用户输入命令，默认为false。</p></li><li><p>–privileged=true|false             是否给执行命令以最高权限，默认为false。</p></li><li><p>-t     –tty=true|false         分配伪终端，默认为false</p></li><li><p>-u    –user=””         执行命令的用户名或者ID</p></li></ul><h3 id="nsenter工具"><a href="#nsenter工具" class="headerlink" title="nsenter工具"></a>nsenter工具</h3><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><ul><li><p>docker ps               查看运行中的容器</p></li><li><p>docker ps  -a          查看所有容器，包括运行的与停止的</p></li><li><p>docker ps -qa          查看所有容器ID</p></li></ul><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用docker rm命令来删除处于终止或者退出状态的容器</p><p>命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f|--force [-v|--volumes] container [container…]</span><br></pre></td></tr></table></figure><p>主要支持的选项包括：</p><ul><li><p>-f            –force=false     是否强行终止并删除一个运行中的容器</p></li><li><p>-l            –link=false      删除容器的连接，但是保留容器</p></li><li><p>-v           –volumes=false       删除容器挂载的数据卷</p></li></ul><p>默认情况下，docker rm命令只能删除处于终止或者退出状态的容器，并不能删除还是处于运行状态的容器。</p><p>如果要删除一个运行中的容器，可以添加-f参数。该命令首先向容器发送SIGKILL信号给容器，终止其中的应用，之后强行删除。</p><h2 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker export -o test_for_run.tar ce5</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">docker export e81 &gt; test_for_stop.tar</span><br></pre></td></tr></table></figure><h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><p>导出的文件可以使用docker import命令导入变成镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import test_for_run.tar – test/ubuntu:v1.0</span><br></pre></td></tr></table></figure><p>实际上，既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以用docker import命令来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也更大。此外，从容器快照文件导入时可以重新制定标签等元数据信息</p><h1 id="第5章-访问docker仓库"><a href="#第5章-访问docker仓库" class="headerlink" title="第5章 访问docker仓库"></a>第5章 访问docker仓库</h1><p>仓库（repositroy）是集中存放镜像的地方，分为公共仓库和私有仓库。</p><p>注意：注册服务器是存放仓库的服务器</p><h2 id="docker-hub公共镜像市场"><a href="#docker-hub公共镜像市场" class="headerlink" title="docker hub公共镜像市场"></a>docker hub公共镜像市场</h2><p>默认使用的镜像来源都是docker  hub中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search lnmp</span><br></pre></td></tr></table></figure><h2 id="时速云镜像市场"><a href="#时速云镜像市场" class="headerlink" title="时速云镜像市场"></a>时速云镜像市场</h2><h2 id="搭建本地私有仓库"><a href="#搭建本地私有仓库" class="headerlink" title="搭建本地私有仓库"></a>搭建本地私有仓库</h2><h3 id="使用registry镜像创建私有仓库"><a href="#使用registry镜像创建私有仓库" class="headerlink" title="使用registry镜像创建私有仓库"></a>使用registry镜像创建私有仓库</h3><p>安装docker之后，可以通过官方提供的<strong>registry</strong>镜像来简单搭建一套本地私有仓库环境:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p>它将自动下载并且启动一个registry容器，创建本地的私有仓库服务</p><p>在默认情况下，会将仓库创建在容器的/tmp/registry目录下。可以通过-v参数来将镜像文件存放在本地的指定路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000  -v /opt/data/registry:/tmp/registry  registry</span><br></pre></td></tr></table></figure><h3 id="管理私有仓库-上传镜像"><a href="#管理私有仓库-上传镜像" class="headerlink" title="管理私有仓库-上传镜像"></a>管理私有仓库-上传镜像</h3><p>因为docker images中的字段，REPOSITORY表示仓库信息，因此，我们在创建了私有仓库之后，要使用镜像，需要对镜像进行tag标签的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker tag ubuntu:14.04 47.93.54.101:5000/test</span><br></pre></td></tr></table></figure><p>上述命令解释：</p><p>使用tag命令将ubuntu镜像标记为47.93.54.101:5000/test【也就是这个仓库下的】</p><p>47.93.54.101:5000是仓库注册服务器，test是仓库名称，test:[name]后面接的是tag信息，没有写的话，默认是latest</p><p>接下来使用docker push上传标记的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker push 47.93.54.101:5000/test</span><br></pre></td></tr></table></figure><hr><p>注意：</p><p>客户端采用https，docker registry未采用https服务，由于服务端没有采用https方式，因此客户端无法使用默认的https形式pull镜像，因此我们要做一些操作</p><hr><ul><li>服务端：</li></ul><p>在/etc/docker/目录下，创建daemon.json文件。在文件中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master docker]# cat daemon.json</span><br><span class="line"></span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;47.93.54.101:5000&quot;]&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><p>在/etc/docker/目录下，创建daemon.json文件。在文件中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master docker]# cat daemon.json</span><br><span class="line"></span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;47.93.54.101:5000&quot;]&#125;</span><br></pre></td></tr></table></figure><p>注意：不光服务端要配置，客户端也需要配置</p><p>配置完毕之后，我们就可以看到客户端能够正常的拉取我们私有仓库中的镜像</p><h1 id="第6章-Docker数据管理"><a href="#第6章-Docker数据管理" class="headerlink" title="第6章 Docker数据管理"></a>第6章 Docker数据管理</h1><p>生产环境中使用docker的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。</p><p>容器中管理数据主要有2种方式</p><ul><li><p>数据卷（data volumes）：容器内数据直接映射到本地主机环境</p></li><li><p>数据卷容器（data volumes containers）：使用特定容器维护数据卷。</p></li></ul><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可以供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于linux的mount挂载操作。</p><p>数据卷可以提供很多有用的特性：</p><ul><li><p>数据卷可以在容器之间共享和重用，容器键传递数据将变得高效方便。</p></li><li><p>对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作。</p></li><li><p>对数据卷的更新不会影响镜像，解耦了应用和数据</p></li><li><p>卷会一直存在，直到没有容器使用，可以安全的卸载它。</p></li></ul><h3 id="在容器内创建一个数据卷"><a href="#在容器内创建一个数据卷" class="headerlink" title="在容器内创建一个数据卷"></a>在容器内创建一个数据卷</h3><p>在用docker run命令的时候，使用-v标记可以在容器内创建一个数据卷。多次重复使用-v标记可以创建多个数据卷。</p><p>下面使用 training/webapp镜像创建一个web容器，并创建一个数据卷挂载到容器的/webapp目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -P --name web -v /webapp training/webapp python app.py</span><br></pre></td></tr></table></figure><p>注意：这里是在容器内部创建一个目录，而不是宿主机上创建</p><p>-P是将容器服务暴露的端口，是自动映射到本地主机的临时端口       </p><h3 id="挂载宿主机目录作为数据卷"><a href="#挂载宿主机目录作为数据卷" class="headerlink" title="挂载宿主机目录作为数据卷"></a>挂载宿主机目录作为数据卷</h3><p>使用-v标记也可以指定挂载一个本地的已有目录到容器中去作为数据卷【推荐方式】</p><p>[root@master ~]# docker run -d -P –name web -v /src/webapp:/opt/webapp training/webapp python app.py</p><p>上述命令加载主机的/src/webapp目录到容器的/opt/webapp目录</p><p>本地目录的路径必须是绝对路径，如果目录不存在，docker会自动创建</p><p>注意：docker挂载数据卷的默认权限是读写（rw）,用户也可以通过ro指定为只读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</span><br></pre></td></tr></table></figure><p><strong>设置为ro</strong>之后，容器内对所挂载数据卷内的数据就无法修改了。</p><p> 使用这个功能，在进行一些测试的时候十分方便，比如用户可以将一些程序或者数据放到本地目录中，然后再容器内运行和使用</p><h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p>-v标记也可以从主机挂载单个文件到容器中作为数据卷（对应容器中的某一个文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run –rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>注意：如果直接挂载一个文件到容器中，使用文件编辑工具，包括vi或者sed等，可能会造成文件inode的概念，从docker 1.1.0版本起，这会导致报错，所以推荐的方式是直接挂载目录。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果用户需要再多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。</p><p>首先，创建一个数据卷容器dbdata，并在其中创建一个数据卷挂载到/dbdata：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /dbdata --name dbdata ubuntu</span><br></pre></td></tr></table></figure><p>【这个dbdata是在容器内部的一个目录，请注意】</p><p>作用是：定义一个数据卷</p><p>然后，可以在其他容器中使用–volumes-from来挂载dbdata容器中的数据卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from  dbdata --name db1 ubuntu</span><br></pre></td></tr></table></figure><p>在容器dbdata中查看，数据已经同步过来                        </p><p>可以多次使用 –volume-from参数来从多个容器挂载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷。</p><p>注意：如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时，显式使用docker rm -v命令来指定同时删除关联的容器。</p><p>使用数据卷容器可以让用户在容器之间自由地升级和移动数据卷。</p><h2 id="利用数据卷容器来迁移"><a href="#利用数据卷容器来迁移" class="headerlink" title="利用数据卷容器来迁移"></a>利用数据卷容器来迁移</h2><p>可以利用数据卷容器对其中的数据卷进行备份、恢复、以实现数据的迁移。</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>使用下面的命令来备份dbdata数据卷容器内的数据卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run --volumes-from  dbdata -v $(pwd):/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdata</span><br><span class="line"></span><br><span class="line">tar: Removing leading `/&apos; from member names</span><br><span class="line">/dbdata/</span><br><span class="line">/dbdata/a</span><br><span class="line">/dbdata/db1</span><br></pre></td></tr></table></figure><p>命令解析：</p><p>首先利用ubuntu镜像创建了一个容器worker，使用–volumes-from dbdata参数来让worker容器挂载dbdata容器的数据卷。</p><p>然后使用-v参数，挂载本地的当前目录到worker容器内部的/backup目录。</p><p>worker容器启动之后，使用tar命令，将/dbdata目录备份到容器内的/backup目录下，也就是宿主机的当前目录下。即可完成整个备份过程。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>数据操作都需要借助容器来完成，需要借助容器来打通一个通道。</p><p>恢复数据的思路（这里指的是恢复数据到另一个没有数据的数据卷容器中）：</p><ul><li><p>创建一个新的数据卷容器</p></li><li><p>创建一个新的容器，挂载该容器（–volumes-from参数）</p></li><li><p>挂载本地的目录到/backup下（这时该目录下就会有本地的数据），然后解压其中的数据</p></li></ul><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure><h1 id="第7章-端口映射与容器互联"><a href="#第7章-端口映射与容器互联" class="headerlink" title="第7章 端口映射与容器互联"></a>第7章 端口映射与容器互联</h1><p>在实际情况中，是需要多个服务组件容器共同协作的情况，因此往往需要多个容器之间能够互相访问到对方的服务。</p><p>除了通过网络来进行访问，docker还提供了两个功能满足服务访问的基本需求：</p><ul><li><p>一个是允许映射容器内应用的服务端口到本地宿主主机</p></li><li><p>另一个是互联机制实现多个容器键通过容器名称来来快速访问</p></li></ul><p>在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。</p><h2 id="端口映射实现访问容器"><a href="#端口映射实现访问容器" class="headerlink" title="端口映射实现访问容器"></a>端口映射实现访问容器</h2><h3 id="所有接口的随机端口"><a href="#所有接口的随机端口" class="headerlink" title="所有接口的随机端口"></a>所有接口的随机端口</h3><p>可以通过-P或者-p参数来指定端口映射。</p><ul><li>当使用-P时，映射一个49000-49900的端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure><p>可以通过docker logs -f [id]来查看应用信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker logs -f 4336a2dbe777</span><br></pre></td></tr></table></figure><h3 id="所有接口的指定端口"><a href="#所有接口的指定端口" class="headerlink" title="所有接口的指定端口"></a>所有接口的指定端口</h3><p>命令格式：hostport:containerport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>使用该命令映射所有接口地址</p><p>此时绑定所有接口上的所有地址，将本地的5000端口映射搭配容器的5000端口</p><h3 id="指定地址的指定端口"><a href="#指定地址的指定端口" class="headerlink" title="指定地址的指定端口"></a>指定地址的指定端口</h3><p>命令格式：IP:hostport:containerport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>指定使用本机的哪一个地址进行端口映射</p><h3 id="指定地址的任意端口"><a href="#指定地址的任意端口" class="headerlink" title="指定地址的任意端口"></a>指定地址的任意端口</h3><p>命令格式：IP::containerport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>还可以使用udp标记来指定udp端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 127.0.0.1::5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure><h2 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h2><p>命令语法：docker port 容id  [port]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker port  4336a2dbe777</span><br><span class="line"></span><br><span class="line">5000/tcp -&gt; 0.0.0.0:32773</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker port  4336a2dbe777 5000</span><br><span class="line"></span><br><span class="line">0.0.0.0:32773</span><br></pre></td></tr></table></figure><h2 id="互联机制实现便捷互访"><a href="#互联机制实现便捷互访" class="headerlink" title="互联机制实现便捷互访"></a>互联机制实现便捷互访</h2><p>容器的互联（link）是一种让多个容器中应用进行快速交互的方式。他会在源和接受容器之间创建连接关系，接受容器可以通过容器名称快速访问到源容器，而不用指定具体的IP地址。</p><h3 id="自定义容器名称"><a href="#自定义容器名称" class="headerlink" title="自定义容器名称"></a>自定义容器名称</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>连接系统通过容器名称来执行，因此需要给每个容器都定义一个名称。</p><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>使用—link参数可以让容器之间安全地进行交互</p><p>link参数格式为：–link name:alias</p><p>docker通过两种方式为容器公开连接信息。</p><ul><li><p>更新环境变量</p></li><li><p>更新/etc/hosts文件。</p></li></ul><p>以下为参考案例：</p><p>首先创建一个新的数据库容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master registry]# docker run -d --name db training/postgres</span><br></pre></td></tr></table></figure><p>创建一个新的web容器，并将它连接到db容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master registry]# docker run -d -P --name web --link db:db training/webapp python app.py</span><br></pre></td></tr></table></figure><p>查看容器之间的连接信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master registry]# docker run --rm --name web2 --link db:db training/webapp env</span><br></pre></td></tr></table></figure><p>查看hosts信息(cat /etc/hosts)</p><p>可以看到，hosts文件中包含db的信息和自身的配置信息。</p><p>以上都是单机中多容器之间的互联，后续还会涉及跨主机之间的容器通信。</p><h1 id="第8章-使用dockerfile创建镜像"><a href="#第8章-使用dockerfile创建镜像" class="headerlink" title="第8章 使用dockerfile创建镜像"></a>第8章 使用dockerfile创建镜像</h1><h1 id="第9章-docker网络"><a href="#第9章-docker网络" class="headerlink" title="第9章 docker网络"></a>第9章 docker网络</h1><h1 id="镜像仓库之-Harbor"><a href="#镜像仓库之-Harbor" class="headerlink" title="镜像仓库之-Harbor"></a>镜像仓库之-Harbor</h1><p>github主页：<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">https://github.com/goharbor/harbor</a></p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li><p><strong>Role based access control</strong>: Users and repositories are organized via ‘projects’ and a user can have different permission for images under a project.</p><blockquote><p>用户和镜像仓库是通过项目关联起来的，不同用户在该项目下拥有不同的权限</p></blockquote></li><li><p><strong>Policy based image replication</strong>: Images can be replicated (synchronized) between multiple registry instances, with auto-retry on errors. Great for load balancing, high availability, multi-datacenter, hybrid and multi-cloud scenarios.</p><blockquote><p>镜像将在多个注册实例中复制，实现高可用、负载均衡、多路选择等功能</p></blockquote></li><li><p><strong>Vulnerability Scanning</strong>: Harbor scans images regularly and warns users of vulnerabilities.</p><blockquote><p>高危扫描：harbor将会在规律的扫描镜像并且提醒用户相关的危险</p></blockquote></li><li><p><strong>LDAP/AD support</strong>: Harbor integrates with existing enterprise LDAP/AD for user authentication and management.</p><blockquote><p>harbor可以聚合企业现在的LDAP/AD等实现用户认证和管理</p></blockquote></li><li><p><strong>Image deletion &amp; garbage collection</strong>: Images can be deleted and their space can be recycled.</p><blockquote><p>镜像删除和垃圾收集</p></blockquote></li><li><p><strong>Notary</strong>: Image authenticity can be ensured.</p><blockquote><p>可以保证镜像的可靠性</p></blockquote></li><li><p><strong>Graphical user portal</strong>: User can easily browse, search repositories and manage projects.</p><blockquote><p>图形化的用户入口：可以浏览，检索，管理项目</p></blockquote></li><li><p><strong>Auditing</strong>: All the operations to the repositories are tracked.</p><blockquote><p>审计：所有的操作都可以被追踪</p></blockquote></li><li><p><strong>RESTful API</strong>: RESTful APIs for most administrative operations, easy to integrate with external systems.</p><blockquote><p>提供api</p></blockquote></li><li><p><strong>Easy deployment</strong>: Provide both an online and offline installer.</p><blockquote><p>部署简单，提供在线和离线两种安装方式</p></blockquote></li></ul><p>### </p><h2 id="Architecture-体系结构"><a href="#Architecture-体系结构" class="headerlink" title="Architecture-体系结构"></a>Architecture-体系结构</h2><p><img src="https://camo.githubusercontent.com/e0de62fb4f08efedd2c5abd44786410d3af06c7b/687474703a2f2f7777772e7468696e6b2d666f756e6472792e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30392f61727469636c65315f696d616765322e706e67" alt="img"></p><p>As depicted in the above diagram, Harbor comprises 6 components:</p><p><strong>Proxy:</strong> Components of Harbor, such as registry, UI and token services, are all behind a reversed proxy. The proxy forwards requests from browsers and Docker clients to various backend services.</p><blockquote><p>harbor使用代理结构，外部的客户端（浏览器或者docker client）访问调用是通过代理层去实现的</p></blockquote><p><strong>Registry:</strong> Responsible for storing Docker images and processing Docker push/pull commands. As Harbor needs to enforce access control to images, the Registry will direct clients to a token service to obtain a valid token for each pull or push request.</p><blockquote><p>注册部分：响应操作docker镜像的请求</p><p>harbor为了确保安全性，客户端在调用的时候，需要取得valid token才可以进行操作</p></blockquote><p><strong>Core services:</strong> Harbor’s core functions, which mainly provides the following services:</p><p><strong>UI:</strong> a graphical user interface to help users manage images on the Registry Webhook: Webhook is a mechanism configured in the Registry so that image status changes in the Registry can be populated to the Webhook endpoint of Harbor. Harbor uses webhook to update logs, initiate replications, and some other functions. Token service: Responsible for issuing a token for every docker push/pull command according to a user’s role of a project. If there is no token in a request sent from a Docker client, the Registry will redirect the request to the token service. Database: Database stores the meta data of projects, users, roles, replication policies and images.</p><blockquote><p>提供一个图形的用户入口，方便用户在注册钩子系统（registry webhook）中管理镜像。</p></blockquote><p><strong>Job services:</strong> used for image replication, local images can be replicated(synchronized) to other Harbor instances.</p><p><strong>Log collector:</strong> Responsible for collecting logs of other modules in a single place.</p><h2 id="安装配置harbor"><a href="#安装配置harbor" class="headerlink" title="安装配置harbor"></a>安装配置harbor</h2><p>参考文献：<a href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md" target="_blank" rel="noopener">https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md</a></p><h3 id="环境要求："><a href="#环境要求：" class="headerlink" title="环境要求："></a>环境要求：</h3><p>Harbor is deployed as several Docker containers, and, therefore, can be deployed on any Linux distribution that supports Docker. The target host requires Python, Docker, and Docker Compose to be installed.</p><p><strong>Hardware</strong></p><table><thead><tr><th>Resource</th><th>Capacity</th><th>Description</th></tr></thead><tbody><tr><td>CPU</td><td>minimal 2 CPU</td><td>4 CPU is prefered</td></tr><tr><td>Mem</td><td>minimal 4GB</td><td>8GB is prefered</td></tr><tr><td>Disk</td><td>minimal 40GB</td><td>160GB is prefered</td></tr></tbody></table><p><strong>Software</strong></p><table><thead><tr><th>Software</th><th>Version</th><th>Description</th></tr></thead><tbody><tr><td>Python</td><td>version 2.7 or higher</td><td>Note that you may have to install Python on Linux distributions (Gentoo, Arch) that do not come with a Python interpreter installed by default</td></tr><tr><td>Docker engine</td><td>version 1.10 or higher</td><td>For installation instructions, please refer to: <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a></td></tr><tr><td>Docker Compose</td><td>version 1.6.0 or higher</td><td>For installation instructions, please refer to: <a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">https://docs.docker.com/compose/install/</a></td></tr><tr><td>Openssl</td><td>latest is prefered</td><td>Generate certificate and keys for Harbor</td></tr></tbody></table><p><strong>Network ports</strong></p><table><thead><tr><th>Port</th><th>Protocol</th><th>Description</th></tr></thead><tbody><tr><td>443</td><td>HTTPS</td><td>Harbor UI and API will accept requests on this port for https protocol</td></tr><tr><td>4443</td><td>HTTPS</td><td>Connections to the Docker Content Trust service for Harbor, only needed when Notary is enabled</td></tr><tr><td>80</td><td>HTTP</td><td>Harbor UI and API will accept requests on this port for http protocol</td></tr></tbody></table><p>Installation Steps**</p><p>The installation steps boil down to the following</p><ol><li>Download the installer;</li><li>Configure <strong>harbor.cfg</strong>;</li><li>Run <strong>install.sh</strong> to install and start Harbor;</li></ol><p>实际操作：</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar xvf harbor-online-installer-&lt;version&gt;.tgz</span><br></pre></td></tr></table></figure><p>安装docker-ce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils   device-mapper-persistent-data   lvm2</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager     --add-repo     https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><p>启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost tools]# systemctl start  docker</span><br><span class="line">[root@localhost tools]# systemctl enable  docker</span><br></pre></td></tr></table></figure><p>安装Docker Compose</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Configuration parameters are located in the file <strong>harbor.cfg</strong></p><p>There are two categories of parameters in harbor.cfg, <strong>required parameters</strong> and <strong>optional parameters</strong>.</p><ul><li><p><strong>required parameters</strong>: These parameters are required to be set in the configuration file. They will take effect if a user updates them in <code>harbor.cfg</code> and run the <code>install.sh</code> script to reinstall Harbor.</p></li><li><p><strong>optional parameters</strong>: These parameters are optional for updating, i.e. user can leave them as default and update them on Web UI after Harbor is started. If they are set in <code>harbor.cfg</code>, they only take effect in the first launch of Harbor. Subsequent update to these parameters in <code>harbor.cfg</code> will be ignored.</p><p><strong>Note:</strong> If you choose to set these parameters via the UI, be sure to do so right after Harbor is started. In particular, you must set the desired <strong>auth_mode</strong> before registering or creating any new users in Harbor. When there are users in the system (besides the default admin user), <strong>auth_mode</strong> cannot be changed.</p></li></ul><p>配置文件中有2种配置内容，一种是必须配置的参数，一种是可选参数</p><ul><li>可选参数：如果你将可选参数设置在配置文件里面，也可以在安装完毕只有在web UI上进行设置，如果在启动之前配置在配置文件里面，那么当启动之后再在web上修改，那么修改将会是无效的，不会被刷新到配置文件当中。</li><li>可选参数：可以再harbor启动之后，在web界面进行更新，如果这些参数是在在配置文件中的，那么不会即时生效。配置文件中的只会在启动之后生效</li></ul><p>修改完毕之后的配置如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@app028-dev harbor]# less harbor.cfg  | egrep -v &apos;^$|^#&apos;</span><br><span class="line">hostname = dhub-dev.dwbops.com</span><br><span class="line">ui_url_protocol = https</span><br><span class="line">max_job_workers = 3</span><br><span class="line">customize_crt = on</span><br><span class="line">ssl_cert = /data/cert/server.cer</span><br><span class="line">ssl_cert_key = /data/cert/server.key</span><br><span class="line">secretkey_path = /data</span><br><span class="line">admiral_url = NA</span><br><span class="line">log_rotate_count = 50</span><br><span class="line">log_rotate_size = 200M</span><br><span class="line">email_identity =</span><br><span class="line">email_server = smtp.mydomain.com</span><br><span class="line">email_server_port = 25</span><br><span class="line">email_username = sample_admin@mydomain.com</span><br><span class="line">email_password = abc</span><br><span class="line">email_from = admin &lt;sample_admin@mydomain.com&gt;</span><br><span class="line">email_ssl = false</span><br><span class="line">email_insecure = false</span><br><span class="line">harbor_admin_password = dHarbor12345</span><br><span class="line">auth_mode = db_auth</span><br><span class="line">ldap_url = ldaps://ldap.mydomain.com</span><br><span class="line">ldap_basedn = ou=people,dc=mydomain,dc=com</span><br><span class="line">ldap_uid = uid</span><br><span class="line">ldap_scope = 2</span><br><span class="line">ldap_timeout = 5</span><br><span class="line">ldap_verify_cert = true</span><br><span class="line">self_registration = on</span><br><span class="line">token_expiration = 30</span><br><span class="line">project_creation_restriction = everyone</span><br><span class="line">db_host = mysql</span><br><span class="line">db_password = root123</span><br><span class="line">db_port = 3306</span><br><span class="line">db_user = root</span><br><span class="line">redis_url =</span><br><span class="line">clair_db_host = postgres</span><br><span class="line">clair_db_password = password</span><br><span class="line">clair_db_port = 5432</span><br><span class="line">clair_db_username = postgres</span><br><span class="line">clair_db = postgres</span><br><span class="line">uaa_endpoint = uaa.mydomain.org</span><br><span class="line">uaa_clientid = id</span><br><span class="line">uaa_clientsecret = secret</span><br><span class="line">uaa_verify_cert = true</span><br><span class="line">uaa_ca_cert = /path/to/ca.pem</span><br><span class="line">registry_storage_provider_name = filesystem</span><br><span class="line">registry_storage_provider_config =</span><br></pre></td></tr></table></figure><p>自己做测试时，将url类型设置成为http，并且将域名设置成为：harbar.wxh.com</p><p>修改完配置之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./install.sh</span><br></pre></td></tr></table></figure><p>整个的安装过程如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost harbor]# ./install.sh</span><br><span class="line"></span><br><span class="line">[Step 0]: checking installation environment ...</span><br><span class="line"></span><br><span class="line">Note: docker version: 18.06.1</span><br><span class="line"></span><br><span class="line">Note: docker-compose version: 1.22.0</span><br><span class="line"></span><br><span class="line">[Step 1]: loading Harbor images ...</span><br><span class="line">651f69aef02c: Loading layer [==================================================&gt;]  135.8MB/135.8MB</span><br><span class="line">40a1aad64343: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">3fe2713e4072: Loading layer [==================================================&gt;]  12.16MB/12.16MB</span><br><span class="line">ba3a1eb0e375: Loading layer [==================================================&gt;]   17.3MB/17.3MB</span><br><span class="line">447427ec5e1a: Loading layer [==================================================&gt;]  15.87kB/15.87kB</span><br><span class="line">4ccb4026663c: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">16faa95946a1: Loading layer [==================================================&gt;]  29.46MB/29.46MB</span><br><span class="line">Loaded image: vmware/notary-server-photon:v0.5.1-v1.4.0</span><br><span class="line">fa7ba9fd42c9: Loading layer [==================================================&gt;]  10.95MB/10.95MB</span><br><span class="line">4e400f9ae23e: Loading layer [==================================================&gt;]   17.3MB/17.3MB</span><br><span class="line">2802fb27c88b: Loading layer [==================================================&gt;]  15.87kB/15.87kB</span><br><span class="line">e6367a4e1e1e: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">8ece8dfcdd98: Loading layer [==================================================&gt;]  28.24MB/28.24MB</span><br><span class="line">Loaded image: vmware/notary-signer-photon:v0.5.1-v1.4.0</span><br><span class="line">a7dd1a8afcaf: Loading layer [==================================================&gt;]  396.7MB/396.7MB</span><br><span class="line">05adebbe496f: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">86eb534949fa: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">d7f127c69380: Loading layer [==================================================&gt;]   7.68kB/7.68kB</span><br><span class="line">5ac1c4dc5ee9: Loading layer [==================================================&gt;]  1.536kB/1.536kB</span><br><span class="line">d0bec56b5b1a: Loading layer [==================================================&gt;]  9.728kB/9.728kB</span><br><span class="line">4bbe83860556: Loading layer [==================================================&gt;]   2.56kB/2.56kB</span><br><span class="line">e526f9e6769f: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">Loaded image: vmware/harbor-db:v1.4.0</span><br><span class="line">1cff102bbda2: Loading layer [==================================================&gt;]  154.1MB/154.1MB</span><br><span class="line">04c9f3e07de1: Loading layer [==================================================&gt;]  10.75MB/10.75MB</span><br><span class="line">7b6c7bf54f5c: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">42f8acdb7fe3: Loading layer [==================================================&gt;]  48.13kB/48.13kB</span><br><span class="line">5b6299d0a1df: Loading layer [==================================================&gt;]   10.8MB/10.8MB</span><br><span class="line">Loaded image: vmware/clair-photon:v2.0.1-v1.4.0</span><br><span class="line">6534131f457c: Loading layer [==================================================&gt;]  94.76MB/94.76MB</span><br><span class="line">73f582101e4b: Loading layer [==================================================&gt;]  6.656kB/6.656kB</span><br><span class="line">86d847823c48: Loading layer [==================================================&gt;]  6.656kB/6.656kB</span><br><span class="line">Loaded image: vmware/postgresql-photon:v1.4.0</span><br><span class="line">5cd250d5a352: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">ad3fd52b54f3: Loading layer [==================================================&gt;]  14.99MB/14.99MB</span><br><span class="line">13b1e24cc368: Loading layer [==================================================&gt;]  14.99MB/14.99MB</span><br><span class="line">Loaded image: vmware/harbor-adminserver:v1.4.0</span><br><span class="line">c26c69706710: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">223f6fe02cc8: Loading layer [==================================================&gt;]  23.45MB/23.45MB</span><br><span class="line">1fc843c8698a: Loading layer [==================================================&gt;]  7.168kB/7.168kB</span><br><span class="line">e09293610ee7: Loading layer [==================================================&gt;]  10.39MB/10.39MB</span><br><span class="line">d59f9780b1d8: Loading layer [==================================================&gt;]  23.44MB/23.44MB</span><br><span class="line">Loaded image: vmware/harbor-ui:v1.4.0</span><br><span class="line">dd4753242e59: Loading layer [==================================================&gt;]  73.07MB/73.07MB</span><br><span class="line">95aed61ca251: Loading layer [==================================================&gt;]  3.584kB/3.584kB</span><br><span class="line">1864f9818562: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">da2a19f80b81: Loading layer [==================================================&gt;]  4.096kB/4.096kB</span><br><span class="line">058531639e75: Loading layer [==================================================&gt;]  3.584kB/3.584kB</span><br><span class="line">a84e69fb619b: Loading layer [==================================================&gt;]  10.24kB/10.24kB</span><br><span class="line">Loaded image: vmware/harbor-log:v1.4.0</span><br><span class="line">b1056051f246: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">07678065e08b: Loading layer [==================================================&gt;]  19.19MB/19.19MB</span><br><span class="line">a2d9bdb8f5fb: Loading layer [==================================================&gt;]  19.19MB/19.19MB</span><br><span class="line">Loaded image: vmware/harbor-jobservice:v1.4.0</span><br><span class="line">7f58ce57cd5e: Loading layer [==================================================&gt;]  4.805MB/4.805MB</span><br><span class="line">Loaded image: vmware/nginx-photon:v1.4.0</span><br><span class="line">4c8965978b77: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">1466c942edde: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">ac5c17331735: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">86824c7c466a: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">fd3bd0e70d67: Loading layer [==================================================&gt;]   22.8MB/22.8MB</span><br><span class="line">b02195d77636: Loading layer [==================================================&gt;]   22.8MB/22.8MB</span><br><span class="line">Loaded image: vmware/registry-photon:v2.6.2-v1.4.0</span><br><span class="line">Loaded image: vmware/photon:1.0</span><br><span class="line">Loaded image: vmware/mariadb-photon:v1.4.0</span><br><span class="line">454c81edbd3b: Loading layer [==================================================&gt;]  135.2MB/135.2MB</span><br><span class="line">e99db1275091: Loading layer [==================================================&gt;]  395.4MB/395.4MB</span><br><span class="line">051e4ee23882: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">6cca4437b6f6: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">1d48fc08c8bc: Loading layer [==================================================&gt;]   7.68kB/7.68kB</span><br><span class="line">0419724fd942: Loading layer [==================================================&gt;]  1.536kB/1.536kB</span><br><span class="line">526b2156bd7a: Loading layer [==================================================&gt;]  637.8MB/637.8MB</span><br><span class="line">9ebf6900ecbd: Loading layer [==================================================&gt;]  78.34kB/78.34kB</span><br><span class="line">Loaded image: vmware/harbor-db-migrator:1.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Step 2]: preparing environment ...</span><br><span class="line">Generated and saved secret to file: /data/secretkey</span><br><span class="line">Generated configuration file: ./common/config/nginx/nginx.conf</span><br><span class="line">Generated configuration file: ./common/config/adminserver/env</span><br><span class="line">Generated configuration file: ./common/config/ui/env</span><br><span class="line">Generated configuration file: ./common/config/registry/config.yml</span><br><span class="line">Generated configuration file: ./common/config/db/env</span><br><span class="line">Generated configuration file: ./common/config/jobservice/env</span><br><span class="line">Generated configuration file: ./common/config/log/logrotate.conf</span><br><span class="line">Generated configuration file: ./common/config/jobservice/app.conf</span><br><span class="line">Generated configuration file: ./common/config/ui/app.conf</span><br><span class="line">Generated certificate, key file: ./common/config/ui/private_key.pem, cert file: ./common/config/registry/root.crt</span><br><span class="line">The configuration files are ready, please use docker-compose to start the service.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Step 3]: checking existing instance of Harbor ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Step 4]: starting Harbor ...</span><br><span class="line">Creating network &quot;harbor_harbor&quot; with the default driver</span><br><span class="line">Creating harbor-log ... done</span><br><span class="line">Creating harbor-db          ... done</span><br><span class="line">Creating registry           ... done</span><br><span class="line">Creating harbor-adminserver ... done</span><br><span class="line">Creating harbor-ui          ... done</span><br><span class="line">Creating nginx              ... done</span><br><span class="line">Creating harbor-jobservice  ... done</span><br><span class="line"></span><br><span class="line">✔ ----Harbor has been installed and started successfully.----</span><br><span class="line"></span><br><span class="line">Now you should be able to visit the admin portal at http://harbar.wxh.com.</span><br><span class="line">For more details, please visit https://github.com/vmware/harbor .</span><br><span class="line"></span><br><span class="line">[root@localhost harbor]#</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h5 id="Required-parameters"><a href="#Required-parameters" class="headerlink" title="Required parameters:"></a>Required parameters:</h5><ul><li><p><strong>hostname</strong>: The target host’s hostname, which is used to access the UI and the registry service. It should be the IP address or the fully qualified domain name (FQDN) of your target machine, e.g., <code>192.168.1.10</code> or <code>reg.yourdomain.com</code>. <em>Do NOT use localhost or 127.0.0.1 for the hostname - the registry service needs to be accessible by external clients!</em></p><blockquote><p><strong>hostname一般配置为域名</strong>,也就是整个harbor的入口</p></blockquote></li><li><p><strong>ui_url_protocol</strong>: (<strong>http</strong> or <strong>https</strong>. Default is <strong>http</strong>) The protocol used to access the UI and the token/notification service. If Notary is enabled, this parameter has to be <em>https</em>. By default, this is <em>http</em>. To set up the https protocol, refer to <strong>Configuring Harbor with HTTPS Access</strong>.</p><blockquote><p><strong>走HTT还是HTTPS</strong></p></blockquote></li><li><p><strong>db_password</strong>: The root password for the MySQL database used for <strong>db_auth</strong>. <em>Change this password for any production use!</em></p></li><li><p><strong>max_job_workers</strong>: (default value is <strong>3</strong>) The maximum number of replication workers in job service. For each image replication job, a worker synchronizes all tags of a repository to the remote destination. Increasing this number allows more concurrent replication jobs in the system. However, since each worker consumes a certain amount of network/CPU/IO resources, please carefully pick the value of this attribute based on the hardware resource of the host.</p><blockquote><p><strong>做复制工作的进程数量，默认3个，这些进程，将这些镜像同步到远端的存储中</strong></p><p>每个进程都需要消耗系统的资源，因此合理设置数量</p></blockquote></li><li><p><strong>customize_crt</strong>: (<strong>on</strong> or <strong>off</strong>. Default is <strong>on</strong>) When this attribute is <strong>on</strong>, the prepare script creates private key and root certificate for the generation/verification of the registry’s token. Set this attribute to <strong>off</strong> when the key and root certificate are supplied by external sources. Refer to <a href="https://github.com/goharbor/harbor/blob/master/docs/customize_token_service.md" target="_blank" rel="noopener">Customize Key and Certificate of Harbor Token Service</a> for more info.</p></li><li><p><strong>ssl_cert</strong>: The path of SSL certificate, it’s applied only when the protocol is set to https</p></li><li><p><strong>ssl_cert_key</strong>: The path of SSL key, it’s applied only when the protocol is set to https</p></li><li><p><strong>secretkey_path</strong>: The path of key for encrypt or decrypt the password of a remote registry in a replication policy.</p></li><li><p><strong>log_rotate_count</strong>: Log files are rotated <strong>log_rotate_count</strong> times before being removed. If count is 0, old versions are removed rather than rotated.</p></li><li><p><strong>log_rotate_size</strong>: Log files are rotated only if they grow bigger than <strong>log_rotate_size</strong> bytes. If size is followed by k, the size is assumed to be in kilobytes. If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G are all valid.</p></li></ul><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><h3 id="上传镜像-1"><a href="#上传镜像-1" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>push的格式为：docker push reg.yourdomain.com/myproject/myrepo:mytag</p><p>注意首先需要登录</p><p>将要上传的镜像打上标志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag hello-world harbar.wxh.com/apps/hello-world</span><br><span class="line"></span><br><span class="line">docker push harbar.wxh.com/apps/hello-world</span><br></pre></td></tr></table></figure><p>这种上传的话，默认是打上latest的标志</p><p>打上指定的标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag hello-world harbar.wxh.com/apps/hello-world:v1</span><br><span class="line">docker push harbar.wxh.com/apps/hello-world:v1</span><br></pre></td></tr></table></figure><h2 id="harbor镜像删除"><a href="#harbor镜像删除" class="headerlink" title="harbor镜像删除"></a>harbor镜像删除</h2><p>在web页面上删除镜像实际上只是执行的软删除，因为镜像存在很强的文件系统依赖关系</p><p>Harbor的UI界面上先删除镜像，但这个操作并没有删除磁盘上存放的镜像文件，只是镜像文件manifest的映射关系，还需要通过GC来删除。</p><p><strong>CAUTION: If both tag A and tag B refer to the same image, after deleting tag A, B will also get deleted. if you enabled content trust, you need to use notary command line tool to delete the tag’s signature before you delete an image.</strong></p><p>注意，如果标签A和B都指向都一个镜像（比如hello-world的2个镜像），那么删除一个之后，另外一个也会消失</p><p>先停止Harbor：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><p>通过带有–dry-run选项，可以<strong>查看</strong>到将要删除的镜像文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name gc --rm --volumes-from registry vmware/registry:2.6.2-photon garbage-collect --dry-run /etc/registry/config.yml1</span><br></pre></td></tr></table></figure><p>不带–dry-run选项，直接<strong>执行删除</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name gc --rm --volumes-from registry vmware/registry:2.6.2-photon garbage-collect /etc/registry/config.yml1</span><br></pre></td></tr></table></figure><p>再启动Harbor：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose start</span><br></pre></td></tr></table></figure><h3 id="使用harbor-go-client"><a href="#使用harbor-go-client" class="headerlink" title="使用harbor-go-client"></a>使用harbor-go-client</h3><p>项目地址：<a href="https://github.com/moooofly/harbor-go-client" target="_blank" rel="noopener">https://github.com/moooofly/harbor-go-client</a></p><p>操作步骤：</p><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/moooofly/harbor-go-client</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>在执行make的时候，可能会存在很多的依赖关系</p><p>有以下依赖关系需要解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/alecthomas/gometalinter</span><br></pre></td></tr></table></figure><h3 id="镜像清理策略"><a href="#镜像清理策略" class="headerlink" title="镜像清理策略"></a>镜像清理策略</h3><p>需求：</p><ul><li><p>暂时不做删除 repo 的处理【这部分手动处理】</p></li><li><p>保留 60 天内创建的所有 tag ，在 60 天之前创建的 tag ，额外保留 10 个；</p></li><li><p>标签数只有 1的镜像，不清理</p></li><li>保留最后一次更新的tag，有些image比较稳定，有可能超过60天都没有修改，但是却一直在用</li><li>针对一些特殊的（比如每天5个tag的镜像，那么60天就有300个），这个单独特殊处理</li></ul><p>最终：</p><ul><li>针对 tag ：保留 60 天内创建的所有 tag ，在 60 天之前创建的 tag ，额外保留 10 个；</li><li>针对 repo ：暂时不做删除 repo 的处理（不太好确定 repo 是否还在使用，理论上讲每个 repo 下至少应该有一个 tag 是被需要的；若打算删除，则建议 repo 负责人自行进行删除操作）；</li><li>私有仓库暂时不做处理；</li></ul><p><strong>具体实现：</strong></p><ul><li>harbor 主要概念的关系：1 个 project -&gt; 每个 project 下具有 N 种不同的 repos &gt; 每个 repo 下具有 M 个 tags</li><li>project 有创建时间，但这个对我们的处理策略来说没有用处；</li><li>repo 有创建时间和 pull 时间，该 pull 时间对应 repo 下任意一个 tag ，最新一次，被拉取的那个时间</li><li>tag 有创建时间，但没有针对 tag 的 pull 时间（harbor 中定义的数据结构中不支持）；</li></ul><p>因此</p><ul><li>保留 60 天内的 tag”，这个根据 tag 的创建时间<ul><li>“60 天之外的看 pull 的数量，关注 60 天之外是不是被 pull 过”，由于 pull 数量是针对 repo 整体的，无法对应到具体的 tag ，即在 API 层面无法方便的知道哪些 tag 最近被 pull 过（当然如果一定要做，就只能沟通分析 log 来搞，性价比不高），所以，只能根据 tag 创建时间的先后，“武断”的认为，后创建的 tag 应该是用户最想保留的；</li></ul></li><li>“如果没有被 pull 过，则只保留最新 5 个 tag”，根据上一条的说明，某个 tag 是否被 pull 过是无法知道的，但目前可以做到根据 tag 的创建时间进行保留（满足保留最新 N 个需求）；</li></ul><h2 id="harbor镜像复制"><a href="#harbor镜像复制" class="headerlink" title="harbor镜像复制"></a>harbor镜像复制</h2><p>参考链接：<a href="https://github.com/goharbor/harbor/blob/master/docs/user_guide.md" target="_blank" rel="noopener">https://github.com/goharbor/harbor/blob/master/docs/user_guide.md</a></p><p>该功能是面向项目的，系统管理员设置之后，匹配了过滤规则的项目，在触发了事先定义好的触发条件之后，这些项目就会被复制到远程的另一个仓库中。</p><p>如果在远程镜像仓库中，改项目不存在，那么就会自动创建这个项目</p><p>如果在远程仓库中，这个项目已经存在，并且配置的用户对这个项目没有写的权限，那么这个操作将会失败</p><p>注意：用户信息不会被复制</p><p>因为网络的原因，在复制传输的过程中，可能会出现一些延迟。如果复制job是因为网络原因而导致失败的，那么这个任务将会在几分钟之后再次尝试，一直尝试，知道网络恢复正常。</p><p>注意：因为api等原因，不同版本的镜像复制可能会失败，所以尽量使用同一个版本。</p><h3 id="创建复制规则"><a href="#创建复制规则" class="headerlink" title="创建复制规则"></a>创建复制规则</h3><p>Click <code>NEW REPLICATION RULE</code> under <code>Administration-&gt;Replications</code></p><p>注意，在创建endpoint的时候，直接test connection是会报错：“harbor Failed to ping endpoint”</p><p>这是因为网络问题导致，在内网访问的时候，还需要额外的添加hosts文件，详见注意事项</p><p>注意：在创建完毕之后，默认不会执行同步，需要手动点击一下replication</p><h3 id="删除replication规则"><a href="#删除replication规则" class="headerlink" title="删除replication规则"></a>删除replication规则</h3><p>Only rules which have no pending/running/retrying jobs can be deleted.</p><p>只有当改规则下面没有正在运行或者等待运行或者正在重传的jobs时，才可以删除</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在创建endpoint的时候，如果事先没有再容器内存配置对端的地址，那么会报连接错误</p><p>官方的issues：<a href="https://github.com/goharbor/harbor/issues/2221" target="_blank" rel="noopener">https://github.com/goharbor/harbor/issues/2221</a></p><h2 id="Harborclient"><a href="#Harborclient" class="headerlink" title="Harborclient"></a>Harborclient</h2><p>详见页面：<a href="https://github.com/int32bit/python-harborclient/blob/master/README.zh.md" target="_blank" rel="noopener">https://github.com/int32bit/python-harborclient/blob/master/README.zh.md</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>1&gt; Why can not push image 192.168.0.1/hello-world:latest to Harbor?</p><p>[<strong>A</strong>] At least two namespaces are needed for repository name in Harbor, so tag the image as 192.168.0.1/project_name/hello-world:latest should fix this. (Create the project on the web page first)</p><p>也就是说，在上传镜像的时候，应该是下面这种格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.0.1/project_name/hello-world:latest</span><br></pre></td></tr></table></figure><p>因为在harbor中有项目的概念，也就是：访问地址/项目名称/镜像名称/版本标签</p><p>在使用dockerhub等进行镜像仓库的时候，用户名/id就是项目名称，因此不能创建多个项目名称，因为这种方式适合个人，但是不适用于企业。</p><p>企业中需要根据不同的项目类型进行分类存储，例如：apps、中间件等</p><h3 id="证书问题"><a href="#证书问题" class="headerlink" title="证书问题"></a>证书问题</h3><p>证书生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -sha256 -x509 -days 365 -nodes -newkey rsa:4096 -keyout  harbar.wxh.com.key -out harbar.wxh.com.crt</span><br></pre></td></tr></table></figure><p>注意，一些name的字段要配置成为域名harbar.wxh.com</p><p>生成之后，将证书存放到指定位置，然后修改配置文件指向这些证书文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">less harbor.cfg  | egrep -v &quot;^$|^#&quot;</span><br><span class="line">ssl_cert = /data/cert/harbar.wxh.com.crt</span><br><span class="line">ssl_cert_key = /data/cert/harbar.wxh.com.key</span><br></pre></td></tr></table></figure><p>然后需要对docker进行一些配置</p><p>mkdir -p /etc/docker/certs.d/harbar.wxh.com</p><p>然后将上面的文件复制到这个目录之下，并将/data/cert/harbar.wxh.com.crt重命名为/data/cert/harbar.wxh.com.cert</p><h2 id="文件创建为目录问题"><a href="#文件创建为目录问题" class="headerlink" title="文件创建为目录问题"></a>文件创建为目录问题</h2><p>/data1/harbor/data/secretkey  </p><p>secretkey为文件，而不是目录，在一些时候可能会出现这种问题，当出现这种问题的时候，将该目录清空，然后重新安装即可</p><h1 id="汇总-docker常用命令"><a href="#汇总-docker常用命令" class="headerlink" title="汇总-docker常用命令"></a>汇总-docker常用命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyname .  # Create image using this directory&apos;s Dockerfile</span><br><span class="line">docker run -p 4000:80 friendlyname  # Run &quot;friendlyname&quot; mapping port 4000 to 80</span><br><span class="line">docker run -d -p 4000:80 friendlyname         # Same thing, but in detached mode</span><br><span class="line">docker container ls                                # List all running containers</span><br><span class="line">docker container ls -a             # List all containers, even those not running</span><br><span class="line">docker container stop &lt;hash&gt;           # Gracefully stop the specified container</span><br><span class="line">docker container kill &lt;hash&gt;         # Force shutdown of the specified container</span><br><span class="line">docker container rm &lt;hash&gt;        # Remove specified container from this machine</span><br><span class="line">docker container rm $(docker container ls -a -q)         # Remove all containers</span><br><span class="line">docker image ls -a                             # List all images on this machine</span><br><span class="line">docker image rm &lt;image id&gt;            # Remove specified image from this machine</span><br><span class="line">docker image rm $(docker image ls -a -q)   # Remove all images from this machine</span><br><span class="line">docker login             # Log in this CLI session using your Docker credentials</span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  # Tag &lt;image&gt; for upload to registry</span><br><span class="line">docker push username/repository:tag            # Upload tagged image to registry</span><br><span class="line">docker run username/repository:tag                   # Run image from a registry</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Docker入门与实践
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="虚拟化" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>day06-面向对象编程</title>
    <link href="http://yoursite.com/2018/08/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/20/编程语言/Python/老男孩视频学习笔记/day06-面向对象编程/</id>
    <published>2018-08-20T12:58:43.000Z</published>
    <updated>2018-08-20T12:58:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向过程-VS-面向对象"><a href="#面向过程-VS-面向对象" class="headerlink" title="面向过程 VS 面向对象"></a>面向过程 VS 面向对象</h1><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a><strong>编程范式</strong></h2><p>编程是 程序 员 用特定的<strong>语法+数据结构+算法</strong>组成的代码来告诉计算机如何执行任务的过程 （算法：其实就是解决一些问题的套路</p><p>一个程序是程序员为了得到一个任务结果而编写的一组指令的集合</p><p>正所谓条条大路通罗马，实现一个任务的方式有很多种不同的方式， 对这些不同的编程方式的特点进行归纳总结得出来的编程方式类别，即为编程范式。</p><p>不同的编程范式本质上代表对各种类型的任务采取的不同的解决问题的思路， 大多数语言只支持一种编程范式，当然也有些语言可以同时支持多种编程范式。 两种最重要的编程范式分别是面向过程编程和面向对象编程。</p><p>范式可以理解为某一个行业的标准，例如羽毛球中的标准动作（挥拍，高远球，走位等），基本上已经达成了统一的标准，那么编程也是一样的，目前已经想成了两种标准，分别适用于两种不同的应用场景，也可以理解为两套羽毛球标准，分别适用于不同的应用场景当中。</p><h2 id="面向过程编程-Procedural-Programming"><a href="#面向过程编程-Procedural-Programming" class="headerlink" title="面向过程编程(Procedural Programming)"></a><strong>面向过程编程(Procedural Programming)</strong></h2><p>Procedural programming uses a list of instructions to tell the computer what to do step-by-step. </p><p>面向过程编程，使用一系列的指令来告诉计算机一步一步的去做什么操作</p><p>面向过程编程依赖 - 你猜到了- procedures，一个procedure包含一组要被进行计算的步骤， 面向过程又被称为top-down languages， 就是程序从上到下一步步执行，一步步从上到下，从头到尾的解决问题 。</p><p><strong>核心思想：基本设计思路就是程序一开始是要着手解决一个大的问题，然后把一个大问题分解成很多个小问题或子过程，这些子过程再执行的过程再继续分解直到小问题足够简单到可以在一个小步骤范围内解决。</strong></p><p>举个典型的面向过程的例子， 数据库备份， 分三步，连接数据库，备份数据库，测试备份文件可用性。</p><p>这样做的问题也是显而易见的，就是如果你要对程序进行修改，对你修改的那部分有依赖的各个部分你都也要跟着修改，举个例子，如果程序开头你设置了一个变量值 为1 ， 但如果其它子过程依赖这个值 为1的变量才能正常运行，那如果你改了这个变量，那这个子过程你也要修改，假如又有一个其它子程序依赖这个子过程 ， 那就会发生一连串的影响，随着程序越来越大， 这种编程方式的维护难度会越来越高。  所以我们一般认为， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程的方式是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护 的， 那还是用面向对象最方便了。</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>OOP编程是利用“类”和“对象”来创建各种模型来实现对真实世界的描述，使用面向对象编程的原因一方面是因为它可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使它人更加容易理解你的代码逻辑，从而使团队开发变得更从容。</p><p>面向对象的几个核心特性如下</p><h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a><strong>Class 类</strong></h3><p>一个类即是对一类拥有相同属性的对象的抽象、蓝图、原型。在类中定义了这些对象的都具备的属性（variables(data)）、共同的方法</p><p>世间万物，皆可分类！</p><p>世间万物，皆为对象！</p><h3 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a><strong>Object 对象</strong></h3><p>一个对象即是一个类的实例化后实例，一个类必须经过实例化后方可在程序中调用，一个类可以实例化多个对象，每个对象亦可以有不同的属性，就像人类是指所有人，每个人是指具体的对象，人与人之前有共性，亦有不同</p><h3 id="Encapsulation-封装"><a href="#Encapsulation-封装" class="headerlink" title="Encapsulation 封装"></a><strong>Encapsulation 封装</strong></h3><p>在类中对数据的赋值、内部调用对外部用户是透明的，这使类变成了一个胶囊或容器，里面包含着类的数据和方法</p><p>例如，可以把类的方法都封装起来，内部的代码不会被暴露在外部，而是隐藏起来，只需要调用即可使用该功能</p><h3 id="Inheritance-继承"><a href="#Inheritance-继承" class="headerlink" title="Inheritance 继承"></a><strong>Inheritance 继承</strong></h3><p>一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承</p><h3 id="Polymorphism-多态"><a href="#Polymorphism-多态" class="headerlink" title="Polymorphism 多态"></a><strong>Polymorphism 多态</strong></h3><p>多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，指一个基类中派生出了不同的子类，且每个子类在继承了同样的方法名的同时又<strong>对父类的方法做了不同的实现</strong>，这就是同一种事物表现出的多种形态。</p><p>编程其实就是一个将具体世界进行抽象化的过程，多态就是抽象化的一种体现，把一系列具体事物的共同点抽象出来, 再通过这个抽象的事物, 与不同的具体事物进行对话。<br>对不同类的对象发出相同的消息将会有不同的行为。比如，你的老板让所有员工在九点钟开始工作, 他只要在九点钟的时候说：“开始工作”即可，而不需要对销售人员说：“开始销售工作”，对技术人员说：“开始技术工作”, 因为“员工”是一个抽象的事物, 只要是员工就可以开始工作，他知道这一点就行了。至于每个员工，当然会各司其职，做各自的工作。</p><p>在这里，工作就相当于父类的方法，而子类继承了之后，针对这个方法，会有不同的实现方式。 相当于是同一个东西，表面上是明确的不变，但是内部是不断在变化的。</p><p>多态允许将子类的对象当作父类的对象使用，某父类型的引用指向其子类型的对象,调用的方法是该子类型的方法。这里引用和调用方法的代码编译前就已经决定了,而引用所指向的对象可以在运行期间动态绑定</p><p>封装、继承、多态是面向对象的3个特性</p><h1 id="面向对象编程-Object-Oriented-Programming-介绍"><a href="#面向对象编程-Object-Oriented-Programming-介绍" class="headerlink" title="面向对象编程(Object-Oriented Programming )介绍"></a>面向对象编程(<strong>Object-Oriented Programming</strong> )介绍</h1><p>对于编程语言的初学者来讲，OOP不是一个很容易理解的编程方式，大家虽然都按老师讲的都知道OOP的三大特性是继承、封装、多态，并且大家也都知道了如何定义类、方法等面向对象的常用语法，但是一到真正写程序的时候，还是很多人喜欢用函数式编程来写代码，特别是初学者，很容易陷入一个窘境就是“我知道面向对象，我也会写类，但我依然没发现在使用了面向对象后，对我们的程序开发效率或其它方面带来什么好处，因为我使用函数编程就可以减少重复代码并做到程序可扩展了，为啥子还用面向对象？”。 对于此，我个人觉得原因应该还是因为你没有充分了解到面向对象能带来的好处，今天我就写一篇关于面向对象的入门文章，希望能帮大家更好的理解和使用面向对象编程。  </p><p>无论用什么形式来编程，我们都要明确记住以下原则：</p><ol><li><strong>写重复代码是非常不好的低级行为</strong></li><li><strong>你写的代码需要经常变更</strong> </li></ol><p>开发正规的程序跟那种写个运行一次就扔了的小脚本一个很大不同就是，你的代码总是需要不断的更改，不是修改bug就是添加新功能等，所以为了日后方便程序的修改及扩展，你写的代码一定要遵循易读、易改的原则（专业数据叫可读性好、易扩展）。</p><p>如果你把一段同样的代码复制、粘贴到了程序的多个地方以实现在程序的各个地方调用 这个功能，那日后你再对这个功能进行修改时，就需要把程序里多个地方都改一遍，这种写程序的方式是有问题的，因为如果你不小心漏掉了一个地方没改，那可能会导致整个程序的运行都 出问题。 因此我们知道 在开发中一定要努力避免写重复的代码，否则就相当于给自己再挖坑。</p><p>还好，函数的出现就能帮我们轻松的解决重复代码的问题，对于需要重复调用的功能，只需要把它写成一个函数，然后在程序的各个地方直接调用这个函数名就好了，并且当需要修改这个功能时，只需改函数代码，然后整个程序就都更新了。</p><p>其实OOP编程的主要作用也是使你的代码修改和扩展变的更容易，那么小白要问了，既然函数都能实现这个需求了，还要OOP干毛线用呢？ 呵呵，说这话就像，古时候，人们打仗杀人都用刀，后来出来了枪，它的主要功能跟刀一样，也是杀人，然后小白就问，既然刀能杀人了，那还要枪干毛线，哈哈，显而易见，因为枪能更好更快更容易的杀人。函数编程与OOP的主要区别就是OOP可以使程序更加容易扩展和易更改。</p><h2 id="init-和self"><a href="#init-和self" class="headerlink" title="__init__和self"></a><code>__init__</code>和self</h2><p>类的写法是下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    def __init__(self,name,type):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line"></span><br><span class="line">    def sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog1 = Dog(&apos;wxh&apos;,&apos;二哈&apos;)</span><br><span class="line"></span><br><span class="line">dog1.sayhi()</span><br></pre></td></tr></table></figure><p><strong>其实self,就是实例本身！你实例化时python会自动把这个实例本身通过self参数传进去。</strong></p><p>上面的这个<strong>init</strong>()叫做<strong>初始化方法(或构造方法)</strong>， 在类被调用时，这个方法(虽然它是函数形式，但在类中就不叫函数了,叫方法)会自动执行，进行一些初始化的动作<br>我们这里写<code>__init__</code>(self,name,role,weapon,life_value=100,money=15000)就是要在创建一个角色时给它设置这些属性，那么这第一个参数self是干毛用的呢？ </p><p>初始化一只狗，就需要调用这个类一次： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`r1 ``=` `Role(``&apos;Alex&apos;``,``&apos;police&apos;``,&apos;AK47’) ``#生成一个角色 , 会自动把参数传给Role下面的__init__(...)方法``r2 ``=` `Role(``&apos;Jack&apos;``,``&apos;terrorist&apos;``,&apos;B22’)  ``#生成一个角色`</span><br></pre></td></tr></table></figure><p>我们看到，上面的创建角色时，我们并没有给<code>__init__</code>传值，程序也没未报错，是因为，类在调用它自己的<strong>init</strong>(…)时自己帮你给self参数赋值了， </p><p>我们再来定义一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Role(object): #定义一个类， class是定义类的语法，Role是类名，(object)是新式类的写法，必须这样写，以后再讲为什么</span><br><span class="line">    def __init__(self,name,role,weapon,life_value=100,money=15000): #初始化函数，在生成一个角色时要初始化的一些属性就填写在这里</span><br><span class="line">        self.name = name #__init__中的第一个参数self,和这里的self都 是什么意思？ 看下面解释</span><br><span class="line">        self.role = role</span><br><span class="line">        self.weapon = weapon</span><br><span class="line">        self.life_value = life_value</span><br><span class="line">        self.money = money</span><br><span class="line">    def buy_gun(self,gun_name):</span><br><span class="line">        print(“%s has just bought %s” %(self.name,gun_name) )</span><br></pre></td></tr></table></figure><p>当执行r1 = Role(‘Alex’,’police’,’AK47<strong>’</strong>)创建一个对象时，python的解释器其实干了两件事：</p><ol><li>在内存中开辟一块空间指向r1这个变量名</li><li>调用Role这个类并执行其中的<code>__init__</code>(…)方法，相当于Role.<code>__init__</code>(r1,’Alex’,’police’,AK47’),这么做是为什么呢？ 是为了把’Alex’,’police’,’AK47’这3个值跟刚开辟的r1关联起来，是为了把’Alex’,’police’,’AK47’这3个值跟刚开辟的r1关联起来，是为了把’Alex’,’police’,’AK47’这3个值跟刚开辟的r1关联起来，重要的事情说3次， 因为关联起来后，你就可以直接r1.name, r1.weapon 这样来调用啦。所以，为实现这种关联，在调用<code>__init__</code>方法时，就必须把r1这个变量也传进去，否则<code>__init__</code>不知道要把那3个参数跟谁关联呀。</li><li>所以这个<code>__init__</code>(…)方法里的，self.name = name , self.role = role 等等的意思就是要把这几个值 存到r1的内存空间里。</li></ol><p><code>__init__(…)</code>基本懂了，但后面的那几个函数，噢 不对，后面那几个方法 为什么也还需要self参数么？ 不是在初始化角色的时候 ，就已经把角色的属性跟r1绑定好了么？ </p><p>上面这个方法通过类调用的话要写成如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`r1 ``=` `Role(``&apos;Alex&apos;``,``&apos;police&apos;``,``&apos;AK47&apos;``)``r1.buy_gun(``&quot;B21”) #python 会自动帮你转成 Role.buy_gun(r1,”B21&quot;``)`</span><br></pre></td></tr></table></figure><p>执行结果</p><p>#Alex has just bought B21 </p><p>我们依然没给self传值 ，但Python还是会自动的帮你把r1 赋值给self这个参数， 为什么呢？ 因为，你在buy_gun(..)方法中可能要访问r1的一些其它属性呀， 比如这里就访问 了r1的名字，怎么访问呢？你得告诉这个方法呀，于是就把r1传给了这个self参数，然后在buy_gun里调用 self.name 就相当于调用r1.name 啦，如果还想知道r1的生命值 有多少，直接写成self.life_value就可以了。 说白了就是在调用类中的一个方法时，你得告诉人家你是谁。</p><p>好啦， 总结一下2点：</p><ol><li>上面的这个r1 = Role(‘Alex’,’police’,’AK47<strong>’</strong>)动作，叫做类的“实例化”， 就是把一个虚拟的抽象的类，通过这个动作，变成了一个具体的对象了， 这个对象就叫做实例</li><li>刚才定义的这个类体现了面向对象的第一个基本特性，封装，<strong>其实就是使用构造方法将内容封装到某个具体对象中，然后通过对象直接或者self间接获取被封装的内容</strong></li></ol><h1 id="父类继承object的原因"><a href="#父类继承object的原因" class="headerlink" title="父类继承object的原因"></a>父类继承object的原因</h1><p>引用知乎，链接：<a href="https://www.zhihu.com/question/19754936/answer/202650790" target="_blank" rel="noopener">https://www.zhihu.com/question/19754936/answer/202650790</a></p><p>继承 object 类的是新式类，不继承 object 类的是经典类，在 Python 2.7 里面新式类和经典类在多继承方面会有差异：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def foo(self):</span><br><span class="line">        print(&apos;called A.foo()&apos;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class C(A):</span><br><span class="line">    def foo(self):</span><br><span class="line">        print(&apos;called C.foo()&apos;)</span><br><span class="line"></span><br><span class="line">class D(B, C): </span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    d = D() </span><br><span class="line">    d.foo()</span><br></pre></td></tr></table></figure><p>B、C 是 A 的子类，D 多继承了 B、C 两个类，其中 C 重写了 A 中的 foo() 方法。</p><p>如果 A 是经典类（如上代码），当调用 D 的实例的 foo() 方法时，Python 会按照深度优先的方法去搜索 foo() ，路径是 B-A-C ，执行的是 A 中的 foo() ；</p><p>如果 A 是新式类，当调用 D 的实例的 foo() 方法时，Python 会按照广度优先的方法去搜索 foo() ，路径是 B-C-A ，执行的是 C 中的 foo() 。</p><p>因为 D 是直接继承 C 的，从逻辑上说，执行 C 中的 foo() 更加合理，因此新式类对多继承的处理更为合乎逻辑。</p><p>在 Python 3.x 中的新式类貌似已经兼容了经典类，无论 A 是否继承 object 类， D 实例中的 foo() 都会执行 C 中的 foo() 。但是在 Python 2.7 中这种差异仍然存在，因此还是推荐使用新式类，要继承 object 类。</p><h1 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class animal(object):</span><br><span class="line">    n = &quot;dff&quot;</span><br><span class="line">    def __init__(self,name,type):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line"></span><br><span class="line">    def sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line">    def talk(self):</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = animal(&quot;wxh&quot;,&quot;二哈&quot;)</span><br><span class="line">print (animal.n)</span><br><span class="line">print (a1.n,a1.name)</span><br><span class="line">执行后输出为：</span><br><span class="line">dff</span><br><span class="line">dff wxh</span><br></pre></td></tr></table></figure><p>注意：如果类变量和实例变量的名称一致，那么生效的是实例变量，也就是局部生效</p><p>类变量：所有实例共用的属性，节省开销</p><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>作用：在实例/对象释放、销毁的时候自动执行的，通常用于一些收尾工作，例如关闭一些数据库连接，关闭打开的临时文件。</p><p>注意：不是在实例/对象结束的时候执行，而是在释放或者销毁的时候自动执行，通过下方的代码可以看出效果</p><p>书写格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class animal(object):</span><br><span class="line">    name = &quot;dff&quot;</span><br><span class="line">    def __init__(self,name,type):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line"></span><br><span class="line">    def sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line">    def talk(self):</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;析构函数&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = animal(&quot;wxh&quot;,&quot;二哈&quot;)</span><br><span class="line">a2 = animal(&quot;wxg&quot;,&quot;金毛&quot;)</span><br><span class="line">print (animal.name)</span><br><span class="line">print (a1.name)</span><br><span class="line">print(a2.name)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dff</span><br><span class="line">wxh</span><br><span class="line">wxg</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br></pre></td></tr></table></figure><p>手动的删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class animal(object):</span><br><span class="line">    name = &quot;dff&quot;</span><br><span class="line">    def __init__(self,name,type):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line"></span><br><span class="line">    def sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line">    def talk(self):</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;析构函数&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = animal(&quot;wxh&quot;,&quot;二哈&quot;)</span><br><span class="line">a2 = animal(&quot;wxg&quot;,&quot;金毛&quot;)</span><br><span class="line">print (animal.name)</span><br><span class="line">print (a1.name)</span><br><span class="line">del a1</span><br><span class="line">print(a2.name)</span><br></pre></td></tr></table></figure><p>这种情况下执行后的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dff</span><br><span class="line">wxh</span><br><span class="line">析构函数</span><br><span class="line">wxg</span><br><span class="line">析构函数</span><br></pre></td></tr></table></figure><h1 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h1><p>在构造方法中定义的私有属性，直接调用获取是不行的，要想使用的话，需要在定义一个方法，在内部进行访问之后，再将值返回出去。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class animal(object):</span><br><span class="line">    name = &quot;dff&quot;</span><br><span class="line">    def __init__(self,name,type,attr):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line">        self.__private_att = attr</span><br><span class="line"></span><br><span class="line">    def sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line">    def talk(self):</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;析构函数&quot;)</span><br><span class="line"></span><br><span class="line">    def show_pri(self):</span><br><span class="line">        print (&quot;the private attr is &#123;private&#125;&quot;.format(private=self.__private_att))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = animal(&quot;wxh&quot;,&quot;二哈&quot;,&quot;pri_test&quot;)</span><br><span class="line">print (a1.name)</span><br><span class="line">a1.show_pri()</span><br><span class="line">print (a1.__private_att)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wxh</span><br><span class="line">the private attr is pri_test</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">析构函数</span><br><span class="line">  File &quot;/Users/wangxiaohua/PycharmProjects/python14/day06/classtest.py&quot;, line 23, in &lt;module&gt;</span><br><span class="line">    print (a1.__private_att)</span><br><span class="line">AttributeError: &apos;animal&apos; object has no attribute &apos;__private_att&apos;</span><br></pre></td></tr></table></figure><p>可以看到，我们使用定义的这个方法去调用是不会报错的，但是直接显示该对象的私有属性的时候，是无法显示的。</p><h1 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h1><p>私有方法和私有属性也是一样的，在定义的是前面加上<strong>__</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class animal(object):</span><br><span class="line">    name = &quot;dff&quot;</span><br><span class="line">    def __init__(self,name,type,attr):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line">        self.__private_att = attr</span><br><span class="line"></span><br><span class="line">    def __sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line"></span><br><span class="line">    def talk(self):</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;析构函数&quot;)</span><br><span class="line"></span><br><span class="line">    def show_pri(self):</span><br><span class="line">        print (&quot;the private attr is &#123;private&#125;&quot;.format(private=self.__private_att))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = animal(&quot;wxh&quot;,&quot;二哈&quot;,&quot;pri_test&quot;)</span><br><span class="line">print (a1.name)</span><br><span class="line">a1.show_pri()</span><br><span class="line">a1.__sayhi()</span><br></pre></td></tr></table></figure><p>执行后输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wxh</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">the private attr is pri_test</span><br><span class="line">  File &quot;/Users/wangxiaohua/PycharmProjects/python14/day06/classtest.py&quot;, line 24, in &lt;module&gt;</span><br><span class="line">析构函数</span><br><span class="line">    a1.__sayhi()</span><br><span class="line">AttributeError: &apos;animal&apos; object has no attribute &apos;__sayhi&apos;</span><br></pre></td></tr></table></figure><h1 id="子类继承"><a href="#子类继承" class="headerlink" title="子类继承"></a>子类继承</h1><h2 id="保留父类属性"><a href="#保留父类属性" class="headerlink" title="保留父类属性"></a>保留父类属性</h2><p>在继承之后，可以在子类中将父类的方法进行重构，但是重构的话，父类原有的动作就不会保留，那么，当我们需要保留父类的内容，也就是说子类是添加操作，在调用的时候，先执行父类的代码，再执行子类的代码，那么这种方式应该如何实现？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class People(object):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;&#123;name&#125; is eating&quot;.format(name=self.name))</span><br><span class="line">    def age(self):</span><br><span class="line">        print(&quot;&#123;name&#125; is &#123;age&#125; years old&quot;.format(name=self.name,age=self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Man(People):</span><br><span class="line">    def eat(self):</span><br><span class="line">        People.eat(self)</span><br><span class="line">        print(&quot;subclass content&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">man1 = Man(&quot;wxh&quot;,11)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">man1.eat()</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wxh is eating</span><br><span class="line">subclass content</span><br></pre></td></tr></table></figure><p>默认情况下，我们不做任何修改的话，就会继承父类的属性</p><h2 id="子类添加私有属性"><a href="#子类添加私有属性" class="headerlink" title="子类添加私有属性"></a>子类添加私有属性</h2><p>在继承父类的之后，如果想要添加自己的属性，那么需要使用下面的这种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class People(object):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;&#123;name&#125; is eating&quot;.format(name=self.name))</span><br><span class="line">    def age(self):</span><br><span class="line">        print(&quot;&#123;name&#125; is &#123;age&#125; years old&quot;.format(name=self.name,age=self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Man(People):</span><br><span class="line">    def __init__(self,name,age,money):</span><br><span class="line">        People.__init__(self,name,age)</span><br><span class="line">        self.money = money</span><br><span class="line">        print (&quot;&#123;name&#125; has &#123;money&#125;$&quot;.format(name=self.name,money=self.money))</span><br><span class="line">    def eat(self):</span><br><span class="line">        People.eat(self)</span><br><span class="line">        print(&quot;subclass content&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">man1 = Man(&quot;wxh&quot;,11,&quot;1000&quot;)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wxh has 1000 $</span><br></pre></td></tr></table></figure><p>可以知道，这个输出并没有调用什么方法，而是子类的构造函数（<code>__init__</code>）输出的</p><p>说明：</p><ul><li>因为是完全覆盖的父类，因此需要把父类的参数全部写一遍</li><li><p>然后再调用父类的方法</p></li><li><p>在子类中重新编写构造方法，注意在定义的时候，父类的属性还是要保留，不能直接覆盖，因为在后续使用的时候，实例化这个子类之后，如果还需要调用父类的属性的时候，还需要有这个属性</p></li><li><p>子类的构造方法中需要需要再调用父类的构造方法（因为父类的构造方法中可能会比较复杂，所有采取直接调用的方式），注意，传入的参数是子类在最外层继承父类的，需要保持一致</p></li><li>调用了父类的构造方法之后，再在下方定义子类的属性</li></ul><p>父类的继承还有另外一种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">People.__init__(self,name,age)</span><br><span class="line">可以写成</span><br><span class="line">super(Man,self).__init__(name,age)</span><br></pre></td></tr></table></figure><p>super是一种内置的方法</p><p>使用这种方式的话，之后如果父类的名称修改了，那么只需要在继承的括号中修改，函数体中不需要再修改。</p><p>但是在涉及到继承多个类的时候，并且父类的属性不同时，这种方式就比不是太友好</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class People(object):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;&#123;name&#125; is eating&quot;.format(name=self.name))</span><br><span class="line">    def age(self):</span><br><span class="line">        print(&quot;&#123;name&#125; is &#123;age&#125; years old&quot;.format(name=self.name,age=self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Relation(object):</span><br><span class="line">    def makefriend(self,object):</span><br><span class="line">        print (&quot;&#123;name1&#125; is make friend with &#123;name2&#125;&quot;.format(name1=self.name,name2=object.name))</span><br><span class="line"></span><br><span class="line">class Man(People,Relation):</span><br><span class="line">    def __init__(self,name,age,money):</span><br><span class="line">        # People.__init__(self,name,age)</span><br><span class="line">        super(Man,self).__init__(name,age)</span><br><span class="line"></span><br><span class="line">        self.money = money</span><br><span class="line">        # print (&quot;&#123;name&#125; has &#123;money&#125;$&quot;.format(name=self.name,money=self.money))</span><br><span class="line">    def eat(self):</span><br><span class="line">        People.eat(self)</span><br><span class="line">        print(&quot;subclass content&quot;)</span><br><span class="line"></span><br><span class="line">class Woman(People,Relation):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        People.__init__(self,name,age)</span><br><span class="line">    def get_birth(self):</span><br><span class="line">        print (&quot;&#123;name&#125; git_birth&quot;.format(name=self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">man1 = Man(&quot;wxh&quot;,11,&quot;1000&quot;)</span><br><span class="line"></span><br><span class="line">women1 = Woman(&quot;xxx&quot;,11)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wxh is make friend with xxx</span><br></pre></td></tr></table></figure><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态特性：一种接口，多种实现</p><p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p><p>那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。</p><p>Pyhon 很多语法都是支持多态的，比如 len(),sorted(), 你给len传字符串就返回字符串的长度，传列表就返回列表长度。</p><p>Python多态示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Animal(object):</span><br><span class="line">    def __init__(self, name):  # Constructor of the class</span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line">    def talk(self):              # Abstract method, defined by convention only</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def talk(self):</span><br><span class="line">        print(&apos;%s: 喵喵喵!&apos; %self.name)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def talk(self):</span><br><span class="line">        print(&apos;%s: 汪！汪！汪！&apos; %self.name)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def func(obj): #一个接口，多种形态</span><br><span class="line">    obj.talk()</span><br><span class="line"> </span><br><span class="line">c1 = Cat(&apos;小晴&apos;)</span><br><span class="line">d1 = Dog(&apos;李磊&apos;)</span><br><span class="line"> </span><br><span class="line">func(c1)</span><br><span class="line">func(d1)</span><br></pre></td></tr></table></figure><p>简单的说，多态其实就是子类重新实现父类的方法，实现接口的重用，然后通过重新定义一个接口去匹配调用</p><p>最终，我们要把这个函数放置到父类当中</p><p>然后通过下面的方式去调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man1 = Man(&quot;wxh&quot;,11,&quot;1000&quot;)</span><br><span class="line">People.people_eat(man1)</span><br></pre></td></tr></table></figure><h1 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h1><p>很多同学都是学会了面向对象的语法，却依然写不出面向对象的程序，原因是什么呢？原因就是因为你还没掌握一门面向对象设计利器， 你说我读书少别骗我， 什么利器？  </p><p>答案就是:<strong>领域建模</strong>。 从领域模型开始,我们就开始了面向对象的分析和设计过程,可以说,领域模型是完成从需求分析到面向 对象设计的一座桥梁。 </p><p>领域模型,顾名思义,就是需求所涉及的领域的一个建模,更通俗的讲法是业务模型。 参考百度百科(<a href="http://baike.baidu.cn/view/757895.htm" target="_blank" rel="noopener">http://baike.baidu.cn/view/757895.htm</a> ),领域模型定义如下: </p><p>从这个定义我们可以看出,领域模型有两个主要的作用:</p><ol><li>发掘重要的业务领域概念</li><li>建立业务领域概念之间的关系 </li></ol><p><strong>领域建模三字经</strong> </p><p>领域模型如此重要,很多同学可能会认为领域建模很复杂,需要很高的技巧。然而事实上领域建模非常简 单,简单得有点难以让人相信,领域建模的方法概括一下就是“<strong>找名词</strong>”! 许多同学看到这个方法后估计都会笑出来:太假了吧,这么简单,找个初中生都会啊,那我们公司那些分 析师和设计师还有什么用哦?</p><p>分析师和设计师当然有用,后面我们会看到,即使是简单的找名词这样的操作,也涉及到分析和提炼,而 不是简单的摘取出来就可,这种情况下分析师和设计师的经验和技能就能够派上用场了。但领域模型分析 也确实相对简单,即使没有丰富的经验和高超的技巧,至少也能完成一个能用的领域模型。 </p><p>虽然我们说“找名词”很简单,但一个关键的问题还没有说明:<strong>从哪里找</strong>? 如果你还记得领域模型是“需求到面向对象的桥梁”,那么你肯定一下子就能想到:从需求模型中找,具 体来说就是从用例中找。 </p><p>归纳一下域建模的方法就是“<strong>从用例中找名词</strong>”。 当然,找到名词后,为了能够更加符合面向对象的要求和特点,我们还需要对这些名词进一步完善,这就 是接下来的步骤:<strong>加属性,连关系</strong>! </p><p>  最后我们总结出领域建模的三字经方法:<strong>找名词、加属性、连关系</strong>。 </p>]]></content>
    
    <summary type="html">
    
      day06-面向对象编程
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>python import模块相关问题</title>
    <link href="http://yoursite.com/2018/08/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/python-import%E6%A8%A1%E5%9D%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/16/编程语言/Python/基础知识/python-import模块相关问题/</id>
    <published>2018-08-16T04:50:21.000Z</published>
    <updated>2018-08-16T04:50:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><a href="https://www.kancloud.cn/st_afei/python_info_ylf/344146" target="_blank" rel="noopener">关于python——import问题</a></li><li><a href="http://codingpy.com/article/python-import-101/" target="_blank" rel="noopener">python导入模块的几种姿势</a></li></ul><h1 id="python-import"><a href="#python-import" class="headerlink" title="python import"></a>python import</h1><p>在python中，每个py文件被称之为模块，每个具有<code>__init__.py</code>文件的目录被称为包。只要模块或者包所在的目录在sys.path中，就可以使用import 模块或import 包来使用。</p><p>作为一名新手Python程序员，你首先需要学习的内容之一就是如何导入模块或包。但是我注意到，那些许多年来不时使用Python的人并不是都知道Python的导入机制其实非常灵活。在本文中，我们将探讨以下话题：</p><ul><li>常规导入（regular imports）</li><li>使用from语句导入</li><li>相对导入（relative imports）</li><li>可选导入（optional imports）</li><li>本地导入（local imports）</li><li>导入注意事项</li></ul><h2 id="常规导入"><a href="#常规导入" class="headerlink" title="常规导入"></a>常规导入</h2><p>常规导入应该是最常使用的导入方式，大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br></pre></td></tr></table></figure><p>你只需要使用<code>import</code>一词，然后指定你希望导入的模块或包即可。通过这种方式导入的好处是可以一次性导入多个包或模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import os, sys, time</span><br></pre></td></tr></table></figure><p>虽然这节省了空间，但是却违背了Python风格指南。<strong>Python风格指南建议将每个导入语句单独成行</strong>。</p><p>有时在导入模块时，你想要重命名这个模块。这个功能很容易实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys as system</span><br><span class="line"></span><br><span class="line">print(system.platform)</span><br></pre></td></tr></table></figure><p>上面的代码将我们导入的<code>sys</code>模块重命名为<code>system</code>。我们可以按照和以前一样的方式调用模块的方法，但是可以用一个新的模块名。也有某些子模块必须要使用点标记法才能导入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.error</span><br></pre></td></tr></table></figure><p>这个情况不常见，但是对此有所了解总是没有坏处的。</p><p>注意：</p><ul><li>import导入为绝对导入</li><li>import 只能导入模块，不能导入模块中的对象（类、函数、变量等)</li></ul><blockquote><p>Python 中所有加载到内存的模块都放在 sys.modules 。当 import 一个模块时首先会在这个列表中查找是否已经加载了此模块，如果没有加载则从 sys.path 目录中按照模块名称查找模块文件，找到后将模块载入内存，并加到 sys.modules 中。只有存在sys.path中的模块才会被正确导入。 </p><p>一个模块不会重复载入。多个不同的模块都可以用 import 引入同一个模块到自己的 Local 名字空间，其实背后的 PyModuleObject 对象只有一个。 </p><p>一个容易忽略的问题：import 只能导入模块，不能导入模块中的对象（类、函数、变量等）。例如：模块 A（A.py）中有个函数 getName，另一个模块不能通过 import A.getName 将 getName导入到本模块，只能用 from A import getName。 </p><p>同级目录下，可以使用import直接导入所需模块</p></blockquote><h2 id="使用from语句导入"><a href="#使用from语句导入" class="headerlink" title="使用from语句导入"></a>使用from语句导入</h2><p>很多时候你只想要导入一个模块或库中的某个部分。我们来看看在Python中如何实现这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from functools import lru_cache</span><br></pre></td></tr></table></figure><p>上面这行代码可以让你直接调用<code>lru_cache</code>。如果你按常规的import方式导入<code>functools</code>，那么你就必须像这样调用<code>lru_cache</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functools.lru_cache(*args)</span><br></pre></td></tr></table></figure><p>根据你实际的使用场景，上面的做法可能是更好的。在复杂的代码库中，能够看出某个函数是从哪里导入的这点很有用的。不过，如果你的代码维护的很好，模块化程度高，那么只从某个模块中导入一部分内容也是非常方便和简洁的。</p><p>当然，你还可以使用from方法导入模块的全部内容，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from os import *</span><br></pre></td></tr></table></figure><p>这种做法在少数情况下是挺方便的，但是这样也会打乱你的命名空间。问题在于，你可能定义了一个与导入模块中名称相同的变量或函数，这时如果你试图使用<code>os</code>模块中的同名变量或函数，实际使用的将是你自己定义的内容。因此，你最后可能会碰到一个相当让人困惑的逻辑错误。<strong>标准库中我唯一推荐全盘导入的模块只有Tkinter</strong>。</p><p>如果你正好要写自己的模块或包，有人会建议你在<code>__init__.py</code>文件中导入所有内容，让模块或者包使用起来更方便。我个人更喜欢显示地导入，而非隐式地导入。</p><p>你也可以采取折中方案，从一个包中导入多个项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from os import path, walk, unlink</span><br><span class="line">from os import uname, remove</span><br></pre></td></tr></table></figure><p>在上述代码中，我们从<code>os</code>模块中导入了5个函数。你可能注意到了，我们是通过多次从同一个模块中导入实现的。当然，如果你愿意的话，你也可以使用圆括号一次性导入多个项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from os import (path, walk, unlink, uname, </span><br><span class="line">                remove, rename)</span><br></pre></td></tr></table></figure><p>这是一个有用的技巧，不过你也可以换一种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from os import path, walk, unlink, uname, \</span><br><span class="line">                remove, rename</span><br></pre></td></tr></table></figure><p>上面的反斜杠是Python中的续行符，告诉解释器这行代码延续至下一行。</p><h2 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h2><p><a href="https://www.python.org/dev/peps/pep-0328/" target="_blank" rel="noopener">PEP 328</a>介绍了引入相对导入的原因，以及选择了哪种语法。具体来说，是使用句点来决定如何相对导入其他包或模块。这么做的原因是为了避免偶然情况下导入标准库中的模块产生冲突。这里我们以PEP 328中给出的文件夹结构为例，看看相对导入是如何工作的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_package/</span><br><span class="line">    __init__.py</span><br><span class="line">    subpackage1/</span><br><span class="line">        __init__.py</span><br><span class="line">        module_x.py</span><br><span class="line">        module_y.py</span><br><span class="line">    subpackage2/</span><br><span class="line">        __init__.py</span><br><span class="line">        module_z.py</span><br><span class="line">    module_a.py</span><br></pre></td></tr></table></figure><p>在本地磁盘上找个地方创建上述文件和文件夹。在顶层的<code>__init__.py</code>文件中，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import subpackage1</span><br><span class="line">from . import subpackage2</span><br></pre></td></tr></table></figure><p>接下来进入<code>subpackage1</code>文件夹，编辑其中的<code>__init__.py</code>文件，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import module_x</span><br><span class="line">from . import module_y</span><br></pre></td></tr></table></figure><p>现在编辑<code>module_x.py</code>文件，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from .module_y import spam as ham</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ham()</span><br></pre></td></tr></table></figure><p>最后编辑<code>module_y.py</code>文件，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def spam():</span><br><span class="line">    print(&apos;spam &apos; * 3)</span><br></pre></td></tr></table></figure><p>打开终端，<code>cd</code>至<code>my_package</code>包所在的文件夹，但不要进入<code>my_package</code>。在这个文件夹下运行Python解释器。我使用的是IPython，因为它的自动补全功能非常方便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import my_package</span><br><span class="line"></span><br><span class="line">In [2]: my_package.subpackage1.module_x</span><br><span class="line">Out[2]: &lt;module &apos;my_package.subpackage1.module_x&apos; from &apos;my_package/subpackage1/module_x.py&apos;&gt;</span><br><span class="line"></span><br><span class="line">In [3]: my_package.subpackage1.module_x.main()</span><br><span class="line">spam spam spam</span><br></pre></td></tr></table></figure><p>相对导入适用于你最终要放入包中的代码。如果你编写了很多相关性强的代码，那么应该采用这种导入方式。<strong>你会发现PyPI上有很多流行的包也是采用了相对导入</strong>。还要注意一点，如果你想要跨越多个文件层级进行导入，只需要使用多个句点即可。不过，<strong>PEP 328建议相对导入的层级不要超过两层</strong>。</p><p>还要注意一点，如果你往<code>module_x.py</code>文件中添加了<code>if __name__ == ‘__main__’</code>，然后试图运行这个文件，你会碰到一个很难理解的错误。编辑一下文件，试试看吧！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from . module_y import spam as ham</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ham()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # This won&apos;t work!</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>现在从终端进入<code>subpackage1</code>文件夹，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python module_x.py</span><br></pre></td></tr></table></figure><p>如果你使用的是Python 2，你应该会看到下面的错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;module_x.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from . module_y import spam as ham</span><br><span class="line">ValueError: Attempted relative import in non-package</span><br></pre></td></tr></table></figure><p>如果你使用的是Python 3，错误信息大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;module_x.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from . module_y import spam as ham</span><br><span class="line">SystemError: Parent module &apos;&apos; not loaded, cannot perform relative import</span><br></pre></td></tr></table></figure><p>这指的是，<code>module_x.py</code>是某个包中的一个模块，而你试图以脚本模式执行，但是<strong>这种模式不支持相对导入</strong>。</p><p>如果你想在自己的代码中使用这个模块，那么你必须将其添加至Python的导入检索路径（import search path）。最简单的做法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&apos;/path/to/folder/containing/my_package&apos;)</span><br><span class="line">import my_package</span><br></pre></td></tr></table></figure><p>注意，你需要添加的是<code>my_package</code>的上一层文件夹路径，而不是<code>my_package</code>本身。原因是<code>my_package</code>就是我们想要使用的包，所以如果你添加它的路径，那么将无法使用这个包。</p><p>我们接下来谈谈可选导入。</p><h2 id="可选导入（Optional-imports）"><a href="#可选导入（Optional-imports）" class="headerlink" title="可选导入（Optional imports）"></a>可选导入（Optional imports）</h2><p>如果你希望优先使用某个模块或包，但是同时也想在没有这个模块或包的情况下有备选，你就可以使用可选导入这种方式。这样做可以导入支持某个软件的多种版本或者实现性能提升。以<a href="http://pythonhosted.org/github2/_modules/github2/request.html" target="_blank" rel="noopener">github2包</a>中的代码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    # For Python 3</span><br><span class="line">    from http.client import responses</span><br><span class="line">except ImportError:  # For Python 2.5-2.7</span><br><span class="line">    try:</span><br><span class="line">        from httplib import responses  # NOQA</span><br><span class="line">    except ImportError:  # For Python 2.4</span><br><span class="line">        from BaseHTTPServer import BaseHTTPRequestHandler as _BHRH</span><br><span class="line">        responses = dict([(k, v[0]) for k, v in _BHRH.responses.items()])</span><br></pre></td></tr></table></figure><p><code>lxml</code>包也有使用可选导入方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    from urlparse import urljoin</span><br><span class="line">    from urllib2 import urlopen</span><br><span class="line">except ImportError:</span><br><span class="line">    # Python 3</span><br><span class="line">    from urllib.parse import urljoin</span><br><span class="line">    from urllib.request import urlopen</span><br></pre></td></tr></table></figure><p>正如以上示例所示，<strong>可选导入的使用很常见，是一个值得掌握的技巧</strong>。</p><h2 id="局部导入"><a href="#局部导入" class="headerlink" title="局部导入"></a>局部导入</h2><p>当你在局部作用域中导入模块时，你执行的就是局部导入。如果你在Python脚本文件的顶部导入一个模块，那么你就是在将该模块导入至全局作用域，这意味着之后的任何函数或方法都可能访问该模块。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import sys  # global scope</span><br><span class="line"></span><br><span class="line">def square_root(a):</span><br><span class="line">    # This import is into the square_root functions local scope</span><br><span class="line">    import math</span><br><span class="line">    return math.sqrt(a)</span><br><span class="line"></span><br><span class="line">def my_pow(base_num, power):</span><br><span class="line">    return math.pow(base_num, power)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print(square_root(49))</span><br><span class="line">    print(my_pow(2, 3))</span><br></pre></td></tr></table></figure><p>这里，我们将<code>sys</code>模块导入至全局作用域，但我们并没有使用这个模块。然后，在<code>square_root</code>函数中，我们将<code>math</code>模块导入至该函数的局部作用域，这意味着<code>math</code>模块只能在<code>square_root</code>函数内部使用。如果我们试图在<code>my_pow</code>函数中使用<code>math</code>，会引发<code>NameError</code>。试着执行这个脚本，看看会发生什么。</p><p>使用局部作用域的好处之一，是你使用的模块可能需要很长时间才能导入，如果是这样的话，将其放在某个不经常调用的函数中或许更加合理，而不是直接在全局作用域中导入。老实说，我几乎从没有使用过局部导入，主要是因为如果模块内部到处都有导入语句，会很难分辨出这样做的原因和用途。<strong>根据约定，所有的导入语句都应该位于模块的顶部</strong>。</p><h2 id="导入注意事项"><a href="#导入注意事项" class="headerlink" title="导入注意事项"></a>导入注意事项</h2><p>在导入模块方面，有几个程序员常犯的错误。这里我们介绍两个。</p><ul><li>循环导入（circular imports）</li><li>覆盖导入（Shadowed imports，暂时翻译为覆盖导入）</li></ul><p>先来看看循环导入。</p><h3 id="循环导入"><a href="#循环导入" class="headerlink" title="循环导入"></a>循环导入</h3><p>如果你创建两个模块，二者相互导入对方，那么就会出现循环导入。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># a.py</span><br><span class="line">import b</span><br><span class="line"></span><br><span class="line">def a_test():</span><br><span class="line">    print(&quot;in a_test&quot;)</span><br><span class="line">    b.b_test()</span><br><span class="line"></span><br><span class="line">a_test()</span><br></pre></td></tr></table></figure><p>然后在同个文件夹中创建另一个模块，将其命名为<code>b.py</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import a</span><br><span class="line"></span><br><span class="line">def b_test():</span><br><span class="line">    print(&apos;In test_b&quot;&apos;)</span><br><span class="line">    a.a_test()</span><br><span class="line"></span><br><span class="line">b_test()</span><br></pre></td></tr></table></figure><p>如果你运行任意一个模块，都会引发<code>AttributeError</code>。这是因为这两个模块都在试图导入对方。简单来说，模块<code>a</code>想要导入模块<code>b</code>，但是因为模块<code>b</code>也在试图导入模块<code>a</code>（这时正在执行），模块<code>a</code>将无法完成模块<code>b</code>的导入。我看过一些解决这个问题的破解方法（hack），但是<strong>一般来说，你应该做的是重构代码，避免发生这种情况</strong>。</p><h3 id="覆盖导入"><a href="#覆盖导入" class="headerlink" title="覆盖导入"></a>覆盖导入</h3><p>当你创建的模块与标准库中的模块同名时，如果你导入这个模块，就会出现覆盖导入。举个例子，创建一个名叫<code>math.py</code>的文件，在其中写入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line">def square_root(number):</span><br><span class="line">    return math.sqrt(number)</span><br><span class="line"></span><br><span class="line">square_root(72)</span><br></pre></td></tr></table></figure><p>现在打开终端，试着运行这个文件，你会得到以下回溯信息（traceback）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;math.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    import math</span><br><span class="line">  File &quot;/Users/michael/Desktop/math.py&quot;, line 6, in &lt;module&gt;</span><br><span class="line">    square_root(72)</span><br><span class="line">  File &quot;/Users/michael/Desktop/math.py&quot;, line 4, in square_root</span><br><span class="line">    return math.sqrt(number)</span><br><span class="line">AttributeError: module &apos;math&apos; has no attribute &apos;sqrt&apos;</span><br></pre></td></tr></table></figure><p>这到底是怎么回事？其实，你运行这个文件的时候，Python解释器首先在当前运行脚本所处的的文件夹中查找名叫<code>math</code>的模块。在这个例子中，解释器找到了我们正在执行的模块，试图导入它。但是我们的模块中并没有叫<code>sqrt</code>的函数或属性，所以就抛出了<code>AttributeError</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们讲了很多有关导入的内容，但是还有部分内容没有涉及。<a href="https://www.python.org/dev/peps/pep-0302/" target="_blank" rel="noopener">PEP 302</a>中介绍了导入钩子（import hooks），支持实现一些非常酷的功能，比如说直接从github导入。Python标准库中还有一个<a href="https://docs.python.org/3/library/importlib.html" target="_blank" rel="noopener">importlib</a>模块，值得查看学习。当然，你还可以多看看别人写的代码，不断挖掘更多好用的妙招。</p>]]></content>
    
    <summary type="html">
    
      python import模块相关问题
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>运维事故记录</title>
    <link href="http://yoursite.com/2018/08/13/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95/%E8%BF%90%E7%BB%B4%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/08/13/IT科学技术知识体系结构-Linux运维方向/运维事故记录/运维事故记录/</id>
    <published>2018-08-13T08:42:08.000Z</published>
    <updated>2018-08-13T08:42:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CDH-服务器负载飙升"><a href="#CDH-服务器负载飙升" class="headerlink" title="CDH 服务器负载飙升"></a>CDH 服务器负载飙升</h1><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>es057服务器在9:52开始，系统负载飙升到14.74，CPU的空闲率（idle）降至0.28%</p><h2 id="问题排查及处理解决"><a href="#问题排查及处理解决" class="headerlink" title="问题排查及处理解决"></a>问题排查及处理解决</h2><ol><li><p>内存使用率正常，无任何异常</p></li><li><p>网络流量正常，无任何异常</p></li><li><p>网络连接数正常，无任何异常</p></li><li><p>CPU使用率 从09:52:18开始飙升，直到10：03：18开始恢复</p><ul><li>CPU每秒的中断数从2000飙升到3W4，升高了12.68倍</li></ul></li></ol><ol><li><p>磁盘</p><ul><li>operations read per seconde on / 从0提高到了8</li></ul></li></ol><h2 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h2><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="问题现象-1"><a href="#问题现象-1" class="headerlink" title="问题现象"></a>问题现象</h2><h2 id="问题排查及处理解决-1"><a href="#问题排查及处理解决-1" class="headerlink" title="问题排查及处理解决"></a>问题排查及处理解决</h2><h2 id="问题反思-1"><a href="#问题反思-1" class="headerlink" title="问题反思"></a>问题反思</h2>]]></content>
    
    <summary type="html">
    
      运维事故记录-错题集
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="运维事故记录" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="运维事故记录" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>MAC操作技巧</title>
    <link href="http://yoursite.com/2018/08/11/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/MAC%E4%BD%BF%E7%94%A8/MAC%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2018/08/11/常用软件工具/MAC使用/MAC操作技巧/</id>
    <published>2018-08-11T10:21:58.000Z</published>
    <updated>2018-08-11T10:21:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美式键盘对应关系"><a href="#美式键盘对应关系" class="headerlink" title="美式键盘对应关系"></a>美式键盘对应关系</h1><p>参考链接：<a href="https://support.apple.com/zh-cn/HT202676" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT202676</a></p><p>在Mac的快捷键中经常会有一些符号，比如⌘、⌥、⇧、⌃等，而Mac下只有command键上有一个⌘的符号，而其他按键均没有符号，很多人可能不知道这是什么意思，之所以只有command键上有一个符号，而其他按键上没有，是因为：</p><ul><li>只有command健才是Mac下唯一独有的一个特殊按键，而shift、alt（option）、control、caps lock、tab等在其他系统下都有，所以Mac在command键上做一个符号，用于表示这一按键的特殊性；</li></ul><p>我们在生活中能接触到的外接键盘基本上都是美式键盘，下面是两种键盘的布局对应关系，在使用外接键盘的时候，需要有充分的了解。</p><p><strong>文字描述：</strong></p><p>⌘ —— Command (Windows键)</p><p>⌃ —— Control(Ctrl键)</p><p>⌥ —— Option (Alt)</p><p>⇧ —— Shift</p><p>⇪ —— Caps Lock</p><p>FN —— FN(Insert)</p><p>括号里面是Windows对应的按键。以前Ctrl+C,Ctrl+V 现在要用Win+C,Win+V。</p><p><strong>图形展示：</strong></p><p><strong>Windows 标志：</strong>按下 Command (⌘) 键<br><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-windows-logo.png" alt=" "></p><p><strong>退格或删除：</strong>按下 Delete 键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-backspace-delete.png" alt=" "></p><p><strong>回车或 ⏎：</strong>按下 Return 键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-enter.png" alt=" "></p><p><strong>Alt（左）：</strong>按下 Option 键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-alt-left.png" alt=" "></p><p><strong>Alt GR（右）：</strong>按下 Option + Control 组合键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-alt-right.png" alt=" "></p><p><strong>应用程序：</strong>Apple 键盘上没有这个按键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-applications.png" alt=" "></p><h1 id="MAC常用快捷键"><a href="#MAC常用快捷键" class="headerlink" title="MAC常用快捷键"></a>MAC常用快捷键</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>先来一张图</p><p><img src="http://picture.watchmen.xin/MAC/mac_key.png" alt=""></p><h2 id="全局操作"><a href="#全局操作" class="headerlink" title="全局操作"></a>全局操作</h2><ul><li>⌃⌘ + f: 进入全屏模式</li></ul><h2 id="强制退出应用"><a href="#强制退出应用" class="headerlink" title="强制退出应用"></a>强制退出应用</h2><p>如果 Mac 上的某个应用停止响应，并且您无法正常退出该应用，则可以使用“强制退出”来关闭该应用。</p><p>同时按住三个按键：Option、Command 和 Esc (Escape) 键。这类似于在 PC 上按下 Control-Alt-Delete。或者，在屏幕左上角的苹果 () 菜单中选取“强制退出”。</p><h2 id="强制刷新页面"><a href="#强制刷新页面" class="headerlink" title="强制刷新页面"></a>强制刷新页面</h2><ul><li><p>正常刷新：command+r</p></li><li><p>强制刷新页面（刷新页面缓存）：command+shift+r</p></li></ul><h2 id="切换全屏页面"><a href="#切换全屏页面" class="headerlink" title="切换全屏页面"></a>切换全屏页面</h2><p>ctrl+方向键的左右</p><h2 id="控制中心"><a href="#控制中心" class="headerlink" title="控制中心"></a>控制中心</h2><p>ctrl+上箭头</p><h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><p>MAC上管理软件包我们一般使用Homebrew来实现</p><p>Homebrew是MAC必备神器之一，作为Mac OSX上的软件包管理工具，它能在Mac中方便的安装软件或者卸载软件， 简单到只需要一个命令。</p><p><strong>安装：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p><strong>命令参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">brew install安装软件</span><br><span class="line">brew list列出已安装的软件</span><br><span class="line">brew update更新brew</span><br><span class="line">brew home用浏览器打开brew的官方网站</span><br><span class="line">brew info显示软件信息</span><br><span class="line">brew deps显示包依赖</span><br></pre></td></tr></table></figure><h1 id="MAC下实现AutoHotKey功能"><a href="#MAC下实现AutoHotKey功能" class="headerlink" title="MAC下实现AutoHotKey功能"></a>MAC下实现AutoHotKey功能</h1><p>在MAC下没有类似autohotkey的软件，但是它给我们提供了相应的工具，我们可以自定义的去实现功能</p><p><strong>步骤1：</strong>从其他中进入automator（中文版的名称为：“自动操作”）</p><p>就是下面这位仁兄：</p><p><img src="http://picture.watchmen.xin/MAC/automator.png" alt=""></p><p><strong>步骤2：</strong>创建服务</p><p><img src="http://picture.watchmen.xin/MAC/automator_new_services.png" alt=""></p><p><strong>步骤3：</strong> 创建applescript，如下图所示，用鼠标将applescript选中并拖到右栏中</p><p>注意，需要先将服务收到一栏中从文本修改为没有输入</p><p><img src="http://picture.watchmen.xin/MAC/automator_new_applescript.png" alt=""></p><p><strong>步骤4：</strong>编辑applescript</p><p>有关applescript的相关内容，网友可以自行查找，网上有非常多的资料。</p><p>简单说明下：</p><ul><li>tell语句，在这里调用谷歌浏览器程序（程序的实际名称可以打开终端，进入/Applications目录下ls查看）</li><li>activate语句，这这里将调用出来的窗口显示在最前端</li><li>open location 语句，实际的操作，后面的参数是具体的链接地址</li><li>end tell语句，结束调用<br><img src="http://picture.watchmen.xin/MAC/applescript.png" alt=""></li></ul><p><strong>步骤5：</strong>运行测试</p><p><img src="http://picture.watchmen.xin/MAC/runapplescript.png" alt=""></p><p>点击两个运行中任一一个，可以看到网页会在最前端弹出，代码执行成功之后，缩进和颜色都会发生相应的变化。</p><p><strong>步骤6：</strong> 保存为服务</p><p>输入command+s，在弹出的对话框中，输入自定义的名称</p><p><img src="http://picture.watchmen.xin/MAC/saveapplescript.png" alt=""></p><p><strong>步骤7：</strong>设置快捷键</p><p>打开系统偏好设置–&gt;键盘—&gt;快捷键–&gt;服务–&gt;通用—&gt;选中刚才保存的服务–&gt;双击—&gt;在编辑器中，敲下自定义的快捷键，系统将会自动识别显示，如下图所示：</p><p><img src="http://picture.watchmen.xin/MAC/config_applescript.png" alt=""></p><p>这个时候，设置就全部完毕，接下来我们就可以随时根据快捷键调用浏览器打开网页。</p><h1 id="Iterm2操作"><a href="#Iterm2操作" class="headerlink" title="Iterm2操作"></a>Iterm2操作</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><strong>标签</strong></p><ul><li>新建标签：command + t</li><li>关闭标签：command + w</li><li>切换标签：command + 数字 command + 左右方向键</li><li>切换全屏：command + enter</li><li>查找：command + f</li></ul><p><strong>分屏</strong></p><ul><li>垂直分屏：command + d</li><li>水平分屏：command + shift + d</li><li>切换屏幕：command + option + 方向键 或者 command + [ ]</li></ul><p><strong>命令</strong></p><ul><li>查看历史命令：command + ;</li><li>查看剪贴板历史：command + shift + h</li><li>上一条命令：ctrl + p</li><li>搜索命令历史：ctrl + r</li></ul><p><strong>行内</strong></p><ul><li>清除当前行：ctrl + u</li><li>到行首：ctrl + a</li><li>到行尾：ctrl + e</li><li>前进后退：ctrl + f/b (相当于左右方向键)</li><li>删除当前光标的字符：ctrl + d</li><li>删除光标之前的字符：ctrl + h</li><li>删除光标之前的单词：ctrl + w</li><li>删除到文本末尾：ctrl + k</li><li>交换光标处文本：ctrl + t</li></ul><p><strong>其他</strong></p><ul><li>清屏1：command + r</li><li>清屏2：ctrl + l</li><li>清屏3：clear</li><li>进入和退出全屏: Command + Enter</li><li>查看当前终端中光标的位置: Command + /</li><li>开启和关闭背景半透明: Command + u</li><li>清屏（重置当前终端）: Command + r</li></ul><h2 id="连接jumpserver"><a href="#连接jumpserver" class="headerlink" title="连接jumpserver"></a>连接jumpserver</h2><ol><li><p>Profile -&gt; Open Profiles… -&gt; Edit Profiles…</p></li><li><p>点击左下角+号</p></li><li><p>输入Profile Name，比如jumper</p></li><li><p>右边Command下选择Command，然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i /Users/yourname/.ssh/id_rsa  username@ip -p port</span><br></pre></td></tr></table></figure></li><li><p>关闭所有窗口</p></li><li><p>在Iterm2的一个窗口中选择右键New Tab或者command+o,在弹出的页面中选择刚创建的jumper，然后回车就登录上了。</p></li></ol><p>注意，如果给RSA秘钥设置了密码，又不想每次在登录的时候都输出密码，这个时候我们可以在命令行中输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -K /Users/yourname/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>输入一次之后，后续就不用再次输入。</p><h2 id="实现rz-sz功能"><a href="#实现rz-sz功能" class="headerlink" title="实现rz/sz功能"></a>实现rz/sz功能</h2><p>Mac上iTerm原生不支持rz/sz命令，也就是不支持Zmodem来进行文件传输，不过只要通过简单的配置就可以实现。网上的教程一大把，这里就简单的记录一下过程。</p><h3 id="安装lrzsz"><a href="#安装lrzsz" class="headerlink" title="安装lrzsz"></a>安装lrzsz</h3><p>首先安装Homebrew(这里不写这个过程)，然后通过它先给Mac安装lrzsz。在终端下输入brew install lrzsz，静等一会即可安装完毕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure><h3 id="下载iTerm2辅助文件"><a href="#下载iTerm2辅助文件" class="headerlink" title="下载iTerm2辅助文件"></a>下载iTerm2辅助文件</h3><p>iTerm不能直接使用lrzsz，不过网上有大神提供了两个辅助脚本。我们只需要把文件下载到 /usr/local/bin/目录下并赋予可执行权限即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">wget https://raw.githubusercontent.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh</span><br><span class="line">wget https://raw.githubusercontent.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh</span><br><span class="line"></span><br><span class="line">chmod +x iterm2-recv-zmodem.sh iterm2-send-zmodem.sh</span><br></pre></td></tr></table></figure><p>这两个脚本实际是使用AppleScript来弹出文件选择窗口，然后把选中的文件名称传递给rzsz命令。我们打开其中一个看下代码。如果这一部分看不懂没关系，直接跳过即可，对后续的配置使用没有任何不良影响 </p><h3 id="配置iTerm2触发器"><a href="#配置iTerm2触发器" class="headerlink" title="配置iTerm2触发器"></a>配置iTerm2触发器</h3><p>这一步最关键，是在iTerm里面配置触发器，当监控到特定字符串的时候执行刚才下载的两个文件。为了使用方便，我专门建立了一个Profile配置，名字是Remote，并且配合后面的autossh使用。</p><p>打开iTerm2 -&gt; Preferences -&gt; Profiles 选择 Advanced 设置 Triggers ，点击 Edit</p><p><img src="http://picture.watchmen.xin/MAC/config_lrzsz.png" alt=""></p><p>在弹出窗口中进行如下配置，最后的<strong>Instant</strong>一定要勾选上。</p><p><img src="http://picture.watchmen.xin/MAC/config_lrzsz_triggers.png" alt=""></p><p>配置的具体内容在这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Regular expression: rz waiting to receive.\*\*B0100</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line"></span><br><span class="line">Regular expression: \*\*B00000000000000</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/local/bin/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure><p>重新启动iTerm之后，rz/sz就应该可以正常使用了。</p><h1 id="Forklift操作"><a href="#Forklift操作" class="headerlink" title="Forklift操作"></a>Forklift操作</h1><p>在文件夹中搜索文件：command+s</p><p>常用文件夹-Favorites：alt+command+f</p><p>ftp等传输工具：command+k</p><p>前进/后退：command+[/]</p><h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><h2 id="pycharm-光标变粗问题"><a href="#pycharm-光标变粗问题" class="headerlink" title="pycharm-光标变粗问题"></a>pycharm-光标变粗问题</h2><p>mac下默认的pycharm的光标是为粗体的改写模式，这是因为安装的时候装了ideaVim插件，改为竖线光标的方法：把ideaVim插件去掉（点击pycharm–&gt;preference–&gt;plugins–&gt;搜索ideavim，然后将该插件勾除掉即可） </p><h2 id="MAC版本snipaste截图后无法输入中文问题"><a href="#MAC版本snipaste截图后无法输入中文问题" class="headerlink" title="MAC版本snipaste截图后无法输入中文问题"></a>MAC版本snipaste截图后无法输入中文问题</h2><p>参考资料：<a href="https://jingyan.baidu.com/article/c1a3101e635d6ade646deb56.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/c1a3101e635d6ade646deb56.html</a></p><ol><li>点击菜单栏截图软件的图标，选择退出软件。</li></ol><ol><li><p>接着按键盘上面的control+space ，选择拼音输入法。</p></li><li><p>这个时候就可以启动截图软件了，按键盘上的cmmand+space，在黑色框输入软件的名字回车。</p></li></ol><ol><li>点击软件图标，选择截图或者是按fn+f1，进行桌面的截图。</li></ol><ol><li>在截图上面，按空格键调出截图软件工具条，然后点击工具条上面的T，这个时候就可以在图片上面进行中文的标注了。总结就是用不了重启软件即可。</li></ol>]]></content>
    
    <summary type="html">
    
      MAC操作技巧
    
    </summary>
    
      <category term="常用软件工具" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="MAC操作技巧" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/MAC%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="MAC" scheme="http://yoursite.com/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>day05-常用模块学习</title>
    <link href="http://yoursite.com/2018/08/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day05-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/08/08/编程语言/Python/老男孩视频学习笔记/day05-常用模块学习/</id>
    <published>2018-08-08T12:29:08.000Z</published>
    <updated>2018-08-08T12:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ol><li><p>定义</p><blockquote><p>模块：本质就是.py结尾的python文件</p><p>用来从逻辑上组织python代码（变量、函数、类、逻辑），目的是实现功能</p><p>包：用来从逻辑上组织模块，本质就是一个目录，必须带有一个<strong>init</strong>.py文件</p><p>导入包的本质其实就是执行该包下的<strong>init</strong>.py文件。</p></blockquote></li><li><p>导入/使用方法</p><blockquote><p>From import和import的区别？</p><p>因为存在定义同名方法等的问题，因此不建议使用import*</p></blockquote></li><li><p>import本质（路径搜索和搜索路径）</p><blockquote><p>导入模块的本质就是把python文件再解释一遍</p></blockquote></li><li><p>导入优化</p></li><li><p>模块的分类</p><blockquote><ul><li>标准库</li><li>开源模块</li><li>自定义模块</li></ul></blockquote></li></ol><h1 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h1><h2 id="time与datetime"><a href="#time与datetime" class="headerlink" title="time与datetime"></a>time与datetime</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"># print(time.clock()) #返回处理器时间,3.3开始已废弃 , 改成了time.process_time()测量处理器运算时间,不包括sleep时间,不稳定,mac上测不出来</span><br><span class="line"># print(time.altzone)  #返回与utc时间的时间差,以秒计算\</span><br><span class="line"># print(time.asctime()) #返回时间格式&quot;Fri Aug 19 11:14:16 2016&quot;,</span><br><span class="line"># print(time.localtime()) #返回本地时间 的struct time对象格式</span><br><span class="line"># print(time.gmtime(time.time()-800000)) #返回utc时间的struc时间对象格式</span><br><span class="line"></span><br><span class="line"># print(time.asctime(time.localtime())) #返回时间格式&quot;Fri Aug 19 11:14:16 2016&quot;,</span><br><span class="line">#print(time.ctime()) #返回Fri Aug 19 12:38:29 2016 格式, 同上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 日期字符串 转成  时间戳</span><br><span class="line"># string_2_struct = time.strptime(&quot;2016/05/22&quot;,&quot;%Y/%m/%d&quot;) #将 日期字符串 转成 struct时间对象格式</span><br><span class="line"># print(string_2_struct)</span><br><span class="line"># #</span><br><span class="line"># struct_2_stamp = time.mktime(string_2_struct) #将struct时间对象转成时间戳</span><br><span class="line"># print(struct_2_stamp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#将时间戳转为字符串格式</span><br><span class="line"># print(time.gmtime(time.time()-86640)) #将utc时间戳转换成struct_time格式</span><br><span class="line"># print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.gmtime()) ) #将utc struct_time格式转成指定的字符串格式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#时间加减</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># print(datetime.datetime.now()) #返回 2016-08-19 12:47:03.941925</span><br><span class="line">#print(datetime.date.fromtimestamp(time.time()) )  # 时间戳直接转成日期格式 2016-08-19</span><br><span class="line"># print(datetime.datetime.now() )</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(3)) #当前时间+3天</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(-3)) #当前时间-3天</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(hours=3)) #当前时间+3小时</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(minutes=30)) #当前时间+30分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># c_time  = datetime.datetime.now()</span><br><span class="line"># print(c_time.replace(minute=3,hour=2)) #时间替换</span><br></pre></td></tr></table></figure><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">随机数</span><br><span class="line"></span><br><span class="line">mport random</span><br><span class="line">print random.random()  随机浮点数，生产0-1之间的随机数，可以查看帮助文档 </span><br><span class="line">print random.randint(1,2) 生成指定范围内的整数 -</span><br><span class="line">print random.randrange(1,10，2) 在指定范围内取值，并且是递增关系，同时不会取最后一个数，间隔是2</span><br><span class="line">print random.choice(&apos;wxh&apos;) 随机取出一个字符</span><br><span class="line"></span><br><span class="line">shufflp用于将一个列表中的元素打乱，执行之后，原有的列表内容将会被改变</span><br><span class="line">p = [&apos;this&apos;,&apos;is&apos;,&apos;for&apos;,&apos;test&apos;]</span><br><span class="line">random.shuffle(p)</span><br><span class="line">print (p)     </span><br><span class="line">执行之后的输出为：[&apos;this&apos;, &apos;for&apos;, &apos;test&apos;, &apos;is&apos;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">random.sample 从指定序列中随机获取指定长度的片断</span><br><span class="line">p = [&apos;this&apos;,&apos;is&apos;,&apos;for&apos;,&apos;test&apos;]</span><br><span class="line">res = random.sample(p,3)</span><br><span class="line">print (res)</span><br><span class="line">print (p)</span><br><span class="line">执行之后的输出为：</span><br><span class="line">[&apos;is&apos;, &apos;for&apos;, &apos;this&apos;]</span><br><span class="line">[&apos;this&apos;, &apos;is&apos;, &apos;for&apos;, &apos;test&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">生成随机验证码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import random</span><br><span class="line">checkcode = &apos;&apos;</span><br><span class="line">for i in range(4):</span><br><span class="line">    current = random.randrange(0,4)</span><br><span class="line">    if current != i:</span><br><span class="line">        temp = chr(random.randint(65,90))</span><br><span class="line">    else:</span><br><span class="line">        temp = random.randint(0,9)</span><br><span class="line">    checkcode += str(temp)</span><br><span class="line">print checkcode</span><br></pre></td></tr></table></figure><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>参考链接：<a href="https://docs.python.org/3/library/string.html?highlight=string#module-string" target="_blank" rel="noopener">https://docs.python.org/3/library/string.html?highlight=string#module-string</a></p><p>string.ascii_lowercase        生成小写字母串</p><p>The lowercase letters <code>&#39;abcdefghijklmnopqrstuvwxyz&#39;</code>. This value is not locale-dependent and will not change.</p><p>string.ascii_uppercase        生成大写字母串<br>The uppercase letters <code>&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code>. This value is not locale-dependent and will not change.</p><p>string.digits        生成数字串</p><p>The string <code>&#39;0123456789&#39;</code>.</p><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><p>This module provides a portable way of using operating system dependent functionality</p><p>os模块主要用于和操作系统之间的交互，这个模块提供了一种方便的使用操作系统函数的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</span><br><span class="line">os.chdir(&quot;dirname&quot;)  改变当前脚本工作目录；相当于shell下cd</span><br><span class="line">os.curdir  返回当前目录: (&apos;.&apos;)</span><br><span class="line">os.pardir  获取当前目录的父目录字符串名：(&apos;..&apos;)</span><br><span class="line">os.makedirs(&apos;dirname1/dirname2&apos;)    可生成多层递归目录</span><br><span class="line">os.removedirs(&apos;dirname1&apos;)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</span><br><span class="line">os.mkdir(&apos;dirname&apos;)    生成单级目录；相当于shell中mkdir dirname</span><br><span class="line">os.rmdir(&apos;dirname&apos;)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</span><br><span class="line">os.listdir(&apos;dirname&apos;)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印，相当于ls -la</span><br><span class="line">os.remove()  删除一个文件</span><br><span class="line">os.rename(&quot;oldname&quot;,&quot;newname&quot;)  重命名文件/目录</span><br><span class="line">os.stat(&apos;path/filename&apos;)  获取文件/目录信息,相当于shell中的stat命令，会显示各种事件信息</span><br><span class="line">os.sep    输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;</span><br><span class="line">os.linesep    输出当前平台使用的行终止符，win下为&quot;\t\n&quot;,Linux下为&quot;\n&quot;</span><br><span class="line">os.pathsep    输出用于分割文件路径的字符串</span><br><span class="line">os.name    输出字符串指示当前使用平台。win-&gt;&apos;nt&apos;; Linux-&gt;&apos;posix&apos;</span><br><span class="line">os.system(&quot;bash command&quot;)  运行shell命令，直接显示</span><br><span class="line">os.environ  获取系统环境变量</span><br><span class="line">os.path.abspath(path)  返回path规范化的绝对路径</span><br><span class="line">os.path.split(path)  将path分割成目录和文件名二元组返回</span><br><span class="line">os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素</span><br><span class="line">os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span><br><span class="line">os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False</span><br><span class="line">os.path.isabs(path)  如果path是绝对路径，返回True</span><br><span class="line">os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False</span><br><span class="line">os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False</span><br><span class="line">os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span><br><span class="line">os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间</span><br><span class="line">os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = os.popen(&quot;pwd&quot;)</span><br><span class="line">x = a.read()</span><br><span class="line">print (x)</span><br></pre></td></tr></table></figure><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><p>This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.</p><p>sys模块主要用于和python解释器之间的交互，这个模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sys.argv           命令行参数List，第一个元素是程序本身路径</span><br><span class="line">sys.exit(n)        退出程序，正常退出时exit(0)</span><br><span class="line">sys.version        获取Python解释程序的版本信息</span><br><span class="line">sys.maxint         最大的Int值</span><br><span class="line">sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值,获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。</span><br><span class="line"></span><br><span class="line">sys.platform       返回操作系统平台名称</span><br><span class="line">sys.stdout.write(&apos;please:&apos;)</span><br><span class="line">val = sys.stdin.readline()[:-1]</span><br></pre></td></tr></table></figure><h2 id="shutil-模块"><a href="#shutil-模块" class="headerlink" title="shutil 模块"></a>shutil 模块</h2><p>高级的 文件、文件夹、压缩包 处理模块</p><p><strong>shutil.copyfileobj(fsrc, fdst[, length])</strong><br>将文件内容拷贝到另一个文件中，可以部分内容</p><p><strong>shutil.copyfile(src, dst)</strong><br>拷贝文件</p><p><strong>shutil.copymode(src, dst)</strong><br>仅拷贝权限。内容、组、用户均不变</p><p><strong>shutil.copystat(src, dst)</strong><br>拷贝状态的信息，包括：mode bits, atime, mtime, flags</p><p><strong>shutil.copy(src, dst)</strong><br>拷贝文件和权限</p><p><strong>shutil.copy2(src, dst)</strong><br>拷贝文件和状态信息</p><p><strong>shutil.ignore_patterns(*patterns)</strong><br><strong>shutil.copytree(src, dst, symlinks=False, ignore=None)</strong><br>递归的去拷贝文件</p><p>例如：copytree(source, destination, ignore=ignore_patterns(‘<em>.pyc’, ‘tmp</em>‘))</p><p><strong>shutil.rmtree(path[, ignore_errors[, onerror]])</strong><br>递归的去删除文件</p><p><strong>shutil.move(src, dst)</strong><br>递归的去移动文件</p><p><strong>shutil.make_archive(base_name, format,…)</strong></p><p>创建压缩包并返回文件路径，例如：zip、tar</p><ul><li>base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，<br>如：www                        =&gt;保存至当前路径<br>如：/Users/wupeiqi/www =&gt;保存至/Users/wupeiqi/<br>   format：    压缩包种类，“zip”, “tar”, “bztar”，“gztar”<br>   root_dir：    要压缩的文件夹路径（默认当前目录）<br>   owner：    用户，默认当前用户<br>   group：    组，默认当前组<br>   logger：    用于记录日志，通常是logging.Logger对象</li></ul><p>shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的，详细：</p><h2 id="json-amp-pickle-模块"><a href="#json-amp-pickle-模块" class="headerlink" title="json &amp; pickle 模块"></a>json &amp; pickle 模块</h2><p>用于序列化的两个模块</p><ul><li>json，用于字符串 和 python数据类型间进行转换</li><li>pickle，用于python特有的类型 和 python的数据类型间进行转换</li></ul><p>Json模块提供了四个功能：dumps、dump、loads、load</p><p>pickle模块提供了四个功能：dumps、dump、loads、load</p><p><img src="https://images2015.cnblogs.com/blog/425762/201511/425762-20151114231017087-842020084.png" alt="img"></p><p>json的作用是把数据进行序列化，一个在内存中的数据对象，比如说是字典、列表等，不能直接写到文件里面，因此要把数据写入到文件里面，那么这个文件只能存byte类型或者是字符串，那就就需要把这些数据转换成为字符串。</p><p>将这些数据转换成为字符串之后，以后想要再加载这些数据的时候，因此需要确保文件中的内容的数据类型没有被破坏</p><p>json：帮助你把python中的内存数据转成字符串；想在其他的程序内再调用这些数据的时候，load一下就可以使用了。</p><p>这解决了：不同的语言，不同的平台之间的数据交换，使python可以和php、java等语言的数据进行交换</p><p>json这一部分还需要再深入下</p><h2 id="shelve-模块"><a href="#shelve-模块" class="headerlink" title="shelve 模块"></a>shelve 模块</h2><p>shelve模块是一个简单的k,v将内存数据通过文件持久化的模块，可以持久化任何pickle可支持的python数据格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import shelve</span><br><span class="line"></span><br><span class="line">#写</span><br><span class="line"></span><br><span class="line">s = shelve.open(&apos;shelve.txt&apos;)</span><br><span class="line"></span><br><span class="line">class Test():</span><br><span class="line">    def __init__(self,n):</span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">t = Test(1233)</span><br><span class="line"></span><br><span class="line">t2 = Test(1111)</span><br><span class="line"></span><br><span class="line">name = [&apos;111&apos;,&apos;sdaf&apos;,&apos;sd&apos;]</span><br><span class="line"></span><br><span class="line">s[&quot;test&quot;] = name</span><br><span class="line"></span><br><span class="line">s[&quot;t1&quot;] = t</span><br><span class="line"></span><br><span class="line">s[&quot;t2&quot;] = t2</span><br><span class="line"></span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line"># 读</span><br><span class="line">d = shelve.open(&apos;shelve.txt&apos;)</span><br><span class="line"></span><br><span class="line">print (d.get(&quot;test&quot;))</span><br><span class="line"></span><br><span class="line">d.close()</span><br></pre></td></tr></table></figure><h2 id="xml处理模块"><a href="#xml处理模块" class="headerlink" title="xml处理模块"></a><strong>xml处理模块</strong></h2><p>xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，古时候，在json还没诞生的黑暗年代，大家只能选择用xml呀，至今很多传统公司如金融行业的很多系统的接口还主要是xml。</p><p>xml的格式如下，就是通过&lt;&gt;节点来区别数据结构的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;country name=&quot;Liechtenstein&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;2&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2008&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;141100&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Austria&quot; direction=&quot;E&quot;/&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Switzerland&quot; direction=&quot;W&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">    &lt;country name=&quot;Singapore&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;5&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2011&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;59900&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Malaysia&quot; direction=&quot;N&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">    &lt;country name=&quot;Panama&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;69&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2011&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;13600&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Costa Rica&quot; direction=&quot;W&quot;/&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Colombia&quot; direction=&quot;E&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure><p>xml协议在各个语言里的都 是支持的，在python中可以用以下模块操作xml 　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)</span><br><span class="line">root = tree.getroot()</span><br><span class="line">print(root.tag)</span><br><span class="line"> </span><br><span class="line">#遍历xml文档</span><br><span class="line">for child in root:</span><br><span class="line">    print(child.tag, child.attrib)</span><br><span class="line">    for i in child:</span><br><span class="line">        print(i.tag,i.text)</span><br><span class="line"> </span><br><span class="line">#只遍历year 节点</span><br><span class="line">for node in root.iter(&apos;year&apos;):</span><br><span class="line">    print(node.tag,node.text)</span><br></pre></td></tr></table></figure><p>修改和删除xml文档内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)</span><br><span class="line">root = tree.getroot()</span><br><span class="line"> </span><br><span class="line">#修改</span><br><span class="line">for node in root.iter(&apos;year&apos;):</span><br><span class="line">    new_year = int(node.text) + 1</span><br><span class="line">    node.text = str(new_year)</span><br><span class="line">    node.set(&quot;updated&quot;,&quot;yes&quot;)</span><br><span class="line"> </span><br><span class="line">tree.write(&quot;xmltest.xml&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#删除node</span><br><span class="line">for country in root.findall(&apos;country&apos;):</span><br><span class="line">   rank = int(country.find(&apos;rank&apos;).text)</span><br><span class="line">   if rank &gt; 50:</span><br><span class="line">     root.remove(country)</span><br><span class="line"> </span><br><span class="line">tree.write(&apos;output.xml&apos;)</span><br></pre></td></tr></table></figure><p>自己创建xml文档</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">new_xml = ET.Element(&quot;namelist&quot;)</span><br><span class="line">name = ET.SubElement(new_xml,&quot;name&quot;,attrib=&#123;&quot;enrolled&quot;:&quot;yes&quot;&#125;)</span><br><span class="line">age = ET.SubElement(name,&quot;age&quot;,attrib=&#123;&quot;checked&quot;:&quot;no&quot;&#125;)</span><br><span class="line">sex = ET.SubElement(name,&quot;sex&quot;)</span><br><span class="line">sex.text = &apos;33&apos;</span><br><span class="line">name2 = ET.SubElement(new_xml,&quot;name&quot;,attrib=&#123;&quot;enrolled&quot;:&quot;no&quot;&#125;)</span><br><span class="line">age = ET.SubElement(name2,&quot;age&quot;)</span><br><span class="line">age.text = &apos;19&apos;</span><br><span class="line"> </span><br><span class="line">et = ET.ElementTree(new_xml) #生成文档对象</span><br><span class="line">et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;,xml_declaration=True)</span><br><span class="line"> </span><br><span class="line">ET.dump(new_xml) #打印生成的格式</span><br></pre></td></tr></table></figure><h2 id="ConfigParser模块"><a href="#ConfigParser模块" class="headerlink" title="ConfigParser模块"></a><strong>ConfigParser模块</strong></h2><p>用于生成和修改常见配置文档，当前模块的名称在 python 3.x 版本中变更为 小写的configparser。</p><p>来看一个好多软件的常见文档格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">ServerAliveInterval = 45</span><br><span class="line">Compression = yes</span><br><span class="line">CompressionLevel = 9</span><br><span class="line">ForwardX11 = yes</span><br><span class="line"> </span><br><span class="line">[bitbucket.org]</span><br><span class="line">User = hg</span><br><span class="line"> </span><br><span class="line">[topsecret.server.com]</span><br><span class="line">Port = 50022</span><br><span class="line">ForwardX11 = no</span><br></pre></td></tr></table></figure><p>如果想用python生成一个这样的文档怎么做呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import configparser</span><br><span class="line"> </span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config[&quot;DEFAULT&quot;] = &#123;&apos;ServerAliveInterval&apos;: &apos;45&apos;,</span><br><span class="line">                      &apos;Compression&apos;: &apos;yes&apos;,</span><br><span class="line">                     &apos;CompressionLevel&apos;: &apos;9&apos;&#125;</span><br><span class="line"> </span><br><span class="line">config[&apos;bitbucket.org&apos;] = &#123;&#125;</span><br><span class="line">config[&apos;bitbucket.org&apos;][&apos;User&apos;] = &apos;hg&apos;</span><br><span class="line">config[&apos;topsecret.server.com&apos;] = &#123;&#125;</span><br><span class="line">topsecret = config[&apos;topsecret.server.com&apos;]</span><br><span class="line">topsecret[&apos;Host Port&apos;] = &apos;50022&apos;     # mutates the parser</span><br><span class="line">topsecret[&apos;ForwardX11&apos;] = &apos;no&apos;  # same here</span><br><span class="line">config[&apos;DEFAULT&apos;][&apos;ForwardX11&apos;] = &apos;yes&apos;</span><br><span class="line"></span><br><span class="line">with open(&apos;example.ini&apos;, &apos;w&apos;) as configfile:</span><br><span class="line">   config.write(configfile)</span><br></pre></td></tr></table></figure><p>写完了还可以再读出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import configparser</span><br><span class="line">&gt;&gt;&gt; config = configparser.ConfigParser()</span><br><span class="line">&gt;&gt;&gt; config.sections()</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; config.read(&apos;example.ini&apos;)</span><br><span class="line">[&apos;example.ini&apos;]</span><br><span class="line">&gt;&gt;&gt; config.sections()</span><br><span class="line">[&apos;bitbucket.org&apos;, &apos;topsecret.server.com&apos;]</span><br><span class="line">&gt;&gt;&gt; &apos;bitbucket.org&apos; in config</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &apos;bytebong.com&apos; in config</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; config[&apos;bitbucket.org&apos;][&apos;User&apos;]</span><br><span class="line">&apos;hg&apos;</span><br><span class="line">&gt;&gt;&gt; config[&apos;DEFAULT&apos;][&apos;Compression&apos;]</span><br><span class="line">&apos;yes&apos;</span><br><span class="line">&gt;&gt;&gt; topsecret = config[&apos;topsecret.server.com&apos;]</span><br><span class="line">&gt;&gt;&gt; topsecret[&apos;ForwardX11&apos;]</span><br><span class="line">&apos;no&apos;</span><br><span class="line">&gt;&gt;&gt; topsecret[&apos;Port&apos;]</span><br><span class="line">&apos;50022&apos;</span><br><span class="line">&gt;&gt;&gt; for key in config[&apos;bitbucket.org&apos;]: print(key)</span><br><span class="line">...</span><br><span class="line">user</span><br><span class="line">compressionlevel</span><br><span class="line">serveraliveinterval</span><br><span class="line">compression</span><br><span class="line">forwardx11</span><br><span class="line">&gt;&gt;&gt; config[&apos;bitbucket.org&apos;][&apos;ForwardX11&apos;]</span><br><span class="line">&apos;yes&apos;</span><br></pre></td></tr></table></figure><p>configparser增删改查语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[section1]</span><br><span class="line">k1 = v1</span><br><span class="line">k2:v2</span><br><span class="line">  </span><br><span class="line">[section2]</span><br><span class="line">k1 = v1</span><br><span class="line"> </span><br><span class="line">import ConfigParser</span><br><span class="line">  </span><br><span class="line">config = ConfigParser.ConfigParser()</span><br><span class="line">config.read(&apos;i.cfg&apos;) </span><br><span class="line">  </span><br><span class="line"># ########## 读 ##########</span><br><span class="line">#secs = config.sections()</span><br><span class="line">#print secs</span><br><span class="line">#options = config.options(&apos;group2&apos;)</span><br><span class="line">#print options</span><br><span class="line">  </span><br><span class="line">#item_list = config.items(&apos;group2&apos;)</span><br><span class="line">#print item_list</span><br><span class="line">  </span><br><span class="line">#val = config.get(&apos;group1&apos;,&apos;key&apos;)</span><br><span class="line">#val = config.getint(&apos;group1&apos;,&apos;key&apos;)</span><br><span class="line">  </span><br><span class="line"># ########## 改写 ##########</span><br><span class="line">#sec = config.remove_section(&apos;group1&apos;)</span><br><span class="line">#config.write(open(&apos;i.cfg&apos;, &quot;w&quot;))</span><br><span class="line">  </span><br><span class="line">#sec = config.has_section(&apos;wupeiqi&apos;)</span><br><span class="line">#sec = config.add_section(&apos;wupeiqi&apos;)</span><br><span class="line">#config.write(open(&apos;i.cfg&apos;, &quot;w&quot;))</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">#config.set(&apos;group2&apos;,&apos;k1&apos;,11111)</span><br><span class="line">#config.write(open(&apos;i.cfg&apos;, &quot;w&quot;))</span><br><span class="line">  </span><br><span class="line">#config.remove_option(&apos;group2&apos;,&apos;age&apos;)</span><br><span class="line">#config.write(open(&apos;i.cfg&apos;, &quot;w&quot;))</span><br></pre></td></tr></table></figure><h2 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块　　"></a><strong>hashlib模块</strong>　　</h2><p>用于加密相关的操作，3.x里代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"> </span><br><span class="line">m = hashlib.md5()</span><br><span class="line">m.update(b&quot;Hello&quot;)</span><br><span class="line">m.update(b&quot;It&apos;s me&quot;)</span><br><span class="line">print(m.digest())</span><br><span class="line">m.update(b&quot;It&apos;s been a long time since last time we ...&quot;)</span><br><span class="line"> </span><br><span class="line">print(m.digest()) #2进制格式hash</span><br><span class="line">print(len(m.hexdigest())) #16进制格式hash</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def digest(self, *args, **kwargs): # real signature unknown</span><br><span class="line">    &quot;&quot;&quot; Return the digest value as a string of binary data. &quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">def hexdigest(self, *args, **kwargs): # real signature unknown</span><br><span class="line">    &quot;&quot;&quot; Return the digest value as a string of hexadecimal digits. &quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">import hashlib</span><br><span class="line"> </span><br><span class="line"># ######## md5 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.md5()</span><br><span class="line">hash.update(&apos;admin&apos;)</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha1 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha1()</span><br><span class="line">hash.update(&apos;admin&apos;)</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha256 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha256()</span><br><span class="line">hash.update(&apos;admin&apos;)</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># ######## sha384 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha384()</span><br><span class="line">hash.update(&apos;admin&apos;)</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha512 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha512()</span><br><span class="line">hash.update(&apos;admin&apos;)</span><br><span class="line">print(hash.hexdigest())</span><br></pre></td></tr></table></figure><p>还不够吊？python 还有一个 hmac 模块，它内部对我们创建 key 和 内容 再进行处理然后再加密</p><p>散列消息鉴别码，简称HMAC，是一种基于消息鉴别码MAC（Message Authentication Code）的鉴别机制。使用HMAC时,消息通讯的双方，通过验证消息中加入的鉴别密钥K来鉴别消息的真伪；</p><p>一般用于网络通信中消息加密，前提是双方先要约定好key,就像接头暗号一样，然后消息发送把用key把消息加密，接收方用key ＋ 消息明文再加密，拿加密后的值 跟 发送者的相对比是否相等，这样就能验证消息的真实性，及发送者的合法性了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import hmac</span><br><span class="line">h = hmac.new(b&apos;天王盖地虎&apos;, b&apos;宝塔镇河妖&apos;)</span><br><span class="line">print h.hexdigest()</span><br></pre></td></tr></table></figure><p>更多关于md5,sha1,sha256等介绍的文章看这里<a href="https://www.tbs-certificates.co.uk/FAQ/en/sha256.html" target="_blank" rel="noopener">https://www.tbs-certificates.co.uk/FAQ/en/sha256.html</a> </p><h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块　　"></a>re模块　　</h2><p>常用正则表达式符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos;     默认匹配除\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行</span><br><span class="line">&apos;^&apos;     匹配字符开头，若指定flags MULTILINE,这种也可以匹配上(r&quot;^a&quot;,&quot;\nabc\neee&quot;,flags=re.MULTILINE)</span><br><span class="line">&apos;$&apos;     匹配字符结尾，或e.search(&quot;foo$&quot;,&quot;bfoo\nsdfsf&quot;,flags=re.MULTILINE).group()也可以</span><br><span class="line">&apos;*&apos;     匹配*号前的字符0次或多次，re.findall(&quot;ab*&quot;,&quot;cabb3abcbbac&quot;)  结果为[&apos;abb&apos;, &apos;ab&apos;, &apos;a&apos;]</span><br><span class="line">&apos;+&apos;     匹配前一个字符1次或多次，re.findall(&quot;ab+&quot;,&quot;ab+cd+abb+bba&quot;) 结果[&apos;ab&apos;, &apos;abb&apos;]</span><br><span class="line">&apos;?&apos;     匹配前一个字符1次或0次</span><br><span class="line">&apos;&#123;m&#125;&apos;   匹配前一个字符m次</span><br><span class="line">&apos;&#123;n,m&#125;&apos; 匹配前一个字符n到m次，re.findall(&quot;ab&#123;1,3&#125;&quot;,&quot;abb abc abbcbbb&quot;) 结果&apos;abb&apos;, &apos;ab&apos;, &apos;abb&apos;]</span><br><span class="line">&apos;|&apos;     匹配|左或|右的字符，re.search(&quot;abc|ABC&quot;,&quot;ABCBabcCD&quot;).group() 结果&apos;ABC&apos;</span><br><span class="line">&apos;(...)&apos; 分组匹配，re.search(&quot;(abc)&#123;2&#125;a(123|456)c&quot;, &quot;abcabca456c&quot;).group() 结果 abcabca456c</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&apos;\A&apos;    只从字符开头匹配，re.search(&quot;\Aabc&quot;,&quot;alexabc&quot;) 是匹配不到的</span><br><span class="line">&apos;\Z&apos;    匹配字符结尾，同$</span><br><span class="line">&apos;\d&apos;    匹配数字0-9</span><br><span class="line">&apos;\D&apos;    匹配非数字</span><br><span class="line">&apos;\w&apos;    匹配[A-Za-z0-9]</span><br><span class="line">&apos;\W&apos;    匹配非[A-Za-z0-9]</span><br><span class="line">&apos;s&apos;     匹配空白字符、\t、\n、\r , re.search(&quot;\s+&quot;,&quot;ab\tc1\n3&quot;).group() 结果 &apos;\t&apos;</span><br><span class="line"> </span><br><span class="line">&apos;(?P&lt;name&gt;...)&apos; 分组匹配 </span><br><span class="line">re.search(&quot;(?P&lt;province&gt;[0-9]&#123;4&#125;)(?P&lt;city&gt;[0-9]&#123;2&#125;)(?P&lt;birthday&gt;[0-9]&#123;4&#125;)&quot;,&quot;371481199306143242&quot;).groupdict(&quot;city&quot;) </span><br><span class="line"></span><br><span class="line">结果&#123;&apos;province&apos;: &apos;3714&apos;, &apos;city&apos;: &apos;81&apos;, &apos;birthday&apos;: &apos;1993&apos;&#125;</span><br><span class="line"></span><br><span class="line">匹配分割</span><br><span class="line">import re</span><br><span class="line">res = re.split(&quot;[0-9]&quot;,&quot;wang123xiao123hua&quot;)</span><br><span class="line">print (res)</span><br><span class="line">输出为：[&apos;wang&apos;, &apos;&apos;, &apos;&apos;, &apos;xiao&apos;, &apos;&apos;, &apos;&apos;, &apos;hua&apos;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">匹配替换</span><br><span class="line">import re</span><br><span class="line">res = re.sub(&quot;[0-9]&quot;,&quot;#&quot;,&quot;wang123xiao123hua123@wangxiaohua123&quot;,count=2)</span><br><span class="line">print (res)</span><br><span class="line">输出为：wang##3xiao123hua123@wangxiaohua123</span><br></pre></td></tr></table></figure><p>最常用的匹配语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">re.match 从头开始匹配</span><br><span class="line">re.search 匹配包含</span><br><span class="line">re.findall 把所有匹配到的字符放到以列表中的元素返回</span><br><span class="line">re.splitall 以匹配到的字符当做列表分隔符</span><br><span class="line">re.sub      匹配字符并替换</span><br></pre></td></tr></table></figure><p>反斜杠的困扰<br>与大多数编程语言相同，正则表达式里使用”\”作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\”，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r”\“表示。同样，匹配一个数字的”\d”可以写成r”\d”。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。</p><p>仅需轻轻知道的几个匹配模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）</span><br><span class="line">M(MULTILINE): 多行模式，改变&apos;^&apos;和&apos;$&apos;的行为（参见上图）</span><br><span class="line">S(DOTALL): 点任意匹配模式，改变&apos;.&apos;的行为</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res = re.search(&quot;[a-z]+&quot;,&quot;abcdA&quot;)</span><br><span class="line">print (res)</span><br><span class="line">执行后输出为：</span><br><span class="line">&lt;re.Match object; span=(0, 4), match=&apos;abcd&apos;&gt;</span><br><span class="line"></span><br><span class="line">修改后：</span><br><span class="line">res = re.search(&quot;[a-z]+&quot;,&quot;abcdA&quot;,flags=re.I)</span><br><span class="line">print (res)</span><br><span class="line">执行后输出为：</span><br><span class="line">&lt;re.Match object; span=(0, 5), match=&apos;abcdA&apos;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">res = re.search(&quot;^a&quot;,&quot;\nabcd\nioush&quot;)</span><br><span class="line">print (res)</span><br><span class="line">None</span><br><span class="line"></span><br><span class="line">res = re.search(&quot;^a&quot;,&quot;\nabcd\nioush&quot;,flags=re.M)</span><br><span class="line">print (res)</span><br><span class="line">执行后输出为：</span><br><span class="line">&lt;re.Match object; span=(1, 2), match=&apos;a&apos;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res = re.search(&quot;.+&quot;,&quot;\nabcd\nghde&quot;)</span><br><span class="line">print (res)</span><br><span class="line">&lt;re.Match object; span=(1, 5), match=&apos;abcd&apos;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = re.search(&quot;.+&quot;,&quot;\nabcd\nghde&quot;,flags=re.S)</span><br><span class="line">print (res)</span><br><span class="line">执行后输出为：</span><br><span class="line">&lt;re.Match object; span=(0, 10), match=&apos;\nabcd\nghde&apos;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      day05-常用模块学习
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>day04-函数装饰器迭代器生成器</title>
    <link href="http://yoursite.com/2018/07/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day04-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2018/07/13/编程语言/Python/老男孩视频学习笔记/day04-函数装饰器迭代器生成器/</id>
    <published>2018-07-13T12:43:08.000Z</published>
    <updated>2018-07-13T12:43:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>器：代表函数的意思。也就是说，装饰器本质是函数，基本语法都是使用def关键字去定义的</p><p>那么它的本质是函数，它的功能是什么？</p><p>定义：装饰器的本质是函数：装饰其他函数的函数【就是为其他函数添加附加功能】</p><p>在实际生产环境中，需要新增功能的时候，有以下原则</p><ol><li>不能修改现有函数的源代码</li><li>函数一旦写好了，原则上就不能再去修改它的源代码</li><li>函数的调用方式也不能被修改</li></ol><p>装饰器有自己独特的需要遵循的原则：</p><ol><li><strong>不能修改被装饰的函数的源代码</strong></li><li><strong>不能修改被装饰的函数的调用方式</strong></li></ol><p>也就是，被装饰的函数式完全透明的（调用函数的一方不知道这个函数被装饰过，函数本身也感知不到装饰器的存在）</p><p>实现装饰器的知识储备：</p><ol><li><p>函数即“变量”</p></li><li><p>高阶函数</p><ul><li><p>把一个函数名都当做实参传递给另外一个函数【在一般的函数使用中，给形参传递的都是<code>实参变量</code>，那么，函数即变量之后，就可以把==函数==当做一个<code>变量实参</code>传递给另外一个函数】</p><p>这一步可以做到，在不修改被装饰函数源代码的情况下，为其添加功能</p></li><li><p>返回值中包含函数名【一般函数的返回值中吗，可以是字符串，列表，数字等等，因为函数是变量，那么在返回值中是也可以包含函数的】</p><p>不修改函数的调用方式</p></li></ul></li><li><p>函数嵌套</p><ul><li>函数嵌套指的是，在一个函数的函数体之内用def去声明一个新的函数，而不是去调用它</li></ul></li></ol><p>高阶函数+嵌套函数==》装饰器</p><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test1&quot;)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test2&quot;)</span><br><span class="line"></span><br><span class="line">def timer(func):</span><br><span class="line">    def deco():</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print (&quot;func is cost &#123;cost&#125;&quot;.format(cost=stop_time-start_time))</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line"># 返回该函数（这里是deco函数）的内存地址</span><br><span class="line"></span><br><span class="line">test1 = timer(test1)</span><br><span class="line">test1()</span><br><span class="line">#test1执行，实际上是在执行deco这个函数</span><br></pre></td></tr></table></figure><p>执行后的输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in the test1</span><br><span class="line">func is cost 1.0031695365905762</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>函数的执行，主要是执行函数体中的内容，而我们在真正执行函数的时候，是通过函数名称进行调用的（也就是一个变量），因此，在函数真正执行之前，我们可以<strong>修改这个函数名称对应的函数体中的内容</strong></p><p>装饰器的编写步骤：</p><ol><li>首先编写一个函数，其中调用这个被装饰的函数，并在其中添加上新的功能</li><li>将这个函数的函数体，也就是<strong>内存地址</strong>拿出来，重新赋值给这个被装饰的函数</li><li>实现第2步，就需要使用函数的嵌套，以此来返回这个函数的内存地址（函数嵌套了函数之后，是直接将子函数的内存地址返回，而没有执行这个子函数）</li><li>而将这个被装饰的源函数传递给这个装饰函数执行，就需要使用高阶函数</li></ol><h3 id="改良"><a href="#改良" class="headerlink" title="改良"></a>改良</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def timer(func):</span><br><span class="line">    def deco():</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print (&quot;func is cost &#123;cost&#125;&quot;.format(cost=stop_time-start_time))</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def test1():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test1&quot;)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test2&quot;)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>在这里，@timer=test1 = timer(test1)</p><p>注意，使用这种方式的时候，timer函数的定义要在这些被装饰函数的前方</p><p>如果函数还涉及到参数，那么，我们就需要重新编写定义装饰器，将它写成通用的方式，不管被装饰的函数传递的是几个函数（0个或多个），都能够正确的读取。</p><p><strong>添加函数传递功能</strong></p><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = lambda x:x*3</span><br><span class="line">print (res(3))</span><br><span class="line"></span><br><span class="line">执行后输出结果为：9</span><br></pre></td></tr></table></figure><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>通过列表生成式【列表解析】，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种<strong><code>一边循环一边计算</code></strong>的<strong>机制</strong>，称为生成器：generator。</p><p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [i*2 for i in range(11)]</span><br><span class="line">b = (i*2 for i in range(11))</span><br><span class="line">print (a)</span><br><span class="line">print (b)</span><br><span class="line"></span><br><span class="line">执行后输出如下所示：</span><br><span class="line">[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x058D5360&gt;</span><br></pre></td></tr></table></figure><p>注意，在进行调用的时候，传统的方式能够直接通过列表下标的方式获取到相应的元素【因为元素已经生成并存在于内存当中】，但是生成器是只有你调用到我这一次的时候，我才会生成这一个，也就是必须循环到这个指定的下标的时候，我才会产生这个元素的值，因此，在前面的数据没有生成的情况下，直接调用中间的某个元素，因为不存在这个元素，因此就会产生报错,不支持这种数据获取方式</p><p>调用生成器的时候，只能使用for循环的方式一个个取用，当不想要获取全部的数据，只需要获取部分数据的时候，使用生成器提供的next方法进行操作【next方法获取当前】。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.__next()__()</span><br></pre></td></tr></table></figure><p>注意：没有previous方法用户获取上一个值，因为，生成器只会当前的位置，不知道前边和后边</p><p><strong>总结：</strong></p><ul><li>生成器只有在调用时，才会生成相应的数据</li><li>只会记录当前位置</li><li>只有一个<code>__next__()</code>方法（2.7中为next()）</li></ul><p>我们创建了一个generator后，基本上永远不会调用<code>next()</code>，而是通过<code>for</code>循环来迭代它，并且不需要关心<code>StopIteration</code>的错误。</p><p>generator非常强大。如果推算的算法比较复杂，用类似列表生成式的<code>for</code>循环无法实现的时候，还可以用函数来实现。</p><p>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p><p>1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p><p>yield的作用：保存函数的中断状态，yield返回当前状态的值，并且将函数保持停留在这里</p><p>对生成器使用send()方法，可以将参数传递给这个生成器，yield就会接受到这个参数</p><p>next()只是单纯的调用yield，它不会给yield传值；send()给yield传值，同时调用yield</p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：</p><p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p><p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p><p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p><p><strong>重点：</strong></p><ul><li><p>可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code></p></li><li><p>生成器不但可以作用于<code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值了。</p></li><li>可以被next()方法调用并不断返回下一个值的对象称为迭代器：<strong><code>Iterator</code></strong>。</li></ul><p>迭代器和next()方法相关联，有next()方法的才能称之为迭代器</p><p>查看一个对象能够调用的所有方法：dir(a)</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象【是否是<strong>迭代器</strong>对象】：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print (isinstance([1,2,3],Iterator))</span><br><span class="line">print (isinstance([],Iterator))</span><br><span class="line">print (isinstance((x for x in range(10)),Iterator))</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">a = [1,2,3]</span><br><span class="line">b = iter(a)</span><br><span class="line">print (isinstance(b,Iterator))</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p><p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p><p>你可能会问，为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？</p><p>这是因为Python的<code>Iterator</code>对象表示的是一个数据流，Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p><code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><h1 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h1><p>python中有以下内置函数</p><table><thead><tr><th></th><th>Built-in Functions</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#abs" target="_blank" rel="noopener"><code>abs()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#delattr" target="_blank" rel="noopener"><code>delattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#hash" target="_blank" rel="noopener"><code>hash()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-memoryview" target="_blank" rel="noopener"><code>memoryview()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-set" target="_blank" rel="noopener"><code>set()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#all" target="_blank" rel="noopener"><code>all()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-dict" target="_blank" rel="noopener"><code>dict()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#help" target="_blank" rel="noopener"><code>help()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#min" target="_blank" rel="noopener"><code>min()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#setattr" target="_blank" rel="noopener"><code>setattr()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#any" target="_blank" rel="noopener"><code>any()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#dir" target="_blank" rel="noopener"><code>dir()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#hex" target="_blank" rel="noopener"><code>hex()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#next" target="_blank" rel="noopener"><code>next()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#slice" target="_blank" rel="noopener"><code>slice()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#ascii" target="_blank" rel="noopener"><code>ascii()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#divmod" target="_blank" rel="noopener"><code>divmod()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#id" target="_blank" rel="noopener"><code>id()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#object" target="_blank" rel="noopener"><code>object()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#sorted" target="_blank" rel="noopener"><code>sorted()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#bin" target="_blank" rel="noopener"><code>bin()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#input" target="_blank" rel="noopener"><code>input()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#oct" target="_blank" rel="noopener"><code>oct()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#staticmethod" target="_blank" rel="noopener"><code>staticmethod()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#bool" target="_blank" rel="noopener"><code>bool()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#eval" target="_blank" rel="noopener"><code>eval()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#int" target="_blank" rel="noopener"><code>int()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#open" target="_blank" rel="noopener"><code>open()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-str" target="_blank" rel="noopener"><code>str()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#breakpoint" target="_blank" rel="noopener"><code>breakpoint()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#exec" target="_blank" rel="noopener"><code>exec()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#ord" target="_blank" rel="noopener"><code>ord()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#sum" target="_blank" rel="noopener"><code>sum()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-bytearray" target="_blank" rel="noopener"><code>bytearray()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#filter" target="_blank" rel="noopener"><code>filter()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#issubclass" target="_blank" rel="noopener"><code>issubclass()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#pow" target="_blank" rel="noopener"><code>pow()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#super" target="_blank" rel="noopener"><code>super()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-bytes" target="_blank" rel="noopener"><code>bytes()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#float" target="_blank" rel="noopener"><code>float()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#iter" target="_blank" rel="noopener"><code>iter()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#print" target="_blank" rel="noopener"><code>print()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-tuple" target="_blank" rel="noopener"><code>tuple()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#callable" target="_blank" rel="noopener"><code>callable()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#format" target="_blank" rel="noopener"><code>format()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#len" target="_blank" rel="noopener"><code>len()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#property" target="_blank" rel="noopener"><code>property()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#type" target="_blank" rel="noopener"><code>type()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#chr" target="_blank" rel="noopener"><code>chr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-frozenset" target="_blank" rel="noopener"><code>frozenset()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-list" target="_blank" rel="noopener"><code>list()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-range" target="_blank" rel="noopener"><code>range()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#vars" target="_blank" rel="noopener"><code>vars()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#classmethod" target="_blank" rel="noopener"><code>classmethod()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#getattr" target="_blank" rel="noopener"><code>getattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#locals" target="_blank" rel="noopener"><code>locals()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#repr" target="_blank" rel="noopener"><code>repr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#zip" target="_blank" rel="noopener"><code>zip()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#compile" target="_blank" rel="noopener"><code>compile()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#globals" target="_blank" rel="noopener"><code>globals()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#map" target="_blank" rel="noopener"><code>map()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#reversed" target="_blank" rel="noopener"><code>reversed()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#__import__" target="_blank" rel="noopener"><code>__import__()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#complex" target="_blank" rel="noopener"><code>complex()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#hasattr" target="_blank" rel="noopener"><code>hasattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#max" target="_blank" rel="noopener"><code>max()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#round" target="_blank" rel="noopener"><code>round()</code></a></td></tr></tbody></table><ul><li><p>all()：判断输出的值是否都为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print (all([9,3]))</span><br><span class="line">print (all([0,9,3]))</span><br><span class="line"></span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p>any()：一个数据为真，就返回真，如果可迭代对象为空，返回也为False</p></li></ul><ul><li>eval()：将字符串变成字典</li></ul><h1 id="json序列化"><a href="#json序列化" class="headerlink" title="json序列化"></a>json序列化</h1><p>序列化：把内存中的数据对象变成字符串</p><p>反序列化： 把磁盘中的数据加载到内存当中</p><p>注意：json只能处理简单的数据类型，列表、字典、字符串等，因为json是所有语言都通用的，json主要的作用是用于不同语言之间进行数据交互，因为一些复杂的东西，例如python和java里面，类的定义和使用方式、一些特性等等，各语言之间很多东西都有很大的差异性，如果需要转换类、函数等对象就会变得相当复杂。所以，json默认只是支持这些比较简单的。</p><ul><li><p>xml知识补充：xml正在逐渐的被json所取代</p><blockquote><p>xml是一种标记语言，</p></blockquote></li></ul><h1 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h1><p>pickle的用法和json完全一样，但是它在序列化的时候，会把内存转换成为二进制的形式，所以在操作文件的时候，需要在序列化和反序列化的时候使用的方法为：wb和rb</p><p>pickle有自己的一套语法映射关系，将数据转换为二进制数据，因此系统的字符集识别之后将会显示为乱码</p><h1 id="dumps-和dump-以及loads-和load-区别"><a href="#dumps-和dump-以及loads-和load-区别" class="headerlink" title="dumps()和dump()以及loads()和load()区别"></a>dumps()和dump()以及loads()和load()区别</h1><p>注意，在序列化的时候，使用dumps和loads操作文件的时候，需要使用文件本身的f.write()或者f.read()方法；但是如果使用dump()和load()的时候，该方法中就可以嵌入了对文件的操作，也就是说不需要再额外的使用以上两个文件方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f.write(pickle.dumps(info))</span><br><span class="line">等价于</span><br><span class="line">pickle.dump(info,f)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">data = pickle.loads(f.read())</span><br><span class="line">等价于</span><br><span class="line">data = pickle.load(f)</span><br></pre></td></tr></table></figure><p>注意，我们可以dump很多次，但是dump很多次之后的这个文件，直接使用load是打不开的。</p><p>也就是说，在python3中，最多只能dump一次。</p><p><strong>在编写程序时的一个准则：</strong></p><ul><li>只dump一次，只load一次</li><li>如果还是想使用原来的文件，那么就把原来的内容覆盖掉 </li><li>例如虚拟机的快照，虚拟机的快照是每一个快照都会对应一个文件，而不是把所有的快照内容都存在一起</li><li>如果想保存好几个状态，那么就dump好几个文件。</li></ul><h1 id="软件目录结构规范"><a href="#软件目录结构规范" class="headerlink" title="软件目录结构规范"></a>软件目录结构规范</h1><h4 id="为什么要设计好目录结构"><a href="#为什么要设计好目录结构" class="headerlink" title="为什么要设计好目录结构?"></a>为什么要设计好目录结构?</h4><p>“设计项目目录结构”，就和”代码编码风格”一样，属于个人风格问题。对于这种风格上的规范，一直都存在两种态度:</p><ol><li>一类同学认为，这种个人风格问题”无关紧要”。理由是能让程序work就好，风格问题根本不是问题。</li><li>另一类同学认为，规范化能更好的控制程序结构，让程序具有更高的可读性。</li></ol><p>我是比较偏向于后者的，因为我是前一类同学思想行为下的直接受害者。我曾经维护过一个非常不好读的项目，其实现的逻辑并不复杂，但是却耗费了我非常长的时间去理解它想表达的意思。从此我个人对于提高项目可读性、可维护性的要求就很高了。”项目目录结构”其实也是属于”可读性和可维护性”的范畴，我们设计一个层次清晰的目录结构，就是为了达到以下两点:</p><ol><li>可读性高: 不熟悉这个项目的代码的人，一眼就能看懂目录结构，知道程序启动脚本是哪个，测试目录在哪儿，配置文件在哪儿等等。从而非常快速的了解这个项目。</li><li>可维护性高: 定义好组织规则后，维护者就能很明确地知道，新增的哪个文件和代码应该放在什么目录之下。这个好处是，随着时间的推移，代码/配置的规模增加，项目结构不会混乱，仍然能够组织良好。</li></ol><p>所以，我认为，保持一个层次清晰的目录结构是有必要的。更何况组织一个良好的工程目录，其实是一件很简单的事儿。</p><h4 id="目录组织方式"><a href="#目录组织方式" class="headerlink" title="目录组织方式"></a>目录组织方式</h4><p>关于如何组织一个较好的Python工程目录结构，已经有一些得到了共识的目录结构。在Stackoverflow的<a href="http://stackoverflow.com/questions/193161/what-is-the-best-project-structure-for-a-python-application" target="_blank" rel="noopener">这个问题</a>上，能看到大家对Python目录结构的讨论。</p><p>这里面说的已经很好了，我也不打算重新造轮子列举各种不同的方式，这里面我说一下我的理解和体会。</p><p>假设你的项目名为foo, 我比较建议的最方便快捷目录结构这样就足够了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Foo/</span><br><span class="line">|-- bin/</span><br><span class="line">|   |-- foo</span><br><span class="line">|</span><br><span class="line">|-- foo/</span><br><span class="line">|   |-- tests/</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- test_main.py</span><br><span class="line">|   |</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- main.py</span><br><span class="line">|</span><br><span class="line">|-- docs/</span><br><span class="line">|   |-- conf.py</span><br><span class="line">|   |-- abc.rst</span><br><span class="line">|</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- requirements.txt</span><br><span class="line">|-- README</span><br></pre></td></tr></table></figure><p>简要解释一下:</p><ol><li><code>bin/</code>: 存放项目的一些可执行文件，当然你可以起名<code>script/</code>之类的也行。</li><li><code>foo/</code>: 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录<code>tests/</code>存放单元测试代码； (3) 程序的入口最好命名为<code>main.py</code>。</li><li><code>docs/</code>: 存放一些文档。</li><li><code>setup.py</code>: 安装、部署、打包的脚本。</li><li><code>requirements.txt</code>: 存放软件依赖的外部Python包列表。</li><li><code>README</code>: 项目说明文件。</li></ol><p>除此之外，有一些方案给出了更加多的内容。比如<code>LICENSE.txt</code>,<code>ChangeLog.txt</code>文件等，我没有列在这里，因为这些东西主要是项目开源的时候需要用到。如果你想写一个开源软件，目录该如何组织，可以参考<a href="http://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/" target="_blank" rel="noopener">这篇文章</a>。</p><p>下面，再简单讲一下我对这些目录的理解和个人要求吧。</p><p><strong>注意：</strong>有<code>__init__.py</code>这个空文件的目录就叫做包，没有的就叫做目录</p><h4 id="关于README的内容"><a href="#关于README的内容" class="headerlink" title="关于README的内容"></a>关于README的内容</h4><p><strong>这个我觉得是每个项目都应该有的一个文件</strong>，目的是能简要描述该项目的信息，让读者快速了解这个项目。</p><p>它需要说明以下几个事项:</p><ol><li>软件定位，软件的基本功能。</li><li>运行代码的方法: 安装环境、启动命令等。</li><li>简要的使用说明。</li><li>代码目录结构说明，更详细点可以说明软件的基本原理。</li><li>常见问题说明。</li></ol><p>我觉得有以上几点是比较好的一个<code>README</code>。在软件开发初期，由于开发过程中以上内容可能不明确或者发生变化，并不是一定要在一开始就将所有信息都补全。但是在项目完结的时候，是需要撰写这样的一个文档的。</p><p>可以参考Redis源码中<a href="https://github.com/antirez/redis#what-is-redis" target="_blank" rel="noopener">Readme</a>的写法，这里面简洁但是清晰的描述了Redis功能和源码结构。</p><h4 id="关于requirements-txt和setup-py"><a href="#关于requirements-txt和setup-py" class="headerlink" title="关于requirements.txt和setup.py"></a>关于requirements.txt和setup.py</h4><h4 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a>setup.py</h4><p>一般来说，用<code>setup.py</code>来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具<a href="https://pythonhosted.org/setuptools/setuptools.html#developer-s-guide" target="_blank" rel="noopener">setuptools</a>来管理这些事情。这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，<strong>一个项目一定要有一个安装部署工具</strong>，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。</p><p>这个我是踩过坑的。</p><p>我刚开始接触Python写项目的时候，安装环境、部署代码、运行程序这个过程全是手动完成，遇到过以下问题:</p><ol><li>安装环境时经常忘了最近又添加了一个新的Python包，结果一到线上运行，程序就出错了。</li><li>Python包的版本依赖问题，有时候我们程序中使用的是一个版本的Python包，但是官方的已经是最新的包了，通过手动安装就可能装错了。</li><li>如果依赖的包很多的话，一个一个安装这些依赖是很费时的事情。</li><li>新同学开始写项目的时候，将程序跑起来非常麻烦，因为可能经常忘了要怎么安装各种依赖。</li></ol><p><code>setup.py</code>可以将这些事情自动化起来，提高效率、减少出错的概率。”复杂的东西自动化，能自动化的东西一定要自动化。”是一个非常好的习惯。</p><p>setuptools的<a href="https://pythonhosted.org/setuptools/setuptools.html#developer-s-guide" target="_blank" rel="noopener">文档</a>比较庞大，刚接触的话，可能不太好找到切入点。学习技术的方式就是看他人是怎么用的，可以参考一下Python的一个Web框架，flask是如何写的: <a href="https://github.com/mitsuhiko/flask/blob/master/setup.py" target="_blank" rel="noopener">setup.py</a></p><p>当然，简单点自己写个安装脚本（<code>deploy.sh</code>）替代<code>setup.py</code>也未尝不可。</p><h4 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a>requirements.txt</h4><p>这个文件存在的目的是:</p><ol><li>方便开发者维护软件的包依赖。将开发过程中新增的包添加进这个列表中，避免在<code>setup.py</code>安装依赖时漏掉软件包。</li><li>方便读者明确项目使用了哪些Python包。</li></ol><p>这个文件的格式是每一行包含一个包依赖的说明，通常是<code>flask&gt;=0.10</code>这种格式，要求是这个格式能被<code>pip</code>识别，这样就可以简单的通过 <code>pip install -r requirements.txt</code>来把所有Python包依赖都装好了。具体格式说明： <a href="https://pip.readthedocs.org/en/1.1/requirements.html" target="_blank" rel="noopener">点这里</a>。</p><h4 id="关于配置文件的使用方法"><a href="#关于配置文件的使用方法" class="headerlink" title="关于配置文件的使用方法"></a>关于配置文件的使用方法</h4><h4 id="注意，在上面的目录结构中，没有将conf-py放在源码目录下，而是放在docs-目录下。"><a href="#注意，在上面的目录结构中，没有将conf-py放在源码目录下，而是放在docs-目录下。" class="headerlink" title="注意，在上面的目录结构中，没有将conf.py放在源码目录下，而是放在docs/目录下。"></a>注意，在上面的目录结构中，没有将<code>conf.py</code>放在源码目录下，而是放在<code>docs/</code>目录下。</h4><p>很多项目对配置文件的使用做法是:</p><ol><li>配置文件写在一个或多个python文件中，比如此处的conf.py。</li><li>项目中哪个模块用到这个配置文件就直接通过<code>import conf</code>这种形式来在代码中使用配置。</li></ol><p>这种做法我不太赞同:</p><ol><li>这让单元测试变得困难（因为模块内部依赖了外部配置）</li><li>另一方面配置文件作为用户控制程序的接口，应当可以由用户自由指定该文件的路径。</li><li>程序组件可复用性太差，因为这种贯穿所有模块的代码硬编码方式，使得大部分模块都依赖<code>conf.py</code>这个文件。</li></ol><p>所以，我认为配置的使用，更好的方式是，</p><ol><li>模块的配置都是可以灵活配置的，不受外部配置文件的影响。</li><li>程序的配置也是可以灵活控制的。</li></ol><p>能够佐证这个思想的是，用过nginx和mysql的同学都知道，nginx、mysql这些程序都可以自由的指定用户配置。</p><p>所以，不应当在代码中直接<code>import conf</code>来使用配置文件。上面目录结构中的<code>conf.py</code>，是给出的一个配置样例，不是在写死在程序中直接引用的配置文件。可以通过给<code>main.py</code>启动参数指定配置路径的方式来让程序读取配置内容。当然，这里的<code>conf.py</code>你可以换个类似的名字，比如<code>settings.py</code>。或者你也可以使用其他格式的内容来编写配置文件，比如<code>settings.yaml</code>之类的。</p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p>作业需求：</p><p>模拟实现一个ATM + 购物商城程序</p><ol><li>额度 15000或自定义</li><li>实现购物商城，买东西加入 购物车，调用信用卡接口结账</li><li>可以提现，手续费5%</li><li>每月22号出账单，每月10号为还款日，过期未还，按欠款总额 万分之5 每日计息</li><li>支持多账户登录</li><li>支持账户间转账</li><li>记录每月日常消费流水</li><li>提供还款接口</li><li>ATM记录操作日志 </li><li>提供管理接口，包括添加账户、用户额度，冻结账户等。。。</li><li>用户认证用装饰器</li></ol><p><strong>相关代码及说明记录在pycharm当中</strong></p>]]></content>
    
    <summary type="html">
    
      day04-函数装饰器迭代器生成器
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>内核模块操作命令-lsmod+rmmod+modinfo+modprobe</title>
    <link href="http://yoursite.com/2018/07/13/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-lsmod+rmmod+modinfo+modprobe/"/>
    <id>http://yoursite.com/2018/07/13/IT科学技术知识体系结构-Linux运维方向/Linux基础知识/Linux常用命令/内核模块操作命令-lsmod+rmmod+modinfo+modprobe/</id>
    <published>2018-07-13T07:23:11.000Z</published>
    <updated>2018-07-13T07:23:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要讲解和Linux内核模块相关的操作命令</p><hr><h1 id="lsmod-查看内核模块信息"><a href="#lsmod-查看内核模块信息" class="headerlink" title="lsmod-查看内核模块信息"></a>lsmod-查看内核模块信息</h1><p><strong>lsmod命令</strong>用于显示已经加载到内核中的模块的状态信息。执行lsmod命令后会列出所有已载入系统的模块。</p><p>Linux操作系统的核心具有模块化的特性，应此在编译核心时，可以不用把全部的功能都放入核心，而是将这些功能编译成一个个单独的模块，待需要时再分别载入使用。 </p><p>命令的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# lsmod </span><br><span class="line">Module                  Size  Used by</span><br><span class="line">iptable_nat             5923  0 </span><br><span class="line">nf_nat                 22676  1 iptable_nat</span><br><span class="line">nf_conntrack_ipv4       9186  3 iptable_nat,nf_nat</span><br><span class="line">nf_conntrack           79537  3 iptable_nat,nf_nat,nf_conntrack_ipv4</span><br><span class="line">nf_defrag_ipv4          1483  1 nf_conntrack_ipv4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# lsmod | grep ip_vs</span><br><span class="line">ip_vs_rr                1420  0 </span><br><span class="line">ip_vs                 126705  2 ip_vs_rr</span><br><span class="line">libcrc32c               1246  1 ip_vs</span><br><span class="line">ipv6                  336368  913 ip_vs,ib_ipoib,ib_addr</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>第1列：表示模块的名称。</li><li>第2列：表示模块的大小。</li><li>第3列：表示该模块调用其他模块的个数</li><li>第4列：显示该模块被其他什么模块调用</li></ul><p>通常在使用lsmod命令时，都会采用类似<code>lsmod | grep -i ipvs</code>这样的命令来查询当前系统是否加载了某些模块。</p><h1 id="modinfo-查看内核模块信息"><a href="#modinfo-查看内核模块信息" class="headerlink" title="modinfo-查看内核模块信息"></a>modinfo-查看内核模块信息</h1><p>modinfo会显示kernel模块的对象文件，以显示该模块的相关信息。 </p><p>modinfo列出Linux内核中命令行指定的模块的信息。若模块名不是一个文件名，则会在/lib/modules/version 目录中搜索，就像modprobe一样。</p><p>modinfo默认情况下，为了便于阅读，以下面的格式列出模块的每个属性：fieldname : value。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">参　　数：</span><br><span class="line">  -a或--author 　显示模块开发人员。 </span><br><span class="line">  -d或--description 　显示模块的说明。 </span><br><span class="line">  -h或--help 　显示modinfo的参数使用方法。 </span><br><span class="line">  -p或--parameters 　显示模块所支持的参数。 </span><br><span class="line">  -V或--version 　显示版本信息。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# modinfo ip_vs</span><br><span class="line">filename:       /lib/modules/2.6.32-696.el6.x86_64/kernel/net/netfilter/ipvs/ip_vs.ko</span><br><span class="line">license:        GPL</span><br><span class="line">srcversion:     0FB85919D62C4255E412E5C</span><br><span class="line">depends:        ipv6,libcrc32c</span><br><span class="line">vermagic:       2.6.32-696.el6.x86_64 SMP mod_unload modversions </span><br><span class="line">parm:           conn_tab_bits:Set connections&apos; hash size (int)</span><br></pre></td></tr></table></figure><p>注意，使用lsmod不能看到内核的相关参数配置，而使用modinfo命令则可以显示</p><h1 id="rmmod-卸载内核模块"><a href="#rmmod-卸载内核模块" class="headerlink" title="rmmod-卸载内核模块"></a>rmmod-卸载内核模块</h1><p><strong>rmmod命令</strong> 用于从当前运行的内核中移除指定的内核模块。</p><p>执行rmmod指令，可删除不需要的模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选项信息：</span><br><span class="line">-v：显示指令执行的详细信息；</span><br><span class="line">-f：强制移除模块，使用此选项比较危险；</span><br><span class="line">-w：等待着，直到模块能够被除时在移除模块；</span><br><span class="line">-s：向系统日志（syslog）发送错误信息。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# rmmod ip_vs</span><br><span class="line">ERROR: Module ip_vs is in use by ip_vs_rr</span><br></pre></td></tr></table></figure><p>使用rmmod卸载模块的时候，提示信息会比使用modprobe -r 的输出更详细，此时会显示该模块的被调用情况</p><h1 id="insmod-载入内核模块"><a href="#insmod-载入内核模块" class="headerlink" title="insmod-载入内核模块"></a>insmod-载入内核模块</h1><p>insmod(install module)命令用于载入模块。</p><p>Linux有许多功能是通过模块的方式，在需要时才载入kernel。如此可使kernel较为精简，进而提高效率，以及保有较大的弹性。这类可载入的模块，通常是设备驱动程序。</p><p><strong>语法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod [-fkmpsvxX][-o &lt;模块名称&gt;][模块文件][符号名称 = 符号值]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">-f 　不检查目前kernel版本与模块编译时的kernel版本是否一致，强制将模块载入。</span><br><span class="line">-k 　将模块设置为自动卸除。</span><br><span class="line">-m 　输出模块的载入信息。</span><br><span class="line">-o&lt;模块名称&gt; 　指定模块的名称，可使用模块文件的文件名。</span><br><span class="line">-p 　测试模块是否能正确地载入kernel。</span><br><span class="line">-s 　将所有信息记录在系统记录文件中。</span><br><span class="line">-v 　执行时显示详细的信息。</span><br><span class="line">-x 　不要汇出模块的外部符号。</span><br><span class="line">-X 　汇出模块所有的外部符号，此为预设置。</span><br></pre></td></tr></table></figure><p>在Linux中，modprobe和insmod都可以用来加载module，不过现在一般都推荐使用modprobe而不是insmod了。<br><strong>modprobe和insmod的区别是什么呢？</strong></p><ul><li>modprobe可以解决load module时的依赖关系，比如load moudleA就必须先load mouduleB之类的，它是通过/lib/modules//modules.dep文件来查找依赖关系的。而insmod不能解决依赖问题。</li><li>modprobe默认会去/lib/modules/目录下面查找module，而insmod只在给它的参数中去找module（默认在当前目录找）。</li></ul><p>但是insmod也有它的有用之处，举个例子吧。</p><p>有/root/my-mod.ko这个module，cd /root/，然后用insmod my-mod.ko(insmod /root/my-mod.ko)就可以insert这个module了，</p><p>但是用modprobe my-mod.ko(modprobe /root/my-mod.ko)却提示”FATAL: Module my-mod.ko not found”，这就是因为modprobe是到/lib/modules/<code>uname -r</code>/下去找module的，如果没找到就是这样了。</p><h1 id="depmod-分析模块依赖性"><a href="#depmod-分析模块依赖性" class="headerlink" title="depmod-分析模块依赖性"></a>depmod-分析模块依赖性</h1><h1 id="modprobe-内核模块操作"><a href="#modprobe-内核模块操作" class="headerlink" title="modprobe-内核模块操作"></a>modprobe-内核模块操作</h1><p><strong>modprobe命令</strong>用于智能地向内核中加载模块或者从内核中移除模块。</p><p>modprobe可载入指定的个别模块，或是载入一组相依的模块。</p><p>modprobe会根据<a href="http://man.linuxde.net/depmod" target="_blank" rel="noopener">depmod</a>所产生的相依关系，决定要载入哪些模块。若在载入过程中发生错误，在modprobe会卸载整组的模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数选项</span><br><span class="line"></span><br><span class="line">-a或--all：载入全部的模块/指定模块；</span><br><span class="line">-c或--show-conf：显示所有模块的设置信息；</span><br><span class="line">-d或--debug：使用排错模式；</span><br><span class="line">-l或--list：显示可用的模块；</span><br><span class="line">-r或--remove：卸载模块；</span><br><span class="line">-t或--type：指定模块类型；</span><br><span class="line">-v或--verbose：执行时显示详细的信息；</span><br><span class="line">-V或--version：显示版本信息；</span><br><span class="line">-help：显示帮助。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">卸载：modprobe -r ip_vs </span><br><span class="line">载入：modprobe -a ip_vs</span><br></pre></td></tr></table></figure><h1 id="get-module"><a href="#get-module" class="headerlink" title="get_module"></a>get_module</h1><p>需要安装sysfsutils包之后才能产生该命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install sysfsutils</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# get_module ip_vs</span><br><span class="line">initstate            : live</span><br><span class="line">refcnt               : 2</span><br><span class="line">srcversion           : 0FB85919D62C4255E412E5C</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">conn_tab_bits        : 12</span><br><span class="line">Sections:</span><br><span class="line">.altinstr_replacement : 0xffffffffa039c2b8</span><br><span class="line">.altinstructions     : 0xffffffffa039ef98</span><br><span class="line">.bss                 : 0xffffffffa03a1c60</span><br><span class="line">.data                : 0xffffffffa039ff00</span><br><span class="line">.data.cacheline_aligned : 0xffffffffa03a1580</span><br><span class="line">.data.read_mostly    : 0xffffffffa03a1040</span><br><span class="line">.exit.text           : 0xffffffffa039c40e</span><br><span class="line">.gnu.linkonce.this_module : 0xffffffffa03a1a20</span><br><span class="line">.init.text           : 0xffffffffa03aa000</span><br><span class="line">.note.gnu.build-id   : 0xffffffffa039c454</span><br><span class="line">.rheldata            : 0xffffffffa039fee0</span><br><span class="line">.rodata              : 0xffffffffa039c480</span><br><span class="line">.rodata.str1.1       : 0xffffffffa039d6e8</span><br><span class="line">.rodata.str1.8       : 0xffffffffa039dc90</span><br><span class="line">.smp_locks           : 0xffffffffa039eb68</span><br><span class="line">.strtab              : 0xffffffffa03ae2f8</span><br><span class="line">.symtab              : 0xffffffffa03aa4d0</span><br><span class="line">.text                : 0xffffffffa038a000</span><br><span class="line">__kcrctab_gpl        : 0xffffffffa039f540</span><br><span class="line">__kcrctab            : 0xffffffffa039fe80</span><br><span class="line">__ksymtab_gpl        : 0xffffffffa039f4f0</span><br><span class="line">__ksymtab_strings    : 0xffffffffa039f590</span><br><span class="line">__ksymtab            : 0xffffffffa039fdc0</span><br><span class="line">__mcount_loc         : 0xffffffffa039f6e8</span><br><span class="line">__param              : 0xffffffffa039f568</span><br><span class="line">__verbose            : 0xffffffffa03a1980</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      内核模块操作-lsmod+rmmod+modinfo+modprobe
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="Linux基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Linux常用命令" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="lsmod" scheme="http://yoursite.com/tags/lsmod/"/>
    
  </entry>
  
  <entry>
    <title>python常见模块+方法+函数记录</title>
    <link href="http://yoursite.com/2018/07/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/python%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/07/11/编程语言/Python/基础知识/python模块/</id>
    <published>2018-07-11T09:43:49.000Z</published>
    <updated>2018-07-11T09:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p>在平常的代码中，我们常常需要与时间打交道。在Python中，与时间处理有关的模块包括：time，datetime以及calendar。</p><p>在开始之前，首先要说明这几点：</p><ol><li><p>在Python中，通常有这几种方式来表示时间：</p><p>1）时间戳 </p><p>2）格式化的时间字符串 </p><p>3）元组（struct_time）共九个元素。由于Python的time模块实现主要调用C库，所以各个平台可能有所不同。</p></li></ol><ol><li>UTC（Coordinated Universal Time，世界协调时）亦即格林威治天文时间，世界标准时间。在中国为UTC+8。DST（Daylight Saving Time）即夏令时。</li></ol><ol><li>时间戳（timestamp）的方式：通常来说，时间戳表示的是从<strong>1970年1月1日00:00:00</strong>开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。返回时间戳方式的函数主要有time()，clock()等。</li></ol><ol><li>元组（struct_time）方式：struct_time元组共有9个元素，返回struct_time的函数主要有gmtime()，localtime()，strptime()。下面列出这种方式元组中的几个元素：</li></ol><table><thead><tr><th>索引（Index）</th><th>属性（Attribute）</th><th>值（Values）</th></tr></thead><tbody><tr><td>0</td><td>tm_year（年）</td><td>比如2011</td></tr><tr><td>1</td><td>tm_mon（月）</td><td>1 - 12</td></tr><tr><td>2</td><td>tm_mday（日）</td><td>1 - 31</td></tr><tr><td>3</td><td>tm_hour（时）</td><td>0 - 23</td></tr><tr><td>4</td><td>tm_min（分）</td><td>0 - 59</td></tr><tr><td>5</td><td>tm_sec（秒）</td><td>0 - 61</td></tr><tr><td>6</td><td>tm_wday（weekday）</td><td>0 - 6（0表示周日）</td></tr><tr><td>7</td><td>tm_yday（一年中的第几天）</td><td>1 - 366</td></tr><tr><td>8</td><td>tm_isdst（是否是夏令时）</td><td>默认为-1</td></tr></tbody></table><h3 id="获取当前时间戳"><a href="#获取当前时间戳" class="headerlink" title="获取当前时间戳"></a>获取当前时间戳</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.time())</span><br><span class="line">输出如下：</span><br><span class="line">1531317129.0039742</span><br></pre></td></tr></table></figure><h3 id="时间元祖"><a href="#时间元祖" class="headerlink" title="时间元祖"></a>时间元祖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.localtime())</span><br><span class="line">输出如下：</span><br><span class="line">time.struct_time(tm_year=2018, tm_mon=7, tm_mday=11, tm_hour=22, tm_min=4, tm_sec=18, tm_wday=2, tm_yday=192, tm_isdst=0)</span><br></pre></td></tr></table></figure><h3 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h3><p>最简单的获取可读模式的方法是asctime()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.asctime())</span><br><span class="line">输出如下：</span><br><span class="line">Wed Jul 11 21:52:09 2018</span><br></pre></td></tr></table></figure><p><strong>使用指定的格式输出</strong>，在这里，使用strftime方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.localtime()))</span><br><span class="line">输入如下：</span><br><span class="line">2018-07-11 22:02:27</span><br></pre></td></tr></table></figure><p><strong>补充-python中时间日期格式化符号</strong></p><p>python中时间日期格式化符号：</p><ul><li>%y 两位数的年份表示（00-99）</li><li>%Y 四位数的年份表示（000-9999）</li><li>%m 月份（01-12）</li><li>%d 月内中的一天（0-31）</li><li>%H 24小时制小时数（0-23）</li><li>%I 12小时制小时数（01-12）</li><li>%M 分钟数（00=59）</li><li>%S 秒（00-59）</li><li>%a 本地简化星期名称</li><li>%A 本地完整星期名称</li><li>%b 本地简化的月份名称</li><li>%B 本地完整的月份名称</li><li>%c 本地相应的日期表示和时间表示</li><li>%j 年内的一天（001-366）</li><li>%p 本地A.M.或P.M.的等价符</li><li>%U 一年中的星期数（00-53）星期天为星期的开始</li><li>%w 星期（0-6），星期天为星期的开始</li><li>%W 一年中的星期数（00-53）星期一为星期的开始</li><li>%x 本地相应的日期表示</li><li>%X 本地相应的时间表示</li><li>%Z 当前时区的名称</li><li>%% %号本身</li></ul><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Python time sleep() 方法推迟调用线程的运行，可通过参数secs指秒数，表示进程挂起的时间。 </p><p>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.sleep(t)</span><br></pre></td></tr></table></figure><h2 id="commands模块-3-x已废弃"><a href="#commands模块-3-x已废弃" class="headerlink" title="commands模块-3.x已废弃"></a>commands模块-3.x已废弃</h2><p>用Python写运维脚本时，经常需要执行linux shell的命令，Python中的commands模块专门用于调用Linux shell命令，并返回状态和结果。</p><p>下面是commands模块的几个主要方法： </p><h3 id="commands-getoutput-‘shell-command’"><a href="#commands-getoutput-‘shell-command’" class="headerlink" title="commands.getoutput(‘shell command’)"></a>commands.getoutput(‘shell command’)</h3><p>执行shell命令，返回结果（string类型）</p><p>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输出指定进程的pid</span><br><span class="line"></span><br><span class="line">wxh@wxh-virtual-machine:~/python_files$ cat tt.py</span><br><span class="line">#!/usr/bin/env python2</span><br><span class="line">import sys,commands</span><br><span class="line">cmdline = sys.argv[1]</span><br><span class="line">cmdline1 = sys.argv[2]</span><br><span class="line"></span><br><span class="line">cmd = &quot;ps -ef|grep &quot; + cmdline + &quot;|grep &quot; + cmdline1 + &quot;|grep -v grep|grep -v python|awk &apos;&#123;print $2&#125;&apos;&quot;</span><br><span class="line"></span><br><span class="line">c1 = commands.getoutput(cmd)</span><br><span class="line">print (c1)</span><br><span class="line">print (type(c1))</span><br></pre></td></tr></table></figure><p>执行后输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-virtual-machine:~/python_files$ python2 ./tt.py unity-panel-service lockscreen-mode</span><br><span class="line"></span><br><span class="line">126263</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="commands-getstatusoutput-‘shell-command’"><a href="#commands-getstatusoutput-‘shell-command’" class="headerlink" title="commands.getstatusoutput(‘shell command’)"></a>commands.getstatusoutput(‘shell command’)</h3><p>执行shell命令, 返回两个元素的元组tuple(status, result)，status为int类型，result为string类型。</p><p>因为cmd的执行方式是{ cmd ; } 2&gt;&amp;1, 故返回结果包含标准输出和标准错误.</p><ul><li>第一个值为命令执行的返回状态码，执行成功则返回的是0，不成功则返回的是非0</li></ul><p>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-virtual-machine:~/python_files$ cat tt.py </span><br><span class="line">#!/usr/bin/env python2</span><br><span class="line">import sys,commands</span><br><span class="line">cmdline = sys.argv[1]</span><br><span class="line">cmdline1 = sys.argv[2]</span><br><span class="line"></span><br><span class="line">cmd = &quot;ps -ef|grep &quot; + cmdline + &quot;|grep &quot; + cmdline1 + &quot;|grep -v grep|grep -v python|awk &apos;&#123;print $2&#125;&apos;&quot;</span><br><span class="line">res = commands.getstatusoutput(cmd)</span><br><span class="line">print (res)</span><br></pre></td></tr></table></figure><p>执行后输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-virtual-machine:~/python_files$ python2 ./tt.py unity-panel-service lockscreen-mode</span><br><span class="line">(0, &apos;126263&apos;)</span><br></pre></td></tr></table></figure><h1 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h1><p>用于检测linux进程的状态</p><p>实例如下：</p><pre><code>def redis_status(new_port):    p = subprocess.Popen([&quot;netstat&quot;, &quot;-unptl&quot;], stdout=subprocess.PIPE)    out, err = p.communicate()    if (new_port in str(out) ):        print (&quot;redis {PORT} instance is running...&quot;.format(PORT=new_port))    else:        print (&quot;start redis {PORT} faild.please check again...&quot;.format(PORT=new_port))</code></pre><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="truncate-方法"><a href="#truncate-方法" class="headerlink" title="truncate() 方法"></a>truncate() 方法</h3><p><strong>truncate()</strong> 方法用于截断文件，如果指定了可选参数 size，则表示截断文件的 size 个字符。 </p><p>如果没有指定 size，则从当前位置起截断（截断余下的所有字符）；截断之后 size 后面的所有字符被删除。 </p><h3 id="seek-方法"><a href="#seek-方法" class="headerlink" title="seek()方法"></a>seek()方法</h3>]]></content>
    
    <summary type="html">
    
      python模块
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>网卡中断与CPU绑定</title>
    <link href="http://yoursite.com/2018/07/11/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E4%B8%8ECPU%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/07/11/IT科学技术知识体系结构-Linux运维方向/性能调优/网络调优/网卡中断与CPU绑定/</id>
    <published>2018-07-11T07:01:32.000Z</published>
    <updated>2018-07-11T07:01:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><p><a href="https://www.cnblogs.com/bamanzi/p/linux-irq-and-cpu-affinity.html" target="_blank" rel="noopener">Linux 性能调优] 网卡中断与CPU的绑定问题</a></p></li><li><p><a href="http://noican.blog.51cto.com/4081966/1355357" target="_blank" rel="noopener">简单介绍下linux下的中断（interrupt）- 一切皆有可能 - 51CTO技术博客</a></p></li><li><a href="https://segmentfault.com/a/1190000006178824" target="_blank" rel="noopener">把网卡中断绑定到CPU,最大化网卡的吞吐量 - SegmentFault</a></li><li><a href="http://www.vpsee.com/2010/07/load-balancing-with-irq-smp-affinity/" target="_blank" rel="noopener">Linux 多核下绑定硬件中断到不同 CPU（IRQ Affinity） | vpsee.com</a></li><li><p><a href="http://www.jianshu.com/p/6beacca6fdcd" target="_blank" rel="noopener">Linux系统CPU的性能监控及调优 - 简书</a></p></li><li><p><a href="https://www.chinanetcloud.com/en/info-center/blog/tech-items-linux-nic-interrupts-overloading-single-cpus/" target="_blank" rel="noopener">Tech Items - Linux NIC Interrupts Overloading Single CPUs - ChinaNetCloud</a> </p></li><li><p><a href="http://www.tuicool.com/articles/naUnia" target="_blank" rel="noopener">Linux网卡中断使单个CPU过载 - 推酷</a> </p></li><li><p><a href="http://wwdhks.blog.51cto.com/839773/1218785" target="_blank" rel="noopener">网卡软中断调优 - deven的博客 - 51CTO技术博客</a> </p></li></ul><p><strong>除了不让多个中断集中到单个CPU，还有更进一步的方法:</strong>  </p><p>调整网卡驱动参数使之采用多个队列，这样多个CPU可以各自处理一个队列。</p><p>当然，这依赖于网卡是否支持 </p><ul><li><a href="http://www.ywnds.com/?p=4380" target="_blank" rel="noopener">多队列网卡及网卡中断绑定阐述 – 运维那点事</a> (这篇文章讲得很全面，推荐阅读） </li><li><a href="http://blog.csdn.net/wyaibyn/article/details/14109325" target="_blank" rel="noopener">网卡多队列及中断绑定 - wyaibyn的专栏 - CSDN博客</a> </li><li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rss.html" target="_blank" rel="noopener">8.6. Receive-Side Scaling (RSS) - Performance Tuning Guide - Red Hat Enterprise Linux 6</a>  </li></ul><p>即使网卡只支持单个队列，我们可以在系统层面模拟层多个队列，这个涉及到被称为Receive Packet Steering (RFS)和Receive Flow Steering (RFS）的两个技术  </p><ul><li><p><a href="http://www.ywnds.com/?p=4380" target="_blank" rel="noopener">多队列网卡及网卡中断绑定阐述 – 运维那点事</a> </p></li><li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rps.html" target="_blank" rel="noopener">8.7. Receive Packet Steering (RPS) - Performance Tuning Guide - Red Hat Enterprise Linux 6</a></p></li><li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rfs.html" target="_blank" rel="noopener">8.8. Receive Flow Steering (RFS) - Performance Tuning Guide - Red Hat Enterprise Linux 6</a> </li></ul><hr><p>在Linux的网络调优方面，如果你发现网络流量上不去，那么有一个方面需要去查一下：网卡处理网络请求的中断是否被绑定到单个CPU（或者说跟处理其它中断的是同一个CPU）。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>网卡与操作系统的交互一般有两种方式：</p><ul><li>一种是中断（IRQ，网卡在收到了网络信号之后，主动发送中断到CPU，而CPU将会立即停下手边的活以便对这个中断信号进行分析），</li><li>另一种叫DMA（Direct Memory Access, 也就是允许硬件在无CPU干预的情况下将数据缓存在指定的内存空间内，在CPU合适的时候才处理）</li></ul><p>在网卡方面，大部分还是在用IRQ方式（据说DMA技术仅仅被应用在少数高端网卡上; 另一个说法是：DMA方式会使外部设备的控制器独占PCI总线，从而CPU无法与外部设备进行交互，这对通用型操作系统Linux来说，是很难接收的，所以DMA方式在Linux内核里使用得很少）。</p><p>但是（再来一个但是），在现在的对称多核处理器（SMP）上，一块网卡的IRQ还是只有一个CPU来响应，其它CPU无法参与，如果这个CPU还要忙其它的中断（其它网卡或者其它使用中断的外设（比如磁盘）），那么就会形成瓶颈。</p><h1 id="问题判定"><a href="#问题判定" class="headerlink" title="问题判定"></a>问题判定</h1><p>网上不少讲这个问题的文章都是直接让查询IRQ跟CPU的绑定情况，甚至直接修改。但我们应该先判断我们的系统是不是受这个问题影响，然后再来看怎么解决。</p><p>首先，让你的网络跑满（比如对于MySQL/MongoDB服务，可以通过客户端发起密集的读操作; 或者执行一个i大文件传送任务）</p><p>第一个要查明的是：<strong>是不是某个CPU在一直忙着处理IRQ？</strong></p><p>这个问题我们可以从 <code>mpstat -P ALL 1</code> 的输出中查明：里面的 <code>%irq</code>一列即说明了CPU忙于处理中断的时间占比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">18:20:33     CPU   %user   %nice    %sys %iowait    %irq   %soft  %steal   %idle    intr/s</span><br><span class="line">18:20:33     all    0,23    0,00    0,08    0,11    6,41    0,02    0,00   93,16   2149,29</span><br><span class="line">18:20:33       0    0,25    0,00    0,12    0,07    0,01    0,05    0,00   99,49    127,08</span><br><span class="line">18:20:33       1    0,14    0,00    0,03    0,04    0,00    0,00    0,00   99,78      0,00</span><br><span class="line">18:20:33       2    0,23    0,00    0,02    0,03    0,00    0,00    0,00   99,72      0,02</span><br><span class="line">18:20:33       3    0,28    0,00    0,15    0,28   25,63    0,03    0,00   73,64   2022,19</span><br></pre></td></tr></table></figure><p>上面的例子中，第四个CPU有25.63%时间在忙于处理中断（这个数值还不算高，如果高达80%（而同时其它CPU这个数值很低）以上就说明有问题了），后面那个 intr/s 也说明了CPU每秒处理的中断数（从上面的数据也可以看出，其它几个CPU都不怎么处理中断）。</p><p>然后我们就要接着查另外一个问题：<strong>这个忙于处理中断的CPU都在处理哪个（些）中断？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupts </span><br><span class="line">           CPU0       CPU1       CPU2       CPU3       </span><br><span class="line">  0:        245          0          0    7134094    IO-APIC-edge  timer</span><br><span class="line">  8:          0          0         49          0    IO-APIC-edge  rtc</span><br><span class="line">  9:          0          0          0          0   IO-APIC-level  acpi</span><br><span class="line"> 66:         67          0          0          0   IO-APIC-level  ehci_hcd:usb2</span><br><span class="line"> 74:     902214          0          0          0         PCI-MSI  eth0</span><br><span class="line">169:          0          0         79          0   IO-APIC-level  ehci_hcd:usb1</span><br><span class="line">177:          0          0          0    7170885   IO-APIC-level  ata_piix, b4xxp</span><br><span class="line">185:          0          0          0      59375   IO-APIC-level  ata_piix</span><br><span class="line">NMI:          0          0          0          0 </span><br><span class="line">LOC:    7104234    7104239    7104243    7104218 </span><br><span class="line">ERR:          0</span><br><span class="line">MIS:          0</span><br></pre></td></tr></table></figure><p>这里记录的是自启动以来，每个CPU处理各类中断的数量（第一列是中断号，最后一列是对应的设备名）[详细说明: <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/s2-proc-interrupts.html" target="_blank" rel="noopener">E.2.10 /proc/interrupts - Deployment Guide - RedHat Enterprise Linux 6</a> )，从上面可以看到： <code>eth0</code>所出发的中断全部都是 <code>CPU0</code>在处理，而CPU0所处理的中断请求中，主要是eth0和LOC中断。</p><p>（有时我们会看到几个CPU对同一个中断类型所处理的的请求数相差无几（比如上面的LOC一行），这并不一定是说多个CPU会轮流处理同一个中断，而是因为这里记录的是“自启动以来”的统计，中间可能因为irq balancer重新分配过处理中断的CPU——当然，也可能是谁手工调节过）。</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>首先说明几点：</p><ol><li>首先应该根据上面的诊断方法查明当前系统是不是受这个原因影响，如果不是，那么就没有必要往下看了;</li><li>现在的多数Linux系统中已经有了IRQ Balance这个服务（服务程序一般是 <code>/usr/sbin/irqbalance</code>），它可以自动调节分配各个中断与CPU的绑定关系，以避免所有中断的处理都集中在少数几个CPU上;</li><li>在某些情况下，这个IRQ Balance反而会导致问题，会出现 irqbalance 这个进程反而自身占用了较高的CPU（当然也就影响了业务系统的性能）</li></ol><p>下面来说手工将中断限定到少数几个CPU的方法。</p><p>首先当然要查明，该网卡的中断当前是否已经限定到某些CPU了？具体是哪些CPU？</p><p>根据上面 <code>/proc/interrupts</code> 的内容我们可以看到 eth0 的中断号是74，然后我们来看看该中断号的CPU绑定情况（或者说叫亲和性 affinity）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /proc/irq/74/smp_affinity</span><br><span class="line">ffffff</span><br></pre></td></tr></table></figure><p>这个输出是一个16进制的数值，<code>0xffffff = ‘0b111111111111111111111111’</code>，这就意味着这里有24个CPU，所有位都为1表示所有CPU都可以被该中断干扰。</p><p>另一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /proc/irq/67/smp_affinity</span><br><span class="line">00000001</span><br></pre></td></tr></table></figure><p>这个例子说明，只有CPU0处理编号为67的中断。</p><p><strong>修改配置的方法</strong>：</p><p>我们可以用 <code>echo 2 &gt; /proc/irq/74/smp_affinity</code> 的方法来修改这个设置（设置为2表示将该中断绑定到CPU1上，0x2 = 0b10，而第一个CPU为CPU0）</p>]]></content>
    
    <summary type="html">
    
      网卡中断与CPU绑定
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="性能调优" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="网络调优" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>LVS性能指标及监控</title>
    <link href="http://yoursite.com/2018/07/10/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/4%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-LVS/LVS%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%8F%8A%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2018/07/10/IT科学技术知识体系结构-Linux运维方向/高并发/负载均衡/4层负载均衡-LVS/LVS性能指标及监控/</id>
    <published>2018-07-10T08:08:26.000Z</published>
    <updated>2018-07-10T08:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考文献：</strong></p><ul><li><a href="http://kb.linuxvirtualserver.org/wiki/Performance_and_Tuning" target="_blank" rel="noopener">Performance and Tuning - LVSKB</a></li></ul><h1 id="性能参数"><a href="#性能参数" class="headerlink" title="性能参数"></a>性能参数</h1><p>LVS 的性能主要通过以下几个方面来提高</p><h2 id="ipvs-connection-table-size-最大连接数"><a href="#ipvs-connection-table-size-最大连接数" class="headerlink" title="ipvs connection table size-最大连接数"></a>ipvs connection table size-最大连接数</h2><p>官方的解释如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">The IPVS connection hash table uses the chaining scheme to handle</span><br><span class="line">hash collisions. Using a big IPVS connection hash table will greatly</span><br><span class="line">reduce conflicts when there are hundreds of thousands of connections</span><br><span class="line">in the hash table.</span><br><span class="line"></span><br><span class="line">Note the table size must be power of 2. The table size will be the</span><br><span class="line">value of 2 to the your input number power. The number to choose is</span><br><span class="line">from 8 to 20, the default number is 12, which means the table size</span><br><span class="line">is 4096. Don&apos;t input the number too small, otherwise you will lose</span><br><span class="line">performance on it. You can adapt the table size yourself, according</span><br><span class="line">to your virtual server application. It is good to set the table size</span><br><span class="line">not far less than the number of connections per second multiplying</span><br><span class="line">average lasting time of connection in the table.  For example, your</span><br><span class="line">virtual server gets 200 connections per second, the connection lasts</span><br><span class="line">for 200 seconds in average in the connection table, the table size</span><br><span class="line">should be not far less than 200x200, it is good to set the table</span><br><span class="line">size 32768 (2**15).</span><br><span class="line"></span><br><span class="line">Another note that each connection occupies 128 bytes effectively and</span><br><span class="line">each hash entry uses 8 bytes, so you can estimate how much memory is</span><br><span class="line">needed for your box.</span><br><span class="line"></span><br><span class="line">You can overwrite this number setting conn_tab_bits module parameter</span><br><span class="line">or by appending ip_vs.conn_tab_bits=? to the kernel command line</span><br><span class="line">if IP VS was compiled built-in.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><p>LVS的连接信息使用<code>IPVS connection hash table</code>这个哈希表去保存，它记录每个进来的连接及路由去向的信息 </p><blockquote><p>任何一个报文到达都需要查找连接Hash表。Hash表的查找复杂度为O(n/m)，其中n为Hash表中对象的个数，m为Hash表的桶个数。当对象在Hash表中均匀分布和Hash表的桶个数与对象个数一样多时，Hash表的查找复杂度可以接近O(1)。 </p></blockquote></li><li><p><code>table size</code>使用2的幂次方进行配置指定，范围为8-20，也就是说连接数的取值范围为：2^8-2^20</p></li><li><p>默认配置为2^12，也就是4096个连接数上限</p></li><li><p>在生产环境中，我们一般设置为最大值，也就是2^20（1048576）</p></li><li><p>注意，这些连接是需要占用内存的，因此要考虑到内存大小的因素</p><blockquote><p>每一个TCP连接需要占用约128字节，哈希表的每个条目需要占用8字节</p><p>以设置为最大值为例，那么，这些连接以及条目共占用内存如下：</p><p>2^20*(128byte+8byte) = 142606336byte = 136MB</p></blockquote></li></ul><p><strong>配置：</strong></p><p>在/etc/modprobe.d/目录下添加文件ip_vs.conf，内容为：</p><p>options ip_vs conn_tab_bits=22（文档中写的上限是20，但是实际配置的时候发现22也是可以的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;options ip_vs conn_tab_bits=22&apos; &gt; /etc/modprobe.d/ipvs.conf</span><br><span class="line">modprobe -r ip_vs &amp;&amp; modprobe -a ip_vs</span><br><span class="line">ipvsadm -Ln</span><br></pre></td></tr></table></figure><p>注意，在卸载内核模块的时候，可能会有依赖关系，这时候使用lsmod先查看依赖调用关系，将调用的模块卸载之后再进行操作，例如，这里的操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# modprobe -r ip_vs_rr</span><br><span class="line">[root@lvs001 modprobe.d]# modprobe -r ip_vs</span><br><span class="line">[root@lvs001 modprobe.d]# modprobe -a ip_vs</span><br><span class="line">[root@lvs001 modprobe.d]# modprobe -a ip_vs_rr</span><br></pre></td></tr></table></figure><h2 id="CPU-Soft-Interrupt-CPU软中断"><a href="#CPU-Soft-Interrupt-CPU软中断" class="headerlink" title="CPU Soft Interrupt -CPU软中断"></a>CPU Soft Interrupt -CPU软中断</h2><p>在Linux的网络调优方面，如果你发现网络流量上不去，那么有一个方面需要去查一下：<strong>网卡处理网络请求的中断是否被绑定/发送到单个CPU，导致只有一个CPU处理网络请求</strong></p><p>但是，在当前的对称多核处理器服务器上，一块网卡的IRQ还是只有一个CPU来响应，其它CPU无法参与，如果这个CPU还要忙其它的中断（其它网卡或者其它使用中断的外设（比如磁盘）），那么就会形成瓶颈。 </p><p><strong>动态查看CPU的irq情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令：mpstat -P ALL 1 </span><br><span class="line">%irq一列即说明了CPU忙于处理中断的时间占比</span><br></pre></td></tr></table></figure><p><strong>查看CPU处理中断的情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupts </span><br><span class="line">这里记录的是自启动以来，每个CPU处理各类中断的数量（第一列是中断号，最后一列是对应的设备名）</span><br></pre></td></tr></table></figure><p>我们进行过滤，获取网卡的中断号，然后再分析CPU的中断情况</p><p>获取对应的中断号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 ~]# cat /proc/interrupts  | egrep &apos;em1|em2|p1p1|p1p2&apos; | awk &apos;&#123;print $1&#125;&apos;</span><br><span class="line">157:</span><br><span class="line">158:</span><br><span class="line">159:</span><br><span class="line">160:</span><br><span class="line">161:</span><br><span class="line">162:</span><br><span class="line">163:</span><br><span class="line">164:</span><br><span class="line">165:</span><br><span class="line">166:</span><br><span class="line">167:</span><br><span class="line">168:</span><br><span class="line">169:</span><br><span class="line">170:</span><br><span class="line">171:</span><br><span class="line">172:</span><br><span class="line">173:</span><br><span class="line">174:</span><br><span class="line">175:</span><br><span class="line">176:</span><br></pre></td></tr></table></figure><p>获取CPU的处理信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 ~]# for i in &#123;157..176&#125;;do cat /proc/interrupts  | egrep -w $i ;done</span><br><span class="line"> 157:   13529132          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-tx-0</span><br><span class="line"> 158:   32642550          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-1</span><br><span class="line"> 159:   30481981          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-2</span><br><span class="line"> 160:   15555217          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-3</span><br><span class="line"> 161:   25509530          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-4</span><br><span class="line"> 162:   13538297          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-tx-0</span><br><span class="line"> 163:   25653580          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-1</span><br><span class="line"> 164:   25741710          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-2</span><br><span class="line"> 165:   35448970          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-3</span><br><span class="line"> 166:   25494937          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-4</span><br><span class="line"> 167:     256824          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-tx-0</span><br><span class="line"> 168:     281534          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-1</span><br><span class="line"> CAL:        133     863797        189        189        189        189        188        189        189        189        189        189        189        189        189        189        188        188        168        185        188        186        188        188        188        188        188        188        188        189        187        130   Function call interrupts</span><br><span class="line"> 169:      64639          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-2</span><br><span class="line"> 170:      65879          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-3</span><br><span class="line"> 171:     425700          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-4</span><br><span class="line"> 172:     256754          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-tx-0</span><br><span class="line"> 173:      43230          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-1</span><br><span class="line"> 174:          4          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-2</span><br><span class="line"> 175:          5          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-3</span><br><span class="line"> 176:          3          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-4</span><br><span class="line">[root@lvs001 ~]#</span><br></pre></td></tr></table></figure><p>这里显示不友好，建议复制到编辑器中查看</p><p>可以看到，这些网卡的中断都是由CPU0来处理的</p><p><strong>查看</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs002 ~]# for i in &#123;157..176&#125;;do cat /proc/irq/$i/smp_affinity;done</span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;157..176&#125;;do echo ffffffff &gt; /proc/irq/$i/smp_affinity;done</span><br></pre></td></tr></table></figure><h2 id="Netfilter-Connection-Track-连接跟踪"><a href="#Netfilter-Connection-Track-连接跟踪" class="headerlink" title="Netfilter Connection Track-连接跟踪"></a>Netfilter Connection Track-连接跟踪</h2><p><strong>原文：</strong></p><p><a href="http://kb.linuxvirtualserver.org/wiki/IPVS" target="_blank" rel="noopener">IPVS</a> uses its own simple and fast connection tracking for performance reasons, instead of using netfilter connection tracking. So, if you don’t use firewalling feature at <a href="http://kb.linuxvirtualserver.org/wiki/Load_balancer" target="_blank" rel="noopener">load balancer</a> and you need an extremely fast load balancer, do not load netfilter conntrack modules into you system, because there is no need to do double tracking. Note that <a href="http://kb.linuxvirtualserver.org/wiki/LVS/NAT" target="_blank" rel="noopener">LVS/NAT</a> should work too without the conntrack modules.</p><p>Julian compared the performance of IPVS with ip_conntrack and without ip_conntrack. See <a href="http://archive.linuxvirtualserver.org/html/lvs-users/2001-12/msg00141.html" target="_blank" rel="noopener">http://archive.linuxvirtualserver.org/html/lvs-users/2001-12/msg00141.html</a></p><p>默认情况下LVS自身会记录连接信息，但是 iptables 也会记录 connection 的状态，但是很多情况下，我们并不需要 iptables 来做这件事，</p><p>我们可以告诉它 NOTRACK，不要记录这些信息。</p><p><strong>配置：</strong></p><p>增加raw表，在其他表处理之前，-j NOTRACK跳过其它表处理 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -t raw -A PREROUTING -d 103.13.244.16/29 -p tcp --dport 80 -j NOTRACK </span><br><span class="line">iptables -t raw -A OUTPUT -d 103.13.244.16/29 -p tcp --dport 80 -j NOTRACK </span><br><span class="line">iptables -t raw -A PREROUTING -d 103.13.244.16/29 -p tcp --dport 443 -j NOTRACK </span><br><span class="line">iptables -t raw -A OUTPUT -d 103.13.244.16/29 -p tcp --dport 443 -j NOTRACK </span><br><span class="line"></span><br><span class="line">[root@lvs002 ~]# /etc/init.d/iptables  save</span><br></pre></td></tr></table></figure><p>与之同时，因为涉及到内网之间的通信，因此这里也将连接跟踪表进行调大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">net.netfilter.nf_conntrack_max = 3065536 </span><br><span class="line">net.nf_conntrack_max = 3065536 </span><br><span class="line"></span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure><h2 id="Real-Server-syn-cookie参数"><a href="#Real-Server-syn-cookie参数" class="headerlink" title="Real Server - syn cookie参数"></a>Real Server - syn cookie参数</h2><p>参考链接：</p><ul><li><a href="https://link.zhihu.com/?target=http%3A//archive.linuxvirtualserver.org/html/lvs-users/2013-05/msg00020.html" target="_blank" rel="noopener">lvs-users IPVS SYN-cookies</a>  </li></ul><p>SYN Cookie是对TCP服务器端的<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">三次握手协议</a>作一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP ACK包时，TCP服务器在根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。 </p><p>SYN Flood攻击利用的是IPv4中TCP协议的<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" target="_blank" rel="noopener">三次握手</a>（Three-Way Handshake）过程进行的攻击。TCP协议规定，一端向另一端发起TCP连接时，它需要首先发送SYN 包到对方，对方收到后发送一个SYN+ACK包回来，发起方再发送 ACK包回去，这样<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" target="_blank" rel="noopener">三次握手</a>就结束了。我们把TCP连接的发起方叫作”TCP客户机（TCP Client）”，TCP连接的接收方叫作”TCP服务器（TCP Server）”。值得注意的是在TCP服务器收到TCP SYN request包时，在发送TCP SYN+ACK包回TCP客户机前，TCP服务器要先分配好一个数据区专门服务于这个即将形成的TCP连接。一般把收到SYN包而还未收到ACK包时的连接状态称为半开连接（Half-open Connection）。</p><p>在最常见的SYN Flood攻击中，攻击者在短时间内发送大量的TCP SYN包给受害者，这时攻击者是TCP客户机，受害者是TCP服务器。根据上面的描述，受害者会为每个TCP SYN包分配一个特定的数据区，只要这些SYN包具有不同的源地址（这一点对于攻击者来说是很容易伪造的）。这将给TCP<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">服务器系统</a>造成很大的系统负担，最终导致系统不能正常工作。</p><p><a href="https://github.com/torvalds/linux/blob/6b15d6650c5301ce023d8df0cc3a60b1a76d377e/Documentation/networking/ip-sysctl.txt#L66" target="_blank" rel="noopener">内核文档说明</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">tcp_syncookies - BOOLEAN</span><br><span class="line">Only valid when the kernel was compiled with CONFIG_SYN_COOKIES</span><br><span class="line">Send out syncookies when the syn backlog queue of a socket</span><br><span class="line">overflows. This is to prevent against the common &apos;SYN flood attack&apos;</span><br><span class="line">Default: 1</span><br><span class="line"></span><br><span class="line">Note, that syncookies is fallback facility.</span><br><span class="line">It MUST NOT be used to help highly loaded servers to stand</span><br><span class="line">against legal connection rate. If you see SYN flood warnings</span><br><span class="line">in your logs, but investigationshows that they occur</span><br><span class="line">because of overload with legal connections, you should tune</span><br><span class="line">another parameters until this warning disappear.</span><br><span class="line">See: tcp_max_syn_backlog, tcp_synack_retries, tcp_abort_on_overflow.</span><br><span class="line"></span><br><span class="line">syncookies seriously violate TCP protocol, do not allow</span><br><span class="line">to use TCP extensions, can result in serious degradation</span><br><span class="line">of some services (f.e. SMTP relaying), visible not by you,</span><br><span class="line">but your clients and relays, contacting you. While you see</span><br><span class="line">SYN flood warnings in logs not being really flooded, your server</span><br><span class="line">is seriously misconfigured.</span><br><span class="line"></span><br><span class="line">If you want to test which effects syncookies have to your</span><br><span class="line">network connections you can set this knob to 2 to enable</span><br><span class="line">unconditionally generation of syncookies.</span><br></pre></td></tr></table></figure><p>注意，即使开启该机制并不意味着所有的连接都是用SYN cookies机制来完成连接的建立，只有在半连接队列已满的情况下才会触发SYN cookies机制。由于SYN cookies机制严重违背TCP协议，不允许使用TCP扩展，可能对某些服务造成严重的性能影响（如SMTP转发），对于防御SYN flood攻击的确有效。对于没有收到攻击的高负载服务器，不要开启此选项，可以通过修改tcp_max_syn_backlog、tcp_synack_retries和tcp_abort_on_overflow系统参数来调节。</p><p>tcp_max_syn_backlog变量告诉你在内存中可以缓存多少个SYN请求。该变量需要打开tcp_syncookies才有效。如果服务器负载很高，可以尝试提高该变量的值。</p><p>tcp_synack_retries变量用于TCP三次握手机制中第二次握手，当收到客户端发来的SYN连接请求后，服务端将回复SYN+ACK包，这时服务端处于SYN_RCVD状态，并等 待客户端发来的回复ACK包。如果服务端没有收到客户端的ACK包，会重新发送SYN+ACK包，直到收到客户端的ACK包。该变量设置发送 SYN+ACK包的次数，超过这个次数，服务端将放弃连接。默认值是5。</p><p>tcp_abort_on_overflow变量的值是个布尔值，默认值为0（FALSE关闭）。如果开启，当服务端接收新连接的速度变慢时，服务端会发送RST包（reset包）给客户端，令客户端 重新连接。这意味着如果突然发生溢出，将重获连接。仅当你真的确定不能通过调整监听进程使接收连接的速度变快，可以启用该选项。该选项会影响到客户的连接。</p><p><strong>配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sysctl.conf </span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 2048</span><br><span class="line">保存退出后，执行：</span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><p>net.ipv4.tcp_syncookies = 1<br>#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN<em>*</em>，默认为0，表示关闭；</p><p>net.ipv4.tcp_tw_reuse = 1<br>#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；为1，开启；</p><p>这个酌情开启，这里暂时不开启</p><p>net.ipv4.tcp_tw_recycle = 1<br>#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；为1，开启；</p><p>net.ipv4.tcp_fin_timeout</p><p>#修改系統默认的 TIMEOUT 时间，<strong>这里根据服务器的实际情况设置</strong>。默认为60秒</p><p>  另外细心的朋友可能发现了，报错信息： Possible SYN flooding on port 13370. Sending cookies.后面跟了句”Check SNMP counters”。这句我当时差点被误导，因为我的服务器上正好跑了一个snmp抓流量的服务，开始以为是它导致的，后来一想那是udp的协议，和tcp没关系呀。查了<a href="https://github.com/torvalds/linux/blob/797cee982eef9195736afc5e7f3b8f613c41d19a/net/ipv4/tcp_input.c" target="_blank" rel="noopener">kernel</a>的代码发现，原来那是print打印的固定info输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static bool tcp_syn_flood_action(const struct sock *sk,</span><br><span class="line">                const struct sk_buff *skb,</span><br><span class="line">                const char *proto)</span><br><span class="line">&#123;</span><br><span class="line">    struct request_sock_queue *queue = &amp;inet_csk(sk)-&gt;icsk_accept_queue;</span><br><span class="line">    const char *msg = &quot;Dropping request&quot;;</span><br><span class="line">    bool want_cookie = false;</span><br><span class="line">    struct net *net = sock_net(sk);</span><br><span class="line">#ifdef CONFIG_SYN_COOKIES</span><br><span class="line">    if (net-&gt;ipv4.sysctl_tcp_syncookies) &#123;</span><br><span class="line">        msg = &quot;Sending cookies&quot;;</span><br><span class="line">        want_cookie = true;</span><br><span class="line">        __NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPREQQFULLDOCOOKIES);</span><br><span class="line">    &#125; else</span><br><span class="line">#endif</span><br><span class="line">        __NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPREQQFULLDROP);</span><br><span class="line">    if (!queue-&gt;synflood_warned &amp;&amp;</span><br><span class="line">    net-&gt;ipv4.sysctl_tcp_syncookies != 2 &amp;&amp;</span><br><span class="line">    xchg(&amp;queue-&gt;synflood_warned, 1) == 0)</span><br><span class="line">        pr_info(&quot;%s: Possible SYN flooding on port %d. %s.  Check SNMP counters.\n&quot;,</span><br><span class="line">            proto, ntohs(tcp_hdr(skb)-&gt;dest), msg);</span><br><span class="line">    return want_cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭网卡LRO和GRO"><a href="#关闭网卡LRO和GRO" class="headerlink" title="关闭网卡LRO和GRO"></a>关闭网卡LRO和GRO</h2><p>现在大多数网卡都具有LRO/GRO功能，即 网卡收包时将同一流的小包合并成大包 （tcpdump抓包可以看到&gt;MTU 1500bytes的数据包）交给 内核协议栈；LVS内核模块在处理&gt;MTU的数据包时，会丢弃；</p><p>因此，如果我们用LVS来传输大文件，很容易出现丢包，传输速度慢；</p><p>解决方法，关闭LRO/GRO功能，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ethtool -k eth0 查看LRO/GRO当前是否打开</span><br><span class="line">ethtool -K eth0 lro off 关闭GRO</span><br><span class="line">ethtool -K eth0 gro off 关闭GRO</span><br><span class="line"></span><br><span class="line">查看：</span><br><span class="line">[root@lvs001 ~]# ethtool -k p1p1 | grep offload</span><br><span class="line">[root@lvs001 ~]# ethtool -k p1p2 | grep offload</span><br><span class="line"></span><br><span class="line">配置：</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p1 lro off</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p1 gro off</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p2 lro off</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p2 gro off</span><br></pre></td></tr></table></figure><p>offload特性，主要是指将原本在协议栈中进行的IP分片、TCP分段、重组、checksum校验等操作，转移到网卡硬件中进行，降低系统CPU的消耗，提高处理性能。 </p><p>包括 LSO/LRO、GSO/GRO、TSO/UFO 等。</p><p><strong>LSO/LRO</strong></p><p>分别对应到发送和接收两个方向，是 Large Segment Offload 和 Large Receive Offload。</p><p>首先来看 LSO。我们知道计算机网络上传输的数据基本单位是离散的网包，既然是网包，就有大小限制，这个限制就是 MTU（Maximum Transmission Unit）的大小，一般是1518字节。比如我们想发送很多数据出去，经过os协议栈的时候，会自动帮你拆分成几个不超过MTU的网包。然而，这个拆分是比较费计算资源的（比如很多时候还要计算分别的checksum），由 CPU 来做的话，往往会造成使用率过高。那可不可以把这些简单重复的操作 offload 到网卡上呢？</p><p>于是就有了 LSO，在发送数据超过 MTU 限制的时候（太容易发生了），OS 只需要提交一次传输请求给网卡，网卡会自动的把数据拿过来，然后进行切，并封包发出，发出的网包不超过 MTU 限制。</p><p>接下来看 LSO，当网卡收到很多碎片包的时候，LRO 可以辅助自动组合成一段较大的数据，一次性提交给 OS处理。</p><p>一般的，LSO 和 LRO 主要面向 TCP 报文。</p><p><strong>GSO/GRO</strong></p><p>Generic Segmentation Offload 和 Generic Receive Offload，分别比 LSO 和 LRO 更通用，自动检测网卡支持特性，支持分包则直接发给网卡，否则先分包后发给网卡。新的驱动一般用 GSO/GRO。 </p><p><strong>TSO/UFO</strong></p><p>TCP Segmentation Offload 和 UDP fragmentation offload，分别对应 TCP 报文和 UDP 报文。</p><p>很典型的，TCP 协议中就考虑了分片存在的情况，往往是切分 TCP 的数据包，叫做 TSO。而一般的情况，则称为 LSO 或者 GSO。</p><p>对于其他不支持切片的协议例如 UDP，则只能进行 IP 层上的切片。</p><p><strong>检查与开关</strong></p><p>可以通过 <code>ethtool -k eth0</code> 命令来查看各个选项的当前状态，注意输出中各种 off-load 选项的状态。 </p><p><strong>总结</strong></p><p>也就是说，在将数据包转发出去的时候，包的大小必须小于1500字节，但是在处理收到的数据包的时候，包的大小没有1500字节的限制</p><ul><li>发送模式：<ul><li>TSO</li><li>GSO</li><li>UFO</li></ul></li><li>接收模式：<ul><li>LRO</li><li>GRO</li><li>RSS</li></ul></li></ul><p><strong>注意</strong></p><p>目前常用的抓包工具大部分都是从协议栈中（如数据链路层）捕获数据包，而网卡的offload特性会将数据包的分片、重组等工作转移到协议栈以下的硬件层面进行，因此在开启TSO、GRO等机制的情况下，我们使用tcpdump、wireshark等工具抓取到的数据包往往不能真实反应链路上实际的数据帧，给网络流量特征的分析造成不利影响。</p><p>在某些情况下，例如分片攻击等攻击方式，甚至可能会因为网卡设备的offload机制处理，而规避防火墙、IDS以及人工的检查。针对这些情况，可以选择关闭网卡offload的相关选项，或者在链路的其他节点进行抓包。</p><h2 id="proc下的IP-VS参数设置"><a href="#proc下的IP-VS参数设置" class="headerlink" title="/proc下的IP_VS参数设置"></a>/proc下的IP_VS参数设置</h2><p>根据前文的介绍，可以通过ipvsadm命令和LVS内核打交道；</p><p>除此之外，我们还可以通过proc参数，来 配置全局参数 和 获取统计信息；</p><ul><li>配置全局参数，位于目录/proc/sys/net/ipv4/vs/下；</li><li>获取统计信息，位于目录/proc/net/下；</li></ul><p>参考资料：<a href="https://github.com/torvalds/linux/blob/master/Documentation/networking/ipvs-sysctl.txt#L41" target="_blank" rel="noopener">官方内核文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 ~]# ll /proc/sys/net/ipv4/vs | awk &apos;&#123;print $9&#125;&apos;</span><br><span class="line">am_droprate</span><br><span class="line">amemthresh</span><br><span class="line">cache_bypass</span><br><span class="line">conn_reuse_mode</span><br><span class="line">drop_entry</span><br><span class="line">drop_packet</span><br><span class="line">expire_nodest_conn</span><br><span class="line">expire_quiescent_template</span><br><span class="line">nat_icmp_send</span><br><span class="line">secure_tcp</span><br><span class="line">sync_qlen_max</span><br><span class="line">sync_refresh_period</span><br><span class="line">sync_retries</span><br><span class="line">sync_sock_size</span><br><span class="line">sync_threshold</span><br><span class="line">sync_version</span><br></pre></td></tr></table></figure><p>有一些几个参数需要进行调整</p><ul><li><p>cache_bypass </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cache_bypass - BOOLEAN</span><br><span class="line">        0 - disabled (default)</span><br><span class="line">        not 0 - enabled</span><br><span class="line"></span><br><span class="line">        If it is enabled, forward packets to the original destination</span><br><span class="line">        directly when no cache server is available and destination</span><br><span class="line">        address is not local (iph-&gt;daddr is RTN_UNICAST). It is mostly</span><br><span class="line">        used in transparent web cache cluster.</span><br></pre></td></tr></table></figure><p>主要用于缓存体系，enable之后，当后端配置的是缓存系统的时候，当没有可用的sever时，直接将数据包转发给后端的数据产生节点</p></li></ul><ul><li><p>conn_reuse_mode </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">conn_reuse_mode - INTEGER</span><br><span class="line">1 - default</span><br><span class="line"></span><br><span class="line">Controls how ipvs will deal with connections that are detected</span><br><span class="line">port reuse. It is a bitmap, with the values being:</span><br><span class="line"></span><br><span class="line">0: disable any special handling on port reuse. The new</span><br><span class="line">connection will be delivered to the same real server that was</span><br><span class="line">servicing the previous connection. This will effectively</span><br><span class="line">disable expire_nodest_conn.</span><br><span class="line"></span><br><span class="line">bit 1: enable rescheduling of new connections when it is safe.</span><br><span class="line">That is, whenever expire_nodest_conn and for TCP sockets, when</span><br><span class="line">the connection is in TIME_WAIT state (which is only possible if</span><br><span class="line">you use NAT mode).</span><br><span class="line"></span><br><span class="line">bit 2: it is bit 1 plus, for TCP connections, when connections</span><br><span class="line">are in FIN_WAIT state, as this is the last state seen by load</span><br><span class="line">balancer in Direct Routing mode. This bit helps on adding new</span><br><span class="line">real servers to a very busy cluster.</span><br></pre></td></tr></table></figure><p>用户后端server开启端口reuse（端口复用，服务器上启动多个进程监听同一个端口，在tenginx中使用时能够极大的提高性能）的情况。</p><p>当设置enable的时候，接受到新连接之后，将进行重新调度，将连接请求分发到启动该端口的其他进程上</p></li><li><p>expire_nodest_conn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">expire_nodest_conn - BOOLEAN</span><br><span class="line">        0 - disabled (default)</span><br><span class="line">        not 0 - enabled</span><br><span class="line"></span><br><span class="line">        The default value is 0, the load balancer will silently drop</span><br><span class="line">        packets when its destination server is not available. It may</span><br><span class="line">        be useful, when user-space monitoring program deletes the</span><br><span class="line">        destination server (because of server overload or wrong</span><br><span class="line">        detection) and add back the server later, and the connections</span><br><span class="line">        to the server can continue.</span><br><span class="line"></span><br><span class="line">        If this feature is enabled, the load balancer will expire the</span><br><span class="line">        connection immediately when a packet arrives and its</span><br><span class="line">        destination server is not available, then the client program</span><br><span class="line">        will be notified that the connection is closed. This is</span><br><span class="line">        equivalent to the feature some people requires to flush</span><br><span class="line">        connections when its destination is not available.</span><br></pre></td></tr></table></figure><p>设置为0时，当后端的server被检测为不可用时，不会立即将连接断开，而是会保持一段时间，让其自然过期失效，如果在这个过程当中，server又恢复正常，那么将继续使用这个连接</p><p>当设置为为enable（非0）时，当检测到后端的server不可用时，将会立即将这个连接关闭。</p></li><li><p>expire_quiescent_template </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">expire_quiescent_template - BOOLEAN</span><br><span class="line">0 - disabled (default)</span><br><span class="line">not 0 - enabled</span><br><span class="line"></span><br><span class="line">When set to a non-zero value, the load balancer will expire</span><br><span class="line">persistent templates when the destination server is quiescent.</span><br><span class="line">This may be useful, when a user makes a destination server</span><br><span class="line">quiescent by setting its weight to 0 and it is desired that</span><br><span class="line">subsequent otherwise persistent connections are sent to a</span><br><span class="line">different destination server.  By default new persistent</span><br><span class="line">connections are allowed to quiescent destination servers.</span><br><span class="line"></span><br><span class="line">If this feature is enabled, the load balancer will expire the</span><br><span class="line">persistence template if it is to be used to schedule a new</span><br><span class="line">connection and the destination server is quiescent.</span><br></pre></td></tr></table></figure><p>默认值为0，当RS的weight为0时（例如健康监测失败时，LB会将RS的权重重置为0），会话保持的新建连接还会继续调度到该RS上</p><p>如果设置为非0，那么当weight为0时，LB会将话保持的连接模板置为无效，重新调度新的RS； </p></li><li><p>sync_threshold</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sync_threshold - vector of 2 INTEGERs: sync_threshold, sync_period</span><br><span class="line">default 3 50</span><br><span class="line"></span><br><span class="line">It sets synchronization threshold, which is the minimum number</span><br><span class="line">of incoming packets that a connection needs to receive before</span><br><span class="line">the connection will be synchronized. A connection will be</span><br><span class="line">synchronized, every time the number of its incoming packets</span><br><span class="line">modulus sync_period equals the threshold. The range of the</span><br><span class="line">threshold is from 0 to sync_period.</span><br><span class="line"></span><br><span class="line">When sync_period and sync_refresh_period are 0, send sync only</span><br><span class="line">for state changes or only once when pkts matches sync_threshold</span><br></pre></td></tr></table></figure><p> 同步阈值设置，该文件中的值为两个整数，默认为3 50 </p><p>数值表示含义如下（以3 50为例）：接受到3个数据包及以上，该连接就可以被同步</p></li></ul><h2 id="Linux系统调优-网络内核参数"><a href="#Linux系统调优-网络内核参数" class="headerlink" title="Linux系统调优-网络内核参数"></a>Linux系统调优-网络内核参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_recyle=1</span><br><span class="line">net.ipv4.tcp_tw_reuse=1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=8192</span><br><span class="line">net.ipv4.tcp_keepalive_time=1800</span><br><span class="line">net.ipv4.tcp_fin_timeout=30</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.ipv4.tcp_rmem=4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem=4096 65536 16777216</span><br><span class="line">net.core.netdev_max_backlog=3000</span><br></pre></td></tr></table></figure><h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><p><strong>SH调度算法</strong>-<strong>尽量不要采用</strong>  </p><p>一些业务为了支持会话保持，选择SH调度算法，以实现 同一源ip的请求调度到同一台RS上；但 SH算法本省没有实现一致性hash，一旦一台RS down，当前所有连接都会断掉；如果配置了inhibit_on_failure，那就更悲剧了，调度到该RS上的流量会一直损失；     实际线上使用时，如需<strong>会话保持</strong>，建议配置<strong>persistence_timeout参数，</strong>保证一段时间同一源ip的请求到同一RS上； </p><p><strong>WLC调度算法-注意RS donw-&gt;up的影响</strong>    </p><p>WLC算法下，RS一旦出现down后up的情况，瞬间所有的新建连接都会调度到该RS上，可能会超过该RS处理请求的上限；  </p><h2 id="快速配置"><a href="#快速配置" class="headerlink" title="快速配置"></a>快速配置</h2><p>[root@lvs002 ~]# vim /etc/sysctl.conf </p><p>[root@lvs002 ~]# sysctl  -p</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">kernel.sysrq = 0</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line">net.core.netdev_max_backlog = 2048</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 462144</span><br><span class="line">vm.swappiness = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 65535</span><br><span class="line">net.core.somaxconn = 32768</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.netfilter.nf_conntrack_max = 3065536</span><br><span class="line">net.nf_conntrack_max = 3065536</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1800</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 16777216</span><br><span class="line">net.core.netdev_max_backlog = 3000</span><br></pre></td></tr></table></figure><h1 id="LVS监控"><a href="#LVS监控" class="headerlink" title="LVS监控"></a>LVS监控</h1><p>一般情况下，我们可以通过watch ipvsadm -ln来监视lvs的当前状态，但如果我们想分析一段时间（一周，一月或者更长）的连接数情况，ipvsadm就无能为力了。我们可以借助一个叫lvs-rrd的小工具来达到这个目的。</p><p>lvs-rrd官网链接：<a href="http://tepedino.org/lvs-rrd/" target="_blank" rel="noopener">http://tepedino.org/lvs-rrd/</a></p><p>但是在这里，由于这个工具只能收集连接数的数据，因此我们还是采用zabbix进行集中监控</p><h2 id="使用lvs-rrd监控lvs状态"><a href="#使用lvs-rrd监控lvs状态" class="headerlink" title="使用lvs-rrd监控lvs状态"></a>使用lvs-rrd监控lvs状态</h2><p><a href="http://www.tepedino.org/lvs-rrd/" target="_blank" rel="noopener">lvs_rrd</a>工具实现了网页的形式来查看lvs状态功能。</p><p>其主要有两个脚本组成：信息收集脚本和图像绘制脚本。</p><p>信息收集脚本是将lvs的信息生成rrd格式的数据文件，然后利用图像绘制脚本生成图像，并生成一个php页面，这个页面中引用其所生成的图像，这样我们可以通过web页面的形式查看生成的php页面，就可以时时的查看lvs的状态信息。</p><p>lvs_rrd需要部署在LVS-Master和LVS-Backup上，更准确的说lvs_rrd中的信息收集脚本一定要在LVS director 上运行（不能安装在其他服务器上）。</p><p>但是通过配置图像生成脚本和图像的生成目录，我们也可以将源数据时时的复制到其他的服务器中，再在其他服务器上生成图像展示</p><p>下面简单的介绍部署的步骤</p><p><strong>下载安装rrdtool（画图）工具</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://oss.oetiker.ch/rrdtool/pub/rrdtool-1.4.7.tar.gz</span><br><span class="line"></span><br><span class="line">yum -y install cairo-devel libxml2-devel pango-devel pango libpng-devel freetype freetype-devel libart_lgpl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker dejavu-lgc-sans-fonts</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/rrdtool</span><br><span class="line">make &amp;&amp;  make install </span><br><span class="line"></span><br><span class="line">echo &quot;/usr/local/rrdtool/lib&quot; &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><p><strong>安装nginx</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre pcre-devel php php-fpm</span><br><span class="line"></span><br><span class="line">useradd -s /sbin/nologin nginx</span><br><span class="line"></span><br><span class="line">wget https://nginx.org/download/nginx-1.14.0.tar.gz</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module --with-pcre</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>注意修改nginx的监听端口为非80</p><p><strong>nginx+php配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/php-fpm start</span><br><span class="line">chkconfig php-fpm on</span><br></pre></td></tr></table></figure><p>在nginx配置文件中添加以下内容</p><pre><code>location ~ \.php$ {    root           html;    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;    include        fastcgi_params;}</code></pre><p><strong>下载安装lvs-rrd工具</strong></p><p>这里使用最新的0.7版本，该版本要求rrdtool版本最低为： 1.2.x </p><p>将lvs-rrd-v0.7.tar.gz解压后将文件夹复制到/data/www/目录下并更名为lvs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://tepedino.org/lvs-rrd/lvs-rrd-v0.7.tar.gz</span><br><span class="line">tar -zxvf lvs-rrd-v0.7.tar.gz</span><br><span class="line"></span><br><span class="line">mv lvs-rrd-v0.7 /usr/local/nginx/html/lvs-rrd</span><br></pre></td></tr></table></figure><p>修改相应的脚本文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim lvs.rrd.update 修改以下内容</span><br><span class="line"></span><br><span class="line">RRDTOOL=&quot;/usr/local/rrdtool/bin/rrdtool&quot;#rrdtool可执行程序路径</span><br><span class="line">IPVSADM=&quot;/sbin/ipvsadm&quot;   #ipvsadm命令路径</span><br><span class="line">WORKDIR=&quot;/data1/lvs-rrd&quot;   #rrdtool收集的数据的存放路径</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim graph-lvs.sh 修改以下内容</span><br><span class="line"></span><br><span class="line"># WORKDIR must match the directory used in the update script.</span><br><span class="line">WORKDIR=&quot;/data1/lvs-rrd&quot;#rrdtool收集的数据的存放路径,同上面一致</span><br><span class="line">RRDTOOL=&quot;/usr/local/rrdtool/bin/rrdtool&quot;  #rrdtool可执行程序路径</span><br><span class="line"># Where to put the graphs. </span><br><span class="line">GRAPHS=&quot;/data1/lvs-rrd/graphs&quot;#生成的图片保存路径</span><br><span class="line">WEBPATH=&quot;/lvs-rrd/graphs&quot;#web访问的路径</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim lvs-rrd.php</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">header(&quot;Cache-Control: max-age=300, must-revalidate&quot;);</span><br><span class="line">system(&quot;/usr/local/nginx/html/lvs-rrd/graph-lvs.sh -H&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注意：WEBPATH的配置是浏览器实际访问时图片的访问路径，也就是<a href="http://ip:port/webpath/xxx.gif" target="_blank" rel="noopener">http://ip:port/webpath/xxx.gif</a></p><p>在日志中的输出显示为：</p><p>/usr/local/nginx/html/lvs-rrd/graphs/lvs.All.All.All.All.All-year.gif</p><p>因此需要手动在站点目录下创建该目录并创建软链接，将<code>生成的图片保存路径</code>链接到该目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/nginx/html/lvs-rrd/graphs</span><br><span class="line">ln -s /data1/lvs-rrd/graphs /usr/local/nginx/html/lvs-rrd/graphs</span><br></pre></td></tr></table></figure><p><strong>配置nginx认证</strong></p><p>在nginx配置文件的server中配置如下两行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth_basic              &quot;dwd&quot;;</span><br><span class="line">auth_basic_user_file    htpasswd;</span><br></pre></td></tr></table></figure><p>然后执行以下命令创建加密文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -bc htpasswd  ops-lvs Dwd_Ops_123</span><br></pre></td></tr></table></figure><p><strong>配置计划任务</strong></p><p>这里，将更新数据的间隔时间设置为30s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /usr/local/nginx/html/lvs-rrd/lvs.rrd.update &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * /usr/local/nginx/html/lvs-rrd/graph-lvs.sh -H &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * sleep 30 ; /usr/local/nginx/html/lvs-rrd/lvs.rrd.update &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * sleep 30 ; /usr/local/nginx/html/lvs-rrd/graph-lvs.sh -H &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="Zabbix监控LVS"><a href="#Zabbix监控LVS" class="headerlink" title="Zabbix监控LVS"></a>Zabbix监控LVS</h2><p><strong>监控指标：</strong></p><p>动态的数据：</p><ul><li>cps(connect per second) ，每秒的连接数情况</li><li>InPPS(input packge per second)，每秒的入向数据包数量情况</li><li>OutPPS(output packge per second)，每秒的出向数据包数量情况</li><li>InBPS（input byte per second）,每秒的流入字节数情况</li><li>OutBPS(output byte per second)，每秒的流出字节数情况</li><li>ActiveConn，处于ESAT的连接（使用系统的netstat无法看到）</li><li>InActConn，处于非ESAT的连接（使用系统的netstat无法看到）</li></ul><p>静态统计数据：</p><ul><li>Conns，自启动之后的总连接数</li><li>InPkts，自启动之后的总入向数据包数量统计</li><li>OutPkts，自启动之后的总出向数据包数量统计</li><li>InBytes，自启动之后的总入向字节数统计</li><li>OutBytes，自启动之后的总出向字节数统计</li></ul><p><strong>监控逻辑：</strong></p><p>使用ipvsadm命令从服务器中采集数据</p><p>所使用的命令分别为：</p><ul><li>ipvsadm -Ln –rate</li><li>ipvsadm -Ln –stats</li></ul><p><strong>注意：</strong>zabbix配置文件中需要打开sudo的权限，拥有root的权限之后才能执行ipvsadm命令去获取数据</p>]]></content>
    
    <summary type="html">
    
      LVS性能指标及监控
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="高并发" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="4层负载均衡-LVS" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/4%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-LVS/"/>
    
    
      <category term="LVS" scheme="http://yoursite.com/tags/LVS/"/>
    
  </entry>
  
</feed>
