<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watchmen1992&#39;s Blog</title>
  
  <subtitle>锦瑟年华当与书香为度，是为不负天地人生。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-12T13:10:34.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>XiaoHua WANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>换行符报警问题</title>
    <link href="http://yoursite.com/2018/08/12/%E6%8D%A2%E8%A1%8C%E7%AC%A6%E6%8A%A5%E8%AD%A6%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/12/换行符报警问题/</id>
    <published>2018-08-12T13:10:34.000Z</published>
    <updated>2018-08-12T13:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    <summary type="html">
    
      详见下文
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/git/"/>
    
      <category term="git基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/git/git%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>MAC操作技巧</title>
    <link href="http://yoursite.com/2018/08/11/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/MAC%E4%BD%BF%E7%94%A8/MAC%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2018/08/11/常用软件工具/MAC使用/MAC操作技巧/</id>
    <published>2018-08-11T10:21:58.000Z</published>
    <updated>2018-08-11T10:21:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美式键盘对应关系"><a href="#美式键盘对应关系" class="headerlink" title="美式键盘对应关系"></a>美式键盘对应关系</h1><p>参考链接：<a href="https://support.apple.com/zh-cn/HT202676" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT202676</a></p><p>在Mac的快捷键中经常会有一些符号，比如⌘、⌥、⇧、⌃等，而Mac下只有command键上有一个⌘的符号，而其他按键均没有符号，很多人可能不知道这是什么意思，之所以只有command键上有一个符号，而其他按键上没有，是因为：</p><ul><li>只有command健才是Mac下唯一独有的一个特殊按键，而shift、alt（option）、control、caps lock、tab等在其他系统下都有，所以Mac在command键上做一个符号，用于表示这一按键的特殊性；</li></ul><p>我们在生活中能接触到的外接键盘基本上都是美式键盘，下面是两种键盘的布局对应关系，在使用外接键盘的时候，需要有充分的了解。</p><p><strong>文字描述：</strong></p><p>⌘ —— Command (Windows键)</p><p>⌃ —— Control(Ctrl键)</p><p>⌥ —— Option (Alt)</p><p>⇧ —— Shift</p><p>⇪ —— Caps Lock</p><p>FN —— FN(Insert)</p><p>括号里面是Windows对应的按键。以前Ctrl+C,Ctrl+V 现在要用Win+C,Win+V。</p><p><strong>图形展示：</strong></p><p><strong>Windows 标志：</strong>按下 Command (⌘) 键<br><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-windows-logo.png" alt=" "></p><p><strong>退格或删除：</strong>按下 Delete 键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-backspace-delete.png" alt=" "></p><p><strong>回车或 ⏎：</strong>按下 Return 键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-enter.png" alt=" "></p><p><strong>Alt（左）：</strong>按下 Option 键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-alt-left.png" alt=" "></p><p><strong>Alt GR（右）：</strong>按下 Option + Control 组合键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-alt-right.png" alt=" "></p><p><strong>应用程序：</strong>Apple 键盘上没有这个按键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-applications.png" alt=" "></p><h1 id="MAC常用快捷键"><a href="#MAC常用快捷键" class="headerlink" title="MAC常用快捷键"></a>MAC常用快捷键</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>先来一张图</p><p><img src="http://picture.watchmen.xin/MAC/mac_key.png" alt=""></p><h2 id="全局操作"><a href="#全局操作" class="headerlink" title="全局操作"></a>全局操作</h2><ul><li>⌃⌘ + f: 进入全屏模式</li></ul><h2 id="强制退出应用"><a href="#强制退出应用" class="headerlink" title="强制退出应用"></a>强制退出应用</h2><p>如果 Mac 上的某个应用停止响应，并且您无法正常退出该应用，则可以使用“强制退出”来关闭该应用。</p><p>同时按住三个按键：Option、Command 和 Esc (Escape) 键。这类似于在 PC 上按下 Control-Alt-Delete。或者，在屏幕左上角的苹果 () 菜单中选取“强制退出”。</p><h2 id="强制刷新页面"><a href="#强制刷新页面" class="headerlink" title="强制刷新页面"></a>强制刷新页面</h2><ul><li><p>正常刷新：command+r</p></li><li><p>强制刷新页面（刷新页面缓存）：command+shift+r</p></li></ul><h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><p>MAC上管理软件包我们一般使用Homebrew来实现</p><p>Homebrew是MAC必备神器之一，作为Mac OSX上的软件包管理工具，它能在Mac中方便的安装软件或者卸载软件， 简单到只需要一个命令。</p><p><strong>安装：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p><strong>命令参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">brew install安装软件</span><br><span class="line">brew list列出已安装的软件</span><br><span class="line">brew update更新brew</span><br><span class="line">brew home用浏览器打开brew的官方网站</span><br><span class="line">brew info显示软件信息</span><br><span class="line">brew deps显示包依赖</span><br></pre></td></tr></table></figure><h1 id="MAC下实现AutoHotKey功能"><a href="#MAC下实现AutoHotKey功能" class="headerlink" title="MAC下实现AutoHotKey功能"></a>MAC下实现AutoHotKey功能</h1><p>在MAC下没有类似autohotkey的软件，但是它给我们提供了相应的工具，我们可以自定义的去实现功能</p><p><strong>步骤1：</strong>从其他中进入automator（中文版的名称为：“自动操作”）</p><p>就是下面这位仁兄：</p><p><img src="http://picture.watchmen.xin/MAC/automator.png" alt=""></p><p><strong>步骤2：</strong>创建服务</p><p><img src="http://picture.watchmen.xin/MAC/automator_new_services.png" alt=""></p><p><strong>步骤3：</strong> 创建applescript，如下图所示，用鼠标将applescript选中并拖到右栏中</p><p>注意，需要先将服务收到一栏中从文本修改为没有输入</p><p><img src="http://picture.watchmen.xin/MAC/automator_new_applescript.png" alt=""></p><p><strong>步骤4：</strong>编辑applescript</p><p>有关applescript的相关内容，网友可以自行查找，网上有非常多的资料。</p><p>简单说明下：</p><ul><li>tell语句，在这里调用谷歌浏览器程序（程序的实际名称可以打开终端，进入/Applications目录下ls查看）</li><li>activate语句，这这里将调用出来的窗口显示在最前端</li><li>open location 语句，实际的操作，后面的参数是具体的链接地址</li><li>end tell语句，结束调用<br><img src="http://picture.watchmen.xin/MAC/applescript.png" alt=""></li></ul><p><strong>步骤5：</strong>运行测试</p><p><img src="http://picture.watchmen.xin/MAC/runapplescript.png" alt=""></p><p>点击两个运行中任一一个，可以看到网页会在最前端弹出，代码执行成功之后，缩进和颜色都会发生相应的变化。</p><p><strong>步骤6：</strong> 保存为服务</p><p>输入command+s，在弹出的对话框中，输入自定义的名称</p><p><img src="http://picture.watchmen.xin/MAC/saveapplescript.png" alt=""></p><p><strong>步骤7：</strong>设置快捷键</p><p>打开系统偏好设置–&gt;键盘—&gt;快捷键–&gt;服务–&gt;通用—&gt;选中刚才保存的服务–&gt;双击—&gt;在编辑器中，敲下自定义的快捷键，系统将会自动识别显示，如下图所示：</p><p><img src="http://picture.watchmen.xin/MAC/config_applescript.png" alt=""></p><p>这个时候，设置就全部完毕，接下来我们就可以随时根据快捷键调用浏览器打开网页。</p><h1 id="Iterm2操作"><a href="#Iterm2操作" class="headerlink" title="Iterm2操作"></a>Iterm2操作</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><strong>标签</strong></p><ul><li>新建标签：command + t</li><li>关闭标签：command + w</li><li>切换标签：command + 数字 command + 左右方向键</li><li>切换全屏：command + enter</li><li>查找：command + f</li></ul><p><strong>分屏</strong></p><ul><li>垂直分屏：command + d</li><li>水平分屏：command + shift + d</li><li>切换屏幕：command + option + 方向键 或者 command + [ ]</li></ul><p><strong>命令</strong></p><ul><li>查看历史命令：command + ;</li><li>查看剪贴板历史：command + shift + h</li><li>上一条命令：ctrl + p</li><li>搜索命令历史：ctrl + r</li></ul><p><strong>行内</strong></p><ul><li>清除当前行：ctrl + u</li><li>到行首：ctrl + a</li><li>到行尾：ctrl + e</li><li>前进后退：ctrl + f/b (相当于左右方向键)</li><li>删除当前光标的字符：ctrl + d</li><li>删除光标之前的字符：ctrl + h</li><li>删除光标之前的单词：ctrl + w</li><li>删除到文本末尾：ctrl + k</li><li>交换光标处文本：ctrl + t</li></ul><p><strong>其他</strong></p><ul><li>清屏1：command + r</li><li>清屏2：ctrl + l</li><li>清屏3：clear</li><li>进入和退出全屏: Command + Enter</li><li>查看当前终端中光标的位置: Command + /</li><li>开启和关闭背景半透明: Command + u</li><li>清屏（重置当前终端）: Command + r</li></ul><h2 id="连接jumpserver"><a href="#连接jumpserver" class="headerlink" title="连接jumpserver"></a>连接jumpserver</h2><ol><li><p>Profile -&gt; Open Profiles… -&gt; Edit Profiles…</p></li><li><p>点击左下角+号</p></li><li><p>输入Profile Name，比如jumper</p></li><li><p>右边Command下选择Command，然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i /Users/yourname/.ssh/id_rsa  username@ip -p port</span><br></pre></td></tr></table></figure></li><li><p>关闭所有窗口</p></li><li><p>在Iterm2的一个窗口中选择右键New Tab或者command+o,在弹出的页面中选择刚创建的jumper，然后回车就登录上了。</p></li></ol><p>注意，如果给RSA秘钥设置了密码，又不想每次在登录的时候都输出密码，这个时候我们可以在命令行中输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add /Users/yourname/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>输入一次之后，后续就不用再次输入，注意重启后需要再次输入。</p><h2 id="实现rz-sz功能"><a href="#实现rz-sz功能" class="headerlink" title="实现rz/sz功能"></a>实现rz/sz功能</h2><p>Mac上iTerm原生不支持rz/sz命令，也就是不支持Zmodem来进行文件传输，不过只要通过简单的配置就可以实现。网上的教程一大把，这里就简单的记录一下过程。</p><h3 id="安装lrzsz"><a href="#安装lrzsz" class="headerlink" title="安装lrzsz"></a>安装lrzsz</h3><p>首先安装Homebrew(这里不写这个过程)，然后通过它先给Mac安装lrzsz。在终端下输入brew install lrzsz，静等一会即可安装完毕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure><h3 id="下载iTerm2辅助文件"><a href="#下载iTerm2辅助文件" class="headerlink" title="下载iTerm2辅助文件"></a>下载iTerm2辅助文件</h3><p>iTerm不能直接使用lrzsz，不过网上有大神提供了两个辅助脚本。我们只需要把文件下载到 /usr/local/bin/目录下并赋予可执行权限即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">wget https://raw.githubusercontent.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh</span><br><span class="line">wget https://raw.githubusercontent.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh</span><br><span class="line"></span><br><span class="line">chmod +x iterm2-recv-zmodem.sh iterm2-send-zmodem.sh</span><br></pre></td></tr></table></figure><p>这两个脚本实际是使用AppleScript来弹出文件选择窗口，然后把选中的文件名称传递给rzsz命令。我们打开其中一个看下代码。如果这一部分看不懂没关系，直接跳过即可，对后续的配置使用没有任何不良影响 </p><h3 id="配置iTerm2触发器"><a href="#配置iTerm2触发器" class="headerlink" title="配置iTerm2触发器"></a>配置iTerm2触发器</h3><p>这一步最关键，是在iTerm里面配置触发器，当监控到特定字符串的时候执行刚才下载的两个文件。为了使用方便，我专门建立了一个Profile配置，名字是Remote，并且配合后面的autossh使用。</p><p>打开iTerm2 -&gt; Preferences -&gt; Profiles 选择 Advanced 设置 Triggers ，点击 Edit</p><p><img src="http://picture.watchmen.xin/MAC/config_lrzsz.png" alt=""></p><p>在弹出窗口中进行如下配置，最后的<strong>Instant</strong>一定要勾选上。</p><p><img src="http://picture.watchmen.xin/MAC/config_lrzsz_triggers.png" alt=""></p><p>配置的具体内容在这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Regular expression: rz waiting to receive.\*\*B0100</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line"></span><br><span class="line">Regular expression: \*\*B00000000000000</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/local/bin/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure><p>重新启动iTerm之后，rz/sz就应该可以正常使用了。</p><h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><h2 id="pycharm-光标变粗问题"><a href="#pycharm-光标变粗问题" class="headerlink" title="pycharm-光标变粗问题"></a>pycharm-光标变粗问题</h2><p>mac下默认的pycharm的光标是为粗体的改写模式，这是因为安装的时候装了ideaVim插件，改为竖线光标的方法：把ideaVim插件去掉（点击pycharm–&gt;preference–&gt;plugins–&gt;搜索ideavim，然后将该插件勾除掉即可） </p><h2 id="MAC版本snipaste截图后无法输入中文问题"><a href="#MAC版本snipaste截图后无法输入中文问题" class="headerlink" title="MAC版本snipaste截图后无法输入中文问题"></a>MAC版本snipaste截图后无法输入中文问题</h2><p>参考资料：<a href="https://jingyan.baidu.com/article/c1a3101e635d6ade646deb56.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/c1a3101e635d6ade646deb56.html</a></p><ol><li>点击菜单栏截图软件的图标，选择退出软件。</li></ol><ol><li><p>接着按键盘上面的control+space ，选择拼音输入法。</p></li><li><p>这个时候就可以启动截图软件了，按键盘上的cmmand+space，在黑色框输入软件的名字回车。</p></li></ol><ol><li>点击软件图标，选择截图或者是按fn+f1，进行桌面的截图。</li></ol><ol><li>在截图上面，按空格键调出截图软件工具条，然后点击工具条上面的T，这个时候就可以在图片上面进行中文的标注了。总结就是用不了重启软件即可。</li></ol>]]></content>
    
    <summary type="html">
    
      MAC操作技巧
    
    </summary>
    
      <category term="常用软件工具" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="MAC操作技巧" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/MAC%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="MAC" scheme="http://yoursite.com/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>day05-常用模块学习</title>
    <link href="http://yoursite.com/2018/08/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day05-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/08/08/编程语言/Python/老男孩视频学习笔记/day05-常用模块学习/</id>
    <published>2018-08-08T12:29:08.000Z</published>
    <updated>2018-08-08T12:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h1><p>This module provides a portable way of using operating system dependent functionality</p><p>os模块主要用于和操作系统之间的交互，这个模块提供了一种方便的使用操作系统函数的方法。</p><h1 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h1><p>This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.</p><p>sys模块主要用于和python解释器之间的交互，这个模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。</p>]]></content>
    
    <summary type="html">
    
      day05-常用模块学习
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>day04-函数装饰器迭代器生成器</title>
    <link href="http://yoursite.com/2018/07/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day04-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2018/07/13/编程语言/Python/老男孩视频学习笔记/day04-函数装饰器迭代器生成器/</id>
    <published>2018-07-13T12:43:08.000Z</published>
    <updated>2018-07-13T12:43:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>器：代表函数的意思。也就是说，装饰器本质是函数，基本语法都是使用def关键字去定义的</p><p>那么它的本质是函数，它的功能是什么？</p><p>定义：装饰器的本质是函数：装饰其他函数的函数【就是为其他函数添加附加功能】</p><p>在实际生产环境中，需要新增功能的时候，有以下原则</p><ol><li>不能修改现有函数的源代码</li><li>函数一旦写好了，原则上就不能再去修改它的源代码</li><li>函数的调用方式也不能被修改</li></ol><p>装饰器有自己独特的需要遵循的原则：</p><ol><li><strong>不能修改被装饰的函数的源代码</strong></li><li><strong>不能修改被装饰的函数的调用方式</strong></li></ol><p>也就是，被装饰的函数式完全透明的（调用函数的一方不知道这个函数被装饰过，函数本身也感知不到装饰器的存在）</p><p>实现装饰器的知识储备：</p><ol><li><p>函数即“变量”</p></li><li><p>高阶函数</p><ul><li><p>把一个函数名都当做实参传递给另外一个函数【在一般的函数使用中，给形参传递的都是<code>实参变量</code>，那么，函数即变量之后，就可以把==函数==当做一个<code>变量实参</code>传递给另外一个函数】</p><p>这一步可以做到，在不修改被装饰函数源代码的情况下，为其添加功能</p></li><li><p>返回值中包含函数名【一般函数的返回值中吗，可以是字符串，列表，数字等等，因为函数是变量，那么在返回值中是也可以包含函数的】</p><p>不修改函数的调用方式</p></li></ul></li><li><p>函数嵌套</p><ul><li>函数嵌套指的是，在一个函数的函数体之内用def去声明一个新的函数，而不是去调用它</li></ul></li></ol><p>高阶函数+嵌套函数==》装饰器</p><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test1&quot;)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test2&quot;)</span><br><span class="line"></span><br><span class="line">def timer(func):</span><br><span class="line">    def deco():</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print (&quot;func is cost &#123;cost&#125;&quot;.format(cost=stop_time-start_time))</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line"># 返回该函数（这里是deco函数）的内存地址</span><br><span class="line"></span><br><span class="line">test1 = timer(test1)</span><br><span class="line">test1()</span><br><span class="line">#test1执行，实际上是在执行deco这个函数</span><br></pre></td></tr></table></figure><p>执行后的输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in the test1</span><br><span class="line">func is cost 1.0031695365905762</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>函数的执行，主要是执行函数体中的内容，而我们在真正执行函数的时候，是通过函数名称进行调用的（也就是一个变量），因此，在函数真正执行之前，我们可以<strong>修改这个函数名称对应的函数体中的内容</strong></p><p>装饰器的编写步骤：</p><ol><li>首先编写一个函数，其中调用这个被装饰的函数，并在其中添加上新的功能</li><li>将这个函数的函数体，也就是<strong>内存地址</strong>拿出来，重新赋值给这个被装饰的函数</li><li>实现第2步，就需要使用函数的嵌套，以此来返回这个函数的内存地址（函数嵌套了函数之后，是直接将子函数的内存地址返回，而没有执行这个子函数）</li><li>而将这个被装饰的源函数传递给这个装饰函数执行，就需要使用高阶函数</li></ol><h3 id="改良"><a href="#改良" class="headerlink" title="改良"></a>改良</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def timer(func):</span><br><span class="line">    def deco():</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print (&quot;func is cost &#123;cost&#125;&quot;.format(cost=stop_time-start_time))</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def test1():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test1&quot;)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test2&quot;)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>在这里，@timer=test1 = timer(test1)</p><p>注意，使用这种方式的时候，timer函数的定义要在这些被装饰函数的前方</p><p>如果函数还涉及到参数，那么，我们就需要重新编写定义装饰器，将它写成通用的方式，不管被装饰的函数传递的是几个函数（0个或多个），都能够正确的读取。</p><p><strong>添加函数传递功能</strong></p><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = lambda x:x*3</span><br><span class="line">print (res(3))</span><br><span class="line"></span><br><span class="line">执行后输出结果为：9</span><br></pre></td></tr></table></figure><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>通过列表生成式【列表解析】，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种<strong><code>一边循环一边计算</code></strong>的<strong>机制</strong>，称为生成器：generator。</p><p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [i*2 for i in range(11)]</span><br><span class="line">b = (i*2 for i in range(11))</span><br><span class="line">print (a)</span><br><span class="line">print (b)</span><br><span class="line"></span><br><span class="line">执行后输出如下所示：</span><br><span class="line">[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x058D5360&gt;</span><br></pre></td></tr></table></figure><p>注意，在进行调用的时候，传统的方式能够直接通过列表下标的方式获取到相应的元素【因为元素已经生成并存在于内存当中】，但是生成器是只有你调用到我这一次的时候，我才会生成这一个，也就是必须循环到这个指定的下标的时候，我才会产生这个元素的值，因此，在前面的数据没有生成的情况下，直接调用中间的某个元素，因为不存在这个元素，因此就会产生报错,不支持这种数据获取方式</p><p>调用生成器的时候，只能使用for循环的方式一个个取用，当不想要获取全部的数据，只需要获取部分数据的时候，使用生成器提供的next方法进行操作【next方法获取当前】。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.__next()__()</span><br></pre></td></tr></table></figure><p>注意：没有previous方法用户获取上一个值，因为，生成器只会当前的位置，不知道前边和后边</p><p><strong>总结：</strong></p><ul><li>生成器只有在调用时，才会生成相应的数据</li><li>只会记录当前位置</li><li>只有一个<code>__next__()</code>方法（2.7中为next()）</li></ul><p>我们创建了一个generator后，基本上永远不会调用<code>next()</code>，而是通过<code>for</code>循环来迭代它，并且不需要关心<code>StopIteration</code>的错误。</p><p>generator非常强大。如果推算的算法比较复杂，用类似列表生成式的<code>for</code>循环无法实现的时候，还可以用函数来实现。</p><p>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p><p>1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p><p>yield的作用：保存函数的中断状态，yield返回当前状态的值，并且将函数保持停留在这里</p><p>对生成器使用send()方法，可以将参数传递给这个生成器，yield就会接受到这个参数</p><p>next()只是单纯的调用yield，它不会给yield传值；send()给yield传值，同时调用yield</p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：</p><p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p><p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p><p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p><p><strong>重点：</strong></p><ul><li><p>可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code></p></li><li><p>生成器不但可以作用于<code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值了。</p></li><li>可以被next()方法调用并不断返回下一个值的对象称为迭代器：<strong><code>Iterator</code></strong>。</li></ul><p>迭代器和next()方法相关联，有next()方法的才能称之为迭代器</p><p>查看一个对象能够调用的所有方法：dir(a)</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象【是否是<strong>迭代器</strong>对象】：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print (isinstance([1,2,3],Iterator))</span><br><span class="line">print (isinstance([],Iterator))</span><br><span class="line">print (isinstance((x for x in range(10)),Iterator))</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">a = [1,2,3]</span><br><span class="line">b = iter(a)</span><br><span class="line">print (isinstance(b,Iterator))</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p><p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p><p>你可能会问，为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？</p><p>这是因为Python的<code>Iterator</code>对象表示的是一个数据流，Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p><code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><h1 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h1><p>python中有以下内置函数</p><table><thead><tr><th></th><th>Built-in Functions</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#abs" target="_blank" rel="noopener"><code>abs()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#delattr" target="_blank" rel="noopener"><code>delattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#hash" target="_blank" rel="noopener"><code>hash()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-memoryview" target="_blank" rel="noopener"><code>memoryview()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-set" target="_blank" rel="noopener"><code>set()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#all" target="_blank" rel="noopener"><code>all()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-dict" target="_blank" rel="noopener"><code>dict()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#help" target="_blank" rel="noopener"><code>help()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#min" target="_blank" rel="noopener"><code>min()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#setattr" target="_blank" rel="noopener"><code>setattr()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#any" target="_blank" rel="noopener"><code>any()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#dir" target="_blank" rel="noopener"><code>dir()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#hex" target="_blank" rel="noopener"><code>hex()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#next" target="_blank" rel="noopener"><code>next()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#slice" target="_blank" rel="noopener"><code>slice()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#ascii" target="_blank" rel="noopener"><code>ascii()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#divmod" target="_blank" rel="noopener"><code>divmod()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#id" target="_blank" rel="noopener"><code>id()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#object" target="_blank" rel="noopener"><code>object()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#sorted" target="_blank" rel="noopener"><code>sorted()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#bin" target="_blank" rel="noopener"><code>bin()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#input" target="_blank" rel="noopener"><code>input()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#oct" target="_blank" rel="noopener"><code>oct()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#staticmethod" target="_blank" rel="noopener"><code>staticmethod()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#bool" target="_blank" rel="noopener"><code>bool()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#eval" target="_blank" rel="noopener"><code>eval()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#int" target="_blank" rel="noopener"><code>int()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#open" target="_blank" rel="noopener"><code>open()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-str" target="_blank" rel="noopener"><code>str()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#breakpoint" target="_blank" rel="noopener"><code>breakpoint()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#exec" target="_blank" rel="noopener"><code>exec()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#ord" target="_blank" rel="noopener"><code>ord()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#sum" target="_blank" rel="noopener"><code>sum()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-bytearray" target="_blank" rel="noopener"><code>bytearray()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#filter" target="_blank" rel="noopener"><code>filter()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#issubclass" target="_blank" rel="noopener"><code>issubclass()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#pow" target="_blank" rel="noopener"><code>pow()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#super" target="_blank" rel="noopener"><code>super()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-bytes" target="_blank" rel="noopener"><code>bytes()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#float" target="_blank" rel="noopener"><code>float()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#iter" target="_blank" rel="noopener"><code>iter()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#print" target="_blank" rel="noopener"><code>print()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-tuple" target="_blank" rel="noopener"><code>tuple()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#callable" target="_blank" rel="noopener"><code>callable()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#format" target="_blank" rel="noopener"><code>format()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#len" target="_blank" rel="noopener"><code>len()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#property" target="_blank" rel="noopener"><code>property()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#type" target="_blank" rel="noopener"><code>type()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#chr" target="_blank" rel="noopener"><code>chr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-frozenset" target="_blank" rel="noopener"><code>frozenset()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-list" target="_blank" rel="noopener"><code>list()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-range" target="_blank" rel="noopener"><code>range()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#vars" target="_blank" rel="noopener"><code>vars()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#classmethod" target="_blank" rel="noopener"><code>classmethod()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#getattr" target="_blank" rel="noopener"><code>getattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#locals" target="_blank" rel="noopener"><code>locals()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#repr" target="_blank" rel="noopener"><code>repr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#zip" target="_blank" rel="noopener"><code>zip()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#compile" target="_blank" rel="noopener"><code>compile()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#globals" target="_blank" rel="noopener"><code>globals()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#map" target="_blank" rel="noopener"><code>map()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#reversed" target="_blank" rel="noopener"><code>reversed()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#__import__" target="_blank" rel="noopener"><code>__import__()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#complex" target="_blank" rel="noopener"><code>complex()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#hasattr" target="_blank" rel="noopener"><code>hasattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#max" target="_blank" rel="noopener"><code>max()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#round" target="_blank" rel="noopener"><code>round()</code></a></td></tr></tbody></table><ul><li><p>all()：判断输出的值是否都为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print (all([9,3]))</span><br><span class="line">print (all([0,9,3]))</span><br><span class="line"></span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p>any()：一个数据为真，就返回真，如果可迭代对象为空，返回也为False</p></li></ul><ul><li>eval()：将字符串变成字典</li></ul><h1 id="json序列化"><a href="#json序列化" class="headerlink" title="json序列化"></a>json序列化</h1><p>序列化：把内存中的数据对象变成字符串</p><p>反序列化： 把磁盘中的数据加载到内存当中</p><p>注意：json只能处理简单的数据类型，列表、字典、字符串等，因为json是所有语言都通用的，json主要的作用是用于不同语言之间进行数据交互，因为一些复杂的东西，例如python和java里面，类的定义和使用方式、一些特性等等，各语言之间很多东西都有很大的差异性，如果需要转换类、函数等对象就会变得相当复杂。所以，json默认只是支持这些比较简单的。</p><ul><li><p>xml知识补充：xml正在逐渐的被json所取代</p><blockquote><p>xml是一种标记语言，</p></blockquote></li></ul><h1 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h1><p>pickle的用法和json完全一样，但是它在序列化的时候，会把内存转换成为二进制的形式，所以在操作文件的时候，需要在序列化和反序列化的时候使用的方法为：wb和rb</p><p>pickle有自己的一套语法映射关系，将数据转换为二进制数据，因此系统的字符集识别之后将会显示为乱码</p><h1 id="dumps-和dump-以及loads-和load-区别"><a href="#dumps-和dump-以及loads-和load-区别" class="headerlink" title="dumps()和dump()以及loads()和load()区别"></a>dumps()和dump()以及loads()和load()区别</h1><p>注意，在序列化的时候，使用dumps和loads操作文件的时候，需要使用文件本身的f.write()或者f.read()方法；但是如果使用dump()和load()的时候，该方法中就可以嵌入了对文件的操作，也就是说不需要再额外的使用以上两个文件方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f.write(pickle.dumps(info))</span><br><span class="line">等价于</span><br><span class="line">pickle.dump(info,f)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">data = pickle.loads(f.read())</span><br><span class="line">等价于</span><br><span class="line">data = pickle.load(f)</span><br></pre></td></tr></table></figure><p>注意，我们可以dump很多次，但是dump很多次之后的这个文件，直接使用load是打不开的。</p><p>也就是说，在python3中，最多只能dump一次。</p><p><strong>在编写程序时的一个准则：</strong></p><ul><li>只dump一次，只load一次</li><li>如果还是想使用原来的文件，那么就把原来的内容覆盖掉 </li><li>例如虚拟机的快照，虚拟机的快照是每一个快照都会对应一个文件，而不是把所有的快照内容都存在一起</li><li>如果想保存好几个状态，那么就dump好几个文件。</li></ul><h1 id="软件目录结构规范"><a href="#软件目录结构规范" class="headerlink" title="软件目录结构规范"></a>软件目录结构规范</h1><h4 id="为什么要设计好目录结构"><a href="#为什么要设计好目录结构" class="headerlink" title="为什么要设计好目录结构?"></a>为什么要设计好目录结构?</h4><p>“设计项目目录结构”，就和”代码编码风格”一样，属于个人风格问题。对于这种风格上的规范，一直都存在两种态度:</p><ol><li>一类同学认为，这种个人风格问题”无关紧要”。理由是能让程序work就好，风格问题根本不是问题。</li><li>另一类同学认为，规范化能更好的控制程序结构，让程序具有更高的可读性。</li></ol><p>我是比较偏向于后者的，因为我是前一类同学思想行为下的直接受害者。我曾经维护过一个非常不好读的项目，其实现的逻辑并不复杂，但是却耗费了我非常长的时间去理解它想表达的意思。从此我个人对于提高项目可读性、可维护性的要求就很高了。”项目目录结构”其实也是属于”可读性和可维护性”的范畴，我们设计一个层次清晰的目录结构，就是为了达到以下两点:</p><ol><li>可读性高: 不熟悉这个项目的代码的人，一眼就能看懂目录结构，知道程序启动脚本是哪个，测试目录在哪儿，配置文件在哪儿等等。从而非常快速的了解这个项目。</li><li>可维护性高: 定义好组织规则后，维护者就能很明确地知道，新增的哪个文件和代码应该放在什么目录之下。这个好处是，随着时间的推移，代码/配置的规模增加，项目结构不会混乱，仍然能够组织良好。</li></ol><p>所以，我认为，保持一个层次清晰的目录结构是有必要的。更何况组织一个良好的工程目录，其实是一件很简单的事儿。</p><h4 id="目录组织方式"><a href="#目录组织方式" class="headerlink" title="目录组织方式"></a>目录组织方式</h4><p>关于如何组织一个较好的Python工程目录结构，已经有一些得到了共识的目录结构。在Stackoverflow的<a href="http://stackoverflow.com/questions/193161/what-is-the-best-project-structure-for-a-python-application" target="_blank" rel="noopener">这个问题</a>上，能看到大家对Python目录结构的讨论。</p><p>这里面说的已经很好了，我也不打算重新造轮子列举各种不同的方式，这里面我说一下我的理解和体会。</p><p>假设你的项目名为foo, 我比较建议的最方便快捷目录结构这样就足够了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Foo/</span><br><span class="line">|-- bin/</span><br><span class="line">|   |-- foo</span><br><span class="line">|</span><br><span class="line">|-- foo/</span><br><span class="line">|   |-- tests/</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- test_main.py</span><br><span class="line">|   |</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- main.py</span><br><span class="line">|</span><br><span class="line">|-- docs/</span><br><span class="line">|   |-- conf.py</span><br><span class="line">|   |-- abc.rst</span><br><span class="line">|</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- requirements.txt</span><br><span class="line">|-- README</span><br></pre></td></tr></table></figure><p>简要解释一下:</p><ol><li><code>bin/</code>: 存放项目的一些可执行文件，当然你可以起名<code>script/</code>之类的也行。</li><li><code>foo/</code>: 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录<code>tests/</code>存放单元测试代码； (3) 程序的入口最好命名为<code>main.py</code>。</li><li><code>docs/</code>: 存放一些文档。</li><li><code>setup.py</code>: 安装、部署、打包的脚本。</li><li><code>requirements.txt</code>: 存放软件依赖的外部Python包列表。</li><li><code>README</code>: 项目说明文件。</li></ol><p>除此之外，有一些方案给出了更加多的内容。比如<code>LICENSE.txt</code>,<code>ChangeLog.txt</code>文件等，我没有列在这里，因为这些东西主要是项目开源的时候需要用到。如果你想写一个开源软件，目录该如何组织，可以参考<a href="http://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/" target="_blank" rel="noopener">这篇文章</a>。</p><p>下面，再简单讲一下我对这些目录的理解和个人要求吧。</p><p><strong>注意：</strong>有<code>__init__.py</code>这个空文件的目录就叫做包，没有的就叫做目录</p><h4 id="关于README的内容"><a href="#关于README的内容" class="headerlink" title="关于README的内容"></a>关于README的内容</h4><p><strong>这个我觉得是每个项目都应该有的一个文件</strong>，目的是能简要描述该项目的信息，让读者快速了解这个项目。</p><p>它需要说明以下几个事项:</p><ol><li>软件定位，软件的基本功能。</li><li>运行代码的方法: 安装环境、启动命令等。</li><li>简要的使用说明。</li><li>代码目录结构说明，更详细点可以说明软件的基本原理。</li><li>常见问题说明。</li></ol><p>我觉得有以上几点是比较好的一个<code>README</code>。在软件开发初期，由于开发过程中以上内容可能不明确或者发生变化，并不是一定要在一开始就将所有信息都补全。但是在项目完结的时候，是需要撰写这样的一个文档的。</p><p>可以参考Redis源码中<a href="https://github.com/antirez/redis#what-is-redis" target="_blank" rel="noopener">Readme</a>的写法，这里面简洁但是清晰的描述了Redis功能和源码结构。</p><h4 id="关于requirements-txt和setup-py"><a href="#关于requirements-txt和setup-py" class="headerlink" title="关于requirements.txt和setup.py"></a>关于requirements.txt和setup.py</h4><h4 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a>setup.py</h4><p>一般来说，用<code>setup.py</code>来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具<a href="https://pythonhosted.org/setuptools/setuptools.html#developer-s-guide" target="_blank" rel="noopener">setuptools</a>来管理这些事情。这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，<strong>一个项目一定要有一个安装部署工具</strong>，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。</p><p>这个我是踩过坑的。</p><p>我刚开始接触Python写项目的时候，安装环境、部署代码、运行程序这个过程全是手动完成，遇到过以下问题:</p><ol><li>安装环境时经常忘了最近又添加了一个新的Python包，结果一到线上运行，程序就出错了。</li><li>Python包的版本依赖问题，有时候我们程序中使用的是一个版本的Python包，但是官方的已经是最新的包了，通过手动安装就可能装错了。</li><li>如果依赖的包很多的话，一个一个安装这些依赖是很费时的事情。</li><li>新同学开始写项目的时候，将程序跑起来非常麻烦，因为可能经常忘了要怎么安装各种依赖。</li></ol><p><code>setup.py</code>可以将这些事情自动化起来，提高效率、减少出错的概率。”复杂的东西自动化，能自动化的东西一定要自动化。”是一个非常好的习惯。</p><p>setuptools的<a href="https://pythonhosted.org/setuptools/setuptools.html#developer-s-guide" target="_blank" rel="noopener">文档</a>比较庞大，刚接触的话，可能不太好找到切入点。学习技术的方式就是看他人是怎么用的，可以参考一下Python的一个Web框架，flask是如何写的: <a href="https://github.com/mitsuhiko/flask/blob/master/setup.py" target="_blank" rel="noopener">setup.py</a></p><p>当然，简单点自己写个安装脚本（<code>deploy.sh</code>）替代<code>setup.py</code>也未尝不可。</p><h4 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a>requirements.txt</h4><p>这个文件存在的目的是:</p><ol><li>方便开发者维护软件的包依赖。将开发过程中新增的包添加进这个列表中，避免在<code>setup.py</code>安装依赖时漏掉软件包。</li><li>方便读者明确项目使用了哪些Python包。</li></ol><p>这个文件的格式是每一行包含一个包依赖的说明，通常是<code>flask&gt;=0.10</code>这种格式，要求是这个格式能被<code>pip</code>识别，这样就可以简单的通过 <code>pip install -r requirements.txt</code>来把所有Python包依赖都装好了。具体格式说明： <a href="https://pip.readthedocs.org/en/1.1/requirements.html" target="_blank" rel="noopener">点这里</a>。</p><h4 id="关于配置文件的使用方法"><a href="#关于配置文件的使用方法" class="headerlink" title="关于配置文件的使用方法"></a>关于配置文件的使用方法</h4><h4 id="注意，在上面的目录结构中，没有将conf-py放在源码目录下，而是放在docs-目录下。"><a href="#注意，在上面的目录结构中，没有将conf-py放在源码目录下，而是放在docs-目录下。" class="headerlink" title="注意，在上面的目录结构中，没有将conf.py放在源码目录下，而是放在docs/目录下。"></a>注意，在上面的目录结构中，没有将<code>conf.py</code>放在源码目录下，而是放在<code>docs/</code>目录下。</h4><p>很多项目对配置文件的使用做法是:</p><ol><li>配置文件写在一个或多个python文件中，比如此处的conf.py。</li><li>项目中哪个模块用到这个配置文件就直接通过<code>import conf</code>这种形式来在代码中使用配置。</li></ol><p>这种做法我不太赞同:</p><ol><li>这让单元测试变得困难（因为模块内部依赖了外部配置）</li><li>另一方面配置文件作为用户控制程序的接口，应当可以由用户自由指定该文件的路径。</li><li>程序组件可复用性太差，因为这种贯穿所有模块的代码硬编码方式，使得大部分模块都依赖<code>conf.py</code>这个文件。</li></ol><p>所以，我认为配置的使用，更好的方式是，</p><ol><li>模块的配置都是可以灵活配置的，不受外部配置文件的影响。</li><li>程序的配置也是可以灵活控制的。</li></ol><p>能够佐证这个思想的是，用过nginx和mysql的同学都知道，nginx、mysql这些程序都可以自由的指定用户配置。</p><p>所以，不应当在代码中直接<code>import conf</code>来使用配置文件。上面目录结构中的<code>conf.py</code>，是给出的一个配置样例，不是在写死在程序中直接引用的配置文件。可以通过给<code>main.py</code>启动参数指定配置路径的方式来让程序读取配置内容。当然，这里的<code>conf.py</code>你可以换个类似的名字，比如<code>settings.py</code>。或者你也可以使用其他格式的内容来编写配置文件，比如<code>settings.yaml</code>之类的。</p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1>]]></content>
    
    <summary type="html">
    
      day04-函数装饰器迭代器生成器
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>内核模块操作命令-lsmod+rmmod+modinfo+modprobe</title>
    <link href="http://yoursite.com/2018/07/13/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-lsmod+rmmod+modinfo+modprobe/"/>
    <id>http://yoursite.com/2018/07/13/IT科学技术知识体系结构-Linux运维方向/Linux基础知识/Linux常用命令/内核模块操作命令-lsmod+rmmod+modinfo+modprobe/</id>
    <published>2018-07-13T07:23:11.000Z</published>
    <updated>2018-07-13T07:23:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要讲解和Linux内核模块相关的操作命令</p><hr><h1 id="lsmod-查看内核模块信息"><a href="#lsmod-查看内核模块信息" class="headerlink" title="lsmod-查看内核模块信息"></a>lsmod-查看内核模块信息</h1><p><strong>lsmod命令</strong>用于显示已经加载到内核中的模块的状态信息。执行lsmod命令后会列出所有已载入系统的模块。</p><p>Linux操作系统的核心具有模块化的特性，应此在编译核心时，可以不用把全部的功能都放入核心，而是将这些功能编译成一个个单独的模块，待需要时再分别载入使用。 </p><p>命令的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# lsmod </span><br><span class="line">Module                  Size  Used by</span><br><span class="line">iptable_nat             5923  0 </span><br><span class="line">nf_nat                 22676  1 iptable_nat</span><br><span class="line">nf_conntrack_ipv4       9186  3 iptable_nat,nf_nat</span><br><span class="line">nf_conntrack           79537  3 iptable_nat,nf_nat,nf_conntrack_ipv4</span><br><span class="line">nf_defrag_ipv4          1483  1 nf_conntrack_ipv4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# lsmod | grep ip_vs</span><br><span class="line">ip_vs_rr                1420  0 </span><br><span class="line">ip_vs                 126705  2 ip_vs_rr</span><br><span class="line">libcrc32c               1246  1 ip_vs</span><br><span class="line">ipv6                  336368  913 ip_vs,ib_ipoib,ib_addr</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>第1列：表示模块的名称。</li><li>第2列：表示模块的大小。</li><li>第3列：表示该模块调用其他模块的个数</li><li>第4列：显示该模块被其他什么模块调用</li></ul><p>通常在使用lsmod命令时，都会采用类似<code>lsmod | grep -i ipvs</code>这样的命令来查询当前系统是否加载了某些模块。</p><h1 id="modinfo-查看内核模块信息"><a href="#modinfo-查看内核模块信息" class="headerlink" title="modinfo-查看内核模块信息"></a>modinfo-查看内核模块信息</h1><p>modinfo会显示kernel模块的对象文件，以显示该模块的相关信息。 </p><p>modinfo列出Linux内核中命令行指定的模块的信息。若模块名不是一个文件名，则会在/lib/modules/version 目录中搜索，就像modprobe一样。</p><p>modinfo默认情况下，为了便于阅读，以下面的格式列出模块的每个属性：fieldname : value。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">参　　数：</span><br><span class="line">  -a或--author 　显示模块开发人员。 </span><br><span class="line">  -d或--description 　显示模块的说明。 </span><br><span class="line">  -h或--help 　显示modinfo的参数使用方法。 </span><br><span class="line">  -p或--parameters 　显示模块所支持的参数。 </span><br><span class="line">  -V或--version 　显示版本信息。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# modinfo ip_vs</span><br><span class="line">filename:       /lib/modules/2.6.32-696.el6.x86_64/kernel/net/netfilter/ipvs/ip_vs.ko</span><br><span class="line">license:        GPL</span><br><span class="line">srcversion:     0FB85919D62C4255E412E5C</span><br><span class="line">depends:        ipv6,libcrc32c</span><br><span class="line">vermagic:       2.6.32-696.el6.x86_64 SMP mod_unload modversions </span><br><span class="line">parm:           conn_tab_bits:Set connections&apos; hash size (int)</span><br></pre></td></tr></table></figure><p>注意，使用lsmod不能看到内核的相关参数配置，而使用modinfo命令则可以显示</p><h1 id="rmmod-卸载内核模块"><a href="#rmmod-卸载内核模块" class="headerlink" title="rmmod-卸载内核模块"></a>rmmod-卸载内核模块</h1><p><strong>rmmod命令</strong> 用于从当前运行的内核中移除指定的内核模块。</p><p>执行rmmod指令，可删除不需要的模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选项信息：</span><br><span class="line">-v：显示指令执行的详细信息；</span><br><span class="line">-f：强制移除模块，使用此选项比较危险；</span><br><span class="line">-w：等待着，直到模块能够被除时在移除模块；</span><br><span class="line">-s：向系统日志（syslog）发送错误信息。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# rmmod ip_vs</span><br><span class="line">ERROR: Module ip_vs is in use by ip_vs_rr</span><br></pre></td></tr></table></figure><p>使用rmmod卸载模块的时候，提示信息会比使用modprobe -r 的输出更详细，此时会显示该模块的被调用情况</p><h1 id="insmod-载入内核模块"><a href="#insmod-载入内核模块" class="headerlink" title="insmod-载入内核模块"></a>insmod-载入内核模块</h1><p>insmod(install module)命令用于载入模块。</p><p>Linux有许多功能是通过模块的方式，在需要时才载入kernel。如此可使kernel较为精简，进而提高效率，以及保有较大的弹性。这类可载入的模块，通常是设备驱动程序。</p><p><strong>语法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod [-fkmpsvxX][-o &lt;模块名称&gt;][模块文件][符号名称 = 符号值]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">-f 　不检查目前kernel版本与模块编译时的kernel版本是否一致，强制将模块载入。</span><br><span class="line">-k 　将模块设置为自动卸除。</span><br><span class="line">-m 　输出模块的载入信息。</span><br><span class="line">-o&lt;模块名称&gt; 　指定模块的名称，可使用模块文件的文件名。</span><br><span class="line">-p 　测试模块是否能正确地载入kernel。</span><br><span class="line">-s 　将所有信息记录在系统记录文件中。</span><br><span class="line">-v 　执行时显示详细的信息。</span><br><span class="line">-x 　不要汇出模块的外部符号。</span><br><span class="line">-X 　汇出模块所有的外部符号，此为预设置。</span><br></pre></td></tr></table></figure><p>在Linux中，modprobe和insmod都可以用来加载module，不过现在一般都推荐使用modprobe而不是insmod了。<br><strong>modprobe和insmod的区别是什么呢？</strong></p><ul><li>modprobe可以解决load module时的依赖关系，比如load moudleA就必须先load mouduleB之类的，它是通过/lib/modules//modules.dep文件来查找依赖关系的。而insmod不能解决依赖问题。</li><li>modprobe默认会去/lib/modules/目录下面查找module，而insmod只在给它的参数中去找module（默认在当前目录找）。</li></ul><p>但是insmod也有它的有用之处，举个例子吧。</p><p>有/root/my-mod.ko这个module，cd /root/，然后用insmod my-mod.ko(insmod /root/my-mod.ko)就可以insert这个module了，</p><p>但是用modprobe my-mod.ko(modprobe /root/my-mod.ko)却提示”FATAL: Module my-mod.ko not found”，这就是因为modprobe是到/lib/modules/<code>uname -r</code>/下去找module的，如果没找到就是这样了。</p><h1 id="depmod-分析模块依赖性"><a href="#depmod-分析模块依赖性" class="headerlink" title="depmod-分析模块依赖性"></a>depmod-分析模块依赖性</h1><h1 id="modprobe-内核模块操作"><a href="#modprobe-内核模块操作" class="headerlink" title="modprobe-内核模块操作"></a>modprobe-内核模块操作</h1><p><strong>modprobe命令</strong>用于智能地向内核中加载模块或者从内核中移除模块。</p><p>modprobe可载入指定的个别模块，或是载入一组相依的模块。</p><p>modprobe会根据<a href="http://man.linuxde.net/depmod" target="_blank" rel="noopener">depmod</a>所产生的相依关系，决定要载入哪些模块。若在载入过程中发生错误，在modprobe会卸载整组的模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数选项</span><br><span class="line"></span><br><span class="line">-a或--all：载入全部的模块/指定模块；</span><br><span class="line">-c或--show-conf：显示所有模块的设置信息；</span><br><span class="line">-d或--debug：使用排错模式；</span><br><span class="line">-l或--list：显示可用的模块；</span><br><span class="line">-r或--remove：卸载模块；</span><br><span class="line">-t或--type：指定模块类型；</span><br><span class="line">-v或--verbose：执行时显示详细的信息；</span><br><span class="line">-V或--version：显示版本信息；</span><br><span class="line">-help：显示帮助。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">卸载：modprobe -r ip_vs </span><br><span class="line">载入：modprobe -a ip_vs</span><br></pre></td></tr></table></figure><h1 id="get-module"><a href="#get-module" class="headerlink" title="get_module"></a>get_module</h1><p>需要安装sysfsutils包之后才能产生该命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install sysfsutils</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# get_module ip_vs</span><br><span class="line">initstate            : live</span><br><span class="line">refcnt               : 2</span><br><span class="line">srcversion           : 0FB85919D62C4255E412E5C</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">conn_tab_bits        : 12</span><br><span class="line">Sections:</span><br><span class="line">.altinstr_replacement : 0xffffffffa039c2b8</span><br><span class="line">.altinstructions     : 0xffffffffa039ef98</span><br><span class="line">.bss                 : 0xffffffffa03a1c60</span><br><span class="line">.data                : 0xffffffffa039ff00</span><br><span class="line">.data.cacheline_aligned : 0xffffffffa03a1580</span><br><span class="line">.data.read_mostly    : 0xffffffffa03a1040</span><br><span class="line">.exit.text           : 0xffffffffa039c40e</span><br><span class="line">.gnu.linkonce.this_module : 0xffffffffa03a1a20</span><br><span class="line">.init.text           : 0xffffffffa03aa000</span><br><span class="line">.note.gnu.build-id   : 0xffffffffa039c454</span><br><span class="line">.rheldata            : 0xffffffffa039fee0</span><br><span class="line">.rodata              : 0xffffffffa039c480</span><br><span class="line">.rodata.str1.1       : 0xffffffffa039d6e8</span><br><span class="line">.rodata.str1.8       : 0xffffffffa039dc90</span><br><span class="line">.smp_locks           : 0xffffffffa039eb68</span><br><span class="line">.strtab              : 0xffffffffa03ae2f8</span><br><span class="line">.symtab              : 0xffffffffa03aa4d0</span><br><span class="line">.text                : 0xffffffffa038a000</span><br><span class="line">__kcrctab_gpl        : 0xffffffffa039f540</span><br><span class="line">__kcrctab            : 0xffffffffa039fe80</span><br><span class="line">__ksymtab_gpl        : 0xffffffffa039f4f0</span><br><span class="line">__ksymtab_strings    : 0xffffffffa039f590</span><br><span class="line">__ksymtab            : 0xffffffffa039fdc0</span><br><span class="line">__mcount_loc         : 0xffffffffa039f6e8</span><br><span class="line">__param              : 0xffffffffa039f568</span><br><span class="line">__verbose            : 0xffffffffa03a1980</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      内核模块操作-lsmod+rmmod+modinfo+modprobe
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="Linux基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Linux常用命令" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="lsmod" scheme="http://yoursite.com/tags/lsmod/"/>
    
  </entry>
  
  <entry>
    <title>python常见模块+方法+函数记录</title>
    <link href="http://yoursite.com/2018/07/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/python%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/07/11/编程语言/Python/基础知识/python模块/</id>
    <published>2018-07-11T09:43:49.000Z</published>
    <updated>2018-07-11T09:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p>在平常的代码中，我们常常需要与时间打交道。在Python中，与时间处理有关的模块包括：time，datetime以及calendar。</p><p>在开始之前，首先要说明这几点：</p><ol><li><p>在Python中，通常有这几种方式来表示时间：</p><p>1）时间戳 </p><p>2）格式化的时间字符串 </p><p>3）元组（struct_time）共九个元素。由于Python的time模块实现主要调用C库，所以各个平台可能有所不同。</p></li></ol><ol><li>UTC（Coordinated Universal Time，世界协调时）亦即格林威治天文时间，世界标准时间。在中国为UTC+8。DST（Daylight Saving Time）即夏令时。</li></ol><ol><li>时间戳（timestamp）的方式：通常来说，时间戳表示的是从<strong>1970年1月1日00:00:00</strong>开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。返回时间戳方式的函数主要有time()，clock()等。</li></ol><ol><li>元组（struct_time）方式：struct_time元组共有9个元素，返回struct_time的函数主要有gmtime()，localtime()，strptime()。下面列出这种方式元组中的几个元素：</li></ol><table><thead><tr><th>索引（Index）</th><th>属性（Attribute）</th><th>值（Values）</th></tr></thead><tbody><tr><td>0</td><td>tm_year（年）</td><td>比如2011</td></tr><tr><td>1</td><td>tm_mon（月）</td><td>1 - 12</td></tr><tr><td>2</td><td>tm_mday（日）</td><td>1 - 31</td></tr><tr><td>3</td><td>tm_hour（时）</td><td>0 - 23</td></tr><tr><td>4</td><td>tm_min（分）</td><td>0 - 59</td></tr><tr><td>5</td><td>tm_sec（秒）</td><td>0 - 61</td></tr><tr><td>6</td><td>tm_wday（weekday）</td><td>0 - 6（0表示周日）</td></tr><tr><td>7</td><td>tm_yday（一年中的第几天）</td><td>1 - 366</td></tr><tr><td>8</td><td>tm_isdst（是否是夏令时）</td><td>默认为-1</td></tr></tbody></table><h3 id="获取当前时间戳"><a href="#获取当前时间戳" class="headerlink" title="获取当前时间戳"></a>获取当前时间戳</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.time())</span><br><span class="line">输出如下：</span><br><span class="line">1531317129.0039742</span><br></pre></td></tr></table></figure><h3 id="时间元祖"><a href="#时间元祖" class="headerlink" title="时间元祖"></a>时间元祖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.localtime())</span><br><span class="line">输出如下：</span><br><span class="line">time.struct_time(tm_year=2018, tm_mon=7, tm_mday=11, tm_hour=22, tm_min=4, tm_sec=18, tm_wday=2, tm_yday=192, tm_isdst=0)</span><br></pre></td></tr></table></figure><h3 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h3><p>最简单的获取可读模式的方法是asctime()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.asctime())</span><br><span class="line">输出如下：</span><br><span class="line">Wed Jul 11 21:52:09 2018</span><br></pre></td></tr></table></figure><p><strong>使用指定的格式输出</strong>，在这里，使用strftime方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.localtime()))</span><br><span class="line">输入如下：</span><br><span class="line">2018-07-11 22:02:27</span><br></pre></td></tr></table></figure><p><strong>补充-python中时间日期格式化符号</strong></p><p>python中时间日期格式化符号：</p><ul><li>%y 两位数的年份表示（00-99）</li><li>%Y 四位数的年份表示（000-9999）</li><li>%m 月份（01-12）</li><li>%d 月内中的一天（0-31）</li><li>%H 24小时制小时数（0-23）</li><li>%I 12小时制小时数（01-12）</li><li>%M 分钟数（00=59）</li><li>%S 秒（00-59）</li><li>%a 本地简化星期名称</li><li>%A 本地完整星期名称</li><li>%b 本地简化的月份名称</li><li>%B 本地完整的月份名称</li><li>%c 本地相应的日期表示和时间表示</li><li>%j 年内的一天（001-366）</li><li>%p 本地A.M.或P.M.的等价符</li><li>%U 一年中的星期数（00-53）星期天为星期的开始</li><li>%w 星期（0-6），星期天为星期的开始</li><li>%W 一年中的星期数（00-53）星期一为星期的开始</li><li>%x 本地相应的日期表示</li><li>%X 本地相应的时间表示</li><li>%Z 当前时区的名称</li><li>%% %号本身</li></ul><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Python time sleep() 方法推迟调用线程的运行，可通过参数secs指秒数，表示进程挂起的时间。 </p><p>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.sleep(t)</span><br></pre></td></tr></table></figure><h2 id="commands模块-3-x已废弃"><a href="#commands模块-3-x已废弃" class="headerlink" title="commands模块-3.x已废弃"></a>commands模块-3.x已废弃</h2><p>用Python写运维脚本时，经常需要执行linux shell的命令，Python中的commands模块专门用于调用Linux shell命令，并返回状态和结果。</p><p>下面是commands模块的几个主要方法： </p><h3 id="commands-getoutput-‘shell-command’"><a href="#commands-getoutput-‘shell-command’" class="headerlink" title="commands.getoutput(‘shell command’)"></a>commands.getoutput(‘shell command’)</h3><p>执行shell命令，返回结果（string类型）</p><p>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输出指定进程的pid</span><br><span class="line"></span><br><span class="line">wxh@wxh-virtual-machine:~/python_files$ cat tt.py</span><br><span class="line">#!/usr/bin/env python2</span><br><span class="line">import sys,commands</span><br><span class="line">cmdline = sys.argv[1]</span><br><span class="line">cmdline1 = sys.argv[2]</span><br><span class="line"></span><br><span class="line">cmd = &quot;ps -ef|grep &quot; + cmdline + &quot;|grep &quot; + cmdline1 + &quot;|grep -v grep|grep -v python|awk &apos;&#123;print $2&#125;&apos;&quot;</span><br><span class="line"></span><br><span class="line">c1 = commands.getoutput(cmd)</span><br><span class="line">print (c1)</span><br><span class="line">print (type(c1))</span><br></pre></td></tr></table></figure><p>执行后输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-virtual-machine:~/python_files$ python2 ./tt.py unity-panel-service lockscreen-mode</span><br><span class="line"></span><br><span class="line">126263</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="commands-getstatusoutput-‘shell-command’"><a href="#commands-getstatusoutput-‘shell-command’" class="headerlink" title="commands.getstatusoutput(‘shell command’)"></a>commands.getstatusoutput(‘shell command’)</h3><p>执行shell命令, 返回两个元素的元组tuple(status, result)，status为int类型，result为string类型。</p><p>因为cmd的执行方式是{ cmd ; } 2&gt;&amp;1, 故返回结果包含标准输出和标准错误.</p><ul><li>第一个值为命令执行的返回状态码，执行成功则返回的是0，不成功则返回的是非0</li></ul><p>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-virtual-machine:~/python_files$ cat tt.py </span><br><span class="line">#!/usr/bin/env python2</span><br><span class="line">import sys,commands</span><br><span class="line">cmdline = sys.argv[1]</span><br><span class="line">cmdline1 = sys.argv[2]</span><br><span class="line"></span><br><span class="line">cmd = &quot;ps -ef|grep &quot; + cmdline + &quot;|grep &quot; + cmdline1 + &quot;|grep -v grep|grep -v python|awk &apos;&#123;print $2&#125;&apos;&quot;</span><br><span class="line">res = commands.getstatusoutput(cmd)</span><br><span class="line">print (res)</span><br></pre></td></tr></table></figure><p>执行后输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-virtual-machine:~/python_files$ python2 ./tt.py unity-panel-service lockscreen-mode</span><br><span class="line">(0, &apos;126263&apos;)</span><br></pre></td></tr></table></figure><h1 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h1><p>用于检测linux进程的状态</p><p>实例如下：</p><pre><code>def redis_status(new_port):    p = subprocess.Popen([&quot;netstat&quot;, &quot;-unptl&quot;], stdout=subprocess.PIPE)    out, err = p.communicate()    if (new_port in str(out) ):        print (&quot;redis {PORT} instance is running...&quot;.format(PORT=new_port))    else:        print (&quot;start redis {PORT} faild.please check again...&quot;.format(PORT=new_port))</code></pre><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="truncate-方法"><a href="#truncate-方法" class="headerlink" title="truncate() 方法"></a>truncate() 方法</h3><p><strong>truncate()</strong> 方法用于截断文件，如果指定了可选参数 size，则表示截断文件的 size 个字符。 </p><p>如果没有指定 size，则从当前位置起截断（截断余下的所有字符）；截断之后 size 后面的所有字符被删除。 </p><h3 id="seek-方法"><a href="#seek-方法" class="headerlink" title="seek()方法"></a>seek()方法</h3>]]></content>
    
    <summary type="html">
    
      python模块
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>网卡中断与CPU绑定</title>
    <link href="http://yoursite.com/2018/07/11/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E4%B8%8ECPU%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/07/11/IT科学技术知识体系结构-Linux运维方向/性能调优/网络调优/网卡中断与CPU绑定/</id>
    <published>2018-07-11T07:01:32.000Z</published>
    <updated>2018-07-11T07:01:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><p><a href="https://www.cnblogs.com/bamanzi/p/linux-irq-and-cpu-affinity.html" target="_blank" rel="noopener">Linux 性能调优] 网卡中断与CPU的绑定问题</a></p></li><li><p><a href="http://noican.blog.51cto.com/4081966/1355357" target="_blank" rel="noopener">简单介绍下linux下的中断（interrupt）- 一切皆有可能 - 51CTO技术博客</a></p></li><li><a href="https://segmentfault.com/a/1190000006178824" target="_blank" rel="noopener">把网卡中断绑定到CPU,最大化网卡的吞吐量 - SegmentFault</a></li><li><a href="http://www.vpsee.com/2010/07/load-balancing-with-irq-smp-affinity/" target="_blank" rel="noopener">Linux 多核下绑定硬件中断到不同 CPU（IRQ Affinity） | vpsee.com</a></li><li><p><a href="http://www.jianshu.com/p/6beacca6fdcd" target="_blank" rel="noopener">Linux系统CPU的性能监控及调优 - 简书</a></p></li><li><p><a href="https://www.chinanetcloud.com/en/info-center/blog/tech-items-linux-nic-interrupts-overloading-single-cpus/" target="_blank" rel="noopener">Tech Items - Linux NIC Interrupts Overloading Single CPUs - ChinaNetCloud</a> </p></li><li><p><a href="http://www.tuicool.com/articles/naUnia" target="_blank" rel="noopener">Linux网卡中断使单个CPU过载 - 推酷</a> </p></li><li><p><a href="http://wwdhks.blog.51cto.com/839773/1218785" target="_blank" rel="noopener">网卡软中断调优 - deven的博客 - 51CTO技术博客</a> </p></li></ul><p><strong>除了不让多个中断集中到单个CPU，还有更进一步的方法:</strong>  </p><p>调整网卡驱动参数使之采用多个队列，这样多个CPU可以各自处理一个队列。</p><p>当然，这依赖于网卡是否支持 </p><ul><li><a href="http://www.ywnds.com/?p=4380" target="_blank" rel="noopener">多队列网卡及网卡中断绑定阐述 – 运维那点事</a> (这篇文章讲得很全面，推荐阅读） </li><li><a href="http://blog.csdn.net/wyaibyn/article/details/14109325" target="_blank" rel="noopener">网卡多队列及中断绑定 - wyaibyn的专栏 - CSDN博客</a> </li><li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rss.html" target="_blank" rel="noopener">8.6. Receive-Side Scaling (RSS) - Performance Tuning Guide - Red Hat Enterprise Linux 6</a>  </li></ul><p>即使网卡只支持单个队列，我们可以在系统层面模拟层多个队列，这个涉及到被称为Receive Packet Steering (RFS)和Receive Flow Steering (RFS）的两个技术  </p><ul><li><p><a href="http://www.ywnds.com/?p=4380" target="_blank" rel="noopener">多队列网卡及网卡中断绑定阐述 – 运维那点事</a> </p></li><li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rps.html" target="_blank" rel="noopener">8.7. Receive Packet Steering (RPS) - Performance Tuning Guide - Red Hat Enterprise Linux 6</a></p></li><li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rfs.html" target="_blank" rel="noopener">8.8. Receive Flow Steering (RFS) - Performance Tuning Guide - Red Hat Enterprise Linux 6</a> </li></ul><hr><p>在Linux的网络调优方面，如果你发现网络流量上不去，那么有一个方面需要去查一下：网卡处理网络请求的中断是否被绑定到单个CPU（或者说跟处理其它中断的是同一个CPU）。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>网卡与操作系统的交互一般有两种方式：</p><ul><li>一种是中断（IRQ，网卡在收到了网络信号之后，主动发送中断到CPU，而CPU将会立即停下手边的活以便对这个中断信号进行分析），</li><li>另一种叫DMA（Direct Memory Access, 也就是允许硬件在无CPU干预的情况下将数据缓存在指定的内存空间内，在CPU合适的时候才处理）</li></ul><p>在网卡方面，大部分还是在用IRQ方式（据说DMA技术仅仅被应用在少数高端网卡上; 另一个说法是：DMA方式会使外部设备的控制器独占PCI总线，从而CPU无法与外部设备进行交互，这对通用型操作系统Linux来说，是很难接收的，所以DMA方式在Linux内核里使用得很少）。</p><p>但是（再来一个但是），在现在的对称多核处理器（SMP）上，一块网卡的IRQ还是只有一个CPU来响应，其它CPU无法参与，如果这个CPU还要忙其它的中断（其它网卡或者其它使用中断的外设（比如磁盘）），那么就会形成瓶颈。</p><h1 id="问题判定"><a href="#问题判定" class="headerlink" title="问题判定"></a>问题判定</h1><p>网上不少讲这个问题的文章都是直接让查询IRQ跟CPU的绑定情况，甚至直接修改。但我们应该先判断我们的系统是不是受这个问题影响，然后再来看怎么解决。</p><p>首先，让你的网络跑满（比如对于MySQL/MongoDB服务，可以通过客户端发起密集的读操作; 或者执行一个i大文件传送任务）</p><p>第一个要查明的是：<strong>是不是某个CPU在一直忙着处理IRQ？</strong></p><p>这个问题我们可以从 <code>mpstat -P ALL 1</code> 的输出中查明：里面的 <code>%irq</code>一列即说明了CPU忙于处理中断的时间占比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">18:20:33     CPU   %user   %nice    %sys %iowait    %irq   %soft  %steal   %idle    intr/s</span><br><span class="line">18:20:33     all    0,23    0,00    0,08    0,11    6,41    0,02    0,00   93,16   2149,29</span><br><span class="line">18:20:33       0    0,25    0,00    0,12    0,07    0,01    0,05    0,00   99,49    127,08</span><br><span class="line">18:20:33       1    0,14    0,00    0,03    0,04    0,00    0,00    0,00   99,78      0,00</span><br><span class="line">18:20:33       2    0,23    0,00    0,02    0,03    0,00    0,00    0,00   99,72      0,02</span><br><span class="line">18:20:33       3    0,28    0,00    0,15    0,28   25,63    0,03    0,00   73,64   2022,19</span><br></pre></td></tr></table></figure><p>上面的例子中，第四个CPU有25.63%时间在忙于处理中断（这个数值还不算高，如果高达80%（而同时其它CPU这个数值很低）以上就说明有问题了），后面那个 intr/s 也说明了CPU每秒处理的中断数（从上面的数据也可以看出，其它几个CPU都不怎么处理中断）。</p><p>然后我们就要接着查另外一个问题：<strong>这个忙于处理中断的CPU都在处理哪个（些）中断？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupts </span><br><span class="line">           CPU0       CPU1       CPU2       CPU3       </span><br><span class="line">  0:        245          0          0    7134094    IO-APIC-edge  timer</span><br><span class="line">  8:          0          0         49          0    IO-APIC-edge  rtc</span><br><span class="line">  9:          0          0          0          0   IO-APIC-level  acpi</span><br><span class="line"> 66:         67          0          0          0   IO-APIC-level  ehci_hcd:usb2</span><br><span class="line"> 74:     902214          0          0          0         PCI-MSI  eth0</span><br><span class="line">169:          0          0         79          0   IO-APIC-level  ehci_hcd:usb1</span><br><span class="line">177:          0          0          0    7170885   IO-APIC-level  ata_piix, b4xxp</span><br><span class="line">185:          0          0          0      59375   IO-APIC-level  ata_piix</span><br><span class="line">NMI:          0          0          0          0 </span><br><span class="line">LOC:    7104234    7104239    7104243    7104218 </span><br><span class="line">ERR:          0</span><br><span class="line">MIS:          0</span><br></pre></td></tr></table></figure><p>这里记录的是自启动以来，每个CPU处理各类中断的数量（第一列是中断号，最后一列是对应的设备名）[详细说明: <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/s2-proc-interrupts.html" target="_blank" rel="noopener">E.2.10 /proc/interrupts - Deployment Guide - RedHat Enterprise Linux 6</a> )，从上面可以看到： <code>eth0</code>所出发的中断全部都是 <code>CPU0</code>在处理，而CPU0所处理的中断请求中，主要是eth0和LOC中断。</p><p>（有时我们会看到几个CPU对同一个中断类型所处理的的请求数相差无几（比如上面的LOC一行），这并不一定是说多个CPU会轮流处理同一个中断，而是因为这里记录的是“自启动以来”的统计，中间可能因为irq balancer重新分配过处理中断的CPU——当然，也可能是谁手工调节过）。</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>首先说明几点：</p><ol><li>首先应该根据上面的诊断方法查明当前系统是不是受这个原因影响，如果不是，那么就没有必要往下看了;</li><li>现在的多数Linux系统中已经有了IRQ Balance这个服务（服务程序一般是 <code>/usr/sbin/irqbalance</code>），它可以自动调节分配各个中断与CPU的绑定关系，以避免所有中断的处理都集中在少数几个CPU上;</li><li>在某些情况下，这个IRQ Balance反而会导致问题，会出现 irqbalance 这个进程反而自身占用了较高的CPU（当然也就影响了业务系统的性能）</li></ol><p>下面来说手工将中断限定到少数几个CPU的方法。</p><p>首先当然要查明，该网卡的中断当前是否已经限定到某些CPU了？具体是哪些CPU？</p><p>根据上面 <code>/proc/interrupts</code> 的内容我们可以看到 eth0 的中断号是74，然后我们来看看该中断号的CPU绑定情况（或者说叫亲和性 affinity）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /proc/irq/74/smp_affinity</span><br><span class="line">ffffff</span><br></pre></td></tr></table></figure><p>这个输出是一个16进制的数值，<code>0xffffff = ‘0b111111111111111111111111’</code>，这就意味着这里有24个CPU，所有位都为1表示所有CPU都可以被该中断干扰。</p><p>另一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /proc/irq/67/smp_affinity</span><br><span class="line">00000001</span><br></pre></td></tr></table></figure><p>这个例子说明，只有CPU0处理编号为67的中断。</p><p><strong>修改配置的方法</strong>：</p><p>我们可以用 <code>echo 2 &gt; /proc/irq/74/smp_affinity</code> 的方法来修改这个设置（设置为2表示将该中断绑定到CPU1上，0x2 = 0b10，而第一个CPU为CPU0）</p>]]></content>
    
    <summary type="html">
    
      网卡中断与CPU绑定
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="性能调优" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="网络调优" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>LVS性能指标及监控</title>
    <link href="http://yoursite.com/2018/07/10/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/4%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-LVS/LVS%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%8F%8A%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2018/07/10/IT科学技术知识体系结构-Linux运维方向/高并发/负载均衡/4层负载均衡-LVS/LVS性能指标及监控/</id>
    <published>2018-07-10T08:08:26.000Z</published>
    <updated>2018-07-10T08:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考文献：</strong></p><ul><li><a href="http://kb.linuxvirtualserver.org/wiki/Performance_and_Tuning" target="_blank" rel="noopener">Performance and Tuning - LVSKB</a></li></ul><h1 id="性能参数"><a href="#性能参数" class="headerlink" title="性能参数"></a>性能参数</h1><p>LVS 的性能主要通过以下几个方面来提高</p><h2 id="ipvs-connection-table-size-最大连接数"><a href="#ipvs-connection-table-size-最大连接数" class="headerlink" title="ipvs connection table size-最大连接数"></a>ipvs connection table size-最大连接数</h2><p>官方的解释如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">The IPVS connection hash table uses the chaining scheme to handle</span><br><span class="line">hash collisions. Using a big IPVS connection hash table will greatly</span><br><span class="line">reduce conflicts when there are hundreds of thousands of connections</span><br><span class="line">in the hash table.</span><br><span class="line"></span><br><span class="line">Note the table size must be power of 2. The table size will be the</span><br><span class="line">value of 2 to the your input number power. The number to choose is</span><br><span class="line">from 8 to 20, the default number is 12, which means the table size</span><br><span class="line">is 4096. Don&apos;t input the number too small, otherwise you will lose</span><br><span class="line">performance on it. You can adapt the table size yourself, according</span><br><span class="line">to your virtual server application. It is good to set the table size</span><br><span class="line">not far less than the number of connections per second multiplying</span><br><span class="line">average lasting time of connection in the table.  For example, your</span><br><span class="line">virtual server gets 200 connections per second, the connection lasts</span><br><span class="line">for 200 seconds in average in the connection table, the table size</span><br><span class="line">should be not far less than 200x200, it is good to set the table</span><br><span class="line">size 32768 (2**15).</span><br><span class="line"></span><br><span class="line">Another note that each connection occupies 128 bytes effectively and</span><br><span class="line">each hash entry uses 8 bytes, so you can estimate how much memory is</span><br><span class="line">needed for your box.</span><br><span class="line"></span><br><span class="line">You can overwrite this number setting conn_tab_bits module parameter</span><br><span class="line">or by appending ip_vs.conn_tab_bits=? to the kernel command line</span><br><span class="line">if IP VS was compiled built-in.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><p>LVS的连接信息使用<code>IPVS connection hash table</code>这个哈希表去保存，它记录每个进来的连接及路由去向的信息 </p><blockquote><p>任何一个报文到达都需要查找连接Hash表。Hash表的查找复杂度为O(n/m)，其中n为Hash表中对象的个数，m为Hash表的桶个数。当对象在Hash表中均匀分布和Hash表的桶个数与对象个数一样多时，Hash表的查找复杂度可以接近O(1)。 </p></blockquote></li><li><p><code>table size</code>使用2的幂次方进行配置指定，范围为8-20，也就是说连接数的取值范围为：2^8-2^20</p></li><li><p>默认配置为2^12，也就是4096个连接数上限</p></li><li><p>在生产环境中，我们一般设置为最大值，也就是2^20（1048576）</p></li><li><p>注意，这些连接是需要占用内存的，因此要考虑到内存大小的因素</p><blockquote><p>每一个TCP连接需要占用约128字节，哈希表的每个条目需要占用8字节</p><p>以设置为最大值为例，那么，这些连接以及条目共占用内存如下：</p><p>2^20*(128byte+8byte) = 142606336byte = 136MB</p></blockquote></li></ul><p><strong>配置：</strong></p><p>在/etc/modprobe.d/目录下添加文件ip_vs.conf，内容为：</p><p>options ip_vs conn_tab_bits=22（文档中写的上限是20，但是实际配置的时候发现22也是可以的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;options ip_vs conn_tab_bits=22&apos; &gt; /etc/modprobe.d/ipvs.conf</span><br><span class="line">modprobe -r ip_vs &amp;&amp; modprobe -a ip_vs</span><br><span class="line">ipvsadm -Ln</span><br></pre></td></tr></table></figure><p>注意，在卸载内核模块的时候，可能会有依赖关系，这时候使用lsmod先查看依赖调用关系，将调用的模块卸载之后再进行操作，例如，这里的操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# modprobe -r ip_vs_rr</span><br><span class="line">[root@lvs001 modprobe.d]# modprobe -r ip_vs</span><br><span class="line">[root@lvs001 modprobe.d]# modprobe -a ip_vs</span><br><span class="line">[root@lvs001 modprobe.d]# modprobe -a ip_vs_rr</span><br></pre></td></tr></table></figure><h2 id="CPU-Soft-Interrupt-CPU软中断"><a href="#CPU-Soft-Interrupt-CPU软中断" class="headerlink" title="CPU Soft Interrupt -CPU软中断"></a>CPU Soft Interrupt -CPU软中断</h2><p>在Linux的网络调优方面，如果你发现网络流量上不去，那么有一个方面需要去查一下：<strong>网卡处理网络请求的中断是否被绑定/发送到单个CPU，导致只有一个CPU处于网络请求</strong></p><p>但是，在当前的对称多核处理器服务器上，一块网卡的IRQ还是只有一个CPU来响应，其它CPU无法参与，如果这个CPU还要忙其它的中断（其它网卡或者其它使用中断的外设（比如磁盘）），那么就会形成瓶颈。 </p><p><strong>动态查看CPU的irq情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令：mpstat -P ALL 1 </span><br><span class="line">%irq一列即说明了CPU忙于处理中断的时间占比</span><br></pre></td></tr></table></figure><p><strong>查看CPU处理中断的情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupts </span><br><span class="line">这里记录的是自启动以来，每个CPU处理各类中断的数量（第一列是中断号，最后一列是对应的设备名）</span><br></pre></td></tr></table></figure><p>我们进行过滤，获取网卡的中断号，然后再分析CPU的中断情况</p><p>获取对应的中断号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 ~]# cat /proc/interrupts  | egrep &apos;em1|em2|p1p1|p1p2&apos; | awk &apos;&#123;print $1&#125;&apos;</span><br><span class="line">157:</span><br><span class="line">158:</span><br><span class="line">159:</span><br><span class="line">160:</span><br><span class="line">161:</span><br><span class="line">162:</span><br><span class="line">163:</span><br><span class="line">164:</span><br><span class="line">165:</span><br><span class="line">166:</span><br><span class="line">167:</span><br><span class="line">168:</span><br><span class="line">169:</span><br><span class="line">170:</span><br><span class="line">171:</span><br><span class="line">172:</span><br><span class="line">173:</span><br><span class="line">174:</span><br><span class="line">175:</span><br><span class="line">176:</span><br></pre></td></tr></table></figure><p>获取CPU的处理信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 ~]# for i in &#123;157..176&#125;;do cat /proc/interrupts  | egrep -w $i ;done</span><br><span class="line"> 157:   13529132          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-tx-0</span><br><span class="line"> 158:   32642550          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-1</span><br><span class="line"> 159:   30481981          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-2</span><br><span class="line"> 160:   15555217          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-3</span><br><span class="line"> 161:   25509530          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-4</span><br><span class="line"> 162:   13538297          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-tx-0</span><br><span class="line"> 163:   25653580          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-1</span><br><span class="line"> 164:   25741710          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-2</span><br><span class="line"> 165:   35448970          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-3</span><br><span class="line"> 166:   25494937          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-4</span><br><span class="line"> 167:     256824          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-tx-0</span><br><span class="line"> 168:     281534          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-1</span><br><span class="line"> CAL:        133     863797        189        189        189        189        188        189        189        189        189        189        189        189        189        189        188        188        168        185        188        186        188        188        188        188        188        188        188        189        187        130   Function call interrupts</span><br><span class="line"> 169:      64639          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-2</span><br><span class="line"> 170:      65879          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-3</span><br><span class="line"> 171:     425700          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-4</span><br><span class="line"> 172:     256754          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-tx-0</span><br><span class="line"> 173:      43230          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-1</span><br><span class="line"> 174:          4          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-2</span><br><span class="line"> 175:          5          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-3</span><br><span class="line"> 176:          3          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-4</span><br><span class="line">[root@lvs001 ~]#</span><br></pre></td></tr></table></figure><p>这里显示不友好，建议复制到编辑器中查看</p><p>可以看到，这些网卡的中断都是由CPU0来处理的</p><p><strong>查看</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs002 ~]# for i in &#123;157..176&#125;;do cat /proc/irq/$i/smp_affinity;done</span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;157..176&#125;;do echo ffffffff &gt; /proc/irq/$i/smp_affinity;done</span><br></pre></td></tr></table></figure><h2 id="Netfilter-Connection-Track-连接跟踪"><a href="#Netfilter-Connection-Track-连接跟踪" class="headerlink" title="Netfilter Connection Track-连接跟踪"></a>Netfilter Connection Track-连接跟踪</h2><p><strong>原文：</strong></p><p><a href="http://kb.linuxvirtualserver.org/wiki/IPVS" target="_blank" rel="noopener">IPVS</a> uses its own simple and fast connection tracking for performance reasons, instead of using netfilter connection tracking. So, if you don’t use firewalling feature at <a href="http://kb.linuxvirtualserver.org/wiki/Load_balancer" target="_blank" rel="noopener">load balancer</a> and you need an extremely fast load balancer, do not load netfilter conntrack modules into you system, because there is no need to do double tracking. Note that <a href="http://kb.linuxvirtualserver.org/wiki/LVS/NAT" target="_blank" rel="noopener">LVS/NAT</a> should work too without the conntrack modules.</p><p>Julian compared the performance of IPVS with ip_conntrack and without ip_conntrack. See <a href="http://archive.linuxvirtualserver.org/html/lvs-users/2001-12/msg00141.html" target="_blank" rel="noopener">http://archive.linuxvirtualserver.org/html/lvs-users/2001-12/msg00141.html</a></p><p>默认情况下LVS自身会记录连接信息，但是 iptables 也会记录 connection 的状态，但是很多情况下，我们并不需要 iptables 来做这件事，</p><p>我们可以告诉它 NOTRACK，不要记录这些信息。</p><p><strong>配置：</strong></p><p>增加raw表，在其他表处理之前，-j NOTRACK跳过其它表处理 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -t raw -A PREROUTING -d 103.13.244.16/29 -p tcp --dport 80 -j NOTRACK </span><br><span class="line">iptables -t raw -A OUTPUT -d 103.13.244.16/29 -p tcp --dport 80 -j NOTRACK </span><br><span class="line">iptables -t raw -A PREROUTING -d 103.13.244.16/29 -p tcp --dport 443 -j NOTRACK </span><br><span class="line">iptables -t raw -A OUTPUT -d 103.13.244.16/29 -p tcp --dport 443 -j NOTRACK </span><br><span class="line"></span><br><span class="line">[root@lvs002 ~]# /etc/init.d/iptables  save</span><br></pre></td></tr></table></figure><p>与之同时，因为涉及到内网之间的通信，因此这里也将连接跟踪表进行调大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">net.netfilter.nf_conntrack_max = 3065536 </span><br><span class="line">net.nf_conntrack_max = 3065536 </span><br><span class="line"></span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure><h2 id="Real-Server-syn-cookie参数"><a href="#Real-Server-syn-cookie参数" class="headerlink" title="Real Server - syn cookie参数"></a>Real Server - syn cookie参数</h2><p>参考链接：</p><ul><li><a href="https://link.zhihu.com/?target=http%3A//archive.linuxvirtualserver.org/html/lvs-users/2013-05/msg00020.html" target="_blank" rel="noopener">lvs-users IPVS SYN-cookies</a>  </li></ul><p>SYN Cookie是对TCP服务器端的<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">三次握手协议</a>作一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP ACK包时，TCP服务器在根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。 </p><p>SYN Flood攻击利用的是IPv4中TCP协议的<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" target="_blank" rel="noopener">三次握手</a>（Three-Way Handshake）过程进行的攻击。TCP协议规定，一端向另一端发起TCP连接时，它需要首先发送SYN 包到对方，对方收到后发送一个SYN+ACK包回来，发起方再发送 ACK包回去，这样<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" target="_blank" rel="noopener">三次握手</a>就结束了。我们把TCP连接的发起方叫作”TCP客户机（TCP Client）”，TCP连接的接收方叫作”TCP服务器（TCP Server）”。值得注意的是在TCP服务器收到TCP SYN request包时，在发送TCP SYN+ACK包回TCP客户机前，TCP服务器要先分配好一个数据区专门服务于这个即将形成的TCP连接。一般把收到SYN包而还未收到ACK包时的连接状态称为半开连接（Half-open Connection）。</p><p>在最常见的SYN Flood攻击中，攻击者在短时间内发送大量的TCP SYN包给受害者，这时攻击者是TCP客户机，受害者是TCP服务器。根据上面的描述，受害者会为每个TCP SYN包分配一个特定的数据区，只要这些SYN包具有不同的源地址（这一点对于攻击者来说是很容易伪造的）。这将给TCP<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">服务器系统</a>造成很大的系统负担，最终导致系统不能正常工作。</p><p><a href="https://github.com/torvalds/linux/blob/6b15d6650c5301ce023d8df0cc3a60b1a76d377e/Documentation/networking/ip-sysctl.txt#L66" target="_blank" rel="noopener">内核文档说明</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">tcp_syncookies - BOOLEAN</span><br><span class="line">Only valid when the kernel was compiled with CONFIG_SYN_COOKIES</span><br><span class="line">Send out syncookies when the syn backlog queue of a socket</span><br><span class="line">overflows. This is to prevent against the common &apos;SYN flood attack&apos;</span><br><span class="line">Default: 1</span><br><span class="line"></span><br><span class="line">Note, that syncookies is fallback facility.</span><br><span class="line">It MUST NOT be used to help highly loaded servers to stand</span><br><span class="line">against legal connection rate. If you see SYN flood warnings</span><br><span class="line">in your logs, but investigationshows that they occur</span><br><span class="line">because of overload with legal connections, you should tune</span><br><span class="line">another parameters until this warning disappear.</span><br><span class="line">See: tcp_max_syn_backlog, tcp_synack_retries, tcp_abort_on_overflow.</span><br><span class="line"></span><br><span class="line">syncookies seriously violate TCP protocol, do not allow</span><br><span class="line">to use TCP extensions, can result in serious degradation</span><br><span class="line">of some services (f.e. SMTP relaying), visible not by you,</span><br><span class="line">but your clients and relays, contacting you. While you see</span><br><span class="line">SYN flood warnings in logs not being really flooded, your server</span><br><span class="line">is seriously misconfigured.</span><br><span class="line"></span><br><span class="line">If you want to test which effects syncookies have to your</span><br><span class="line">network connections you can set this knob to 2 to enable</span><br><span class="line">unconditionally generation of syncookies.</span><br></pre></td></tr></table></figure><p>注意，即使开启该机制并不意味着所有的连接都是用SYN cookies机制来完成连接的建立，只有在半连接队列已满的情况下才会触发SYN cookies机制。由于SYN cookies机制严重违背TCP协议，不允许使用TCP扩展，可能对某些服务造成严重的性能影响（如SMTP转发），对于防御SYN flood攻击的确有效。对于没有收到攻击的高负载服务器，不要开启此选项，可以通过修改tcp_max_syn_backlog、tcp_synack_retries和tcp_abort_on_overflow系统参数来调节。</p><p>tcp_max_syn_backlog变量告诉你在内存中可以缓存多少个SYN请求。该变量需要打开tcp_syncookies才有效。如果服务器负载很高，可以尝试提高该变量的值。</p><p>tcp_synack_retries变量用于TCP三次握手机制中第二次握手，当收到客户端发来的SYN连接请求后，服务端将回复SYN+ACK包，这时服务端处于SYN_RCVD状态，并等 待客户端发来的回复ACK包。如果服务端没有收到客户端的ACK包，会重新发送SYN+ACK包，直到收到客户端的ACK包。该变量设置发送 SYN+ACK包的次数，超过这个次数，服务端将放弃连接。默认值是5。</p><p>tcp_abort_on_overflow变量的值是个布尔值，默认值为0（FALSE关闭）。如果开启，当服务端接收新连接的速度变慢时，服务端会发送RST包（reset包）给客户端，令客户端 重新连接。这意味着如果突然发生溢出，将重获连接。仅当你真的确定不能通过调整监听进程使接收连接的速度变快，可以启用该选项。该选项会影响到客户的连接。</p><p><strong>配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sysctl.conf </span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 2048</span><br><span class="line">保存退出后，执行：</span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><p>net.ipv4.tcp_syncookies = 1<br>#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN<em>*</em>，默认为0，表示关闭；</p><p>net.ipv4.tcp_tw_reuse = 1<br>#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；为1，开启；</p><p>这个酌情开启，这里暂时不开启</p><p>net.ipv4.tcp_tw_recycle = 1<br>#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；为1，开启；</p><p>net.ipv4.tcp_fin_timeout</p><p>#修改系統默认的 TIMEOUT 时间，<strong>这里根据服务器的实际情况设置</strong>。默认为60秒</p><p>  另外细心的朋友可能发现了，报错信息： Possible SYN flooding on port 13370. Sending cookies.后面跟了句”Check SNMP counters”。这句我当时差点被误导，因为我的服务器上正好跑了一个snmp抓流量的服务，开始以为是它导致的，后来一想那是udp的协议，和tcp没关系呀。查了<a href="https://github.com/torvalds/linux/blob/797cee982eef9195736afc5e7f3b8f613c41d19a/net/ipv4/tcp_input.c" target="_blank" rel="noopener">kernel</a>的代码发现，原来那是print打印的固定info输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static bool tcp_syn_flood_action(const struct sock *sk,</span><br><span class="line">                const struct sk_buff *skb,</span><br><span class="line">                const char *proto)</span><br><span class="line">&#123;</span><br><span class="line">    struct request_sock_queue *queue = &amp;inet_csk(sk)-&gt;icsk_accept_queue;</span><br><span class="line">    const char *msg = &quot;Dropping request&quot;;</span><br><span class="line">    bool want_cookie = false;</span><br><span class="line">    struct net *net = sock_net(sk);</span><br><span class="line">#ifdef CONFIG_SYN_COOKIES</span><br><span class="line">    if (net-&gt;ipv4.sysctl_tcp_syncookies) &#123;</span><br><span class="line">        msg = &quot;Sending cookies&quot;;</span><br><span class="line">        want_cookie = true;</span><br><span class="line">        __NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPREQQFULLDOCOOKIES);</span><br><span class="line">    &#125; else</span><br><span class="line">#endif</span><br><span class="line">        __NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPREQQFULLDROP);</span><br><span class="line">    if (!queue-&gt;synflood_warned &amp;&amp;</span><br><span class="line">    net-&gt;ipv4.sysctl_tcp_syncookies != 2 &amp;&amp;</span><br><span class="line">    xchg(&amp;queue-&gt;synflood_warned, 1) == 0)</span><br><span class="line">        pr_info(&quot;%s: Possible SYN flooding on port %d. %s.  Check SNMP counters.\n&quot;,</span><br><span class="line">            proto, ntohs(tcp_hdr(skb)-&gt;dest), msg);</span><br><span class="line">    return want_cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭网卡LRO和GRO"><a href="#关闭网卡LRO和GRO" class="headerlink" title="关闭网卡LRO和GRO"></a>关闭网卡LRO和GRO</h2><p>现在大多数网卡都具有LRO/GRO功能，即 网卡收包时将同一流的小包合并成大包 （tcpdump抓包可以看到&gt;MTU 1500bytes的数据包）交给 内核协议栈；LVS内核模块在处理&gt;MTU的数据包时，会丢弃；</p><p>因此，如果我们用LVS来传输大文件，很容易出现丢包，传输速度慢；</p><p>解决方法，关闭LRO/GRO功能，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ethtool -k eth0 查看LRO/GRO当前是否打开</span><br><span class="line">ethtool -K eth0 lro off 关闭GRO</span><br><span class="line">ethtool -K eth0 gro off 关闭GRO</span><br><span class="line"></span><br><span class="line">查看：</span><br><span class="line">[root@lvs001 ~]# ethtool -k p1p1 | grep offload</span><br><span class="line">[root@lvs001 ~]# ethtool -k p1p2 | grep offload</span><br><span class="line"></span><br><span class="line">配置：</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p1 lro off</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p1 gro off</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p2 lro off</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p2 gro off</span><br></pre></td></tr></table></figure><p>offload特性，主要是指将原本在协议栈中进行的IP分片、TCP分段、重组、checksum校验等操作，转移到网卡硬件中进行，降低系统CPU的消耗，提高处理性能。 </p><p>包括 LSO/LRO、GSO/GRO、TSO/UFO 等。</p><p><strong>LSO/LRO</strong></p><p>分别对应到发送和接收两个方向，是 Large Segment Offload 和 Large Receive Offload。</p><p>首先来看 LSO。我们知道计算机网络上传输的数据基本单位是离散的网包，既然是网包，就有大小限制，这个限制就是 MTU（Maximum Transmission Unit）的大小，一般是1518字节。比如我们想发送很多数据出去，经过os协议栈的时候，会自动帮你拆分成几个不超过MTU的网包。然而，这个拆分是比较费计算资源的（比如很多时候还要计算分别的checksum），由 CPU 来做的话，往往会造成使用率过高。那可不可以把这些简单重复的操作 offload 到网卡上呢？</p><p>于是就有了 LSO，在发送数据超过 MTU 限制的时候（太容易发生了），OS 只需要提交一次传输请求给网卡，网卡会自动的把数据拿过来，然后进行切，并封包发出，发出的网包不超过 MTU 限制。</p><p>接下来看 LSO，当网卡收到很多碎片包的时候，LRO 可以辅助自动组合成一段较大的数据，一次性提交给 OS处理。</p><p>一般的，LSO 和 LRO 主要面向 TCP 报文。</p><p><strong>GSO/GRO</strong></p><p>Generic Segmentation Offload 和 Generic Receive Offload，分别比 LSO 和 LRO 更通用，自动检测网卡支持特性，支持分包则直接发给网卡，否则先分包后发给网卡。新的驱动一般用 GSO/GRO。 </p><p><strong>TSO/UFO</strong></p><p>TCP Segmentation Offload 和 UDP fragmentation offload，分别对应 TCP 报文和 UDP 报文。</p><p>很典型的，TCP 协议中就考虑了分片存在的情况，往往是切分 TCP 的数据包，叫做 TSO。而一般的情况，则称为 LSO 或者 GSO。</p><p>对于其他不支持切片的协议例如 UDP，则只能进行 IP 层上的切片。</p><p><strong>检查与开关</strong></p><p>可以通过 <code>ethtool -k eth0</code> 命令来查看各个选项的当前状态，注意输出中各种 off-load 选项的状态。 </p><p><strong>总结</strong></p><p>也就是说，在将数据包转发出去的时候，包的大小必须小于1500字节，但是在处理收到的数据包的时候，包的大小没有1500字节的限制</p><ul><li>发送模式：<ul><li>TSO</li><li>GSO</li><li>UFO</li></ul></li><li>接收模式：<ul><li>LRO</li><li>GRO</li><li>RSS</li></ul></li></ul><p><strong>注意</strong></p><p>目前常用的抓包工具大部分都是从协议栈中（如数据链路层）捕获数据包，而网卡的offload特性会将数据包的分片、重组等工作转移到协议栈以下的硬件层面进行，因此在开启TSO、GRO等机制的情况下，我们使用tcpdump、wireshark等工具抓取到的数据包往往不能真实反应链路上实际的数据帧，给网络流量特征的分析造成不利影响。</p><p>在某些情况下，例如分片攻击等攻击方式，甚至可能会因为网卡设备的offload机制处理，而规避防火墙、IDS以及人工的检查。针对这些情况，可以选择关闭网卡offload的相关选项，或者在链路的其他节点进行抓包。</p><h2 id="proc下的IP-VS参数设置"><a href="#proc下的IP-VS参数设置" class="headerlink" title="/proc下的IP_VS参数设置"></a>/proc下的IP_VS参数设置</h2><p>根据前文的介绍，可以通过ipvsadm命令和LVS内核打交道；</p><p>除此之外，我们还可以通过proc参数，来 配置全局参数 和 获取统计信息；</p><ul><li>配置全局参数，位于目录/proc/sys/net/ipv4/vs/下；</li><li>获取统计信息，位于目录/proc/net/下；</li></ul><p>参考资料：<a href="https://github.com/torvalds/linux/blob/master/Documentation/networking/ipvs-sysctl.txt#L41" target="_blank" rel="noopener">官方内核文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 ~]# ll /proc/sys/net/ipv4/vs | awk &apos;&#123;print $9&#125;&apos;</span><br><span class="line">am_droprate</span><br><span class="line">amemthresh</span><br><span class="line">cache_bypass</span><br><span class="line">conn_reuse_mode</span><br><span class="line">drop_entry</span><br><span class="line">drop_packet</span><br><span class="line">expire_nodest_conn</span><br><span class="line">expire_quiescent_template</span><br><span class="line">nat_icmp_send</span><br><span class="line">secure_tcp</span><br><span class="line">sync_qlen_max</span><br><span class="line">sync_refresh_period</span><br><span class="line">sync_retries</span><br><span class="line">sync_sock_size</span><br><span class="line">sync_threshold</span><br><span class="line">sync_version</span><br></pre></td></tr></table></figure><p>有一些几个参数需要进行调整</p><ul><li><p>cache_bypass </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cache_bypass - BOOLEAN</span><br><span class="line">        0 - disabled (default)</span><br><span class="line">        not 0 - enabled</span><br><span class="line"></span><br><span class="line">        If it is enabled, forward packets to the original destination</span><br><span class="line">        directly when no cache server is available and destination</span><br><span class="line">        address is not local (iph-&gt;daddr is RTN_UNICAST). It is mostly</span><br><span class="line">        used in transparent web cache cluster.</span><br></pre></td></tr></table></figure><p>主要用于缓存体系，enable之后，当后端配置的是缓存系统的时候，当没有可用的sever时，直接将数据包转发给后端的数据产生节点</p></li></ul><ul><li><p>conn_reuse_mode </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">conn_reuse_mode - INTEGER</span><br><span class="line">1 - default</span><br><span class="line"></span><br><span class="line">Controls how ipvs will deal with connections that are detected</span><br><span class="line">port reuse. It is a bitmap, with the values being:</span><br><span class="line"></span><br><span class="line">0: disable any special handling on port reuse. The new</span><br><span class="line">connection will be delivered to the same real server that was</span><br><span class="line">servicing the previous connection. This will effectively</span><br><span class="line">disable expire_nodest_conn.</span><br><span class="line"></span><br><span class="line">bit 1: enable rescheduling of new connections when it is safe.</span><br><span class="line">That is, whenever expire_nodest_conn and for TCP sockets, when</span><br><span class="line">the connection is in TIME_WAIT state (which is only possible if</span><br><span class="line">you use NAT mode).</span><br><span class="line"></span><br><span class="line">bit 2: it is bit 1 plus, for TCP connections, when connections</span><br><span class="line">are in FIN_WAIT state, as this is the last state seen by load</span><br><span class="line">balancer in Direct Routing mode. This bit helps on adding new</span><br><span class="line">real servers to a very busy cluster.</span><br></pre></td></tr></table></figure><p>用户后端server开启端口reuse（端口复用，服务器上启动多个进程监听同一个端口，在tenginx中使用时能够极大的提高性能）的情况。</p><p>当设置enable的时候，接受到新连接之后，将进行重新调度，将连接请求分发到启动该端口的其他进程上</p></li></ul><ul><li><p>expire_nodest_conn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">expire_nodest_conn - BOOLEAN</span><br><span class="line">        0 - disabled (default)</span><br><span class="line">        not 0 - enabled</span><br><span class="line"></span><br><span class="line">        The default value is 0, the load balancer will silently drop</span><br><span class="line">        packets when its destination server is not available. It may</span><br><span class="line">        be useful, when user-space monitoring program deletes the</span><br><span class="line">        destination server (because of server overload or wrong</span><br><span class="line">        detection) and add back the server later, and the connections</span><br><span class="line">        to the server can continue.</span><br><span class="line"></span><br><span class="line">        If this feature is enabled, the load balancer will expire the</span><br><span class="line">        connection immediately when a packet arrives and its</span><br><span class="line">        destination server is not available, then the client program</span><br><span class="line">        will be notified that the connection is closed. This is</span><br><span class="line">        equivalent to the feature some people requires to flush</span><br><span class="line">        connections when its destination is not available.</span><br></pre></td></tr></table></figure><p>设置为0时，当后端的server被检测为不可用时，不会立即将连接断开，而是会保持一段时间，让其自然过期失效，如果在这个过程当中，server又恢复正常，那么将继续使用这个连接</p><p>当设置为为enable（非0）时，当检测到后端的server不可用时，将会立即将这个连接关闭。</p></li></ul><ul><li><p>expire_quiescent_template </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">expire_quiescent_template - BOOLEAN</span><br><span class="line">0 - disabled (default)</span><br><span class="line">not 0 - enabled</span><br><span class="line"></span><br><span class="line">When set to a non-zero value, the load balancer will expire</span><br><span class="line">persistent templates when the destination server is quiescent.</span><br><span class="line">This may be useful, when a user makes a destination server</span><br><span class="line">quiescent by setting its weight to 0 and it is desired that</span><br><span class="line">subsequent otherwise persistent connections are sent to a</span><br><span class="line">different destination server.  By default new persistent</span><br><span class="line">connections are allowed to quiescent destination servers.</span><br><span class="line"></span><br><span class="line">If this feature is enabled, the load balancer will expire the</span><br><span class="line">persistence template if it is to be used to schedule a new</span><br><span class="line">connection and the destination server is quiescent.</span><br></pre></td></tr></table></figure></li></ul><p>  默认值为0，当RS的weight为0时（例如健康监测失败时，LB会将RS的权重重置为0），会话保持的新建连接还会继续调度到该RS上</p><p>  如果设置为非0，那么当weight为0时，LB会将话保持的连接模板置为无效，重新调度新的RS； </p><ul><li><p>sync_threshold</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sync_threshold - vector of 2 INTEGERs: sync_threshold, sync_period</span><br><span class="line">default 3 50</span><br><span class="line"></span><br><span class="line">It sets synchronization threshold, which is the minimum number</span><br><span class="line">of incoming packets that a connection needs to receive before</span><br><span class="line">the connection will be synchronized. A connection will be</span><br><span class="line">synchronized, every time the number of its incoming packets</span><br><span class="line">modulus sync_period equals the threshold. The range of the</span><br><span class="line">threshold is from 0 to sync_period.</span><br><span class="line"></span><br><span class="line">When sync_period and sync_refresh_period are 0, send sync only</span><br><span class="line">for state changes or only once when pkts matches sync_threshold</span><br></pre></td></tr></table></figure><p> 同步阈值设置，该文件中的值为两个整数，默认为3 50 </p><p>数值表示含义如下（以3 50为例）：接受到3个数据包及以上，该连接就可以被同步</p></li></ul><h2 id="Linux系统调优-网络内核参数"><a href="#Linux系统调优-网络内核参数" class="headerlink" title="Linux系统调优-网络内核参数"></a>Linux系统调优-网络内核参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_recyle=1</span><br><span class="line">net.ipv4.tcp_tw_reuse=1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=8192</span><br><span class="line">net.ipv4.tcp_keepalive_time=1800</span><br><span class="line">net.ipv4.tcp_fin_timeout=30</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.ipv4.tcp_rmem=4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem=4096 65536 16777216</span><br><span class="line">net.core.netdev_max_backlog=3000</span><br></pre></td></tr></table></figure><h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><p><strong>SH调度算法</strong>-<strong>尽量不要采用</strong>  </p><p>一些业务为了支持会话保持，选择SH调度算法，以实现 同一源ip的请求调度到同一台RS上；但 SH算法本省没有实现一致性hash，一旦一台RS down，当前所有连接都会断掉；如果配置了inhibit_on_failure，那就更悲剧了，调度到该RS上的流量会一直损失；     实际线上使用时，如需<strong>会话保持</strong>，建议配置<strong>persistence_timeout参数，</strong>保证一段时间同一源ip的请求到同一RS上； </p><p><strong>WLC调度算法-注意RS donw-&gt;up的影响</strong>    </p><p>WLC算法下，RS一旦出现down后up的情况，瞬间所有的新建连接都会调度到该RS上，可能会超过该RS处理请求的上限；  </p><h2 id="快速配置"><a href="#快速配置" class="headerlink" title="快速配置"></a>快速配置</h2><p>[root@lvs002 ~]# vim /etc/sysctl.conf </p><p>[root@lvs002 ~]# sysctl  -p</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">kernel.sysrq = 0</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line">net.core.netdev_max_backlog = 2048</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 462144</span><br><span class="line">vm.swappiness = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 65535</span><br><span class="line">net.core.somaxconn = 32768</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.netfilter.nf_conntrack_max = 3065536</span><br><span class="line">net.nf_conntrack_max = 3065536</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1800</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 16777216</span><br><span class="line">net.core.netdev_max_backlog = 3000</span><br></pre></td></tr></table></figure><h1 id="LVS监控"><a href="#LVS监控" class="headerlink" title="LVS监控"></a>LVS监控</h1><p>一般情况下，我们可以通过watch ipvsadm -ln来监视lvs的当前状态，但如果我们想分析一段时间（一周，一月或者更长）的连接数情况，ipvsadm就无能为力了。我们可以借助一个叫lvs-rrd的小工具来达到这个目的。</p><p>lvs-rrd官网链接：<a href="http://tepedino.org/lvs-rrd/" target="_blank" rel="noopener">http://tepedino.org/lvs-rrd/</a></p><p>但是在这里，由于这个工具只能收集连接数的数据，因此我们还是采用zabbix进行集中监控</p><h2 id="使用lvs-rrd监控lvs状态"><a href="#使用lvs-rrd监控lvs状态" class="headerlink" title="使用lvs-rrd监控lvs状态"></a>使用lvs-rrd监控lvs状态</h2><p><a href="http://www.tepedino.org/lvs-rrd/" target="_blank" rel="noopener">lvs_rrd</a>工具实现了网页的形式来查看lvs状态功能。</p><p>其主要有两个脚本组成：信息收集脚本和图像绘制脚本。</p><p>信息收集脚本是将lvs的信息生成rrd格式的数据文件，然后利用图像绘制脚本生成图像，并生成一个php页面，这个页面中引用其所生成的图像，这样我们可以通过web页面的形式查看生成的php页面，就可以时时的查看lvs的状态信息。</p><p>lvs_rrd需要部署在LVS-Master和LVS-Backup上，更准确的说lvs_rrd中的信息收集脚本一定要在LVS director 上运行（不能安装在其他服务器上）。</p><p>但是通过配置图像生成脚本和图像的生成目录，我们也可以将源数据时时的复制到其他的服务器中，再在其他服务器上生成图像展示</p><p>下面简单的介绍部署的步骤</p><p><strong>下载安装rrdtool（画图）工具</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://oss.oetiker.ch/rrdtool/pub/rrdtool-1.4.7.tar.gz</span><br><span class="line"></span><br><span class="line">yum -y install cairo-devel libxml2-devel pango-devel pango libpng-devel freetype freetype-devel libart_lgpl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker dejavu-lgc-sans-fonts</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/rrdtool</span><br><span class="line">make &amp;&amp;  make install </span><br><span class="line"></span><br><span class="line">echo &quot;/usr/local/rrdtool/lib&quot; &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><p><strong>安装nginx</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre pcre-devel php php-fpm</span><br><span class="line"></span><br><span class="line">useradd -s /sbin/nologin nginx</span><br><span class="line"></span><br><span class="line">wget https://nginx.org/download/nginx-1.14.0.tar.gz</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module --with-pcre</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>注意修改nginx的监听端口为非80</p><p><strong>nginx+php配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/php-fpm start</span><br><span class="line">chkconfig php-fpm on</span><br></pre></td></tr></table></figure><p>在nginx配置文件中添加以下内容</p><pre><code>location ~ \.php$ {    root           html;    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;    include        fastcgi_params;}</code></pre><p><strong>下载安装lvs-rrd工具</strong></p><p>这里使用最新的0.7版本，该版本要求rrdtool版本最低为： 1.2.x </p><p>将lvs-rrd-v0.7.tar.gz解压后将文件夹复制到/data/www/目录下并更名为lvs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://tepedino.org/lvs-rrd/lvs-rrd-v0.7.tar.gz</span><br><span class="line">tar -zxvf lvs-rrd-v0.7.tar.gz</span><br><span class="line"></span><br><span class="line">mv lvs-rrd-v0.7 /usr/local/nginx/html/lvs-rrd</span><br></pre></td></tr></table></figure><p>修改相应的脚本文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim lvs.rrd.update 修改以下内容</span><br><span class="line"></span><br><span class="line">RRDTOOL=&quot;/usr/local/rrdtool/bin/rrdtool&quot;#rrdtool可执行程序路径</span><br><span class="line">IPVSADM=&quot;/sbin/ipvsadm&quot;   #ipvsadm命令路径</span><br><span class="line">WORKDIR=&quot;/data1/lvs-rrd&quot;   #rrdtool收集的数据的存放路径</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim graph-lvs.sh 修改以下内容</span><br><span class="line"></span><br><span class="line"># WORKDIR must match the directory used in the update script.</span><br><span class="line">WORKDIR=&quot;/data1/lvs-rrd&quot;#rrdtool收集的数据的存放路径,同上面一致</span><br><span class="line">RRDTOOL=&quot;/usr/local/rrdtool/bin/rrdtool&quot;  #rrdtool可执行程序路径</span><br><span class="line"># Where to put the graphs. </span><br><span class="line">GRAPHS=&quot;/data1/lvs-rrd/graphs&quot;#生成的图片保存路径</span><br><span class="line">WEBPATH=&quot;/lvs-rrd/graphs&quot;#web访问的路径</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim lvs-rrd.php</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">header(&quot;Cache-Control: max-age=300, must-revalidate&quot;);</span><br><span class="line">system(&quot;/usr/local/nginx/html/lvs-rrd/graph-lvs.sh -H&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注意：WEBPATH的配置是浏览器实际访问时图片的访问路径，也就是<a href="http://ip:port/webpath/xxx.gif" target="_blank" rel="noopener">http://ip:port/webpath/xxx.gif</a></p><p>在日志中的输出显示为：</p><p>/usr/local/nginx/html/lvs-rrd/graphs/lvs.All.All.All.All.All-year.gif</p><p>因此需要手动在站点目录下创建该目录并创建软链接，将<code>生成的图片保存路径</code>链接到该目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/nginx/html/lvs-rrd/graphs</span><br><span class="line">ln -s /data1/lvs-rrd/graphs /usr/local/nginx/html/lvs-rrd/graphs</span><br></pre></td></tr></table></figure><p><strong>配置nginx认证</strong></p><p>在nginx配置文件的server中配置如下两行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth_basic              &quot;dwd&quot;;</span><br><span class="line">auth_basic_user_file    htpasswd;</span><br></pre></td></tr></table></figure><p>然后执行以下命令创建加密文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -bc htpasswd  ops-lvs Dwd_Ops_123</span><br></pre></td></tr></table></figure><p><strong>配置计划任务</strong></p><p>这里，将更新数据的间隔时间设置为30s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /usr/local/nginx/html/lvs-rrd/lvs.rrd.update &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * /usr/local/nginx/html/lvs-rrd/graph-lvs.sh -H &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * sleep 30 ; /usr/local/nginx/html/lvs-rrd/lvs.rrd.update &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * sleep 30 ; /usr/local/nginx/html/lvs-rrd/graph-lvs.sh -H &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="Zabbix监控LVS"><a href="#Zabbix监控LVS" class="headerlink" title="Zabbix监控LVS"></a>Zabbix监控LVS</h2><p><strong>监控指标：</strong></p><p>动态的数据：</p><ul><li>cps(connect per second) ，每秒的连接数情况</li><li>InPPS(input packge per second)，每秒的入向数据包数量情况</li><li>OutPPS(output packge per second)，每秒的出向数据包数量情况</li><li>InBPS（input byte per second）,每秒的流入字节数情况</li><li>OutBPS(output byte per second)，每秒的流出字节数情况</li><li>ActiveConn，处于ESAT的连接（使用系统的netstat无法看到）</li><li>InActConn，处于非ESAT的连接（使用系统的netstat无法看到）</li></ul><p>静态统计数据：</p><ul><li>Conns，自启动之后的总连接数</li><li>InPkts，自启动之后的总入向数据包数量统计</li><li>OutPkts，自启动之后的总出向数据包数量统计</li><li>InBytes，自启动之后的总入向字节数统计</li><li>OutBytes，自启动之后的总出向字节数统计</li></ul><p><strong>监控逻辑：</strong></p><p>使用ipvsadm命令从服务器中采集数据</p><p>所使用的命令分别为：</p><ul><li>ipvsadm -Ln –rate</li><li>ipvsadm -Ln –stats</li></ul><p><strong>注意：</strong>zabbix配置文件中需要打开sudo的权限，拥有root的权限之后才能执行ipvsadm命令去获取数据</p>]]></content>
    
    <summary type="html">
    
      LVS性能指标及监控
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="高并发" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="4层负载均衡-LVS" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/4%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-LVS/"/>
    
    
      <category term="LVS" scheme="http://yoursite.com/tags/LVS/"/>
    
  </entry>
  
  <entry>
    <title>day03-集合及文件操作知识补充+函数</title>
    <link href="http://yoursite.com/2018/07/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day03-%E9%9B%86%E5%90%88%E5%8F%8A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85+%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/07/08/编程语言/Python/老男孩视频学习笔记/day03-集合及文件操作知识补充+函数/</id>
    <published>2018-07-08T12:26:10.000Z</published>
    <updated>2018-07-08T12:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合是一个无序的，不重复的数据组合，它的主要作用如下：</p><ul><li>去重，把一个列表变成集合，就自动去重了</li><li>关系测试，测试两组数据之前的交集、差集、并集等关系</li></ul><p><strong>集合创建：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4,5,7,6,6,1,7,8]</span><br><span class="line">list_set = set(list)</span><br><span class="line">print (list_set,type(list_set))</span><br><span class="line"></span><br><span class="line">set1 = set()</span><br><span class="line">print (set1,type(set1))</span><br><span class="line"></span><br><span class="line">执行后输出如下：</span><br><span class="line">&#123;1, 2, 3, 4, 5, 6, 7, 8&#125; &lt;class &apos;set&apos;&gt;</span><br><span class="line">set() &lt;class &apos;set&apos;&gt;</span><br></pre></td></tr></table></figure><p><strong>高级操作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = t | s          # t 和 s的并集  </span><br><span class="line">  </span><br><span class="line">b = t &amp; s          # t 和 s的交集  </span><br><span class="line">  </span><br><span class="line">c = t – s          # 求差集（项在t中，但不在s中）  </span><br><span class="line">  </span><br><span class="line">d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中），也就是在并集中去除掉了交集</span><br></pre></td></tr></table></figure><p><strong>其他操作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.add(&apos;x&apos;)            # 添加一项  </span><br><span class="line">  </span><br><span class="line">s.update([10,37,42])  # 在s中添加多项</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用remove()可以删除一项：  </span><br><span class="line">  </span><br><span class="line">t.remove(&apos;H&apos;)  </span><br><span class="line"></span><br><span class="line">还有discard()方法可以删除，但是当元素不存在的时候，它不会和remove一样报错</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">len(s)  </span><br><span class="line">set 的长度  </span><br><span class="line">  </span><br><span class="line">x in s  </span><br><span class="line">测试 x 是否是 s 的成员  </span><br><span class="line">  </span><br><span class="line">x not in s  </span><br><span class="line">测试 x 是否不是 s 的成员  </span><br><span class="line">  </span><br><span class="line">s.issubset(t)  </span><br><span class="line">s &lt;= t  </span><br><span class="line">测试是否 s 中的每一个元素都在 t 中  </span><br><span class="line">  </span><br><span class="line">s.issuperset(t)  </span><br><span class="line">s &gt;= t  </span><br><span class="line">测试是否 t 中的每一个元素都在 s 中  </span><br><span class="line">  </span><br><span class="line">s.union(t)  </span><br><span class="line">s | t  </span><br><span class="line">返回一个新的 set 包含 s 和 t 中的每一个元素  </span><br><span class="line">  </span><br><span class="line">s.intersection(t)  </span><br><span class="line">s &amp; t  </span><br><span class="line">返回一个新的 set 包含 s 和 t 中的公共元素  </span><br><span class="line">  </span><br><span class="line">s.difference(t)  </span><br><span class="line">s - t  </span><br><span class="line">返回一个新的 set 包含 s 中有但是 t 中没有的元素  </span><br><span class="line">  </span><br><span class="line">s.symmetric_difference(t)  </span><br><span class="line">s ^ t  </span><br><span class="line">返回一个新的 set 包含 s 和 t 中不重复的元素  </span><br><span class="line">  </span><br><span class="line">s.copy()  </span><br><span class="line">返回 set “s”的一个浅复制  </span><br><span class="line"></span><br><span class="line">判断两个集合是否有交集</span><br><span class="line">s1 = set([1,2,3,4,5,6])</span><br><span class="line">s2 = set([2,4,6,8,10])</span><br><span class="line">s3 = set([11,22,44,55])</span><br><span class="line">print (s1.isdisjoint(s2))</span><br><span class="line">print (s1.isdisjoint(s3))</span><br><span class="line">输出为：</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="文件操作相关知识"><a href="#文件操作相关知识" class="headerlink" title="文件操作相关知识"></a>文件操作相关知识</h2><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>read()方法，一次性读取文件的所有内容，当文件非常大的时候非常不建议</p><p>readline()方法，一次只读取文件的一行，从上往下的顺序</p><p>readlines()方法，将文件的内容按行一次性重新输出为一个==列表==，每行一个元素</p><p>read()和readlines()方法都是一次性读取文件的全部内容，只适合于小文件，不适合大文件</p><p>readline()是一行一行的读取，在大文件的时候也是十分占用内存的</p><p>注意，以上这三种方法只适合读取小文件，在读取大文件的时候，不能够再使用这种方法。</p><p>思路：文件的内容，打印完一行之后就不再需要这一行了，因此已经读取的内容就没有必要再存储在内存当中，在内存中永远只保存一行</p><p>写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f =  open(r&apos;C:\Users\Administrator\PycharmProjects\files\login.txt&apos;, &apos;r&apos;)</span><br><span class="line">for line in f:</span><br><span class="line">    print(line)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="tell-和seek-文件位置"><a href="#tell-和seek-文件位置" class="headerlink" title="tell()和seek()-文件位置"></a>tell()和seek()-文件位置</h2><p>tell打印当前文件内容的输出位置，seek将当前光标重新定向到指定的位置</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(f.readline())</span><br><span class="line">print(f.readline())</span><br><span class="line">print (f.tell())</span><br><span class="line">f.seek(0)</span><br><span class="line">print (f.readline())</span><br><span class="line"></span><br><span class="line">执行后输出为：</span><br><span class="line">wxh:wxh123</span><br><span class="line">wsy:wsy123</span><br><span class="line">24</span><br><span class="line">wxh:wxh123</span><br></pre></td></tr></table></figure><h2 id="缓存区-flush"><a href="#缓存区-flush" class="headerlink" title="缓存区-flush()"></a>缓存区-flush()</h2><p>在进行循环等操作的时候，程序需要等循环完毕才输出，也就是缓存区满了之后再进行显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys,time</span><br><span class="line">for i in range(50):</span><br><span class="line">    sys.stdout.write(&quot;#&quot;)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    </span><br><span class="line">执行后的程序输出将会是持续的输出#</span><br></pre></td></tr></table></figure><p>使用flush()方法，可以在操作时立即输出</p><h1 id="程序练习"><a href="#程序练习" class="headerlink" title="程序练习"></a>程序练习</h1><h2 id="实现shell-sed替换功能"><a href="#实现shell-sed替换功能" class="headerlink" title="实现shell sed替换功能"></a>实现shell sed替换功能</h2><p>用户输入旧的需要替换的字符和新的字符，通过给脚本传入参数来实现</p><p>可以使用sys模块的argv进行参数获取，然后进行替换操作</p><h2 id="修改haproxy配置文件"><a href="#修改haproxy配置文件" class="headerlink" title="修改haproxy配置文件"></a>修改haproxy配置文件</h2><p>需求</p><ul><li>进入程序之后，可以选择：增、删、改、查等操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1、查</span><br><span class="line">    输入：www.oldboy.org</span><br><span class="line">    获取当前backend下的所有记录</span><br><span class="line"></span><br><span class="line">2、新建</span><br><span class="line">    输入：</span><br><span class="line">        arg = &#123;</span><br><span class="line">            &apos;bakend&apos;: &apos;www.oldboy.org&apos;,</span><br><span class="line">            &apos;record&apos;:&#123;</span><br><span class="line">                &apos;server&apos;: &apos;100.1.7.9&apos;,</span><br><span class="line">                &apos;weight&apos;: 20,</span><br><span class="line">                &apos;maxconn&apos;: 30</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">3、删除</span><br><span class="line">    输入：</span><br><span class="line">        arg = &#123;</span><br><span class="line">            &apos;bakend&apos;: &apos;www.oldboy.org&apos;,</span><br><span class="line">            &apos;record&apos;:&#123;</span><br><span class="line">                &apos;server&apos;: &apos;100.1.7.9&apos;,</span><br><span class="line">                &apos;weight&apos;: 20,</span><br><span class="line">                &apos;maxconn&apos;: 30</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>源文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">global       </span><br><span class="line">        log 127.0.0.1 local2</span><br><span class="line">        daemon</span><br><span class="line">        maxconn 256</span><br><span class="line">        log 127.0.0.1 local2 info</span><br><span class="line">defaults</span><br><span class="line">        log global</span><br><span class="line">        mode http</span><br><span class="line">        timeout connect 5000ms</span><br><span class="line">        timeout client 50000ms</span><br><span class="line">        timeout server 50000ms</span><br><span class="line">        option  dontlognull</span><br><span class="line"></span><br><span class="line">listen stats :8888</span><br><span class="line">        stats enable</span><br><span class="line">        stats uri       /admin</span><br><span class="line">        stats auth      admin:1234</span><br><span class="line"></span><br><span class="line">frontend oldboy.org</span><br><span class="line">        bind 0.0.0.0:80</span><br><span class="line">        option httplog</span><br><span class="line">        option httpclose</span><br><span class="line">        option  forwardfor</span><br><span class="line">        log global</span><br><span class="line">        acl www hdr_reg(host) -i www.oldboy.org</span><br><span class="line">        use_backend www.oldboy.org if www</span><br><span class="line"></span><br><span class="line">backend www.oldboy.org</span><br><span class="line">        server 100.1.7.9 100.1.7.9 weight 20 maxconn 3000</span><br></pre></td></tr></table></figure><p>使用eval实现</p><h1 id="函数基础知识"><a href="#函数基础知识" class="headerlink" title="函数基础知识"></a>函数基础知识</h1><h2 id="函数结构"><a href="#函数结构" class="headerlink" title="函数结构"></a>函数结构</h2><p>面向对象：类 class</p><p>面向过程：过程 def  【过程实际上可以理解为没有返回值的函数】</p><p>函数式编程：函数 def 【函数式逻辑结构化和过程化的一种编程方法】</p><p>注意，过程和函数的定义都是使用def进行标识的</p><p>在python中<strong>定义一个函数</strong>的结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def test(x):</span><br><span class="line">    &quot;&quot;&quot;define the function for test&quot;&quot;&quot;</span><br><span class="line">    x += 1</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line">a = test(1)</span><br><span class="line">print (a)</span><br></pre></td></tr></table></figure><ul><li>def：定义函数的关键字</li><li>test：函数名称</li><li>()：参数列表空间，内可定义形参</li><li>中间是代码块，用于实现程序处理逻辑</li><li>return：定义返回值</li></ul><p>在python当中，过程也是被当做函数来处理，python其实也给过程隐式的定义了返回值None，因此在调用过程的时候，我们也能看到返回值，但是返回值是None</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>将实参传递给形参的时候，有两种方法，</p><ul><li>一种是在括号中直接写实参，例如：test(1,2)，这个时候将会按照这个顺序进行参数的传递，与形参一一对应</li><li>一种是人为的指定赋值对象，例如：test1(x=2,y=1)，这个时候将会按照指定的值进行赋值导入，与形参的顺序无关</li></ul><h3 id="函数为什么要有返回值"><a href="#函数为什么要有返回值" class="headerlink" title="函数为什么要有返回值"></a>函数为什么要有返回值</h3><p>函数有返回值的一个最主要的原因是，我想要这个函数整个的执行结果</p><p>后面的处理逻辑需要根据这个返回值的结果进行相应的操作</p><h2 id="定义不限制数量的函数形参个数"><a href="#定义不限制数量的函数形参个数" class="headerlink" title="定义不限制数量的函数形参个数"></a>定义不限制数量的函数形参个数</h2><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">输出为元祖类型：</span><br><span class="line"></span><br><span class="line">def test(x,*wxh):</span><br><span class="line">    print (x)</span><br><span class="line">    print (wxh)</span><br><span class="line"></span><br><span class="line">test(1,2,2,34,45)</span><br><span class="line">执行后输出如下所示：</span><br><span class="line">1</span><br><span class="line">(2, 2, 34, 45)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出为字典类型：</span><br><span class="line">def test(x,**wxh):</span><br><span class="line">    print (x)</span><br><span class="line">    print (wxh)</span><br><span class="line"></span><br><span class="line">test(1,name=&quot;wxh&quot;,age=6)</span><br><span class="line">执行后输出如下所示：</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">&#123;&apos;name&apos;: &apos;wxh&apos;, &apos;age&apos;: 6&#125;</span><br></pre></td></tr></table></figure><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>测试代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def change_name(name):</span><br><span class="line">    print (&quot;befor change&quot;,name)</span><br><span class="line">    name = &quot;wang xiao hua&quot;</span><br><span class="line">    print (&quot;after change&quot;,name)</span><br><span class="line">name = &quot;wxh&quot;</span><br><span class="line">a1= change_name(name)</span><br><span class="line">print (name)</span><br><span class="line">print (a1)</span><br><span class="line"></span><br><span class="line">执行后的输出如下所示:</span><br><span class="line"></span><br><span class="line">befor change wxh</span><br><span class="line">after change wang xiao hua</span><br><span class="line">wxh</span><br><span class="line">None</span><br></pre></td></tr></table></figure><p>这个测试的效果就是局部变量，局部变量只会在函数里面生效，可以理解为，这个函数就是这个变量的作用域，在这个函数之外</p><h2 id="函数内操作全局变量"><a href="#函数内操作全局变量" class="headerlink" title="函数内操作全局变量"></a>函数内操作全局变量</h2><p>默认情况下，在函数体中操作的都是局部变量，但是有些情况需要在函数体中操作全局变量，这个时候就需要在变量的前面加上标志信息：global</p><p>注意，在外部定义的全局变量，只有字符串和单独的整数这种是不能再函数中去修改的，而像列表字典元祖集合等比较复杂的数据类型，这些都是可以直接在局部里面直接修改全局的 </p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自己本身，那么这个函数就是递归函数。</p><h2 id="递归的特性"><a href="#递归的特性" class="headerlink" title="递归的特性"></a>递归的特性</h2><p>递归函数应该拥有以下特性：</p><ul><li>必须有一个明确的结束条件</li><li>每次进入更深一层的递归时，问题规模相比上次递归都应有所减少</li><li>递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用时通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。）</li></ul><p>演示代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def cal(n):</span><br><span class="line">    print (n)</span><br><span class="line">    if int(n/2)&gt;0:</span><br><span class="line">        return (cal(int(n/2)))</span><br><span class="line">cal(10)</span><br><span class="line">输出为：</span><br><span class="line">10</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">这就是一个有明确结束条件的递归函数</span><br></pre></td></tr></table></figure><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>演示代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def add(a,b,f):</span><br><span class="line">    return f(a),f(b)</span><br><span class="line"></span><br><span class="line">res = add(-5,-4,abs)</span><br><span class="line">print (res)</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">(5, 4)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      day03-集合及文件操作知识补充+函数
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>day02-模块初始及列表字典等深入</title>
    <link href="http://yoursite.com/2018/06/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day02-%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B/"/>
    <id>http://yoursite.com/2018/06/27/编程语言/Python/老男孩视频学习笔记/day02-模块初始/</id>
    <published>2018-06-27T13:54:39.000Z</published>
    <updated>2018-06-27T13:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h1><p>模块的简单介绍：用户写好了一堆功能，将其封装在一个文件当中，从网上下载下来之后，导入之后就可以使用，不用再去重新编写相对应的功能代码。这个文件就叫做模块，又可以叫做库</p><p>模块（库）主要分为两种：</p><ul><li>一个是标准库（不需要额外安装下载，就可以直接导入的库，比如说getpass,os,sys模块等）</li><li>一个是第三方库（必须要额外的下载安装之后，才可以使用，例如django）</li></ul><p>几个要点：</p><ul><li>模块在系统中是以.py结尾的文件方式存在的</li><li>这些模块文件在python有一个寻找路径/环境变量（存储路径可以通过sys模块的path方法进行查看，默认情况下，会最优先从当前目录下进行寻找）【这个是python的全局变量，和系统的path环境变量不一样】，这个python全局变量，存储的是路径信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;python</span><br><span class="line">Python 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 16:07:46) [MSC v.1900 32 bit (Intel)] on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; print (sys.path)</span><br><span class="line">[&apos;&apos;, &apos;D:\\software\\python\\python36.zip&apos;, &apos;D:\\software\\python\\DLLs&apos;, &apos;D:\\software\\python\\lib&apos;, &apos;D:\\software\\python&apos;, &apos;D:\\software\\python\\lib\\site-packages&apos;]</span><br></pre></td></tr></table></figure><p>一般情况下，python安装的第三方库都是存放在lib\site-packages路径下</p><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">print (sys.path)</span><br><span class="line">print(sys.argv)</span><br></pre></td></tr></table></figure><p>输出信息如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;C:\Users\Administrator\PycharmProjects\python14\day02&apos;, &apos;C:\Users\Administrator\PycharmProjects\python14&apos;, &apos;D:\software\python\python36.zip&apos;, &apos;D:\software\python\DLLs&apos;, &apos;D:\software\python\lib&apos;, &apos;D:\software\python&apos;, &apos;D:\software\python\lib\site-packages&apos;]</span><br><span class="line"></span><br><span class="line">[&apos;C:/Users/Administrator/PycharmProjects/python14/day02/moudles.py&apos;]</span><br></pre></td></tr></table></figure><ul><li>path方法输出python定义的环境变量信息</li><li>argv方法输出当前文件所在相对路径信息（注意是相对路径，这里输出是因为在IDE中调用的时候写的脚本名字的路径就是绝对路径，pycharm在调用的时候写的是绝对路径）</li></ul><h2 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h2><p>OS模块是跟操作系统进行交互</p><p>从python中调用shell的命令，或者在系统上创建一个文件、目录等</p><p>比如</p><p>执行命令，使用方法：os.system()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import os</span><br><span class="line">cmd_res = os.system(&quot;df -h&quot;)</span><br><span class="line">print (cmd_res)</span><br></pre></td></tr></table></figure><p>执行后的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@redis001 ~]# python test.py</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda2       197G  1.4G  186G   1% /</span><br><span class="line">tmpfs            63G   24K   63G   1% /dev/shm</span><br><span class="line">/dev/sda1       283M   37M  232M  14% /boot</span><br><span class="line">/dev/sda6       1.3T  203M  1.3T   1% /data1</span><br><span class="line">/dev/sda3        99G   60M   94G   1% /home</span><br><span class="line">/dev/sda5        50G   52M   47G   1% /tmp</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意：在使用os.system执行命令的时候，这个结果的输出是直接输出到屏幕上的，而不是存到这个变量中，所以输出之后就没有了</p><p>0 是命令执行成功与否的返回状态码</p><p>上面的system是执行命令，但是不保存结果</p><p>那么，我们就想保存结果的时候，该做什么操作？ 这个时候我们使用popen方法</p><p>popen()方法输出的是一个内存的对象地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@redis001 ~]# cat test.py </span><br><span class="line">#!/usr/bin/python</span><br><span class="line">import os</span><br><span class="line">cmd_res = os.popen(&quot;ls&quot;)</span><br><span class="line">print (cmd_res)</span><br><span class="line">[root@redis001 ~]# python test.py</span><br><span class="line">&lt;open file &apos;ls&apos;, mode &apos;r&apos; at 0x7ff2cce43c00&gt;</span><br><span class="line">ls: write error: Broken pipe</span><br></pre></td></tr></table></figure><p>那么，想要真正的结果，则需要再调用一下read()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@redis001 ~]# cat test.py </span><br><span class="line">#!/usr/bin/python</span><br><span class="line">import os</span><br><span class="line">cmd_res = os.popen(&quot;ls&quot;).read()</span><br><span class="line">print (cmd_res)</span><br><span class="line">[root@redis001 ~]# python test.py</span><br><span class="line">anaconda-ks.cfg</span><br><span class="line">install.log</span><br><span class="line">install.log.syslog</span><br><span class="line">test.py</span><br></pre></td></tr></table></figure><p>解析：在执行完popen()之后，这个结果是保存在内存的一个临时的地方，这个地方，必须通过read()方法，再去取出来</p><h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表切片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">print (list[1:3])</span><br><span class="line">输出为：</span><br><span class="line">[&apos;wsy&apos;, &apos;dabadou&apos;]</span><br></pre></td></tr></table></figure><p>打印列表中item的数量-使用count方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">print(list.count(&quot;wxh&quot;))</span><br></pre></td></tr></table></figure><p>清除列表-clear方法-注意这里只是清空了但是不会被删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.clear()</span><br></pre></td></tr></table></figure><p>列表反转-reverse()方法</p><p>列表合并-extend()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">list2 = [1,2,3,4]</span><br><span class="line">list.extend(list2)</span><br><span class="line">print (list)</span><br><span class="line">输出为：</span><br><span class="line">[&apos;wxh&apos;, &apos;wsy&apos;, &apos;dabadou&apos;, &apos;badou&apos;, &apos;wxh&apos;, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>列表删除-del命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list2 = [1,2,3,4]</span><br><span class="line">del list2</span><br><span class="line">print (list2)</span><br></pre></td></tr></table></figure><p>列表嵌套列表及子列表赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,[&quot;wxh&quot;,&quot;heheh&quot;,&quot;haha&quot;],&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">list[3][1] = &quot;WXH&quot;</span><br><span class="line">print(list)</span><br><span class="line">执行后输出为：</span><br><span class="line">[&apos;wxh&apos;, &apos;wsy&apos;, &apos;dabadou&apos;, [&apos;wxh&apos;, &apos;WXH&apos;, &apos;haha&apos;], &apos;badou&apos;, &apos;wxh&apos;]</span><br></pre></td></tr></table></figure><p>列表复制-使用copy模块的copy方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,[&quot;wxh&quot;,&quot;heheh&quot;,&quot;haha&quot;],&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">list2 = copy.copy(list)</span><br><span class="line">print (list2)</span><br><span class="line">输出为：</span><br><span class="line">[&apos;wxh&apos;, &apos;wsy&apos;, &apos;dabadou&apos;, [&apos;wxh&apos;, &apos;heheh&apos;, &apos;haha&apos;], &apos;badou&apos;, &apos;wxh&apos;]</span><br><span class="line"></span><br><span class="line">也可以使用下面这种方式：</span><br><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,[&quot;wxh&quot;,&quot;heheh&quot;,&quot;haha&quot;],&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">list2 = list[:]</span><br><span class="line">print (list2)</span><br></pre></td></tr></table></figure><p>使用这种列表再赋值的方式，可以拿来作为联合账号类功能，也就是说前者最开始的列表将会连带的影响所有的列表。</p><p>列表循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in list:</span><br><span class="line">print (i)</span><br></pre></td></tr></table></figure><p>在循环的时候-按照步长进行输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(list[0:-1:2])</span><br></pre></td></tr></table></figure><h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h2><p>元祖和列表差不多，只不过一旦创建之后就不能再次修改，因此又叫做只读列表</p><p>元祖使用()进行定义，而不是列表的[]</p><p>元祖只有两个方法，count和index方法</p><h2 id="购物车程序"><a href="#购物车程序" class="headerlink" title="购物车程序"></a>购物车程序</h2><p>需求如下：</p><ol><li>启动程序之后，让用户输入工资，然后打印商品列表</li><li>允许用户根据商品编号购买商品</li><li>用户选择商品后，检测余额是否足够，够久直接扣款，不够就提醒（不够的话可以选择便宜的，也就是说进入下一次循环）</li><li>可以随时退出，退出时，打印已经购买的商品和余额</li></ol><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Author:XiaoHua Wang</span><br><span class="line">goods = [(&quot;iphone&quot;,7000),(&quot;Ipad pro&quot;,5000),(&quot;Mac pro&quot;,22000),(&quot;tea&quot;,40),(&quot;bag&quot;,2000),(&quot;Nike&quot;,860),(&quot;book&quot;,105)]</span><br><span class="line">salary = int(input(&quot;Please input your salary: &quot;))</span><br><span class="line">message2 = &quot;Please choice which number to buy,enter q to quit in any time:&quot;</span><br><span class="line">buy_goods = []</span><br><span class="line">while True:</span><br><span class="line">    print(&quot;These are all goods you can buy:&quot;)</span><br><span class="line">#    for i in range(len(goods)):</span><br><span class="line">#        print(str(i) + &quot; &quot; + str(goods[i]))</span><br><span class="line">    for item in goods:</span><br><span class="line">        print (goods.index(item),item)</span><br><span class="line">    Tag = input(message2)</span><br><span class="line">    jude = Tag.isdigit()</span><br><span class="line">    if Tag == &quot;q&quot;:</span><br><span class="line">        break</span><br><span class="line">    if jude != True:</span><br><span class="line">        print (&quot;sorry,input error,please enter number or q&quot;)</span><br><span class="line">        break</span><br><span class="line">    consume_moneny = int(goods[int(Tag)][1])</span><br><span class="line">    salary1 = salary</span><br><span class="line">    salary = salary - consume_moneny</span><br><span class="line">    if  salary &lt; 0:</span><br><span class="line">        print (&quot;sorry,you The amount is not enough,please select again&quot;)</span><br><span class="line">        print( &quot;rest salary is &#123;Salary&#125;&quot;.format(Salary=salary1) )</span><br><span class="line">        salary = salary1</span><br><span class="line">        continue</span><br><span class="line">#    if salary == 0:</span><br><span class="line">    if salary == 0:</span><br><span class="line">        print(&quot;Add &quot; + str(goods[int(Tag)]) )</span><br><span class="line">        print(&quot;consume all money just right,&quot;+ &quot;rest salary is 0 . you can&apos;t buy again.&quot;)</span><br><span class="line">        buy_goods = buy_goods.append(goods[int(Tag)][0])</span><br><span class="line">        break</span><br><span class="line">    print(&quot;Add &quot; + str(goods[int(Tag)]))</span><br><span class="line">#    print(&quot;rest salary is &quot; + str(salary))</span><br><span class="line">    print(&quot;rest salary is &#123;Salary&#125;&quot;.format(Salary=salary))</span><br><span class="line">    buy_goods.append(goods[int(Tag)][0])</span><br><span class="line">    continue</span><br><span class="line">print (&quot;you have buy blow goods: &quot;)</span><br><span class="line">print (buy_goods)</span><br></pre></td></tr></table></figure><p>注意：匹配列表的索引和对应的值还可以使用下面的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">goods = [(&quot;iphone&quot;,7000),(&quot;Ipad pro&quot;,5000),(&quot;Mac pro&quot;,22000),(&quot;tea&quot;,40),(&quot;bag&quot;,2000),(&quot;Nike&quot;,860),(&quot;book&quot;,105)]</span><br><span class="line">for item in goods:</span><br><span class="line">    print(goods.index(item), item)</span><br><span class="line">#或者</span><br><span class="line">for index,item in enumerate(goods):</span><br><span class="line">    print (index,item)</span><br><span class="line"></span><br><span class="line">执行后输出如下：</span><br><span class="line">0 (&apos;iphone&apos;, 7000)</span><br><span class="line">1 (&apos;Ipad pro&apos;, 5000)</span><br><span class="line">2 (&apos;Mac pro&apos;, 22000)</span><br><span class="line">3 (&apos;tea&apos;, 40)</span><br><span class="line">4 (&apos;bag&apos;, 2000)</span><br><span class="line">5 (&apos;Nike&apos;, 860)</span><br><span class="line">6 (&apos;book&apos;, 105)</span><br><span class="line">0 (&apos;iphone&apos;, 7000)</span><br><span class="line">1 (&apos;Ipad pro&apos;, 5000)</span><br><span class="line">2 (&apos;Mac pro&apos;, 22000)</span><br><span class="line">3 (&apos;tea&apos;, 40)</span><br><span class="line">4 (&apos;bag&apos;, 2000)</span><br><span class="line">5 (&apos;Nike&apos;, 860)</span><br><span class="line">6 (&apos;book&apos;, 105)</span><br></pre></td></tr></table></figure><h2 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h2><p><strong>字符串对应位置替换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;wangxiaohua&quot;</span><br><span class="line">p = str.maketrans(&quot;abcdefg&quot;,&quot;1234567&quot;)</span><br><span class="line">print (name.translate(p))</span><br><span class="line"></span><br><span class="line">执行之后的输出如下所示：</span><br><span class="line">w1n7xi1ohu1</span><br></pre></td></tr></table></figure><p><strong>临时替换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print (&quot;wangxiaohua&quot;.replace(&apos;a&apos;,&apos;A&apos;,2))</span><br><span class="line">执行后输出如下：</span><br><span class="line">wAngxiAohua</span><br><span class="line"></span><br><span class="line">格式为：旧字符，新字符，替换的格式个数</span><br></pre></td></tr></table></figure><p><strong>split分割-按照字符</strong></p><p>将字符串的值，按照指定的分隔符号，重新定义为列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = &quot;1+2+3+4&quot;</span><br><span class="line">print (num.split(&quot;+&quot;))</span><br><span class="line">执行后输出如下：</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]</span><br></pre></td></tr></table></figure><p><strong>split分割-按照行</strong></p><p>split分割按照行来进行区分的时候，我们就需要使用splitlines()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num = &quot;1+2+3\n+4+\n5+6&quot;</span><br><span class="line">print (num)</span><br><span class="line">print (num.split(&quot;+&quot;))</span><br><span class="line">print (num.splitlines())</span><br><span class="line"></span><br><span class="line">执行后输出如下所示：</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3\n&apos;, &apos;4&apos;, &apos;\n5&apos;, &apos;6&apos;]</span><br><span class="line">[&apos;1+2+3&apos;, &apos;+4+&apos;, &apos;5+6&apos;]</span><br></pre></td></tr></table></figure><p>注意：在linux和windows平台上使用splitlines()方法的时候，它会自动的识别换行符（Linux和windows的换行符号是不一样的）</p><p><strong>Title格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;wang xiao hua&quot;</span><br><span class="line">name1 = &quot;wangxiaohua&quot;</span><br><span class="line">print (name.title())</span><br><span class="line">print (name1.title())</span><br><span class="line"></span><br><span class="line">执行后的输出如下所示：</span><br><span class="line">Wang Xiao Hua</span><br><span class="line">Wangxiaohua</span><br></pre></td></tr></table></figure><p>将输入的字符串输出为标题的格式，也就是首字母大写的格式</p><h2 id="字典操作"><a href="#字典操作" class="headerlink" title="字典操作"></a>字典操作</h2><p>字典的数据类型是一种key-value类型</p><p>字典的特性：</p><ul><li>dict是无序的</li><li>key必须是唯一的，因此字典天生就具备去重的功能</li><li>在输出的时候，默认是没有顺序的，因此可能写在最后的在最前面输出，因为字典没有下标信息，因为列表是通过索引下标进行查找，但是字典是通过key进行查找的</li><li>在取值的时候，用法和列表的相似，不过是在[]中将索引下标数字修改成为key值</li></ul><p>删除字典有几种方法，使用pop的时候，可以再进行赋值，使用del的时候就是真的删除了</p><p>字典的查找，可以使用get方法，也可以使用in的用法</p><p>字典中有该值则返回，没有的话则返回None</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangxiaohua&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;26&quot;,</span><br><span class="line">    &quot;sex&quot;:&quot;man&quot;</span><br><span class="line">&#125;</span><br><span class="line">print (info.get(&quot;name&quot;))</span><br><span class="line">print (info.get(&quot;named&quot;))</span><br><span class="line">if &quot;name&quot; in info:</span><br><span class="line">    print (&quot;Yes&quot;)</span><br><span class="line"></span><br><span class="line">执行后的输出如下所示：</span><br><span class="line">wangxiaohua</span><br><span class="line">None</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p>字典的特殊赋值-如果能取到值则返回取到的值，如果值不存在则创建一个新的-setdefault()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangxiaohua&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;26&quot;,</span><br><span class="line">    &quot;sex&quot;:&quot;man&quot;</span><br><span class="line">&#125;</span><br><span class="line">info.setdefault(&quot;name&quot;,&quot;hehe&quot;)</span><br><span class="line">print (info)</span><br><span class="line"></span><br><span class="line">执行后输出如下所示：</span><br><span class="line">&#123;&apos;name&apos;: &apos;wangxiaohua&apos;, &apos;age&apos;: &apos;26&apos;, &apos;sex&apos;: &apos;man&apos;&#125;</span><br></pre></td></tr></table></figure><p>字典的合并更新-存在交叉的key值进行覆盖，不存在的则进行插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangxiaohua&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;26&quot;,</span><br><span class="line">    &quot;sex&quot;:&quot;man&quot;</span><br><span class="line">&#125;</span><br><span class="line">info2 = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;dabadou&quot;,</span><br><span class="line">    &quot;city&quot;:&quot;hangzhou&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info.update(info2)</span><br><span class="line">print (info)</span><br><span class="line"></span><br><span class="line">执行后的输出如下所示：</span><br><span class="line">&#123;&apos;name&apos;: &apos;dabadou&apos;, &apos;age&apos;: &apos;26&apos;, &apos;sex&apos;: &apos;man&apos;, &apos;city&apos;: &apos;hangzhou&apos;&#125;</span><br></pre></td></tr></table></figure><p><strong>字典的循环</strong></p><p>字典的循环，一般使用的是items()方法，但是使用下面这种方法，会比items()方法高效很多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangxiaohua&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;26&quot;,</span><br><span class="line">    &quot;sex&quot;:&quot;man&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i in info:</span><br><span class="line">  print (i,info[i])</span><br><span class="line"></span><br><span class="line">for k,v in info.items():</span><br><span class="line">    print (k,v)</span><br><span class="line">    </span><br><span class="line">执行后的输出如下所示：</span><br><span class="line"></span><br><span class="line">name wangxiaohua</span><br><span class="line">age 26</span><br><span class="line">sex man</span><br><span class="line">name wangxiaohua</span><br><span class="line">age 26</span><br><span class="line">sex man</span><br></pre></td></tr></table></figure><p>上面的方式，是通过索引的形式（这里是key）就直接把value取出来了，但是下面这个items()相当于是把字典变成一个列表，因此就多了一个字典转换成列表的过程，在数据量大的时候，效率非常的差</p><p>因此字典的循环，最好使用上面的这种方式，尽量避免使用items()方法来实现</p><h2 id="三级菜单程序"><a href="#三级菜单程序" class="headerlink" title="三级菜单程序"></a>三级菜单程序</h2><ul><li>三级菜单【省市县】【例如，浙江省–&gt;杭州市–&gt;xx县/区】</li><li>可依次选择进入各个子菜单</li><li>所需新知识点：列表，字典</li></ul><p>打开程序，列出中国所有的省，选择一个省，列出下面所有的城市，选中一个城市，再列出下面所有的县</p><p>在任何一个级别，可以返回上一级</p><p>在任何一个级别的时候，可以整个退出程序，输入例如quit等退出程序</p>]]></content>
    
    <summary type="html">
    
      day02-模块初始
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器双网卡bond配置</title>
    <link href="http://yoursite.com/2018/06/26/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/2%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8C%E7%BD%91%E5%8D%A1bond%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/06/26/IT科学技术知识体系结构-Linux运维方向/高并发/负载均衡/2层负载均衡/Linux服务器双网卡bond配置/</id>
    <published>2018-06-26T02:04:42.000Z</published>
    <updated>2018-06-26T02:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考文献：</strong></p><ul><li><a href="https://www.jianshu.com/p/e7df65f996f4" target="_blank" rel="noopener">linux 网卡绑定 bonding</a></li><li><a href="https://www.cnblogs.com/wuxulei/p/3270256.html" target="_blank" rel="noopener">Linux网卡绑定探析</a></li><li><a href="https://www.linuxidc.com/Linux/2017-06/144865.htm" target="_blank" rel="noopener">Linux下网卡bonding配置</a></li><li><a href="https://blog.csdn.net/werm520/article/details/43953421" target="_blank" rel="noopener">LINUX-网卡Bond</a></li><li><a href="http://blog.51cto.com/lixin15/1769338" target="_blank" rel="noopener">Linux双网卡绑定bond详解</a></li><li><a href="http://blog.51cto.com/linuxnote/1680315" target="_blank" rel="noopener">Linux网卡bond的七种模式详解</a></li></ul><h1 id="基础知识概述"><a href="#基础知识概述" class="headerlink" title="基础知识概述"></a>基础知识概述</h1><h2 id="什么是bond"><a href="#什么是bond" class="headerlink" title="什么是bond"></a>什么是bond</h2><p>网卡bond是通过多张网卡绑定为一个逻辑网卡，实现本地网卡的<strong><code>冗余，带宽扩容和负载均衡</code></strong>，在生产场景中是一种常用的技术。</p><p>通俗点讲就是两块网卡具有相同的IP地址而并行链接聚合成一个逻辑链路工作。</p><p>其实这项技术在Sun和Cisco中早已存在，被称为Trunking和Etherchannel 技术，在Linux的2.4.x的内核中开始采用这这种技术，被称为bonding。 </p><h2 id="内核支持"><a href="#内核支持" class="headerlink" title="内核支持"></a>内核支持</h2><p>在Linux Kernels 2.4.12及以后的版本均供bonding模块，以前的版本可以通过patch实现。可以通过以下命令确定内核是否支持 bonding： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 ~]# cat /boot/config-2.6.32-696.el6.x86_64 | grep -i bond</span><br><span class="line"># CONFIG_PATA_WINBOND is not set</span><br><span class="line">CONFIG_BONDING=m</span><br><span class="line">CONFIG_WINBOND_840=m</span><br><span class="line">CONFIG_INPUT_WINBOND_CIR=m</span><br><span class="line">CONFIG_IR_WINBOND_CIR=m</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">[root@nginx001 ~]# cat /boot/config-2.6.32-696.el6.x86_64 | grep -i bonding</span><br><span class="line">CONFIG_BONDING=m</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">[root@ network-scripts]# modinfo bonding</span><br><span class="line">filename:       /lib/modules/2.6.32-696.el6.x86_64/kernel/drivers/net/bonding/bonding.ko</span><br><span class="line">author:         Thomas Davis, tadavis@lbl.gov and many others</span><br><span class="line">description:    Ethernet Channel Bonding Driver, v3.7.1</span><br><span class="line">version:        3.7.1</span><br><span class="line">license:        GPL</span><br><span class="line">alias:          rtnl-link-bond</span><br><span class="line">srcversion:     454FF5806F146AD7FB41356</span><br><span class="line">depends:        </span><br><span class="line">vermagic:       2.6.32-696.el6.x86_64 SMP mod_unload modversions </span><br><span class="line">parm:           max_bonds:Max number of bonded devices (int)</span><br><span class="line">parm:           tx_queues:Max number of transmit queues (default = 16) (int)</span><br><span class="line">parm:           num_grat_arp:Number of peer notifications to send on failover event (alias of num_unsol_na) (int)</span><br><span class="line">parm:           num_unsol_na:Number of peer notifications to send on failover event (alias of num_grat_arp) (int)</span><br><span class="line">parm:           miimon:Link check interval in milliseconds (int)</span><br><span class="line">parm:           updelay:Delay before considering link up, in milliseconds (int)</span><br><span class="line">parm:           downdelay:Delay before considering link down, in milliseconds (int)</span><br><span class="line">parm:           use_carrier:Use netif_carrier_ok (vs MII ioctls) in miimon; 0 for off, 1 for on (default) (int)</span><br><span class="line">parm:           mode:Mode of operation; 0 for balance-rr, 1 for active-backup, 2 for balance-xor, 3 for broadcast, 4 for 802.3ad, 5 for balance-tlb, 6 for balance-alb (charp)</span><br><span class="line">parm:           primary:Primary network device to use (charp)</span><br><span class="line">parm:           primary_reselect:Reselect primary slave once it comes up; 0 for always (default), 1 for only if speed of primary is better, 2 for only on active slave failure (charp)</span><br><span class="line">parm:           lacp_rate:LACPDU tx rate to request from 802.3ad partner; 0 for slow, 1 for fast (charp)</span><br><span class="line">parm:           ad_select:803.ad aggregation selection logic; 0 for stable (default), 1 for bandwidth, 2 for count (charp)</span><br><span class="line">parm:           min_links:Minimum number of available links before turning on carrier (int)</span><br><span class="line">parm:           xmit_hash_policy:balance-xor and 802.3ad hashing method; 0 for layer 2 (default), 1 for layer 3+4, 2 for layer 2+3 (charp)</span><br><span class="line">parm:           arp_interval:arp interval in milliseconds (int)</span><br><span class="line">parm:           arp_ip_target:arp targets in n.n.n.n form (array of charp)</span><br><span class="line">parm:           arp_validate:validate src/dst of ARP probes; 0 for none (default), 1 for active, 2 for backup, 3 for all (charp)</span><br><span class="line">parm:           arp_all_targets:fail on any/all arp targets timeout; 0 for any (default), 1 for all (charp)</span><br><span class="line">parm:           fail_over_mac:For active-backup, do not set all slaves to the same MAC; 0 for none (default), 1 for active, 2 for follow (charp)</span><br><span class="line">parm:           all_slaves_active:Keep all frames received on an interface by setting active flag for all slaves; 0 for never (default), 1 for always. (int)</span><br><span class="line">parm:           resend_igmp:Number of IGMP membership reports to send on link failure (int)</span><br><span class="line">parm:           packets_per_slave:Packets to send per slave in balance-rr mode; 0 for a random slave, 1 packet per slave (default), &gt;1 packets per slave. (int)</span><br><span class="line">parm:           lp_interval:The number of seconds between instances where the bonding driver sends learning packets to each slaves peer switch. The default is 1. (uint)</span><br></pre></td></tr></table></figure><p>当看到有相关配置输出的时候则说明当前操作系统的内核版本是支持bond的</p><h2 id="bond模式"><a href="#bond模式" class="headerlink" title="bond模式"></a>bond模式</h2><p><strong>bonding的七种工作模式:</strong> </p><p>bonding技术提供了七种工作模式，在使用的时候需要指定一种，每种有各自的优缺点.</p><ol><li>balance-rr (mode=0)       默认, 有高可用 (容错) 和负载均衡的功能,  需要交换机的配置，每块网卡轮询发包 (流量分发比较均衡).</li><li>active-backup (mode=1)  只有高可用 (容错) 功能, 不需要交换机配置, 这种模式只有一块网卡工作, 对外只有一个mac地址。缺点是端口利用率比较低</li><li>balance-xor (mode=2)     不常用</li><li>broadcast (mode=3)        不常用</li><li>802.3ad (mode=4)          IEEE 802.3ad 动态链路聚合，需要交换机配置，没用过</li><li>balance-tlb (mode=5)      不常用</li><li>balance-alb (mode=6)     有高可用 ( 容错 )和负载均衡的功能，不需要交换机配置  (流量分发到每个接口不是特别均衡)</li></ol><p>具体的网上有很多资料，了解每种模式的特点根据自己的选择就行, 一般会用到0、1、4、6这几种模式。</p><p>一般常用的常用的有两种：</p><p>  <strong>mode=0（balance-rr）</strong></p><p>​    表示负载分担round-robin，并且是轮询的方式比如第一个包走eth0，第二个包走eth1，直到数据包发送完毕。</p><p>​    优点：流量提高一倍</p><p>​    缺点：需要接入交换机做端口聚合，否则可能无法使用</p><p>  <strong>mode=1（active-backup）</strong></p><p>​    表示主备模式，即同时只有1块网卡在工作。</p><p>​    优点：冗余性高</p><p>​    缺点：链路利用率低，两块网卡只有1块在工作</p><h1 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h1><h2 id="配置子网卡"><a href="#配置子网卡" class="headerlink" title="配置子网卡"></a>配置子网卡</h2><p><strong>源文件内容：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 network-scripts]# cat ifcfg-p1p1</span><br><span class="line">DEVICE=&quot;p1p1&quot;</span><br><span class="line">BOOTPROTO=&quot;dhcp&quot;</span><br><span class="line">DHCP_HOSTNAME=&quot;bigdata&quot;</span><br><span class="line">HWADDR=&quot;D0:94:66:5B:76:89&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;no&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">UUID=&quot;9126f785-f642-4ce4-84d8-558284f17623&quot;</span><br></pre></td></tr></table></figure><p><strong>修改后的文件内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 network-scripts]# cat ifcfg-p1p1</span><br><span class="line">DEVICE=&quot;p1p1&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">DHCP_HOSTNAME=&quot;bigdata&quot;</span><br><span class="line">HWADDR=&quot;D0:94:66:5B:76:89&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">UUID=&quot;9126f785-f642-4ce4-84d8-558284f17623&quot;</span><br><span class="line">MASTER=bond1</span><br><span class="line">SLAVE=yes</span><br></pre></td></tr></table></figure><p>同样的，在第二块网卡上进行配置，配置之后的文件内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 network-scripts]# cat  ifcfg-p1p2</span><br><span class="line">DEVICE=&quot;p1p2&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">DHCP_HOSTNAME=&quot;bigdata&quot;</span><br><span class="line">HWADDR=&quot;D0:94:66:5B:76:8A&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">UUID=&quot;a89099a9-0852-4c43-bef3-07e3999ec597&quot;</span><br><span class="line">MASTER=bond1</span><br><span class="line">SLAVE=yes</span><br></pre></td></tr></table></figure><h2 id="配置bond网卡"><a href="#配置bond网卡" class="headerlink" title="配置bond网卡"></a>配置bond网卡</h2><p>子网卡配置完毕之后，我们开始配置bond网卡，vim创建文件，填入以下内容之后，保存退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 network-scripts]# vim ifcfg-bond1</span><br><span class="line">DEVICE=&quot;bond1&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">MTU=&quot;1500&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">IPADDR=103.13.244.21</span><br><span class="line">NETMASK=255.255.255.248</span><br><span class="line">GATEWAY=103.13.244.17</span><br><span class="line">DNS1=223.5.5.5</span><br><span class="line">DNS2=223.6.6.6</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Linux服务器双网卡bond配置
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="高并发" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="2层负载均衡" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/2%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="负载均衡" scheme="http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Chrome常用操作</title>
    <link href="http://yoursite.com/2018/06/25/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Chrome/Chrome%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/06/25/常用软件工具/Chrome/Chrome常用操作/</id>
    <published>2018-06-25T07:39:26.000Z</published>
    <updated>2018-06-25T07:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考文献：</strong></p><ul><li><a href="https://support.google.com/chrome/answer/157179?hl=zh-Hans" target="_blank" rel="noopener">chrome键盘快捷键</a></li></ul><hr><h2 id="Windows和Linux"><a href="#Windows和Linux" class="headerlink" title="Windows和Linux"></a>Windows和Linux</h2><p><strong>标签页和窗口快捷键</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开新窗口</td><td><strong>Ctrl + n</strong></td></tr><tr><td>在无痕模式下打开新窗口</td><td><strong>Ctrl + Shift + n</strong></td></tr><tr><td>打开新的标签页，并跳转到该标签页</td><td><strong>Ctrl + t</strong></td></tr><tr><td>重新打开最后关闭的标签页，并跳转到该标签页</td><td><strong>Ctrl + Shift + t</strong></td></tr><tr><td>跳转到下一个打开的标签页</td><td><strong>Ctrl + Tab</strong> 或 <strong>Ctrl + PgDn</strong></td></tr><tr><td>跳转到上一个打开的标签页</td><td><strong>Ctrl + Shift + Tab</strong> 或 <strong>Ctrl + PgUp</strong></td></tr><tr><td>跳转到特定标签页</td><td><strong>Ctrl + 1</strong> 到 <strong>Ctrl + 8</strong></td></tr><tr><td>跳转到最后一个标签页</td><td><strong>Ctrl + 9</strong></td></tr><tr><td>在当前标签页中打开主页</td><td><strong>Alt + Home</strong></td></tr><tr><td>打开当前标签页浏览记录中记录的上一个页面</td><td><strong>Alt + 向左箭头键</strong></td></tr><tr><td>打开当前标签页浏览记录中记录的下一个页面</td><td><strong>Alt + 向右箭头键</strong></td></tr><tr><td>关闭当前标签页</td><td><strong>Ctrl + w</strong> 或 <strong>Ctrl + F4</strong></td></tr><tr><td>关闭当前窗口</td><td><strong>Ctrl + Shift + w</strong></td></tr><tr><td>最小化当前窗口</td><td><strong>Alt + 空格键 + n</strong></td></tr><tr><td>最大化当前窗口</td><td><strong>Alt + 空格键 + x</strong></td></tr><tr><td>关闭当前窗口</td><td><strong>Alt + F4</strong></td></tr><tr><td>退出 Google Chrome</td><td><strong>Ctrl + Shift + q</strong></td></tr></tbody></table><p><strong>Google Chrome 功能快捷键</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开 Chrome 菜单</td><td><strong>Alt + f</strong> 或 <strong>Alt + e</strong> 或 <strong>F10 + Enter 键</strong></td></tr><tr><td>显示或隐藏书签栏</td><td><strong>Ctrl + Shift + b</strong></td></tr><tr><td>打开书签管理器</td><td><strong>Ctrl + Shift + o</strong></td></tr><tr><td>在新标签页中打开“历史记录”页</td><td><strong>Ctrl + h</strong></td></tr><tr><td>在新标签页中打开“下载内容”页</td><td><strong>Ctrl + j</strong></td></tr><tr><td>打开 Chrome 任务管理器</td><td><strong>Shift + Esc</strong></td></tr><tr><td>将焦点放置在 Chrome 工具栏中的第一项上</td><td><strong>Shift + Alt + t</strong></td></tr><tr><td>将焦点放置在 Chrome 工具栏中的最后一项上</td><td><strong>F10</strong></td></tr><tr><td>将焦点移到未聚焦于的对话框（如果显示）中</td><td><strong>F6</strong></td></tr><tr><td>打开查找栏搜索当前网页</td><td><strong>Ctrl + f</strong> 或 <strong>F3</strong></td></tr><tr><td>跳转到与查找栏中搜索字词相匹配的下一条内容</td><td><strong>Ctrl + g</strong></td></tr><tr><td>跳转到与查找栏中搜索字词相匹配的上一条内容</td><td><strong>Ctrl + Shift + g</strong></td></tr><tr><td>打开“开发者工具”</td><td><strong>Ctrl + Shift + j</strong> 或 <strong>F12</strong></td></tr><tr><td>打开“清除浏览数据”选项</td><td><strong>Ctrl + Shift + Delete</strong></td></tr><tr><td>在新标签页中打开 Chrome 帮助中心</td><td><strong>F1</strong></td></tr><tr><td>使用其他帐号登录或以访客身份浏览</td><td><strong>Ctrl + Shift + m</strong></td></tr><tr><td>打开反馈表单</td><td><strong>Alt + Shift + i</strong></td></tr></tbody></table><p><strong>地址栏快捷键</strong></p><p>在地址栏中可使用以下快捷键：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>使用默认搜索引擎进行搜索</td><td>输入搜索字词并按 <strong>Enter</strong> 键</td></tr><tr><td>使用其他搜索引擎进行搜索</td><td>输入搜索引擎名称，然后按 <strong>Tab</strong> 键</td></tr><tr><td>为网站名称添加 <code>www.</code> 和 <code>.com</code>，并在当前标签页中打开该网站</td><td>输入网站名称并按 <strong>Ctrl + Enter</strong> 键</td></tr><tr><td>打开新的标签页并执行 Google 搜索</td><td>输入搜索字词并按 <strong>Alt + Enter</strong> 键</td></tr><tr><td>跳转到地址栏</td><td><strong>Ctrl + l</strong>、<strong>Alt + d</strong> 或 <strong>F6</strong></td></tr><tr><td>从页面中的任意位置搜索</td><td><strong>Ctrl + k</strong> 或 <strong>Ctrl + e</strong></td></tr><tr><td>从地址栏中移除联想查询内容</td><td>按<strong>向下箭头键</strong>以突出显示相应内容，然后按 <strong>Shift + Delete</strong> 键</td></tr></tbody></table><p><strong>网页快捷键</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开选项以打印当前网页</td><td><strong>Ctrl + p</strong></td></tr><tr><td>打开选项以保存当前网页</td><td><strong>Ctrl + s</strong></td></tr><tr><td>重新加载当前网页</td><td><strong>F5</strong> 或 <strong>Ctrl + r</strong></td></tr><tr><td>重新加载当前网页（忽略缓存的内容）</td><td><strong>Shift + F5</strong> 或 <strong>Ctrl + Shift + r</strong></td></tr><tr><td>停止加载网页</td><td><strong>Esc</strong></td></tr><tr><td>浏览下一个可点击项</td><td><strong>Tab</strong></td></tr><tr><td>浏览上一个可点击项</td><td><strong>Shift + Tab</strong></td></tr><tr><td>使用 Chrome 打开计算机中的文件</td><td>按住 <strong>Ctrl + o</strong> 键并选择文件</td></tr><tr><td>显示当前网页的 HTML 源代码（不可修改）</td><td><strong>Ctrl + u</strong></td></tr><tr><td>将当前网页保存为书签</td><td><strong>Ctrl + d</strong></td></tr><tr><td>将所有打开的标签页以书签的形式保存在新文件夹中</td><td><strong>Ctrl + Shift + d</strong></td></tr><tr><td>开启或关闭全屏模式</td><td><strong>F11</strong></td></tr><tr><td>放大网页上的所有内容</td><td><strong>Ctrl 和 +</strong></td></tr><tr><td>缩小网页上的所有内容</td><td><strong>Ctrl 和 -</strong></td></tr><tr><td>将网页上的所有内容恢复到默认大小</td><td><strong>Ctrl + 0</strong></td></tr><tr><td>向下滚动网页，一次一个屏幕</td><td><strong>空格键</strong>或 <strong>PgDn</strong></td></tr><tr><td>向上滚动网页，一次一个屏幕</td><td><strong>Shift + 空格键</strong>或 <strong>PgUp</strong></td></tr><tr><td>转到网页顶部</td><td><strong>首页</strong></td></tr><tr><td>转到网页底部</td><td><strong>末尾</strong></td></tr><tr><td>在网页上水平滚动</td><td>按住 <strong>Shift</strong> 键并滚动鼠标滚轮</td></tr><tr><td>将光标移到文本字段中的上一个字词前面</td><td><strong>Ctrl + 向左箭头键</strong></td></tr><tr><td>将光标移到文本字段中的上一个字词后面</td><td><strong>Ctrl + 向右箭头键</strong></td></tr><tr><td>删除文本字段中的上一个字词</td><td><strong>Ctrl + Backspace</strong></td></tr><tr><td>在当前标签页中打开主页</td><td><strong>Alt + Home</strong></td></tr></tbody></table><p><strong>鼠标快捷键</strong></p><p>以下快捷键要求您使用鼠标：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>在当前标签页中打开链接（仅限鼠标）</td><td>将链接拖到标签页中</td></tr><tr><td>在新的后台标签页中打开链接</td><td>按住 <strong>Ctrl</strong> 键的同时点击链接</td></tr><tr><td>打开链接，并跳转到该链接</td><td>按住 <strong>Ctrl + Shift</strong> 键的同时点击链接</td></tr><tr><td>打开链接，并跳转到该链接（仅使用鼠标）</td><td>将链接拖到标签栏的空白区域</td></tr><tr><td>在新窗口中打开链接</td><td>按住 <strong>Shift</strong> 键的同时点击链接</td></tr><tr><td>在新窗口中打开标签页（仅使用鼠标）</td><td>将标签页拖出标签栏</td></tr><tr><td>将标签页移至当前窗口（仅限鼠标）</td><td>将标签页拖到现有窗口中</td></tr><tr><td>将标签页移回其原始位置</td><td>拖动标签页的同时按 <strong>Esc</strong></td></tr><tr><td>将当前网页保存为书签</td><td>将相应网址拖动到书签栏中</td></tr><tr><td>下载链接目标</td><td>按住 <strong>Alt</strong> 键的同时点击链接</td></tr><tr><td>显示浏览记录</td><td>右键点击“后退”箭头 <img src="https://lh3.googleusercontent.com/u8GsV4Wm3XNjCmpc3qkbAIPf2Tmily1qNewCqzlV9L32bAeITAp7AWsD9IvYjJVjfx0=w18-h18" alt="返回"> 或“前进”箭头 <img src="https://lh3.googleusercontent.com/2XV3kvUf2fdl-UElXpPIVaqjdNC_fzLbBnWlPmj2_4BnsqX7pYcf-qF0n62Xo2ZxFg=w18-h18" alt="Next">，或者点击（按住鼠标按键别松手）“后退”箭头 <img src="https://lh3.googleusercontent.com/u8GsV4Wm3XNjCmpc3qkbAIPf2Tmily1qNewCqzlV9L32bAeITAp7AWsD9IvYjJVjfx0=w18-h18" alt="返回"> 或“前进”箭头 <img src="https://lh3.googleusercontent.com/2XV3kvUf2fdl-UElXpPIVaqjdNC_fzLbBnWlPmj2_4BnsqX7pYcf-qF0n62Xo2ZxFg=w18-h18" alt="Next"></td></tr><tr><td>在最大化模式和窗口模式间切换</td><td>双击标签栏的空白区域</td></tr><tr><td>放大网页上的所有内容</td><td>按住 <strong>Ctrl</strong> 键的同时向上滚动鼠标滚轮</td></tr><tr><td>缩小网页上的所有内容</td><td>按住 <strong>Ctrl</strong> 键的同时向下滚动鼠标滚轮</td></tr></tbody></table><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p><strong>标签页和窗口快捷键</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开新窗口</td><td><strong>⌘ + n</strong></td></tr><tr><td>在无痕模式下打开新窗口</td><td><strong>⌘ + Shift + n</strong></td></tr><tr><td>打开新的标签页，并跳转到该标签页</td><td><strong>⌘ + t</strong></td></tr><tr><td>重新打开最后关闭的标签页，并跳转到该标签页</td><td><strong>⌘ + Shift + t</strong></td></tr><tr><td>跳转到下一个打开的标签页</td><td><strong>⌘ + Option + 向右箭头键</strong></td></tr><tr><td>跳转到上一个打开的标签页</td><td><strong>⌘ + Option + 向左箭头键</strong></td></tr><tr><td>跳转到特定标签页</td><td><strong>⌘ + 1</strong> 到 <strong>⌘ + 8</strong></td></tr><tr><td>跳转到最后一个标签页</td><td><strong>⌘ + 9</strong></td></tr><tr><td>打开当前标签页浏览记录中记录的上一个页面</td><td><strong>⌘ + [</strong> 或 <strong>⌘ + 向左箭头键</strong></td></tr><tr><td>打开当前标签页浏览记录中记录的下一个页面</td><td><strong>⌘ + ]</strong> 或 <strong>⌘ + 向右箭头键</strong></td></tr><tr><td>关闭当前标签页或弹出式窗口</td><td><strong>⌘ + w</strong></td></tr><tr><td>关闭当前窗口</td><td><strong>⌘ + Shift + w</strong></td></tr><tr><td>最小化窗口</td><td><strong>⌘ + m</strong></td></tr><tr><td>隐藏 Google Chrome</td><td><strong>⌘ + h</strong></td></tr><tr><td>退出 Google Chrome</td><td><strong>⌘ + q</strong></td></tr></tbody></table><p><strong>Google Chrome 功能快捷键</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>显示或隐藏书签栏</td><td><strong>⌘ + Shift + b</strong></td></tr><tr><td>打开书签管理器</td><td><strong>⌘ + Option + b</strong></td></tr><tr><td>在新标签页中打开“设置”页</td><td><strong>⌘ + ,</strong></td></tr><tr><td>在新标签页中打开“历史记录”页</td><td><strong>⌘ + y</strong></td></tr><tr><td>在新标签页中打开“下载内容”页</td><td><strong>⌘ + Shift + j</strong></td></tr><tr><td>打开查找栏搜索当前网页</td><td><strong>⌘ + f</strong></td></tr><tr><td>跳转到与查找栏中搜索字词相匹配的下一条内容</td><td><strong>⌘ + g</strong></td></tr><tr><td>跳转到与查找栏中搜索字词相匹配的上一条内容</td><td><strong>⌘ + Shift + g</strong></td></tr><tr><td>打开查找栏后，搜索选定文本</td><td><strong>⌘ + e</strong></td></tr><tr><td>打开“开发者工具”</td><td><strong>⌘ + Option + i</strong></td></tr><tr><td>打开“清除浏览数据”选项</td><td><strong>⌘ + Shift + Delete</strong></td></tr><tr><td>使用其他帐号登录或以访客身份浏览</td><td><strong>⌘ + Shift + m</strong></td></tr></tbody></table><p><strong>地址栏快捷键</strong></p><p>在地址栏中可使用以下快捷键：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>使用默认搜索引擎进行搜索</td><td>输入搜索字词并按 <strong>Enter</strong> 键</td></tr><tr><td>使用其他搜索引擎进行搜索</td><td>输入搜索引擎名称，然后按 <strong>Tab</strong> 键</td></tr><tr><td>为网站名称添加 <code>www.</code> 和 <code>.com</code>，并在当前标签页中打开该网站</td><td>输入网站名称并按 <strong>Control + Enter</strong> 键</td></tr><tr><td>为网站名称添加 <code>www.</code> 和 <code>.com</code>，并在新标签页中打开该网站</td><td>输入网站名称并按 <strong>Control + Shift + Enter</strong> 键</td></tr><tr><td>在新的后台标签页中打开网站</td><td>输入网址并按 <strong>⌘ + Enter</strong> 键</td></tr><tr><td>跳转到地址栏</td><td><strong>⌘ + l</strong></td></tr><tr><td>从地址栏中移除联想查询内容</td><td>按<strong>向下箭头键</strong>以突出显示相应内容，然后按 <strong>Shift + fn + Delete</strong> 键</td></tr></tbody></table><p><strong>网页快捷键</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开选项以打印当前网页</td><td><strong>⌘ + p</strong></td></tr><tr><td>打开选项以保存当前网页</td><td><strong>⌘ + s</strong></td></tr><tr><td>打开“页面设置”对话框</td><td><strong>⌘ + Option + p</strong></td></tr><tr><td>重新加载当前网页（忽略缓存的内容）</td><td><strong>⌘ + Shift + r</strong></td></tr><tr><td>停止加载网页</td><td><strong>Esc</strong></td></tr><tr><td>浏览下一个可点击项</td><td><strong>Tab</strong></td></tr><tr><td>浏览上一个可点击项</td><td><strong>Shift + Tab</strong></td></tr><tr><td>使用 Google Chrome 打开计算机中的文件</td><td>按住 <strong>⌘ + o</strong> 键并选择文件</td></tr><tr><td>显示当前网页的 HTML 源代码（不可修改）</td><td><strong>⌘ + Option + u</strong></td></tr><tr><td>打开 JavaScript 控制台</td><td><strong>⌘ + Option + j</strong></td></tr><tr><td>将当前网页保存为书签</td><td><strong>⌘ + d</strong></td></tr><tr><td>将所有打开的标签页以书签的形式保存在新文件夹中</td><td><strong>⌘ + Shift + d</strong></td></tr><tr><td>开启或关闭全屏模式</td><td><strong>⌘ + Ctrl + f</strong></td></tr><tr><td>放大网页上的所有内容</td><td><strong>⌘ 和 +</strong></td></tr><tr><td>缩小网页上的所有内容</td><td><strong>⌘ 和 -</strong></td></tr><tr><td>将网页上的所有内容恢复到默认大小</td><td><strong>⌘ + 0</strong></td></tr><tr><td>向下滚动网页，一次一个屏幕</td><td><strong>空格键</strong></td></tr><tr><td>向上滚动网页，一次一个屏幕</td><td><strong>Shift + 空格键</strong></td></tr><tr><td>搜索网络</td><td><strong>⌘ + Option + f</strong></td></tr><tr><td>将光标移到文本字段中的上一个字词前面</td><td><strong>Option + 向左箭头键</strong></td></tr><tr><td>将光标移到文本字段中的上一个字词后面</td><td><strong>Option + 向右箭头键</strong></td></tr><tr><td>删除文本字段中的上一个字词</td><td><strong>Option + Delete</strong></td></tr><tr><td>在当前标签页中打开主页</td><td><strong>⌘ + Shift + h</strong></td></tr></tbody></table><p><strong>鼠标快捷键</strong></p><p>以下快捷键要求您使用鼠标：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>在当前标签页中打开链接（仅限鼠标）</td><td>将链接拖到标签页中</td></tr><tr><td>在新的后台标签页中打开链接</td><td>按住 <strong>⌘</strong> 键的同时点击链接</td></tr><tr><td>打开链接，并跳转到该链接</td><td>按住 <strong>⌘ + Shift</strong> 键的同时点击链接</td></tr><tr><td>打开链接，并跳转到该链接（仅使用鼠标）</td><td>将链接拖到标签栏的空白区域</td></tr><tr><td>在新窗口中打开链接</td><td>按住 <strong>Shift</strong> 键的同时点击链接</td></tr><tr><td>在新窗口中打开标签页（仅使用鼠标）</td><td>将标签页拖出标签栏</td></tr><tr><td>将标签页移至当前窗口（仅限鼠标）</td><td>将标签页拖到现有窗口中</td></tr><tr><td>将标签页移回其原始位置</td><td>拖动标签页的同时按 <strong>Esc</strong></td></tr><tr><td>将当前网页保存为书签</td><td>将相应网址拖动到书签栏中</td></tr><tr><td>下载链接目标</td><td>按住 <strong>Option</strong> 键的同时点击链接</td></tr><tr><td>显示浏览记录</td><td>右键点击“后退”箭头 <img src="https://lh3.googleusercontent.com/u8GsV4Wm3XNjCmpc3qkbAIPf2Tmily1qNewCqzlV9L32bAeITAp7AWsD9IvYjJVjfx0=w18-h18" alt="返回"> 或“前进”箭头 <img src="https://lh3.googleusercontent.com/2XV3kvUf2fdl-UElXpPIVaqjdNC_fzLbBnWlPmj2_4BnsqX7pYcf-qF0n62Xo2ZxFg=w18-h18" alt="Next">，或者点击（按住鼠标按键别松手）“后退”箭头 <img src="https://lh3.googleusercontent.com/u8GsV4Wm3XNjCmpc3qkbAIPf2Tmily1qNewCqzlV9L32bAeITAp7AWsD9IvYjJVjfx0=w18-h18" alt="返回"> 或“前进”箭头<img src="https://lh3.googleusercontent.com/2XV3kvUf2fdl-UElXpPIVaqjdNC_fzLbBnWlPmj2_4BnsqX7pYcf-qF0n62Xo2ZxFg=w18-h18" alt="Next"></td></tr><tr><td>将窗口高度最大化</td><td>双击标签栏的空白区域</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Chrome常用操作
    
    </summary>
    
      <category term="常用软件工具" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Chrome" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Chrome/"/>
    
    
      <category term="Chrome" scheme="http://yoursite.com/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>第1章：中国人学习英语的误区</title>
    <link href="http://yoursite.com/2018/06/24/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%B7%9F%E6%81%B6%E9%AD%94%E5%A5%B6%E7%88%B8%E5%AD%A6%E8%8B%B1%E8%AF%AD/%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD%E7%9A%84%E8%AF%AF%E5%8C%BA/"/>
    <id>http://yoursite.com/2018/06/24/个人知识体系/英语学习/跟恶魔奶爸学英语/第1章：中国人学习英语的误区/</id>
    <published>2018-06-24T12:20:41.000Z</published>
    <updated>2018-06-24T12:20:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神功大力丸思想"><a href="#神功大力丸思想" class="headerlink" title="神功大力丸思想"></a>神功大力丸思想</h1><p>大部分人幻想通过一套教材就能够解决英语的所有问题，幻想简单、高效、快速、直接的一种方法，解决学习英语中遇到的所有难题</p><p>国内这种大力丸的思想的起源基本是来自于老师群体，培训机构的老师群体，把这种理念和方法进行包装，试图以一种简单的策略来解决所有的英语问题</p><p>语言学习是一个复杂的整体，分为不同的阶段，每个阶段的重点都不一样，需要选用的教材，方法，策略也都不一样。并且，因为每个人的学习习惯和作息习惯都不一样，因此选用的学习策略自然也不应该相同</p><p>在整个英语学习过程当中，需要输入大量的听力和阅读材料，不能只靠一套课本就彻底解决所有问题，你需要认真分析你所处的水平基础（每个人的水平和基础不一样），灵活选择不同的教材和不同的方法策略</p><p>国内的学习者总是喜欢想当然，一定要在某种方法和达到某种水平之间建立因果关系，也就是说，他们做了某事，就一定可以收获什么，如果说我不能收获到成果，可能不是因为方法材料不适合，而只是因为我不够努力和坚持。盲目应用不适合自己的方法和教材</p><p><img src="http://picture.watchmen.xin/naiba/allinone.png" alt="allinone"></p><h1 id="坚持一切以考试为核心"><a href="#坚持一切以考试为核心" class="headerlink" title="坚持一切以考试为核心"></a>坚持一切以考试为核心</h1>]]></content>
    
    <summary type="html">
    
      第1章：中国人学习英语的误区
    
    </summary>
    
      <category term="个人知识体系" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
      <category term="英语学习" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="跟恶魔奶爸学英语" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%B7%9F%E6%81%B6%E9%AD%94%E5%A5%B6%E7%88%B8%E5%AD%A6%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="英语学习" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《运动与健康》-湖北大学</title>
    <link href="http://yoursite.com/2018/06/24/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC/%E3%80%8A%E8%BF%90%E5%8A%A8%E4%B8%8E%E5%81%A5%E5%BA%B7%E3%80%8B-%E6%B9%96%E5%8C%97%E5%A4%A7%E5%AD%A6/"/>
    <id>http://yoursite.com/2018/06/24/个人知识体系/中国大学MOOC/《运动与健康》-湖北大学/</id>
    <published>2018-06-24T07:16:19.000Z</published>
    <updated>2018-06-24T07:16:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：健康与亚健康"><a href="#第一章：健康与亚健康" class="headerlink" title="第一章：健康与亚健康"></a>第一章：健康与亚健康</h1><h2 id="第一节：你健康吗？"><a href="#第一节：你健康吗？" class="headerlink" title="第一节：你健康吗？"></a>第一节：你健康吗？</h2><p>世界卫生组织对健康的定义：健康是一种全面的身体、心理以及社会幸福的理想状态。包括<strong><code>身体健康，心理健康，社会适应良好和道德健康</code></strong>的理想状态。</p><p> <strong>一：身体健康</strong></p><ul><li>身体健康的特征之一：身体形态与结构发育状况良好。</li></ul><blockquote><p>身体形态具体指的是身体的外部形状和特征，主要包括体型、身体姿势、营养状况及身体成分等方面，反映了人体的生长发育水平，一般通过测量身高体重胸围皮下组织等来考察</p><p>身体结构来看：人体的上部与下部，大腿与小腿，上臂与前臂等比例较协调，较为合理的比值是0.618:1，即我们常说的黄金分割。</p></blockquote><ul><li>身体健康的特征之二：生理机能水平高。</li></ul><blockquote><p>人体身体机能是指人体各器官系统发育是否良好，功能是否健全，运转是否自如等。常见的人体机能衡量指标有：心率、血压、肺活量等</p><p>以心率为例，人的心率与寿命成反比关系，即心跳越慢，寿命越长，心跳越快，寿命越短</p><p>自然界中，乌龟的寿命长达500年以上，它心脏每分钟的跳动次数为至少只有8次，而有一种小鼠，每分钟心跳高达1200次，其寿命只有一年。</p><p>人类研究证实（有科学根据）：如果成人安静时的心率维持在60次/分钟左右，其寿命可以达到93岁。相反，如果安静时的心率大于80次/分钟，其寿命明显缩短</p><p>心率是寿命的标尺</p><p> 经过长期运动训练的人，其安静时的心率，一般维持在60次/分钟左右。</p></blockquote><ul><li>身体健康的特征之三：身体素质好与运动能力强</li></ul><blockquote><p>身体素质是指人体在活动中表现出来的力量、速度、耐力、灵敏、柔韧等机能。身体素质的强弱是衡量一个人体质健康的重要指标之一</p></blockquote><ul><li><p>身体健康的特征之四：身体具有良好的适应能力</p><p>指的是人体在适应内外环境中所表示出来的机能能力。对高温、低温、加速度、旋转等的适应能力</p></li></ul><p><strong>二：心理健康</strong></p><p> 心理健康的特征：</p><ul><li>具有良好的自我控制和调节能力。</li><li>对于外界的刺激有良好的应激能力，心理经常处于平衡和满足状态。</li></ul><p>具体表现为：</p><ul><li>有充分的安全感</li><li>有自知之明</li><li>善于平衡人际关系</li><li>正视现实</li><li>热爱生活</li><li>乐于工作</li><li>能保持人格的完整与和谐</li><li>善于学习、努力进取</li></ul><p><strong>三：道德健康</strong></p><p> 道德健康的基本特征：</p><ul><li>有积极向上的信仰</li><li>高尚的品德与情操、完美的人格</li></ul><p>具体表现：</p><ul><li>作风正派</li><li>遵纪守法</li><li>努力工作</li><li>乐于奉献</li><li>有责任感</li><li>努力进取</li></ul><p><strong>四：社会适应能力</strong></p><p>指人为了在社会上更好生存而进行心理上、生理上以及行为上的各种适应性变化，与社会达到和谐状态的一种执行适应能力。</p><p>一般认为包括以下方面：</p><ul><li>个人生活自理能力</li><li>基本劳动能力</li><li>用道德规范约束自己的能力</li></ul><p>根据统计资料显示：真正按照世界卫生组织的健康标准，健康人不超过15%。而真正有各种疾病的大概也只有15%。也就是说70%人处于健康和疾病之间的第三种状态-亚健康状态。</p><h2 id="第二节：你离亚健康有多远？"><a href="#第二节：你离亚健康有多远？" class="headerlink" title="第二节：你离亚健康有多远？"></a>第二节：你离亚健康有多远？</h2>]]></content>
    
    <summary type="html">
    
      《运动与健康》-湖北大学
    
    </summary>
    
      <category term="个人知识体系" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
      <category term="中国大学MOOC" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC/"/>
    
      <category term="《运动与健康》-湖北大学" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC/%E3%80%8A%E8%BF%90%E5%8A%A8%E4%B8%8E%E5%81%A5%E5%BA%B7%E3%80%8B-%E6%B9%96%E5%8C%97%E5%A4%A7%E5%AD%A6/"/>
    
    
      <category term="中国大学MOOC" scheme="http://yoursite.com/tags/%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC/"/>
    
  </entry>
  
  <entry>
    <title>《鞠强教授暨嫡传弟子团:管理心理学之技巧与理论》</title>
    <link href="http://yoursite.com/2018/06/24/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85FM/%E3%80%8A%E9%9E%A0%E5%BC%BA%E6%95%99%E6%8E%88%E6%9A%A8%E5%AB%A1%E4%BC%A0%E5%BC%9F%E5%AD%90%E5%9B%A2-%E7%AE%A1%E7%90%86%E5%BF%83%E7%90%86%E5%AD%A6%E4%B9%8B%E6%8A%80%E5%B7%A7%E4%B8%8E%E7%90%86%E8%AE%BA%E3%80%8B/"/>
    <id>http://yoursite.com/2018/06/24/个人知识体系/喜马拉雅FM/《鞠强教授暨嫡传弟子团-管理心理学之技巧与理论》/</id>
    <published>2018-06-24T07:09:03.000Z</published>
    <updated>2018-06-24T07:09:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="市场细分化理解深化"><a href="#市场细分化理解深化" class="headerlink" title="市场细分化理解深化"></a>市场细分化理解深化</h1><h1 id="中国历史为什么大统一是主流"><a href="#中国历史为什么大统一是主流" class="headerlink" title="中国历史为什么大统一是主流"></a>中国历史为什么大统一是主流</h1><h1 id="拖延症最大的坏处不是效率低-是什么呢？"><a href="#拖延症最大的坏处不是效率低-是什么呢？" class="headerlink" title="拖延症最大的坏处不是效率低-是什么呢？"></a>拖延症最大的坏处不是效率低-是什么呢？</h1><h1 id="矛盾营销信息成本高"><a href="#矛盾营销信息成本高" class="headerlink" title="矛盾营销信息成本高"></a>矛盾营销信息成本高</h1>]]></content>
    
    <summary type="html">
    
      《鞠强教授暨嫡传弟子团:管理心理学之技巧与理论》
    
    </summary>
    
      <category term="个人知识体系" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
      <category term="喜马拉雅FM" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85FM/"/>
    
      <category term="鞠强教授暨嫡传弟子团:管理心理学之技巧与理论" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85FM/%E9%9E%A0%E5%BC%BA%E6%95%99%E6%8E%88%E6%9A%A8%E5%AB%A1%E4%BC%A0%E5%BC%9F%E5%AD%90%E5%9B%A2-%E7%AE%A1%E7%90%86%E5%BF%83%E7%90%86%E5%AD%A6%E4%B9%8B%E6%8A%80%E5%B7%A7%E4%B8%8E%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="喜马拉雅FM" scheme="http://yoursite.com/tags/%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85FM/"/>
    
  </entry>
  
  <entry>
    <title>每日碎片知识梳理-2018年</title>
    <link href="http://yoursite.com/2018/06/24/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%AF%8F%E6%97%A5%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/2018%E5%B9%B4/%E6%AF%8F%E6%97%A5%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86-2018%E5%B9%B4/"/>
    <id>http://yoursite.com/2018/06/24/个人知识体系/每日碎片知识梳理/2018年/每日碎片知识梳理-2018年/</id>
    <published>2018-06-24T05:52:04.000Z</published>
    <updated>2018-06-24T05:52:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018年6月"><a href="#2018年6月" class="headerlink" title="2018年6月"></a>2018年6月</h1><h2 id="6月24日"><a href="#6月24日" class="headerlink" title="6月24日"></a>6月24日</h2><p><strong>标题：为泡妞之成功而读书</strong></p><ul><li>来源：《得到》-逻辑思维-第20期</li></ul><p><strong>内容：</strong></p><ul><li>传统的知识构成和今天我们要面对的知识构成是有区别的</li></ul><blockquote><p>近代化以来，教育是人类一项沉重的负担，因为随着工业化的发展，各个门类的知识持续增长，所以就必须建立一个体系，将这些知识灌输给年轻人</p></blockquote><h2 id="6月25日"><a href="#6月25日" class="headerlink" title="6月25日"></a>6月25日</h2>]]></content>
    
    <summary type="html">
    
      每日碎片知识梳理-2018年
    
    </summary>
    
      <category term="个人知识体系" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
      <category term="每日碎片知识梳理" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%AF%8F%E6%97%A5%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
      <category term="2018年" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%AF%8F%E6%97%A5%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/2018%E5%B9%B4/"/>
    
    
      <category term="每日碎片知识梳理" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Typora</title>
    <link href="http://yoursite.com/2018/06/24/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Markdown/Typora/"/>
    <id>http://yoursite.com/2018/06/24/常用软件工具/Markdown/Typora/</id>
    <published>2018-06-24T04:05:16.000Z</published>
    <updated>2018-06-24T04:05:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考文献：</strong></p><ul><li><u><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora官方网站</a></u></li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p>markdown编辑器有很多的选择，对比使用之后，目前在用的是一款叫Typora编辑器，特写文章记录一下。本文只是简单介绍，待亲自上手体验之后方可体会它的美感。</p><p><strong>官方说明：</strong></p><blockquote><p>Typora will give you a seamless experience as both a reader and a writer. It removes the preview window, mode switcher, syntax symbols of markdown source code, and all other unnecessary distractions. Replace them with a real live preview feature to help you concentrate the content itself. </p></blockquote><p>Markdown 编辑器，比较常见的是双栏布局：左边敲源码，右边显示渲染结果。 </p><p>但是Typora 是单栏布局，是真正意义上的所见即所得，摒弃了传统的markdown编辑器的分栏设置（例如markdown pad 2左边是源码，右边是渲染之后的显示效果）以及其他非必须的内容，书写时直接显示成效图。光标一离开，就立刻显示为想要的样子，并且由用户选择何时进入源码模式（输入ctrl+/即可切换源码编辑模式）</p><h1 id="入门实践"><a href="#入门实践" class="headerlink" title="入门实践"></a>入门实践</h1><h2 id="快捷键操作"><a href="#快捷键操作" class="headerlink" title="快捷键操作"></a>快捷键操作</h2><h3 id="标题操作"><a href="#标题操作" class="headerlink" title="标题操作"></a>标题操作</h3><p><strong>插入标题：</strong></p><ul><li><strong>一级标题：</strong>ctrl+1</li><li><strong>二级标题：</strong>ctrl+2</li><li><strong>三级标题：</strong>ctrl+3</li><li><strong>四级标题：</strong>ctrl+4</li><li><strong>五级标题：</strong>ctrl+5</li></ul><p><strong>增大标题级别：</strong>ctrl + =</p><p><strong>减小标题级别：</strong>ctrl + -</p><h3 id="表格操作"><a href="#表格操作" class="headerlink" title="表格操作"></a>表格操作</h3><p><strong>插入表格：</strong></p><ul><li><p>编辑器中插入</p><blockquote><p>直接<strong><code>ctrl+t</code></strong>插入表格，并且在弹出的提示框中可以自由选择表格的行和列数</p></blockquote></li><li><p>外部复制（excel等专业表格软件中复制）</p><blockquote><p>直接复制即可，Typora会自动把excel的格式转换为markdown的语法格式</p></blockquote></li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul><li><p>行内代码块</p><blockquote><p>使用``号将内容包含即可，快捷键为：ctrl+shift+反引号</p></blockquote></li><li><p>行代码块</p><blockquote><p>在开头输入```然后回车，在下方输入内容，内容将会自动的变成代码块的形式</p></blockquote></li><li><p>指定格式的行代码块</p><blockquote><p>在开头输入```bash/python/ruby然后回车，在下方输入内容，内容将会自动的变成指定代码块的形式</p></blockquote></li></ul><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li><p>基础无序列表： 使用 - content 即可</p></li><li><p>完成/未完成列表：<code>-[] content or - [x] content</code></p></li><li><p>无序列表缩进问题</p><ul><li>增大列表缩进（也就是右移，子列表）：ctrl+]</li><li>减小列表缩进（也就是左移，父列表）：ctrl+[</li></ul></li></ul><h3 id="网页链接与图片"><a href="#网页链接与图片" class="headerlink" title="网页链接与图片"></a>网页链接与图片</h3><ul><li><p>编辑器中插入网页超链接</p><blockquote><p>直接ctrl+k即可出现相对应的格式</p></blockquote></li><li><p>给文字加上超链接</p><blockquote><p>只需拷贝链接，然后选中文字，按一下ctrl + k，链接就添上了 </p></blockquote></li><li><p>编辑器中插入图片</p><blockquote><p>ctrl+shift+i</p></blockquote></li><li><p>图片拖拽</p><blockquote><p>这个功能可以将拖入图片转化为插入图片，但是这个功能默认是关闭的，需要在设置中手动开启，设置的路径为: Preferences -&gt; Editor</p></blockquote></li></ul><h3 id="切换源码-预览模式"><a href="#切换源码-预览模式" class="headerlink" title="切换源码/预览模式"></a>切换源码/预览模式</h3><p>输入ctrl+/可以再源码模式和成像预览模式之间进行来回切换</p><h3 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h3><ul><li>文字加粗：ctrl+b</li><li>文字倾斜：ctrl+i</li><li>文字下划线：ctrl+u</li><li>文字删除线：两个波浪线分别在文字的两边<code>~~content~~</code></li><li>清除格式：ctrl+\</li></ul><h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3><p>输出[toc]然后回车，将会自动产生一个目录，这个目录抽取了文章的所有标题，自动更新内容</p><h2 id="软件本身操作"><a href="#软件本身操作" class="headerlink" title="软件本身操作"></a>软件本身操作</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><h4 id="快速打开"><a href="#快速打开" class="headerlink" title="快速打开"></a>快速打开</h4><p>输入ctrl+p之后，输入关键字，它会在当前文件夹下进行搜索</p><h4 id="打开文件位置"><a href="#打开文件位置" class="headerlink" title="打开文件位置"></a>打开文件位置</h4><p>点击文件之后，在侧边栏中会有<code>打开文件位置</code>的选项，它能进入该文件所在的目录，这个功能十分的方便。</p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>ctrl+f 进行查找</p><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>ctrl+h进行替换</p><h4 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h4><p>在其中的空格与换行中，有首行缩进的选项，选中之后，会把所有内容中的首行内容进行缩进两个空格。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>ctrl+shitf+`</p><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>alt+shift+5</p><h4 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h4><p><code>==</code>content<code>==</code></p><p>效果如下：</p><p>==content==</p><h4 id="清除样式"><a href="#清除样式" class="headerlink" title="清除样式"></a>清除样式</h4><p>ctrl+\</p>]]></content>
    
    <summary type="html">
    
      Typora软件使用
    
    </summary>
    
      <category term="常用软件工具" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Markdown" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Markdown/"/>
    
    
      <category term="Typora" scheme="http://yoursite.com/tags/Typora/"/>
    
  </entry>
  
  <entry>
    <title>修改主题超链接样式</title>
    <link href="http://yoursite.com/2018/06/23/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Hexo/%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98%E8%B6%85%E9%93%BE%E6%8E%A5%E6%A0%B7%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/06/23/个人知识体系/个人博客/Hexo/修改主题超链接样式/</id>
    <published>2018-06-23T10:56:27.000Z</published>
    <updated>2018-06-23T10:56:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为我使用的是Next主题，这里说下Next主题的修改，其他主题的操作也都是一致的</p><p>Next默认对超链接只有下划线样式，在查看文章内容的时候很容易被忽略</p><p>主题样式是在\hexoBlog\themes\next\source\css,这里面保存了Muse,Mist和Pisces等主题的css文件</p><p>例如,字体和边框的颜色还有字体,图片的大小等保存在next\source\css_variables里.</p><p>而我们要修改的body超链接的样式在themes\next\source\css_common\components\post\post.styl里,编辑文件，在文件中添加以下内容:</p><pre><code>.post-body a {  color: #428BCA;  font-weight: bold;}</code></pre><p>添加以后，我们需要执行clean操作生效</p><pre><code>hexo clean hexo g -d</code></pre><p>强制刷新我们的文章内容，就能看到超链接已经变成蓝色粗体的形式</p><p>如下图所示：</p><p><img src="http://picture.watchmen.xin/tmp/next_css.png" alt="css"></p>]]></content>
    
    <summary type="html">
    
      修改主题超链接样式
    
    </summary>
    
      <category term="个人知识体系" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
      <category term="个人博客" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>iperf命令</title>
    <link href="http://yoursite.com/2018/06/12/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/iperf%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/06/12/IT科学技术知识体系结构-Linux运维方向/Linux基础知识/Linux常用命令/iperf命令/</id>
    <published>2018-06-12T09:19:32.000Z</published>
    <updated>2018-06-12T09:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><a href="https://github.com/esnet/iperf" target="_blank" rel="noopener">github主页</a></li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>使用iperf时，涉及服务端和客户端的概念</p><p>因为iperf是使用C语言编写的，因此在安装之前服务器上要安装gcc编译器。</p><h2 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h2><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code># wget http://downloads.es.net/pub/iperf/iperf-3.5.tar.gz# tar -zxvf iperf-3.5.tar.gz# cd iperf-3.5# ./configure; make; make install</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code># iperf3 -s -D</code></pre><p>iperf2版本启动之后，默认的监听端口为：5001</p><p>iperf3版本启动之后，默认的监听端口为：5201</p><p>因为iperf2版本存在很多问题，因此我们现在主要使用iperf3版本进行测试</p><h3 id="补充：服务端启动参数"><a href="#补充：服务端启动参数" class="headerlink" title="补充：服务端启动参数"></a>补充：服务端启动参数</h3><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><pre><code># wget http://downloads.es.net/pub/iperf/iperf-3.5.tar.gz# tar -zxvf iperf-3.5.tar.gz# cd iperf-3.5# ./configure; make; make install</code></pre><p>客户端不需要启动</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p><strong>客户端指定发送一个5GB的数据包，每隔5秒钟输出一次传输状态，输出结果的显示单位为MB显示，并发3个线程发送</strong></p><pre><code># iperf  -c 10.11.6.3 -n 5000000000 -p 5201 -i 5 -f M -P 3 </code></pre>]]></content>
    
    <summary type="html">
    
      Linux常用命令之iperf命令
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="Linux基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Linux常用命令" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="iperf" scheme="http://yoursite.com/tags/iperf/"/>
    
  </entry>
  
  <entry>
    <title>高速通道从入门到实践</title>
    <link href="http://yoursite.com/2018/06/08/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/%E9%98%BF%E9%87%8C%E4%BA%91/%E9%AB%98%E9%80%9F%E9%80%9A%E9%81%93%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/06/08/IT科学技术知识体系结构-Linux运维方向/公有云产品/阿里云/高速通道从入门到实践/</id>
    <published>2018-06-08T04:12:15.000Z</published>
    <updated>2018-06-08T04:12:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>阿里云高速通道（Express Connect）服务，帮助您在VPC间、VPC与本地数据中心间搭建私网通信通道，提高网络拓扑的灵活性和跨网络通信的质量和安全性。使用高速通道可以使您避免绕行公网带来的网络质量不稳定问题，同时可以免去数据在传输过程中被窃取的风险。</p><p><strong>VPC间内网通信</strong></p><ul><li>高速通道支持位于相同地域或不同地域，同一账号或不同账号的VPC之间进行内网互通。</li></ul><ul><li>阿里云通过在<strong><code>两侧VPC的路由器上分别创建路由器接口</code></strong>，以及自有的骨干传输网络来搭建高速通道，轻松实现两个VPC之间安全可靠，方便快捷的通信。</li></ul><p><strong>本地数据中心和阿里云上VPC间内网通信</strong></p><ul><li>您可以通过物理专线在物理层面上连接您的本地数据中心到阿里云，然后建立边界路由器和路由器接口来连接数据中心与阿里云VPC。</li></ul><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>基于软件自定义网络（Software Defined Network，简称SDN）架构下的三层Overlay技术和交换机虚拟化技术，阿里云将客户的物理专线接入的端口隔离起来，并抽象成边界路由器。通过目前主流的隧道技术，阿里云将客户的数据包在交换机内部进行封装，在用户的物理专线和VPC的路由器之间加上隧道封装，然后将数据传输到VPC内。</p><p><img src="http://picture.watchmen.xin/channel/base.png" alt="base"></p><h2 id="路由器接口"><a href="#路由器接口" class="headerlink" title="路由器接口"></a>路由器接口</h2><p>路由器接口是一种虚拟设备，具备搭建通信通道并控制其工作状态的功能。</p><p>高速通道通过在两侧的VPC路由器上分别创建路由器接口为两个VPC之间搭建内网通信通道。</p><p>在两个路由器接口建立连接后，两侧的路由器可以通过建立的通道相互发送消息。因此，两个VPC中的资源（比如ECS实例）就可以通过内网进行通信了。</p><p><img src="http://picture.watchmen.xin/channel/interface.png" alt=""></p><h3 id="发起端和接受端"><a href="#发起端和接受端" class="headerlink" title="发起端和接受端"></a>发起端和接受端</h3><p>当两个路由器接口进行互连时，一个扮演连接发起端角色，另一个扮演连接接受端角色。只有发起端路由器接口才可以发起连接，接受端路由器接口只能等待发起端发起连接。发起端和接受端仅用于控制连接建立的过程，在实际进行网络通信时，通信链路是双向的，发起端和接受端没有任何差别。</p><p>对于同账号VPC互通，高速通道提供了同时创建两端的选项。在这种情况下，您不需要手动发起连接，系统会自动发起并建立连接。对于跨账号VPC互通，您必须手动发起路由器接口间的连接。</p><p>发起端与接受端的对比如下表所示。</p><p><img src="http://picture.watchmen.xin/channel/duibi.png" alt="duibi"></p><p><strong>注意：</strong></p><p>和我们传统的路由器的发起和接受概念有点不一样，这里需要明确的指定</p><ul><li>发起端需要指定接受端的路由器接口</li></ul><ul><li>接收端需要指定发起端的路由器接口</li></ul><p>也就是说，这两个接口只能是给这一条通道使用</p><h3 id="连接过程和连接状态"><a href="#连接过程和连接状态" class="headerlink" title="连接过程和连接状态"></a>连接过程和连接状态</h3><p>路由器接口的连接过程为：发起端路由器接口发起连接 &gt; 接受端路由器接口接受连接 &gt; 连接成功。</p><p>在不同的连接过程和阶段，路由器接口的状态也不同如下表所示。路由器接口创建后的初始状态为未连接。</p><blockquote><p>说明：在创建路由器接口时，如果您选择了同时创建两端，系统会自动发起并建立连接，此种情况下路由器接口直接变为已激活状态。</p></blockquote><p><img src="http://picture.watchmen.xin/channel/status.png" alt=""></p><p>整个连接过程如下所示：</p><p><img src="http://picture.watchmen.xin/channel/process.png" alt=""></p><h3 id="路由器接口规格"><a href="#路由器接口规格" class="headerlink" title="路由器接口规格"></a>路由器接口规格</h3><p>高速通道提供小型（10MB-50MB）、中型（100MB-900MB）和大型（1GB-4.5GB）三种规格的路由器接口。</p><p>可选择的路由器接口规格在不同连接场景和不同地域中并不相同。您可以根据具体的配置在购买页面选择合适的路由器接口规格。同地域间VPC互连的路由器接口规格默认为大型2档（2GB）。</p><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><ul><li><font color="red"><strong>两个VPC之间只能有一对连接成功的路由器接口。</strong></font></li><li><p>路由器接口创建后无法修改连接角色。</p></li><li><p>边界路由器（VBR）必须是发起端。</p></li></ul><h2 id="物理专线"><a href="#物理专线" class="headerlink" title="物理专线"></a>物理专线</h2><p>物理专线是对阿里云接入点和本地数据中心之间建立的网络线路的抽象。您需要通过租用一条运营商的专线将本地数据中心连接到阿里云接入点，建立专线连接。</p><p>专线接入后，您可以创建一个边界路由器（VBR）将您本地数据中心和阿里云连接起来，构建混合云环境，使云上资源可以绕过公网通过私网访问本地数据中心。</p><p>物理专线的私网连接不通过公网，因此与传统的公网连接相比，物理专线连接更加安全、可靠、速度更快、延迟更低。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>高速通道物理专线提供以下功能：</p><p><strong>多种连接方式</strong></p><p>您可以选择使用点对点以太网连接或MPLS VPN连接。物理专线支持以太格式的RJ45电口和LC模式光口, 可以提供1Mbps至10Gbps的传输速率。</p><p><strong>冗余连接</strong></p><p>物理专线通过等价路由实现两条物理线路冗余：</p><ul><li><p>如果两条专线接入同地域下不同接入点，则两条线路形成天然冗余。</p></li><li><p>如果两条专线接入同地域下同一个接入点，您可以在申请第二条物理专线时，将第一条物理专线作为冗余线路。</p></li></ul><h3 id="使用限制-1"><a href="#使用限制-1" class="headerlink" title="使用限制"></a>使用限制</h3><p>物理专线使用限制如下：</p><p>物理专线不支持SDH的G.703、V.35格式接口。</p><p>阿里云在每个可接入的地域提供一个或多个接入点，不同的接入点有运营商限制。在申请专线接入前，您需要提交工单获取接入点以及运营商限制信息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在物理专线接入之后，你会得到一个边界路由器</p><p>边界路由器（VBR）必须是发起端。</p><p>购买物理专线之后，其实不是直接连接到阿里云的机房，而是连接到这个边界路由器，边界路由器的对端再连接VPC的路由器</p><h2 id="边界路由器"><a href="#边界路由器" class="headerlink" title="边界路由器"></a>边界路由器</h2><p>边界路由器（Virtual border router, VBR）是您申请的物理专线接入交换机的产品映射，可以看做是CPE（Customer-premises equipment）设备和VPC之间的一个路由器，作为数据从VPC到本地数据中心的转发桥梁。</p><p>边界路由器同VPC中的路由器一样，同样管理一个路由表。在该路由表中配置路由条目，可以对边界路由器中的流量转发进行管理。</p><p><img src="http://picture.watchmen.xin/channel/vbr.png" alt=""></p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>边界路由器提供如下功能：</p><ul><li>作为VPC和本地数据中心的中间路由器，交换数据包。</li></ul><ul><li>在三层子接口模式下，可以识别或附加VLAN(Virtual Local Area Network)标签。</li></ul><ul><li>决定物理专线端口模式：三层路由接口或基于VLAN的三层子接口。</li></ul><ul><li>支持添加BGP动态路由。</li></ul><h3 id="使用限制-2"><a href="#使用限制-2" class="headerlink" title="使用限制"></a>使用限制</h3><ul><li>目前不支持源地址策略路由。</li></ul><ul><li>每个边界路由器有且只有1个路由表。</li></ul><ul><li>每个路由表支持48条自定义路由条目。</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="VPC私网互连"><a href="#VPC私网互连" class="headerlink" title="VPC私网互连"></a>VPC私网互连</h3><p>您可以使用高速通道实现两个VPC间的的私网通信需求，既可以避免绕行公网带来的网络质量不稳定问题，也可以免去数据在传输过程中被窃取的风险。详情请参考跨地域VPC互连和跨账号VPC互连。</p><h3 id="本地数据中心专线接入VPC"><a href="#本地数据中心专线接入VPC" class="headerlink" title="本地数据中心专线接入VPC"></a>本地数据中心专线接入VPC</h3><p>如果您的本地数据中心需要与VPC进行私网通信，您可以使用<strong><code>高速通道的物理专线功能实现两侧的私网通信</code></strong>，您可以选择自行搭建专线接入阿里云或让阿里巴巴的合作伙伴为您搭建物理专线。通过物理专线可以实现本地数据中心和VPC间高质量、高可靠且安全性高的私网通信。您可以使用高速通道实现两个VPC间的的私网通信需求，既可以避免绕行公网带来的网络质量不稳定问题，也可以免去数据在传输过程中被窃取的风险。详情请参考同账号专线接入和跨账号专线接入。</p><h3 id="两个VPC共用NAT网关"><a href="#两个VPC共用NAT网关" class="headerlink" title="两个VPC共用NAT网关"></a>两个VPC共用NAT网关</h3><p>如果您需要两个VPC共用一个NAT网关进行公网通信，您可以使用高速通道实现同两个VPC使用同一个NAT网关来访问公网。</p><p><img src="http://picture.watchmen.xin/channel/vpc_nat.jpg" alt=""></p><h2 id="使用限制-3"><a href="#使用限制-3" class="headerlink" title="使用限制"></a>使用限制</h2><ul><li>同一个路由器上的路由器接口不能互连。</li></ul><ul><li><font color="red"><strong>边界路由器上的路由器接口只能作为发起端。</strong></font></li></ul><ul><li>一对VPC之间只能同时存在一对互连的路由器接口。</li></ul><ul><li>一条物理专线上最多可以存在的边界路由器个数：50个。</li></ul><ul><li>一个用户名下最多可以存在的已激活的路由器接口个数：5个。</li></ul><ul><li>一个路由器上最多可以存在的已激活的路由器接口个数：5个。</li></ul><ul><li>一个账号最多可以在一个接入点接入的物理专线条数：2条。</li></ul><ul><li>一个账号下最多可以存在的空闲边界路由器（没有接口的边界路由器）个数：2个。</li></ul><h1 id="入门实践"><a href="#入门实践" class="headerlink" title="入门实践"></a>入门实践</h1><h2 id="跨地域VPC互连"><a href="#跨地域VPC互连" class="headerlink" title="跨地域VPC互连"></a>跨地域VPC互连</h2><p>本操作以如下同一个账号下的两个VPC为例演示如何使用高速通道实现VPC私网互通。</p><blockquote><p>说明：同账号下同地域和跨地域VPC互连的操作步骤一样。</p></blockquote><p>前提条件</p><ul><li>确保要进行互连的VPC或交换机的网段不冲突。</li></ul><p>文章内容：<a href="https://help.aliyun.com/document_detail/44842.html?spm=a2c4g.11186623.6.550.zI2Wp5" target="_blank" rel="noopener">跨地域VPC互连</a></p><h2 id="跨账号VPC互连"><a href="#跨账号VPC互连" class="headerlink" title="跨账号VPC互连"></a>跨账号VPC互连</h2><p>前提条件</p><ul><li>两个VPC中交换机地址不能冲突。</li></ul><ul><li>已获取双方的阿里云账号ID和路由器ID。</li></ul><p>文章内容：<a href="https://help.aliyun.com/document_detail/44843.html?spm=a2c4g.11186623.6.551.PoqdWg" target="_blank" rel="noopener">跨账号VPC互连</a></p><h2 id="物理专线-1"><a href="#物理专线-1" class="headerlink" title="物理专线"></a>物理专线</h2><p>文章内容：<a href="https://help.aliyun.com/document_detail/44844.html?spm=a2c4g.11186623.6.552.0hqrXn" target="_blank" rel="noopener">物理专线接入</a></p>]]></content>
    
    <summary type="html">
    
      高速通道从入门到实践
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="公有云产品" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"/>
    
      <category term="阿里云" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    
      <category term="高速通道" scheme="http://yoursite.com/tags/%E9%AB%98%E9%80%9F%E9%80%9A%E9%81%93/"/>
    
  </entry>
  
</feed>
