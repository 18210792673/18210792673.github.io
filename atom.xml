<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watchmen1992&#39;s Blog</title>
  
  <subtitle>锦瑟年华当与书香为度，是为不负天地人生。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-28T06:17:44.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>XiaoHua WANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ubuntu更改apt源</title>
    <link href="http://yoursite.com/2018/08/28/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/ubuntu%E6%9B%B4%E6%94%B9apt%E6%BA%90/"/>
    <id>http://yoursite.com/2018/08/28/IT科学技术知识体系结构-Linux运维方向/Linux基础知识/Linux系统管理/ubuntu更改apt源/</id>
    <published>2018-08-28T06:17:44.000Z</published>
    <updated>2018-08-28T06:17:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在安装完ubuntu之后，我们一般都需要将apt源替换为阿里云等国内软件源站点，以便提高响应速度。</p><p>这里使用的是Ubuntu18.04发行版本</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>其实Ubuntu18.04版之前的任一版更改apt源为国内源方法早就有了，内容大同小异，我们应当掌握其规律了，其实每一版内容不同的地方就是版本号（或者官方一点的说：系统代号），所以我们先了解下新版本的系统代号：</p><p>使用如下命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -c</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:/etc/apt$ lsb_release -c</span><br><span class="line">Codename:bionic</span><br></pre></td></tr></table></figure><p>我们可以看到新版本的Ubuntu系统代号为bionic</p><p>同样的我们也可以得到之前任意版本的系统代号：</p><ul><li>Ubuntu 12.04 (LTS)代号为precise。</li><li>Ubuntu 14.04 (LTS)代号为trusty。</li><li>Ubuntu 15.04 代号为vivid。</li><li>Ubuntu 15.10 代号为wily。</li><li>Ubuntu 16.04 (LTS)代号为xenial。</li></ul><p>所以这也就解释了为什么我们百度出来的那么多方案里面内容不尽相同的原因，因为他们更改apt安装源时用的系统不一样。</p><p>下面开始实际操作</p><hr><h1 id="备份源文件"><a href="#备份源文件" class="headerlink" title="备份源文件"></a>备份源文件</h1><p>我们要修改的文件是sources.list，它在目录/etc/apt/下，sources.list是包管理工具apt所用的<strong><code>记录软件包仓库</code></strong>位置的配置文件，同样类型的还有位于 同目录下sources.list.d文件下的各种.list后缀的各文件。</p><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h1 id="编辑源文件内容"><a href="#编辑源文件内容" class="headerlink" title="编辑源文件内容"></a>编辑源文件内容</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>将原有的内容注释或删除掉，添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>配置格式说明：</p><p>我们可以看到sources.list文件的条目都是有格式的（通过上面的内容大家也看的出来），一般有如下形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://site.example.com/debian distribution component1 component2 component3</span><br><span class="line">deb-src http://site.example.com/debian distribution component1 component2 component3</span><br></pre></td></tr></table></figure><p>后面几个参数是对软件包的分类（Ubuntu下是main， restricted，universe ，multiverse这四个）</p><h1 id="补充-etc-apt-sources-list-详解"><a href="#补充-etc-apt-sources-list-详解" class="headerlink" title="补充-/etc/apt/sources.list 详解"></a>补充-/etc/apt/sources.list 详解</h1><p><code>/etc/apt/sources.list</code> 是包管理工具 <code>apt</code> 所用的记录软件包仓库位置的配置文件，同样的还有位于 <code>/etc/apt/sources.list.d/*.list</code> 的各文件。</p><p><code>sources.list</code> 文件中的条目一般都有如下所示的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://site.example.com/debian distribution component1 component2 component3</span><br><span class="line">deb-src http://site.example.com/debian distribution component1 component2 component3</span><br></pre></td></tr></table></figure><h2 id="档案类型-Archive-type"><a href="#档案类型-Archive-type" class="headerlink" title="档案类型 (Archive type)"></a>档案类型 (Archive type)</h2><p>条目的第一个词 <code>deb</code> 或是 <code>deb-src</code> 表明了所获取的软件包档案类型。</p><p>其中：</p><ul><li><p><strong>deb</strong></p><p>档案类型为二进制预编译软件包，一般我们所用的档案类型。</p></li><li><p><strong>deb-src</strong></p><p>档案类型为用于编译二进制软件包的源代码。</p></li></ul><h2 id="仓库地址-Repository-URL"><a href="#仓库地址-Repository-URL" class="headerlink" title="仓库地址 (Repository URL)"></a>仓库地址 (Repository URL)</h2><p>条目的第二个词则是软件包所在仓库的地址。我们可以更换仓库地址为其他地理位置更靠近自己的镜像来提高下载速度。</p><p>常用镜像地址列表：</p><ul><li><p><strong>Debian</strong></p><p><a href="https://www.debian.org/mirror/list" target="_blank" rel="noopener">https://www.debian.org/mirror/list</a></p></li><li><p><strong>Ubuntu</strong></p><p><a href="http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/源列表</a></p></li></ul><h2 id="发行版-Distribution"><a href="#发行版-Distribution" class="headerlink" title="发行版 (Distribution)"></a>发行版 (Distribution)</h2><p>跟在仓库地址后的是发行版。发行版有两种分类方法，一类是发行版的具体代号，如 <code>xenial</code>,<code>trusty</code>, <code>precise</code> 等；还有一类则是发行版的发行类型，如<code>oldstable</code>, <code>stable</code>, <code>testing</code> 和 <code>unstable</code>。</p><p>另外，在发行版后还可能有进一步的指定，如 <code>xenial-updates</code>, <code>trusty-security</code>, <code>stable-backports</code> 等。</p><h2 id="软件包分类-Component"><a href="#软件包分类-Component" class="headerlink" title="软件包分类 (Component)"></a>软件包分类 (Component)</h2><p>跟在发行版之后的就是软件包的具体分类了，可以有一个或多个。</p><p>不同的 Linux 发行版对软件有着不同的分类，如：</p><h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h3><ul><li><p><strong>main</strong></p><p>包含符合 <a href="https://www.debian.org/social_contract#guidelines" target="_blank" rel="noopener">DFSG</a> 指导原则的自由软件包，而且这些软件包不依赖不符合该指导原则的软件包。这些软件包被视为 Debian 发型版的一部分。</p></li><li><p><strong>contrib</strong></p><p>包含符合 <a href="https://www.debian.org/social_contract#guidelines" target="_blank" rel="noopener">DFSG</a> 指导原则的自由软件包，不过这些软件包依赖不在 <em>main</em> 分类中的软件包。</p></li><li><p><strong>non-free</strong></p><p>包含不符合 <a href="https://www.debian.org/social_contract#guidelines" target="_blank" rel="noopener">DFSG</a> 指导原则的非自由软件包。</p></li></ul><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><ul><li><p><strong>main</strong></p><p>官方支持的<a href="http://www.ubuntu.com/about/about-ubuntu/our-philosophy" target="_blank" rel="noopener">自由</a>软件。</p></li><li><p><strong>restricted</strong></p><p>官方支持的非完全<a href="http://www.ubuntu.com/about/about-ubuntu/our-philosophy" target="_blank" rel="noopener">自由</a>的软件。</p></li><li><p><strong>universe</strong></p><p>社区维护的自由软件。</p></li><li><p><strong>multiverse</strong></p><p>非自由软件。</p></li></ul><p>Ubuntu 对软件包的分类可以用下表来表示（参考自 <a href="https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#Package_classification_and_support" target="_blank" rel="noopener">Wikipedia</a>）：</p><table><thead><tr><th></th><th>自由软件</th><th>非自由软件</th></tr></thead><tbody><tr><td>官方支持的</td><td>Main</td><td>Restricted</td></tr><tr><td>非官方支持的</td><td>Universe</td><td>Multiverse</td></tr></tbody></table><h1 id="补充-update和upgrade"><a href="#补充-update和upgrade" class="headerlink" title="补充-update和upgrade"></a>补充-update和upgrade</h1><p>每个LINUX的发行版，比如ubuntu、centos等，都会维护一个自己的软件仓库，我们常用的几乎所有软件都在这里面。这里面的软件绝对安全，而且绝对的能正常安装。</p><p>在UBUNTU下，我们维护一个源列表，源列表里面都是一些网址信息，这每一条网址就是一个源，这个地址指向的数据标识着这台源服务器上有哪些软件可以安装使用。</p><p>编辑源命令：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.<span class="keyword">list</span></span><br></pre></td></tr></table></figure><p>在这个文件里加入或者注释（加#）掉一些源后，保存。这时候，我们的源列表里指向的软件就会增加或减少一部分。</p><p>获得最近的软件包的列表:(列表中包含一些包的信息，比如这个包是否更新过)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>这个命令，会访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。软件包管理器里看到的软件列表，都是通过update命令更新的。</p><p>update后，可能需要upgrade一下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>这个命令，会把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。如果你的软件都是最新版本，会提示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。</span><br></pre></td></tr></table></figure><p><strong>总而言之，update是更新软件列表，upgrade是更新软件。</strong></p><p>注意：一般在执行 sudo apt-get upgrade 命令之前需要先执行一下 sudo apt-get update；这其实和windows下的软件检测更新是一样的，需要更新的会帮你自动更新并安装好</p><p>apt-get update 命令会同步使用者端和APT服务器的RPM 索引清单（package list），APT 服务器的RPM 索引清单置于base 资料夹内，使用者端电脑取得base 资料夹内的bz2 RPM 索引清单压缩档后，会将其解压置放于/var/state/apt/lists/，而使用者使用apt-get install 或apt-get dist-upgrade 指令的时候，就会将这个资料夹内的资料和使用者端电脑内的RPM 资料库比对，如此一来就可以知道那些RPM 已安装、未安装、或是可以升级的。</p>]]></content>
    
    <summary type="html">
    
      ubuntu更改apt源
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="Linux基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Linux系统管理" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>DNS记录类型简介</title>
    <link href="http://yoursite.com/2018/08/28/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/DNS/DNS%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/08/28/IT科学技术知识体系结构-Linux运维方向/网络知识/DNS/DNS记录类型简介/</id>
    <published>2018-08-28T03:54:17.000Z</published>
    <updated>2018-08-28T03:54:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>DNS：（Domain Name System，域名系统），因特网上作为域名和<a href="http://baike.baidu.com/view/3930.htm" target="_blank" rel="noopener">IP地址</a>相互映射的一个<a href="http://baike.baidu.com/view/68389.htm" target="_blank" rel="noopener">分布式数据库</a>，能够使用户更方便的访问<a href="http://baike.baidu.com/view/6825.htm" target="_blank" rel="noopener">互联网</a>，而不用去记住能够被机器直接读取的IP数串。通过<a href="http://baike.baidu.com/view/23880.htm" target="_blank" rel="noopener">主机</a>名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。使用端口号53。</p><p>DNS服务器：用于对域名进行解析的域名解析服务器。</p><p>DNS代理：用于代理域名服务器，对客户端的查询请求进行响应（一般是本地查找，查找不到再向代理的服务器转发客户端的查询请求）</p><h1 id="dns记录类型介绍"><a href="#dns记录类型介绍" class="headerlink" title="dns记录类型介绍"></a>dns记录类型介绍</h1><p>A记录：</p><h2 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h2><p>说明：WEB服务器的IP指向</p><p>A （Address）记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置域名的子域名。通俗来说A记录就是服务器的IP,域名绑定A记录就是告诉DNS,当你输入域名的时候给你引导向设置在DNS的A记录所对应的服务器。 </p><p>简单的说，A记录是指定域名对应的IP地址。</p><h2 id="AAAA记录"><a href="#AAAA记录" class="headerlink" title="AAAA记录"></a>AAAA记录</h2><p>作用同A记录，只不过该记录是将域名解析到一个指定的<strong>IPV6</strong>的IP上</p><h2 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h2><p>通常称别名解析。可以将注册的不同域名都转到一个域名记录上，由这个域名记录统一解析管理</p><p>这种记录允许您将多个名字映射到同一台计算机。 通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。 它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。 这两个别名的全称就是“www.mydomain.com”和“mail.mydomain.com”。实际上他们都指向“host.mydomain.com”。</p><p>同样的方法可以用于当您拥有多个域名需要指向同一服务器IP，此时您就可以将一个域名做A记录指向服务器IP然后将其他的域名做别名到之前做A记录的域名上，那么当您的服务器IP地址变更时您就可以不必麻烦的一个一个域名更改指向了 只需要更改做A记录的那个域名其他做别名的那些域名的指向也将自动更改到新的IP地址上了。</p><h2 id="NS记录"><a href="#NS记录" class="headerlink" title="NS记录"></a>NS记录</h2><p>解析服务器记录，用来表明由哪台服务器对该域名进行解析。</p><p>这里的NS记录只对子域名生效。</p><p>例如用户希望由12.34.56.78这台服务器解析news.mydomain.com，则需要设置news.mydomain.com的NS记录。 </p><p>说明： </p><ul><li>“优先级”中的数字越小表示级别越高； </li><li>“IP地址/主机名”中既可以填写IP地址，也可以填写像ns.mydomain.com这样的主机地址，但必须保证该主机地址有效。如，将 news.mydomain.com的NS记录指向到ns.mydomain.com，在设置NS记录的同时还需要设置ns.mydomain.com的 指向，否则NS记录将无法正常解析； </li><li>NS记录优先于A记录。即，如果一个主机地址同时存在NS记录和A记录，则A记录不生效。这里的NS记录只对子域名生效。</li></ul><h2 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h2><p>MX（Mail Exchanger）记录是邮件交换记录，它指向一个邮件服务器，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器。例如，当Internet上的某用户要发一封信给 user@mydomain.com 时，该用户的邮件系统通过DNS查找mydomain.com这个域名的MX记录，如果MX记录存在， 用户计算机就将邮件发送到MX记录所指定的邮件服务器上。</p><hr><p>其他的记录类型涉及到的时候再详细补充</p>]]></content>
    
    <summary type="html">
    
      DNS记录类型简介
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="网络知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
      <category term="DNS" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/DNS/"/>
    
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu设置ssh服务</title>
    <link href="http://yoursite.com/2018/08/26/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/ubuntu%E8%AE%BE%E7%BD%AEssh%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/08/26/IT科学技术知识体系结构-Linux运维方向/Linux基础知识/Linux系统管理/ubuntu设置ssh服务/</id>
    <published>2018-08-26T09:49:54.000Z</published>
    <updated>2018-08-26T09:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，安装完ubuntu之后，操作系统不会像centos一样会自动把openssh-server给安装上，也就是说，在系统安装完毕之后，我们还需要进行额外的操作，才能通过ssh的方式远程访问我们的ubuntu系统。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>SSH分客户端openssh-client和openssh-server</p><p>如果你只是想登陆别的机器，那么只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。</p><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>在命令行中使用如下命令进行安装</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>ssh-server配置文件位于/etc/ssh/sshd_config，在这里可以定义SSH的服务端口，默认端口是22，你可以自己定义成其他端口号。</p><p>通过修改配置文件/etc/ssh/sshd_config，可以进行修改ssh登录端口、禁止root登录等一系列操作，修改端口可以防止被端口扫描。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>默认情况下，安装完毕之后将会自动启动，我们可用用过ps来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -elf | grep sshd</span><br></pre></td></tr></table></figure><p>如果没有启动的话，我们执行以下命令启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      ubuntu设置ssh服务
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="Linux基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Linux系统管理" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门与实践</title>
    <link href="http://yoursite.com/2018/08/23/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker/Docker%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/08/23/IT科学技术知识体系结构-Linux运维方向/虚拟化/Docker/Docker入门与实践/</id>
    <published>2018-08-23T09:42:27.000Z</published>
    <updated>2018-08-23T09:42:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li>书籍：《Docker技术入门与实战 第2版》</li></ul><hr><h1 id="第1章-基础知识"><a href="#第1章-基础知识" class="headerlink" title="第1章 基础知识"></a>第1章 基础知识</h1><h2 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h2><h3 id="有关虚拟化"><a href="#有关虚拟化" class="headerlink" title="有关虚拟化"></a>有关虚拟化</h3><p>虚拟化技术是一个通用的概念，在不同领域有不同的理解，在计算领域，一般指的是计算虚拟化（computing Virtualization），或通常说的服务器虚拟化。</p><p>维基百科定义如下：“虚拟化是一种资源管理技术”，是将计算机的各种实体资源，例如服务器、网络、内存及存储等，予以抽象，转换后呈现出来的，打破实体结构间的不可切割的障碍，使用户可以比原来的组态更好的方式来应用这些资源</p><p>传统来看，虚拟化既可以通过硬件模拟来实现（xen、esxi等），也可以通过操作系统软件来实现（KVM等）。而容器技术则更为优雅，它充分利用了操作系统本身已有的机制和特性，可以实现远超传统虚拟机的轻量级虚拟化。因此，有人甚至把它称为“新一代的虚拟化”技术，并将<strong>基于容器打造的云平台亲切地称之为“容器云”</strong></p><h3 id="什么docker"><a href="#什么docker" class="headerlink" title="什么docker"></a>什么docker</h3><p>Docker的构想是要实现“build,ship and run any app,anywhere”,即通过对应用程序的封装、分发、部署、运行生命周期。达到应用组件，“一次封装，到处运行”的目的。这里的应用组件，既可以是一个web应用、一个编译环境、也可以是一套数据库平台服务，甚至是一个操作系统或者集群</p><p>可以说，Docker首次为应用的开发、运行和部署提供了“一站式”的实用解决方案</p><p>IBM DeveloperWorks网站关于容器技术的描述十分准确：“容器技术有效地将由单个操作系统管理的资源划分到孤立的组中，以更好的在孤立的组之间平衡有冲突的资源使用需求”</p><p>总结：Docker是一项容器技术，是一个开源项目</p><h3 id="从LXC从到Docker"><a href="#从LXC从到Docker" class="headerlink" title="从LXC从到Docker"></a>从LXC从到Docker</h3><p>Docker技术的主要实现参考的是Linux容器技术（Linux Containers LXC）</p><p>在LXC的基础之上，Docker进一步优化了容器的使用体验，让它进入了寻常百姓家。</p><p>优化项目：</p><p>首先，Docker提供了各种容器管理工具（如分发、版本、移植等），让用户无需关注底层的操作，可以简单明了地管理和使用容器。</p><p>其次，docker引入了<strong>分层文件系统构建和高效的镜像机制</strong>，降低了迁移难度极大地提升了用户体验。用户操作docker就像操作应用自身一样简单。</p><h3 id="使用Docker的好处"><a href="#使用Docker的好处" class="headerlink" title="使用Docker的好处"></a>使用Docker的好处</h3><p>在云时代，开发者创建的应用需要要很方便的在网络上传播，也就是说，应用必须要脱离底层物理硬件的限制，同时必须是“任何时间，任何地点”都可获取的。因此，开发者需要一种新型的创建分布式应用程序的方式，<strong>快速分发和部署</strong>，这正是docker所能够提供的最大优势。</p><p>举例来说，如果要部署LAMP平台，需要分别部署mysql，apache，php等，然后再进行一系列的配置，这样的配置非常繁琐并且容易出错。并且如果需要服务器迁移，往往需要重新部署。</p><p>docker提供了一种更为聪明的方式，通过容器来打包应用。解耦应用和运行平台。这意味着在进行应用迁移的时候，只需要再新的机器上面再启动容器就可以了，不需要再进行重新部署等操作。无论服务器是否是同一类型的平台架构。这节约了大量的时间，并降低了部署过程出现问题的风险。</p><h3 id="Docker在开发和运维中的优势"><a href="#Docker在开发和运维中的优势" class="headerlink" title="Docker在开发和运维中的优势"></a>Docker在开发和运维中的优势</h3><p>具体来说，Docker在开发和运维过程中，具有如下几个方面的优势：</p><ul><li>更快速的交付和部署</li></ul><p>使用镜像来快速构建一套标准环境，</p><ul><li>更高效的资源利用</li></ul><p>docker容器不需要额外的虚拟化管理程序支持，它是内核级别的虚拟化，可以实现更高的性能</p><ul><li>更轻松的迁移和扩展</li></ul><p>docker容器几乎可以在任何的平台上运行，包括物理机，虚拟机，公有云，私有云，个人电脑，服务器等。</p><ul><li>更简单的更新管理</li></ul><p>使用dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作，并且所有的修改都是以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</p><h3 id="Docker与虚拟机的比较"><a href="#Docker与虚拟机的比较" class="headerlink" title="Docker与虚拟机的比较"></a>Docker与虚拟机的比较</h3><ul><li><p>docker容器很快，启动和停止可以在秒级实现，而传统的虚拟机方式需要数分钟</p></li><li><p>docker容器对系统资源的需求很少，一台主机可以同时运行数千个docker容器</p></li><li><p>docker通过类似git设计理念的操作来方便用户获取，分发和应用镜像，存储复用，增量更新。</p></li><li><p>docker通过dockerfile支持灵活的自动化创建和部署机制，提高工作效率，使流程标准化。</p></li></ul><h3 id="Docker和核心价值"><a href="#Docker和核心价值" class="headerlink" title="Docker和核心价值"></a>Docker和核心价值</h3><p>docker的核心价值在于，他很有可能改变传统的软件“交付”方式和运行方式。传统的交付源码或者交付软件的方式的最大问题在于，软件运行期间所“依赖的环境”是无法控制的、不能标准化的，IT人员常常需要耗费很多精力来解决因为“依赖的环境”而导致软件运行出现的各种问题。</p><p>而docker将<strong>软件与其“依赖的环境”打包在一起</strong>，以镜像的方式交付，让软件运行在“标准的环境中”，这非常符合云计算的要求。这种变革一旦被IT人员接受，可能会对产业链带来很大的冲击，我们熟悉的apt-get、yum是否会逐渐被docker pull取代？</p><p>从这一点可以毫不夸张的说，docker是革命性的，它重新定义了软件开发、测试、交付和部署的流程。我们交付的不再是代码、配置文件、数据库定义等。而是整个应用程序运行环境：“OS+各种中间件、类库+应用程序代码”</p><p>有了标准化的运行环境，再加上对CPU、内存、磁盘、网络等动态资源的限制，docker构造了一个“轻量级虚拟环境”，传统虚拟机的绝大多数使用场景可以被docker取代，这将给IT基础设施带来一次更大的冲击；传统虚拟化（KVM、XEN、VMWare）将会何去何从？此外，docker秒级创建/删除虚拟机以及<strong>动态调整资源</strong>的能力，也非常契合云计算的“实例水平扩展”、“资源动态调整”的需求，docker很有可能成为云计算的基石。</p><h3 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h3><p>通过上面的介绍，可以总结出以下几个使用docker的场景</p><ul><li><p>业务高峰期通过启动大量容器进行横向扩展</p></li><li><p>应用需要经常迁移或者多环境运行</p></li></ul><h2 id="核心概念-名词解释"><a href="#核心概念-名词解释" class="headerlink" title="核心概念/名词解释"></a>核心概念/名词解释</h2><p>只有理解了这三个核心概念，才能顺利的理解Docker容器的整个生命周期。</p><p>docker的大部分操作都围绕着它的三个核心概念：<strong>镜像、容器和仓库</strong>展开。因此准确把握这三大核心概念对于掌握docker技术尤为重要。</p><h3 id="三剑客之镜像-Image"><a href="#三剑客之镜像-Image" class="headerlink" title="三剑客之镜像-Image"></a>三剑客之镜像-Image</h3><p>Docker镜像类似<strong>虚拟机镜像</strong>，可以将它理解为一个<strong>只读的模板</strong>。例如，一个镜像可以包含一个基本的操作系统环境，里面仅安装了apache应用程序（或者其他需要的程序），这个时候，可以把它称之为一个apache镜像。</p><p>镜像是创建Docker容器的基础。通过<strong>版本管理和增量的文件系统</strong>，Docker提供了一套十分简单的机制来<strong>创建和更新删除</strong>现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并且直接使用</p><p>功能总结</p><ul><li><p>只读的模板（包含OS+应用）</p></li><li><p>版本管理和增量文件系统的机制在其之上</p></li><li><p>操作：自行创建或网上下载、更新、删除</p></li></ul><h3 id="三剑客之容器-Container"><a href="#三剑客之容器-Container" class="headerlink" title="三剑客之容器-Container"></a>三剑客之容器-Container</h3><p>我们可以将Docker的容器理解为一种轻量级的沙盒（sanbox）。</p><p>Docker利用容器来<strong>运行和隔离</strong>应用（镜像）。</p><p>容器是从镜像创建的应用运行实例，可以将指定的镜像<strong>启动、开始、停止、删除</strong>。而这些容器都是彼此相互隔离的，互不可见的。【容器是镜像的隔离运行单元】</p><p>每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止都十分快速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。</p><p>每个容器都是一个操作系统实例</p><p><strong>容器的功能</strong></p><ul><li>通过容器打包运行应用</li></ul><p>解耦应用和运行平台。这意味着在进行应用迁移的时候，只需要再新的机器上面再启动容器就可以了，不需要再进行重新部署等操作。无论服务器是否是同一类型的平台架构。</p><ul><li>隔离应用</li></ul><p><strong>容器的组成结构</strong></p><ul><li><p>上层：实际应用</p></li><li><p>下层：操作系统环境（主要是内核+函数库）</p></li></ul><h3 id="三剑客之仓库-Repository"><a href="#三剑客之仓库-Repository" class="headerlink" title="三剑客之仓库-Repository"></a>三剑客之仓库-Repository</h3><p>docker仓库类似于代码仓库，它是docker集中存放镜像文件的场所</p><p>需要注意docker仓库和仓库注册服务器（Registry）的区别。</p><ul><li><p>仓库注册服务器是存放仓库的地方，其中往往存放着多个仓库。</p></li><li><p>每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的tag（标签）来进行区分。</p></li></ul><p>根据所存储的镜像公开与否，Docker仓库可以分为两种形式。目前，最大公开仓库是官方提供的docker Hub，其中存放了数量庞大的镜像供用户下载。国内不少云服务提供商（时速云，阿里云等）也提供了仓库的本地源，可以提供稳定的国内访问</p><p>docker也支持用户在本地网络内创建一个只能自己访问的私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到指定的公有或者私有仓库有。这样用户下次在另外一台机器上使用该镜像时，只需要将其从仓库上pull下来就可以。</p><h3 id="Docker-EE和Docker-CE"><a href="#Docker-EE和Docker-CE" class="headerlink" title="Docker-EE和Docker-CE"></a>Docker-EE和Docker-CE</h3><p>Docker Engine改为Docker CE（社区版）, Docker Community Edition</p><p>Docker Data Center改为Docker EE（企业版）, Docker Enterprise Edition</p><p>在Docker三个定价层增加了额外的支付产品和支持</p><p>Docker社区版（CE）是为了开发人员或小团队创建基于容器的应用,与团队成员分享和自动化的开发管道。docker-ce提供了简单的安装和快速的安装，以便可以立即开始开发。docker-ce集成和优化，基础设施。 </p><p>Docker企业版（EE）是专为企业的发展和IT团队建立谁。docker-ee为企业提供最安全的容器平台，以应用为中心的平台。</p><h1 id="第2章-安装配置"><a href="#第2章-安装配置" class="headerlink" title="第2章 安装配置"></a>第2章 安装配置</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>docker目前只能运行在64为平台上，并且要求内核版本不低于3.10，实际上内核越新越好，过低的内核版本容易造成功能不稳定。</p><h3 id="centos环境下安装docker"><a href="#centos环境下安装docker" class="headerlink" title="centos环境下安装docker"></a>centos环境下安装docker</h3><p>安装依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \ device-mapper-persistent-data \lvm2</span><br></pre></td></tr></table></figure><p>添加yum源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum-config-manager \ --add-repo \</span><br><span class="line">https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>安装docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum -y install docker-ce</span><br></pre></td></tr></table></figure><h2 id="配置Docker服务"><a href="#配置Docker服务" class="headerlink" title="配置Docker服务"></a>配置Docker服务</h2><h3 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a><strong>权限配置</strong></h3><p>为了避免每次使用docker命令都需要sudo使用特权身份，可以将当前用户加入安装中自动创建的docker用户组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker [username]</span><br></pre></td></tr></table></figure><h3 id="配置文件不存在问题"><a href="#配置文件不存在问题" class="headerlink" title="配置文件不存在问题"></a><strong>配置文件不存在问题</strong></h3><p>docker服务的默认配置文件为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu中：/etc/default/docker</span><br><span class="line">centos中：/etc/sysconfig/docker</span><br></pre></td></tr></table></figure><p>在该配置文件中，我们可以通过修改其中的<strong>DOCKER_OPTS</strong>来修改服务<strong>启动的参数</strong></p><p>但是实际情况，安装完docker之后，是没有改配置文件的</p><p>因此在docker的高版本之后，配置文件变成了：/etc/docker/key.json</p><p>官方参考配置文档：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd//#daemon-configuration-file</a></p><h2 id="启动Docker服务"><a href="#启动Docker服务" class="headerlink" title="启动Docker服务"></a>启动Docker服务</h2><p> 在Centos 7 中，我们可以使用如下命令启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># systemctl enable  docker</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload     #加载配置</span><br></pre></td></tr></table></figure><h1 id="第3章-使用Docker镜像"><a href="#第3章-使用Docker镜像" class="headerlink" title="第3章 使用Docker镜像"></a>第3章 使用Docker镜像</h1><p>镜像（image）是Docker三大核心概念中最为重要的，自Docker诞生之日起，“镜像”就是相关社区最为热门的关键词。</p><p>docker运行容器前需要本地存在对应的镜像，如果镜像没有保存在本地，docker会尝试先从默认镜像仓库下载（默认使用docker Hub公共注册服务器中的仓库），用户也可以通过配置，使用自定义的镜像仓库。</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>镜像是运行容器的前提，官方的docker Hub网站已经提供了数十万个镜像供大家开放下载。</p><p>可以使用docker pull命令直接从docker Hub 镜像源来下载镜像。该命令的格式为docker pull NAME[:TAG]。其中，NAME是镜像仓库的名称（用来区分镜像），TAG是镜像的标签（往往用来表示版本信息）。例如：ubuntu系统是NAME，14.04是TAG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure><hr><p><strong>注意：</strong></p><p>如果不显性的制定TAG，该命令会自动选择latest标签，这会下载仓库中最新版本的镜像。</p><p>镜像的latest标签意味着该镜像的内容会跟踪最新的非稳定版本而发布，内部是不稳定的。</p><p>在生产环境中禁止忽略镜像的标签信息或者使用默认的latest标签</p><hr><h3 id="镜像的分层特性"><a href="#镜像的分层特性" class="headerlink" title="镜像的分层特性"></a>镜像的分层特性</h3><p>镜像文件一般由若干层（layer）构成，每一层都有一个唯一的id（完整的id有256比特，由64个十六进制字符组成）。</p><p>使用docker pull命令下载时会获取并输出镜像的各层信息。<strong>当不同的镜像包括相同的层时，本地仅存储该层的一份内容，减少了需要的存储空间。</strong></p><h3 id="镜像的重名问题"><a href="#镜像的重名问题" class="headerlink" title="镜像的重名问题"></a>镜像的重名问题</h3><p>在使用不同的镜像仓库时，可能会出现镜像重名的情况？</p><p>严格来讲，镜像的仓库名称中还应该添加仓库地址（即仓库注册服务器（Registry））的地址作为前缀，默认我们使用的是docker Hub的服务，该前缀可以忽略不写。</p><p>例如：docker pull ubuntu:14.04 命令相当于docker pull registry.hub.docker.com/ubuntu:14.04命令。</p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>下载镜像到本地之后，即可随时使用该镜像，例如利用该镜像创建一个容器，在其中运行bash应用，执行ping localhost命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master yum.repos.d]# docker run -it ubuntu:14.04 bash</span><br></pre></td></tr></table></figure><h2 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h2><h3 id="使用images命令列出镜像"><a href="#使用images命令列出镜像" class="headerlink" title="使用images命令列出镜像"></a>使用images命令列出镜像</h3><p>使用docker images命令可以列出本地主机上已有镜像的基本信息。、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker images</span><br></pre></td></tr></table></figure><p>在列出的信息中，可以看到以下几个字段信息：</p><ul><li><p>来自于哪个仓库           REPOSITORY</p></li><li><p>镜像的TAG（标签）信息，标签知识标记，并不能识别镜像内容</p></li><li><p>镜像的ID（唯一标识镜像）。IMAGE ID</p></li><li><p>创建时间        CREATED</p></li><li><p>镜像大小               SIZE</p></li></ul><p>其中镜像的ID信息十分重要，它唯一标识了镜像。在使用镜像ID的时候，一般可以使用该ID的前若干个字符组成的可区分串来替代完整的ID。</p><p>镜像大小信息只是标识该镜像的逻辑体积的大小，实际上由于相同的镜像层本地只会存储一份，物理上占用的存储空间会小于各镜像的逻辑体积之和。</p><p>images支持的的选项参数：</p><ul><li><p>-a    –all=true|false         列出所有的镜像文件（包括临时文件），默认为否</p></li><li><p>–digests=true|false          列出镜像的数字摘要值，默认为否</p></li><li><p>-f    –filter=[]                过滤列出的镜像</p></li><li><p>…..</p></li></ul><p>具体可以通过man docker-images 进行查看。</p><h3 id="使用tag命令添加镜像标签"><a href="#使用tag命令添加镜像标签" class="headerlink" title="使用tag命令添加镜像标签"></a>使用tag命令添加镜像标签</h3><p>为了方便在后续的工作中使用特定镜像，还可以使用docker tag命令来为本地镜像任意添加新的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker tag ubuntu:14.04 ubuntu:my14.04</span><br></pre></td></tr></table></figure><p>  注意：docker tag命令添加的标签实际上起到了类似链接的作用</p><h3 id="使用inspect命令查看详细信息"><a href="#使用inspect命令查看详细信息" class="headerlink" title="使用inspect命令查看详细信息"></a>使用inspect命令查看详细信息</h3><p>使用docker inspect命令可以获取该镜像的详细信息，包括制作者，使用架构，各层的数字摘要等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker inspect ubuntu:14.04</span><br></pre></td></tr></table></figure><p>返回的是一个JSON格式的消息，如果我们只要其中一项内容时，可以使用参数-f来指定，例如，获取镜像的Architecture参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker inspect ubuntu:14.04 -f &#123;&#123;&quot;.Architecture&quot;&#125;&#125;</span><br><span class="line">amd64</span><br></pre></td></tr></table></figure><h3 id="使用history命令查看镜像历史"><a href="#使用history命令查看镜像历史" class="headerlink" title="使用history命令查看镜像历史"></a>使用history命令查看镜像历史</h3><p>既然镜像由多个层组成，那么怎么知道各个层的内容具体是什么呢？这时候可以使用history子命令，该命令将列出各层的创建信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker history ubuntu:14.04</span><br><span class="line"></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line"></span><br><span class="line">a35e70164dfb        12 days ago         /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;do…   7B                  </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c sed -i &apos;s/^#\s(deb.universe)$…   2.76kB              </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c rm -rf /var/lib/apt/lists/*          0B                  </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /…   195kB               </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c #(nop) ADD file:3900b83a46e97708a…   222MB</span><br></pre></td></tr></table></figure><h2 id="搜寻镜像"><a href="#搜寻镜像" class="headerlink" title="搜寻镜像"></a>搜寻镜像</h2><p>使用docker search命令来搜索源端仓库中共享的镜像，默认搜索官方仓库中的镜像。</p><p>用法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search TERM</span><br></pre></td></tr></table></figure><p>支持的主要参数为：</p><ul><li><p>–automated=true|false：仅显示自动创建的镜像，默认为否。</p></li><li><p>–no-trubc=true|false：输出信息不截断显示，默认为否</p></li><li><p>-s     –starts=X：指定仅显示评价为指定星级以上的镜像，默认为0，即输出所有的镜像。</p></li></ul><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><h3 id="使用标签删除镜像"><a href="#使用标签删除镜像" class="headerlink" title="使用标签删除镜像"></a>使用标签删除镜像</h3><p>使用docker rmi命令可以删除镜像，命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi IMAGE [IMAGE…]</span><br><span class="line"></span><br><span class="line">其中IMAGE可以为标签或ID,例如：ubuntu:my14.04</span><br></pre></td></tr></table></figure><p>注意：当同一个镜像拥有多个标签的时候，docker rmi命令只是删除该镜像多个标签中的制定标签而已，并不影响镜像文件。因此上述操作相当于只是删除了镜像a35e70164dfb的一个标签而已。</p><p>但是，当镜像只是剩下一个标签的时候，此时再使用docker rmi 命令会彻底删除镜像。</p><h3 id="使用镜像ID删除镜像"><a href="#使用镜像ID删除镜像" class="headerlink" title="使用镜像ID删除镜像"></a>使用镜像ID删除镜像</h3><p>当使用docker rmi（remove image）命令，并且后面跟上镜像的ID（也可以是能进行区分的部分ID串前缀）时，会先尝试删除所有指向该镜像，然后再删除该镜像文件本身</p><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi xxxx(ID)</span><br></pre></td></tr></table></figure><p>注意：使用该命令可以彻底将该镜像删除，而不是只是删除对应的标签，请务必注意。</p><hr><p>注意：</p><p>当有该镜像创建的容器存在时，镜像文件默认是无法被删除的</p><p>试图删除该镜像，docker会提示有容器正在运行，无法删除</p><p>如果要强行删除镜像，可以使用-f参数</p><hr><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>创建镜像的方法主要有三种：</p><ul><li><p>基于已有镜像的容器创建</p></li><li><p>基于本地模板导入</p></li><li><p>基于dockerfile创建</p></li></ul><h3 id="基于已有镜像的容器创建"><a href="#基于已有镜像的容器创建" class="headerlink" title="基于已有镜像的容器创建"></a>基于已有镜像的容器创建</h3><p>当运行一个容器后，内部发生了变化，我们可以把这个发生了变化的容器做成一个新的镜像。</p><p>该方法主要是通过docker commit命令。</p><p>命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [options] container [repository[:tag]]</span><br></pre></td></tr></table></figure><p>主要选项包括：</p><ul><li><p>-a     –author=””：作者信息</p></li><li><p>-c     –change=[]：提交的时候之心dockerfile指令，</p></li><li><p>-m   –message=””：提交消息</p></li><li><p>-p    –pause=true     提交时暂停容器运行</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -it ubuntu:14.04 /bin/bash</span><br><span class="line"></span><br><span class="line">root@fdbe2f28b1d6:/# touch test</span><br><span class="line"></span><br><span class="line">root@fdbe2f28b1d6:/# exit</span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line">[root@master ~]# docker commit -m &quot;add a new file&quot; -a &quot;wxh&quot; fdbe2f28b1d6 test:0.1</span><br><span class="line"></span><br><span class="line">sha256:cd9c21826184f9e65e11644f826fb97918d40d469aa5e3fd8827cbcac19351ed</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker images 查看</span><br></pre></td></tr></table></figure><p>I’m just </p><h3 id="基于本地模板导入"><a href="#基于本地模板导入" class="headerlink" title="基于本地模板导入"></a>基于本地模板导入</h3><p>这部分不常用，详见书籍《docker技术入门与实践》-p32</p><h3 id="基于dockerfile创建"><a href="#基于dockerfile创建" class="headerlink" title="基于dockerfile创建"></a>基于dockerfile创建</h3><h2 id="存出和载入镜像"><a href="#存出和载入镜像" class="headerlink" title="存出和载入镜像"></a>存出和载入镜像</h2><p>用户可以使用docker save和docker load命令来存出和载入镜像</p><h3 id="存出镜像"><a href="#存出镜像" class="headerlink" title="存出镜像"></a>存出镜像</h3><p>如果要导出镜像到本地文件，可以使用docker save命令。例如导出本地的ubunt:14.04镜像为ubuntu_14.04.tar。如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker save -o ubuntu:14.04.tar ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h3><p>可以使用docker load将导出的tar文件再导入到本地的镜像库，例如从上述文件导入镜像到本地镜像列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker load --input ubuntu\:14.04.tar</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker load &lt; ubuntu\:14.04.tar</span><br></pre></td></tr></table></figure><p>该命令将导入镜像及其相关的元数据信息（包括标签等）。导入成功之后，可以使用docker images命令进行查看。</p><h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>首先在docker hub网站完成注册</p><p>可以通过执行 docker login 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><p>你可以通过 docker logout 退出登录。</p><h3 id="上传镜像-1"><a href="#上传镜像-1" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>可以使用docker push命令上传镜像到仓库，默认上传到docker Hub官方仓库（需要登录）</p><p>命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</span><br></pre></td></tr></table></figure><p>例如上传一个自制的镜像的步骤（首先需要在docker hub网站完成注册）</p><p>操作步骤：</p><ul><li>首先需要使用tag将要上传的镜像打上标签，标签的格式为：username/仓库名:tag</li></ul><p>例如这里是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu:14.04 watchmen1992/test:ubuntu14.04</span><br></pre></td></tr></table></figure><ul><li>打上标签之后才可以正确上传</li></ul><p>在docker hub的页面可以看到新增内容</p><h1 id="第4章-使用Docker容器"><a href="#第4章-使用Docker容器" class="headerlink" title="第4章 使用Docker容器"></a>第4章 使用Docker容器</h1><p>容器是docker的另一个和细腻概念。简单来说，容器是镜像的一个运行实例。所不同的是，镜像是静态的只读文件，而容器带有运行时需要的可写文件层。</p><h2 id="创建启动容器"><a href="#创建启动容器" class="headerlink" title="创建启动容器"></a>创建启动容器</h2><h3 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h3><p>使用docker create命令新建一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：docker create -it ubuntu:latest</span><br></pre></td></tr></table></figure><p>注意：使用该命令新建的容器<strong>处于停止状态</strong>，可以使用docker start命令来启动它。</p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>使用docker start 命令来启动一个已经创建的容器，例如启动刚创建的ubuntu容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start af</span><br></pre></td></tr></table></figure><h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><p>除了创建容器后通过start命令来启动，也可以直接新建并启动容器。</p><p>所需要的命令主要为:docker run。等价于先执行docker create命令，再执行docker start命令</p><p>例如，下面的命令输出一个“hello world”之后容器终止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run ubuntu:14.04 /bin/echo &quot;hello,world&quot;</span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure><p>当利用docker run命令来创建并启动容器时，docker在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库中下载</li><li>利用镜像创建一个容器，并启动该容器</li><li>分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中</li><li>从网桥的地址池配置一个IP地址给容器</li><li>执行用户执行的应用程序</li><li>执行完毕后容器被自动终止</li></ul><p>下面命令启动一个bash终端，允许用户进行交互</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -it ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure><p>-t选项让docker分配一个伪终端，并绑定到容器的标准输入上，一则让容器的标准输入保持打开。更多的命令可以通过 man docker-run进行查看。</p><hr><p>注意：</p><p>对于所创建的bash容器，当使用exit命令退出之后，容器就自动处于退出状态了，这是因为对于docker容器来说，当运行的应用退出之后，容器也就没有继续运行的必要了</p><hr><h3 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h3><p>更多的时候，需要让docker容器在后台以守护态（daemonized）形式运行。此时可以添加-d参数来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d  ubuntu:14.04 /bin/bash -c &quot;while true;do echo hello,world;sleep 1;done&quot;</span><br></pre></td></tr></table></figure><p>此时，要获取容器的输出信息，可以使用如下的docker logs命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker logs 9e7</span><br></pre></td></tr></table></figure><p>退出错误代码</p><ul><li><p>125         docker daemon执行出错，例如指定了不支持的docker命令参数</p></li><li><p>126         所指定命令无法执行，例如权限出错</p></li><li><p>127         容器内命令无法找到</p></li></ul><p>当命令执行出错时，会默认返回错误码</p><h3 id="容器参数"><a href="#容器参数" class="headerlink" title="容器参数"></a>容器参数</h3><p>详见书籍《docker技术从入门到实践》p35-37</p><ul><li><p>–rm  容器在终止后会立刻删除</p></li><li><p>-d           守护态启动，注意—rm和-d不能同时使用</p></li></ul><h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用docker stop来终止一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令格式为：docker stop -t|--time[=10]</span><br></pre></td></tr></table></figure><p>该命令首先向容器发送SIGTERM信号，等待一段超时时间（默认为10秒）后，再发送SIGKILL信号来终止容器</p><p>当容器中指定的应用终结时，容器也会自动终止。</p><p>处于终止状态的容器，可以通过start命令来重新启动</p><p>此外，docker restart 命令会将一个运行态的容器先终止，然后再重新启动它</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><h3 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h3><p>这种方法，同一时间只能有一个活动窗口。不建议</p><h3 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h3><p>通过exec命令对容器执行操作是最为推荐的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker start 9e708d44e39a</span><br><span class="line">9e708d44e39a</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker exec -it 9e7 /bin/bash</span><br><span class="line">root@9e708d44e39a:/#</span><br></pre></td></tr></table></figure><p>比较常用的参数有：</p><ul><li><p>-i            –interactive=true|false             打开标准输入接受用户输入命令，默认为false。</p></li><li><p>–privileged=true|false             是否给执行命令以最高权限，默认为false。</p></li><li><p>-t     –tty=true|false         分配伪终端，默认为false</p></li><li><p>-u    –user=””         执行命令的用户名或者ID</p></li></ul><h3 id="nsenter工具"><a href="#nsenter工具" class="headerlink" title="nsenter工具"></a>nsenter工具</h3><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><ul><li><p>docker ps               查看运行中的容器</p></li><li><p>docker ps  -a          查看所有容器，包括运行的与停止的</p></li><li><p>docker ps -qa          查看所有容器ID</p></li></ul><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用docker rm命令来删除处于终止或者退出状态的容器</p><p>命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f|--force [-v|--volumes] container [container…]</span><br></pre></td></tr></table></figure><p>主要支持的选项包括：</p><ul><li><p>-f            –force=false     是否强行终止并删除一个运行中的容器</p></li><li><p>-l            –link=false      删除容器的连接，但是保留容器</p></li><li><p>-v           –volumes=false       删除容器挂载的数据卷</p></li></ul><p>默认情况下，docker rm命令只能删除处于终止或者退出状态的容器，并不能删除还是处于运行状态的容器。</p><p>如果要删除一个运行中的容器，可以添加-f参数。该命令首先向容器发送SIGKILL信号给容器，终止其中的应用，之后强行删除。</p><h2 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker export -o test_for_run.tar ce5</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">docker export e81 &gt; test_for_stop.tar</span><br></pre></td></tr></table></figure><h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><p>导出的文件可以使用docker import命令导入变成镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import test_for_run.tar – test/ubuntu:v1.0</span><br></pre></td></tr></table></figure><p>实际上，既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以用docker import命令来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也更大。此外，从容器快照文件导入时可以重新制定标签等元数据信息</p><h1 id="第5章-访问docker仓库"><a href="#第5章-访问docker仓库" class="headerlink" title="第5章 访问docker仓库"></a>第5章 访问docker仓库</h1><p>仓库（repositroy）是集中存放镜像的地方，分为公共仓库和私有仓库。</p><p>注意：注册服务器是存放仓库的服务器</p><h2 id="docker-hub公共镜像市场"><a href="#docker-hub公共镜像市场" class="headerlink" title="docker hub公共镜像市场"></a>docker hub公共镜像市场</h2><p>默认使用的镜像来源都是docker  hub中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search lnmp</span><br></pre></td></tr></table></figure><h2 id="时速云镜像市场"><a href="#时速云镜像市场" class="headerlink" title="时速云镜像市场"></a>时速云镜像市场</h2><h2 id="搭建本地私有仓库"><a href="#搭建本地私有仓库" class="headerlink" title="搭建本地私有仓库"></a>搭建本地私有仓库</h2><h3 id="使用registry镜像创建私有仓库"><a href="#使用registry镜像创建私有仓库" class="headerlink" title="使用registry镜像创建私有仓库"></a>使用registry镜像创建私有仓库</h3><p>安装docker之后，可以通过官方提供的<strong>registry</strong>镜像来简单搭建一套本地私有仓库环境:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p>它将自动下载并且启动一个registry容器，创建本地的私有仓库服务</p><p>在默认情况下，会将仓库创建在容器的/tmp/registry目录下。可以通过-v参数来将镜像文件存放在本地的指定路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000  -v /opt/data/registry:/tmp/registry  registry</span><br></pre></td></tr></table></figure><h3 id="管理私有仓库-上传镜像"><a href="#管理私有仓库-上传镜像" class="headerlink" title="管理私有仓库-上传镜像"></a>管理私有仓库-上传镜像</h3><p>因为docker images中的字段，REPOSITORY表示仓库信息，因此，我们在创建了私有仓库之后，要使用镜像，需要对镜像进行tag标签的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker tag ubuntu:14.04 47.93.54.101:5000/test</span><br></pre></td></tr></table></figure><p>上述命令解释：</p><p>使用tag命令将ubuntu镜像标记为47.93.54.101:5000/test【也就是这个仓库下的】</p><p>47.93.54.101:5000是仓库注册服务器，test是仓库名称，test:[name]后面接的是tag信息，没有写的话，默认是latest</p><p>接下来使用docker push上传标记的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker push 47.93.54.101:5000/test</span><br></pre></td></tr></table></figure><hr><p>注意：</p><p>客户端采用https，docker registry未采用https服务，由于服务端没有采用https方式，因此客户端无法使用默认的https形式pull镜像，因此我们要做一些操作</p><hr><ul><li>服务端：</li></ul><p>在/etc/docker/目录下，创建daemon.json文件。在文件中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master docker]# cat daemon.json</span><br><span class="line"></span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;47.93.54.101:5000&quot;]&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><p>在/etc/docker/目录下，创建daemon.json文件。在文件中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master docker]# cat daemon.json</span><br><span class="line"></span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;47.93.54.101:5000&quot;]&#125;</span><br></pre></td></tr></table></figure><p>注意：不光服务端要配置，客户端也需要配置</p><p>配置完毕之后，我们就可以看到客户端能够正常的拉取我们私有仓库中的镜像</p><h1 id="第6章-Docker数据管理"><a href="#第6章-Docker数据管理" class="headerlink" title="第6章 Docker数据管理"></a>第6章 Docker数据管理</h1><p>生产环境中使用docker的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。</p><p>容器中管理数据主要有2种方式</p><ul><li><p>数据卷（data volumes）：容器内数据直接映射到本地主机环境</p></li><li><p>数据卷容器（data volumes containers）：使用特定容器维护数据卷。</p></li></ul><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可以供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于linux的mount挂载操作。</p><p>数据卷可以提供很多有用的特性：</p><ul><li><p>数据卷可以在容器之间共享和重用，容器键传递数据将变得高效方便。</p></li><li><p>对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作。</p></li><li><p>对数据卷的更新不会影响镜像，解耦了应用和数据</p></li><li><p>卷会一直存在，直到没有容器使用，可以安全的卸载它。</p></li></ul><h3 id="在容器内创建一个数据卷"><a href="#在容器内创建一个数据卷" class="headerlink" title="在容器内创建一个数据卷"></a>在容器内创建一个数据卷</h3><p>在用docker run命令的时候，使用-v标记可以在容器内创建一个数据卷。多次重复使用-v标记可以创建多个数据卷。</p><p>下面使用 training/webapp镜像创建一个web容器，并创建一个数据卷挂载到容器的/webapp目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -P --name web -v /webapp training/webapp python app.py</span><br></pre></td></tr></table></figure><p>注意：这里是在容器内部创建一个目录，而不是宿主机上创建</p><p>-P是将容器服务暴露的端口，是自动映射到本地主机的临时端口       </p><h3 id="挂载宿主机目录作为数据卷"><a href="#挂载宿主机目录作为数据卷" class="headerlink" title="挂载宿主机目录作为数据卷"></a>挂载宿主机目录作为数据卷</h3><p>使用-v标记也可以指定挂载一个本地的已有目录到容器中去作为数据卷【推荐方式】</p><p>[root@master ~]# docker run -d -P –name web -v /src/webapp:/opt/webapp training/webapp python app.py</p><p>上述命令加载主机的/src/webapp目录到容器的/opt/webapp目录</p><p>本地目录的路径必须是绝对路径，如果目录不存在，docker会自动创建</p><p>注意：docker挂载数据卷的默认权限是读写（rw）,用户也可以通过ro指定为只读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</span><br></pre></td></tr></table></figure><p><strong>设置为ro</strong>之后，容器内对所挂载数据卷内的数据就无法修改了。</p><p> 使用这个功能，在进行一些测试的时候十分方便，比如用户可以将一些程序或者数据放到本地目录中，然后再容器内运行和使用</p><h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p>-v标记也可以从主机挂载单个文件到容器中作为数据卷（对应容器中的某一个文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run –rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>注意：如果直接挂载一个文件到容器中，使用文件编辑工具，包括vi或者sed等，可能会造成文件inode的概念，从docker 1.1.0版本起，这会导致报错，所以推荐的方式是直接挂载目录。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果用户需要再多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。</p><p>首先，创建一个数据卷容器dbdata，并在其中创建一个数据卷挂载到/dbdata：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /dbdata --name dbdata ubuntu</span><br></pre></td></tr></table></figure><p>【这个dbdata是在容器内部的一个目录，请注意】</p><p>作用是：定义一个数据卷</p><p>然后，可以在其他容器中使用–volumes-from来挂载dbdata容器中的数据卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from  dbdata --name db1 ubuntu</span><br></pre></td></tr></table></figure><p>在容器dbdata中查看，数据已经同步过来                        </p><p>可以多次使用 –volume-from参数来从多个容器挂载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷。</p><p>注意：如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时，显式使用docker rm -v命令来指定同时删除关联的容器。</p><p>使用数据卷容器可以让用户在容器之间自由地升级和移动数据卷。</p><h2 id="利用数据卷容器来迁移"><a href="#利用数据卷容器来迁移" class="headerlink" title="利用数据卷容器来迁移"></a>利用数据卷容器来迁移</h2><p>可以利用数据卷容器对其中的数据卷进行备份、恢复、以实现数据的迁移。</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>使用下面的命令来备份dbdata数据卷容器内的数据卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run --volumes-from  dbdata -v $(pwd):/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdata</span><br><span class="line"></span><br><span class="line">tar: Removing leading `/&apos; from member names</span><br><span class="line">/dbdata/</span><br><span class="line">/dbdata/a</span><br><span class="line">/dbdata/db1</span><br></pre></td></tr></table></figure><p>命令解析：</p><p>首先利用ubuntu镜像创建了一个容器worker，使用–volumes-from dbdata参数来让worker容器挂载dbdata容器的数据卷。</p><p>然后使用-v参数，挂载本地的当前目录到worker容器内部的/backup目录。</p><p>worker容器启动之后，使用tar命令，将/dbdata目录备份到容器内的/backup目录下，也就是宿主机的当前目录下。即可完成整个备份过程。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>数据操作都需要借助容器来完成，需要借助容器来打通一个通道。</p><p>恢复数据的思路（这里指的是恢复数据到另一个没有数据的数据卷容器中）：</p><ul><li><p>创建一个新的数据卷容器</p></li><li><p>创建一个新的容器，挂载该容器（–volumes-from参数）</p></li><li><p>挂载本地的目录到/backup下（这时该目录下就会有本地的数据），然后解压其中的数据</p></li></ul><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure><h1 id="第7章-端口映射与容器互联"><a href="#第7章-端口映射与容器互联" class="headerlink" title="第7章 端口映射与容器互联"></a>第7章 端口映射与容器互联</h1><p>在实际情况中，是需要多个服务组件容器共同协作的情况，因此往往需要多个容器之间能够互相访问到对方的服务。</p><p>除了通过网络来进行访问，docker还提供了两个功能满足服务访问的基本需求：</p><ul><li><p>一个是允许映射容器内应用的服务端口到本地宿主主机</p></li><li><p>另一个是互联机制实现多个容器键通过容器名称来来快速访问</p></li></ul><p>在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。</p><h2 id="端口映射实现访问容器"><a href="#端口映射实现访问容器" class="headerlink" title="端口映射实现访问容器"></a>端口映射实现访问容器</h2><h3 id="所有接口的随机端口"><a href="#所有接口的随机端口" class="headerlink" title="所有接口的随机端口"></a>所有接口的随机端口</h3><p>可以通过-P或者-p参数来指定端口映射。</p><ul><li>当使用-P时，映射一个49000-49900的端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure><p>可以通过docker logs -f [id]来查看应用信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker logs -f 4336a2dbe777</span><br></pre></td></tr></table></figure><h3 id="所有接口的指定端口"><a href="#所有接口的指定端口" class="headerlink" title="所有接口的指定端口"></a>所有接口的指定端口</h3><p>命令格式：hostport:containerport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>使用该命令映射所有接口地址</p><p>此时绑定所有接口上的所有地址，将本地的5000端口映射搭配容器的5000端口</p><h3 id="指定地址的指定端口"><a href="#指定地址的指定端口" class="headerlink" title="指定地址的指定端口"></a>指定地址的指定端口</h3><p>命令格式：IP:hostport:containerport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>指定使用本机的哪一个地址进行端口映射</p><h3 id="指定地址的任意端口"><a href="#指定地址的任意端口" class="headerlink" title="指定地址的任意端口"></a>指定地址的任意端口</h3><p>命令格式：IP::containerport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>还可以使用udp标记来指定udp端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 127.0.0.1::5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure><h2 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h2><p>命令语法：docker port 容id  [port]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker port  4336a2dbe777</span><br><span class="line"></span><br><span class="line">5000/tcp -&gt; 0.0.0.0:32773</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker port  4336a2dbe777 5000</span><br><span class="line"></span><br><span class="line">0.0.0.0:32773</span><br></pre></td></tr></table></figure><h2 id="互联机制实现便捷互访"><a href="#互联机制实现便捷互访" class="headerlink" title="互联机制实现便捷互访"></a>互联机制实现便捷互访</h2><p>容器的互联（link）是一种让多个容器中应用进行快速交互的方式。他会在源和接受容器之间创建连接关系，接受容器可以通过容器名称快速访问到源容器，而不用指定具体的IP地址。</p><h3 id="自定义容器名称"><a href="#自定义容器名称" class="headerlink" title="自定义容器名称"></a>自定义容器名称</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>连接系统通过容器名称来执行，因此需要给每个容器都定义一个名称。</p><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>使用—link参数可以让容器之间安全地进行交互</p><p>link参数格式为：–link name:alias</p><p>docker通过两种方式为容器公开连接信息。</p><ul><li><p>更新环境变量</p></li><li><p>更新/etc/hosts文件。</p></li></ul><p>以下为参考案例：</p><p>首先创建一个新的数据库容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master registry]# docker run -d --name db training/postgres</span><br></pre></td></tr></table></figure><p>创建一个新的web容器，并将它连接到db容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master registry]# docker run -d -P --name web --link db:db training/webapp python app.py</span><br></pre></td></tr></table></figure><p>查看容器之间的连接信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master registry]# docker run --rm --name web2 --link db:db training/webapp env</span><br></pre></td></tr></table></figure><p>查看hosts信息(cat /etc/hosts)</p><p>可以看到，hosts文件中包含db的信息和自身的配置信息。</p><p>以上都是单机中多容器之间的互联，后续还会涉及跨主机之间的容器通信。</p><h1 id="第8章-使用dockerfile创建镜像"><a href="#第8章-使用dockerfile创建镜像" class="headerlink" title="第8章 使用dockerfile创建镜像"></a>第8章 使用dockerfile创建镜像</h1><h1 id="第9章-docker网络"><a href="#第9章-docker网络" class="headerlink" title="第9章 docker网络"></a>第9章 docker网络</h1>]]></content>
    
    <summary type="html">
    
      Docker入门与实践
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="虚拟化" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>day06-面向对象编程</title>
    <link href="http://yoursite.com/2018/08/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/20/编程语言/Python/老男孩视频学习笔记/day06-面向对象编程/</id>
    <published>2018-08-20T12:58:43.000Z</published>
    <updated>2018-08-20T12:58:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向过程-VS-面向对象"><a href="#面向过程-VS-面向对象" class="headerlink" title="面向过程 VS 面向对象"></a>面向过程 VS 面向对象</h1><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a><strong>编程范式</strong></h2><p>编程是 程序 员 用特定的<strong>语法+数据结构+算法</strong>组成的代码来告诉计算机如何执行任务的过程 （算法：其实就是解决一些问题的套路</p><p>一个程序是程序员为了得到一个任务结果而编写的一组指令的集合</p><p>正所谓条条大路通罗马，实现一个任务的方式有很多种不同的方式， 对这些不同的编程方式的特点进行归纳总结得出来的编程方式类别，即为编程范式。</p><p>不同的编程范式本质上代表对各种类型的任务采取的不同的解决问题的思路， 大多数语言只支持一种编程范式，当然也有些语言可以同时支持多种编程范式。 两种最重要的编程范式分别是面向过程编程和面向对象编程。</p><p>范式可以理解为某一个行业的标准，例如羽毛球中的标准动作（挥拍，高远球，走位等），基本上已经达成了统一的标准，那么编程也是一样的，目前已经想成了两种标准，分别适用于两种不同的应用场景，也可以理解为两套羽毛球标准，分别适用于不同的应用场景当中。</p><h2 id="面向过程编程-Procedural-Programming"><a href="#面向过程编程-Procedural-Programming" class="headerlink" title="面向过程编程(Procedural Programming)"></a><strong>面向过程编程(Procedural Programming)</strong></h2><p>Procedural programming uses a list of instructions to tell the computer what to do step-by-step. </p><p>面向过程编程，使用一系列的指令来告诉计算机一步一步的去做什么操作</p><p>面向过程编程依赖 - 你猜到了- procedures，一个procedure包含一组要被进行计算的步骤， 面向过程又被称为top-down languages， 就是程序从上到下一步步执行，一步步从上到下，从头到尾的解决问题 。</p><p><strong>核心思想：基本设计思路就是程序一开始是要着手解决一个大的问题，然后把一个大问题分解成很多个小问题或子过程，这些子过程再执行的过程再继续分解直到小问题足够简单到可以在一个小步骤范围内解决。</strong></p><p>举个典型的面向过程的例子， 数据库备份， 分三步，连接数据库，备份数据库，测试备份文件可用性。</p><p>这样做的问题也是显而易见的，就是如果你要对程序进行修改，对你修改的那部分有依赖的各个部分你都也要跟着修改，举个例子，如果程序开头你设置了一个变量值 为1 ， 但如果其它子过程依赖这个值 为1的变量才能正常运行，那如果你改了这个变量，那这个子过程你也要修改，假如又有一个其它子程序依赖这个子过程 ， 那就会发生一连串的影响，随着程序越来越大， 这种编程方式的维护难度会越来越高。  所以我们一般认为， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程的方式是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护 的， 那还是用面向对象最方便了。</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>OOP编程是利用“类”和“对象”来创建各种模型来实现对真实世界的描述，使用面向对象编程的原因一方面是因为它可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使它人更加容易理解你的代码逻辑，从而使团队开发变得更从容。</p><p>面向对象的几个核心特性如下</p><h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a><strong>Class 类</strong></h3><p>一个类即是对一类拥有相同属性的对象的抽象、蓝图、原型。在类中定义了这些对象的都具备的属性（variables(data)）、共同的方法</p><p>世间万物，皆可分类！</p><p>世间万物，皆为对象！</p><h3 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a><strong>Object 对象</strong></h3><p>一个对象即是一个类的实例化后实例，一个类必须经过实例化后方可在程序中调用，一个类可以实例化多个对象，每个对象亦可以有不同的属性，就像人类是指所有人，每个人是指具体的对象，人与人之前有共性，亦有不同</p><h3 id="Encapsulation-封装"><a href="#Encapsulation-封装" class="headerlink" title="Encapsulation 封装"></a><strong>Encapsulation 封装</strong></h3><p>在类中对数据的赋值、内部调用对外部用户是透明的，这使类变成了一个胶囊或容器，里面包含着类的数据和方法</p><p>例如，可以把类的方法都封装起来，内部的代码不会被暴露在外部，而是隐藏起来，只需要调用即可使用该功能</p><h3 id="Inheritance-继承"><a href="#Inheritance-继承" class="headerlink" title="Inheritance 继承"></a><strong>Inheritance 继承</strong></h3><p>一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承</p><h3 id="Polymorphism-多态"><a href="#Polymorphism-多态" class="headerlink" title="Polymorphism 多态"></a><strong>Polymorphism 多态</strong></h3><p>多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，指一个基类中派生出了不同的子类，且每个子类在继承了同样的方法名的同时又<strong>对父类的方法做了不同的实现</strong>，这就是同一种事物表现出的多种形态。</p><p>编程其实就是一个将具体世界进行抽象化的过程，多态就是抽象化的一种体现，把一系列具体事物的共同点抽象出来, 再通过这个抽象的事物, 与不同的具体事物进行对话。<br>对不同类的对象发出相同的消息将会有不同的行为。比如，你的老板让所有员工在九点钟开始工作, 他只要在九点钟的时候说：“开始工作”即可，而不需要对销售人员说：“开始销售工作”，对技术人员说：“开始技术工作”, 因为“员工”是一个抽象的事物, 只要是员工就可以开始工作，他知道这一点就行了。至于每个员工，当然会各司其职，做各自的工作。</p><p>在这里，工作就相当于父类的方法，而子类继承了之后，针对这个方法，会有不同的实现方式。 相当于是同一个东西，表面上是明确的不变，但是内部是不断在变化的。</p><p>多态允许将子类的对象当作父类的对象使用，某父类型的引用指向其子类型的对象,调用的方法是该子类型的方法。这里引用和调用方法的代码编译前就已经决定了,而引用所指向的对象可以在运行期间动态绑定</p><p>封装、继承、多态是面向对象的3个特性</p><h1 id="面向对象编程-Object-Oriented-Programming-介绍"><a href="#面向对象编程-Object-Oriented-Programming-介绍" class="headerlink" title="面向对象编程(Object-Oriented Programming )介绍"></a>面向对象编程(<strong>Object-Oriented Programming</strong> )介绍</h1><p>对于编程语言的初学者来讲，OOP不是一个很容易理解的编程方式，大家虽然都按老师讲的都知道OOP的三大特性是继承、封装、多态，并且大家也都知道了如何定义类、方法等面向对象的常用语法，但是一到真正写程序的时候，还是很多人喜欢用函数式编程来写代码，特别是初学者，很容易陷入一个窘境就是“我知道面向对象，我也会写类，但我依然没发现在使用了面向对象后，对我们的程序开发效率或其它方面带来什么好处，因为我使用函数编程就可以减少重复代码并做到程序可扩展了，为啥子还用面向对象？”。 对于此，我个人觉得原因应该还是因为你没有充分了解到面向对象能带来的好处，今天我就写一篇关于面向对象的入门文章，希望能帮大家更好的理解和使用面向对象编程。  </p><p>无论用什么形式来编程，我们都要明确记住以下原则：</p><ol><li><strong>写重复代码是非常不好的低级行为</strong></li><li><strong>你写的代码需要经常变更</strong> </li></ol><p>开发正规的程序跟那种写个运行一次就扔了的小脚本一个很大不同就是，你的代码总是需要不断的更改，不是修改bug就是添加新功能等，所以为了日后方便程序的修改及扩展，你写的代码一定要遵循易读、易改的原则（专业数据叫可读性好、易扩展）。</p><p>如果你把一段同样的代码复制、粘贴到了程序的多个地方以实现在程序的各个地方调用 这个功能，那日后你再对这个功能进行修改时，就需要把程序里多个地方都改一遍，这种写程序的方式是有问题的，因为如果你不小心漏掉了一个地方没改，那可能会导致整个程序的运行都 出问题。 因此我们知道 在开发中一定要努力避免写重复的代码，否则就相当于给自己再挖坑。</p><p>还好，函数的出现就能帮我们轻松的解决重复代码的问题，对于需要重复调用的功能，只需要把它写成一个函数，然后在程序的各个地方直接调用这个函数名就好了，并且当需要修改这个功能时，只需改函数代码，然后整个程序就都更新了。</p><p>其实OOP编程的主要作用也是使你的代码修改和扩展变的更容易，那么小白要问了，既然函数都能实现这个需求了，还要OOP干毛线用呢？ 呵呵，说这话就像，古时候，人们打仗杀人都用刀，后来出来了枪，它的主要功能跟刀一样，也是杀人，然后小白就问，既然刀能杀人了，那还要枪干毛线，哈哈，显而易见，因为枪能更好更快更容易的杀人。函数编程与OOP的主要区别就是OOP可以使程序更加容易扩展和易更改。</p><h2 id="init-和self"><a href="#init-和self" class="headerlink" title="__init__和self"></a><code>__init__</code>和self</h2><p>类的写法是下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    def __init__(self,name,type):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line"></span><br><span class="line">    def sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog1 = Dog(&apos;wxh&apos;,&apos;二哈&apos;)</span><br><span class="line"></span><br><span class="line">dog1.sayhi()</span><br></pre></td></tr></table></figure><p><strong>其实self,就是实例本身！你实例化时python会自动把这个实例本身通过self参数传进去。</strong></p><p>上面的这个<strong>init</strong>()叫做初始化方法(或构造方法)， 在类被调用时，这个方法(虽然它是函数形式，但在类中就不叫函数了,叫方法)会自动执行，进行一些初始化的动作<br>我们这里写<code>__init__</code>(self,name,role,weapon,life_value=100,money=15000)就是要在创建一个角色时给它设置这些属性，那么这第一个参数self是干毛用的呢？ </p><p>初始化一只狗，就需要调用这个类一次： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`r1 ``=` `Role(``&apos;Alex&apos;``,``&apos;police&apos;``,&apos;AK47’) ``#生成一个角色 , 会自动把参数传给Role下面的__init__(...)方法``r2 ``=` `Role(``&apos;Jack&apos;``,``&apos;terrorist&apos;``,&apos;B22’)  ``#生成一个角色`</span><br></pre></td></tr></table></figure><p>我们看到，上面的创建角色时，我们并没有给<code>__init__</code>传值，程序也没未报错，是因为，类在调用它自己的<strong>init</strong>(…)时自己帮你给self参数赋值了， </p><p>我们再来定义一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Role(object): #定义一个类， class是定义类的语法，Role是类名，(object)是新式类的写法，必须这样写，以后再讲为什么</span><br><span class="line">    def __init__(self,name,role,weapon,life_value=100,money=15000): #初始化函数，在生成一个角色时要初始化的一些属性就填写在这里</span><br><span class="line">        self.name = name #__init__中的第一个参数self,和这里的self都 是什么意思？ 看下面解释</span><br><span class="line">        self.role = role</span><br><span class="line">        self.weapon = weapon</span><br><span class="line">        self.life_value = life_value</span><br><span class="line">        self.money = money</span><br><span class="line">    def buy_gun(self,gun_name):</span><br><span class="line">        print(“%s has just bought %s” %(self.name,gun_name) )</span><br></pre></td></tr></table></figure><p>当执行r1 = Role(‘Alex’,’police’,’AK47<strong>’</strong>)创建一个对象时，python的解释器其实干了两件事：</p><ol><li>在内存中开辟一块空间指向r1这个变量名</li><li>调用Role这个类并执行其中的<code>__init__</code>(…)方法，相当于Role.<code>__init__</code>(r1,’Alex’,’police’,AK47’),这么做是为什么呢？ 是为了把’Alex’,’police’,’AK47’这3个值跟刚开辟的r1关联起来，是为了把’Alex’,’police’,’AK47’这3个值跟刚开辟的r1关联起来，是为了把’Alex’,’police’,’AK47’这3个值跟刚开辟的r1关联起来，重要的事情说3次， 因为关联起来后，你就可以直接r1.name, r1.weapon 这样来调用啦。所以，为实现这种关联，在调用<code>__init__</code>方法时，就必须把r1这个变量也传进去，否则<code>__init__</code>不知道要把那3个参数跟谁关联呀。</li><li>所以这个<code>__init__</code>(…)方法里的，self.name = name , self.role = role 等等的意思就是要把这几个值 存到r1的内存空间里。</li></ol><p><code>__init__(…)</code>基本懂了，但后面的那几个函数，噢 不对，后面那几个方法 为什么也还需要self参数么？ 不是在初始化角色的时候 ，就已经把角色的属性跟r1绑定好了么？ </p><p>上面这个方法通过类调用的话要写成如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`r1 ``=` `Role(``&apos;Alex&apos;``,``&apos;police&apos;``,``&apos;AK47&apos;``)``r1.buy_gun(``&quot;B21”) #python 会自动帮你转成 Role.buy_gun(r1,”B21&quot;``)`</span><br></pre></td></tr></table></figure><p>我们依然没给self传值 ，但Python还是会自动的帮你把r1 赋值给self这个参数， 为什么呢？ 因为，你在buy_gun(..)方法中可能要访问r1的一些其它属性呀， 比如这里就访问 了r1的名字，怎么访问呢？你得告诉这个方法呀，于是就把r1传给了这个self参数，然后在buy_gun里调用 self.name 就相当于调用r1.name 啦，如果还想知道r1的生命值 有多少，直接写成self.life_value就可以了。 说白了就是在调用类中的一个方法时，你得告诉人家你是谁。</p><p>好啦， 总结一下2点：</p><ol><li>上面的这个r1 = Role(‘Alex’,’police’,’AK47<strong>’</strong>)动作，叫做类的“实例化”， 就是把一个虚拟的抽象的类，通过这个动作，变成了一个具体的对象了， 这个对象就叫做实例</li><li>刚才定义的这个类体现了面向对象的第一个基本特性，封装，<strong>其实就是使用构造方法将内容封装到某个具体对象中，然后通过对象直接或者self间接获取被封装的内容</strong></li></ol><h1 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h1><p>很多同学都是学会了面向对象的语法，却依然写不出面向对象的程序，原因是什么呢？原因就是因为你还没掌握一门面向对象设计利器， 你说我读书少别骗我， 什么利器？  </p><p>答案就是:<strong>领域建模</strong>。 从领域模型开始,我们就开始了面向对象的分析和设计过程,可以说,领域模型是完成从需求分析到面向 对象设计的一座桥梁。 </p><p>领域模型,顾名思义,就是需求所涉及的领域的一个建模,更通俗的讲法是业务模型。 参考百度百科(<a href="http://baike.baidu.cn/view/757895.htm" target="_blank" rel="noopener">http://baike.baidu.cn/view/757895.htm</a> ),领域模型定义如下: </p><p>从这个定义我们可以看出,领域模型有两个主要的作用:</p><ol><li>发掘重要的业务领域概念</li><li>建立业务领域概念之间的关系 </li></ol><p><strong>领域建模三字经</strong> </p><p>领域模型如此重要,很多同学可能会认为领域建模很复杂,需要很高的技巧。然而事实上领域建模非常简 单,简单得有点难以让人相信,领域建模的方法概括一下就是“<strong>找名词</strong>”! 许多同学看到这个方法后估计都会笑出来:太假了吧,这么简单,找个初中生都会啊,那我们公司那些分 析师和设计师还有什么用哦?</p><p>分析师和设计师当然有用,后面我们会看到,即使是简单的找名词这样的操作,也涉及到分析和提炼,而 不是简单的摘取出来就可,这种情况下分析师和设计师的经验和技能就能够派上用场了。但领域模型分析 也确实相对简单,即使没有丰富的经验和高超的技巧,至少也能完成一个能用的领域模型。 </p><p>虽然我们说“找名词”很简单,但一个关键的问题还没有说明:<strong>从哪里找</strong>? 如果你还记得领域模型是“需求到面向对象的桥梁”,那么你肯定一下子就能想到:从需求模型中找,具 体来说就是从用例中找。 </p><p>归纳一下域建模的方法就是“<strong>从用例中找名词</strong>”。 当然,找到名词后,为了能够更加符合面向对象的要求和特点,我们还需要对这些名词进一步完善,这就 是接下来的步骤:<strong>加属性,连关系</strong>! </p><p>  最后我们总结出领域建模的三字经方法:<strong>找名词、加属性、连关系</strong>。 </p>]]></content>
    
    <summary type="html">
    
      day06-面向对象编程
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>python import模块相关问题</title>
    <link href="http://yoursite.com/2018/08/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/python-import%E6%A8%A1%E5%9D%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/16/编程语言/Python/基础知识/python-import模块相关问题/</id>
    <published>2018-08-16T04:50:21.000Z</published>
    <updated>2018-08-16T04:50:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><a href="https://www.kancloud.cn/st_afei/python_info_ylf/344146" target="_blank" rel="noopener">关于python——import问题</a></li><li><a href="http://codingpy.com/article/python-import-101/" target="_blank" rel="noopener">python导入模块的几种姿势</a></li></ul><h1 id="python-import"><a href="#python-import" class="headerlink" title="python import"></a>python import</h1><p>在python中，每个py文件被称之为模块，每个具有<code>__init__.py</code>文件的目录被称为包。只要模块或者包所在的目录在sys.path中，就可以使用import 模块或import 包来使用。</p><p>作为一名新手Python程序员，你首先需要学习的内容之一就是如何导入模块或包。但是我注意到，那些许多年来不时使用Python的人并不是都知道Python的导入机制其实非常灵活。在本文中，我们将探讨以下话题：</p><ul><li>常规导入（regular imports）</li><li>使用from语句导入</li><li>相对导入（relative imports）</li><li>可选导入（optional imports）</li><li>本地导入（local imports）</li><li>导入注意事项</li></ul><h2 id="常规导入"><a href="#常规导入" class="headerlink" title="常规导入"></a>常规导入</h2><p>常规导入应该是最常使用的导入方式，大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br></pre></td></tr></table></figure><p>你只需要使用<code>import</code>一词，然后指定你希望导入的模块或包即可。通过这种方式导入的好处是可以一次性导入多个包或模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import os, sys, time</span><br></pre></td></tr></table></figure><p>虽然这节省了空间，但是却违背了Python风格指南。<strong>Python风格指南建议将每个导入语句单独成行</strong>。</p><p>有时在导入模块时，你想要重命名这个模块。这个功能很容易实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys as system</span><br><span class="line"></span><br><span class="line">print(system.platform)</span><br></pre></td></tr></table></figure><p>上面的代码将我们导入的<code>sys</code>模块重命名为<code>system</code>。我们可以按照和以前一样的方式调用模块的方法，但是可以用一个新的模块名。也有某些子模块必须要使用点标记法才能导入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.error</span><br></pre></td></tr></table></figure><p>这个情况不常见，但是对此有所了解总是没有坏处的。</p><p>注意：</p><ul><li>import导入为绝对导入</li><li>import 只能导入模块，不能导入模块中的对象（类、函数、变量等)</li></ul><blockquote><p>Python 中所有加载到内存的模块都放在 sys.modules 。当 import 一个模块时首先会在这个列表中查找是否已经加载了此模块，如果没有加载则从 sys.path 目录中按照模块名称查找模块文件，找到后将模块载入内存，并加到 sys.modules 中。只有存在sys.path中的模块才会被正确导入。 </p><p>一个模块不会重复载入。多个不同的模块都可以用 import 引入同一个模块到自己的 Local 名字空间，其实背后的 PyModuleObject 对象只有一个。 </p><p>一个容易忽略的问题：import 只能导入模块，不能导入模块中的对象（类、函数、变量等）。例如：模块 A（A.py）中有个函数 getName，另一个模块不能通过 import A.getName 将 getName导入到本模块，只能用 from A import getName。 </p><p>同级目录下，可以使用import直接导入所需模块</p></blockquote><h2 id="使用from语句导入"><a href="#使用from语句导入" class="headerlink" title="使用from语句导入"></a>使用from语句导入</h2><p>很多时候你只想要导入一个模块或库中的某个部分。我们来看看在Python中如何实现这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from functools import lru_cache</span><br></pre></td></tr></table></figure><p>上面这行代码可以让你直接调用<code>lru_cache</code>。如果你按常规的import方式导入<code>functools</code>，那么你就必须像这样调用<code>lru_cache</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functools.lru_cache(*args)</span><br></pre></td></tr></table></figure><p>根据你实际的使用场景，上面的做法可能是更好的。在复杂的代码库中，能够看出某个函数是从哪里导入的这点很有用的。不过，如果你的代码维护的很好，模块化程度高，那么只从某个模块中导入一部分内容也是非常方便和简洁的。</p><p>当然，你还可以使用from方法导入模块的全部内容，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from os import *</span><br></pre></td></tr></table></figure><p>这种做法在少数情况下是挺方便的，但是这样也会打乱你的命名空间。问题在于，你可能定义了一个与导入模块中名称相同的变量或函数，这时如果你试图使用<code>os</code>模块中的同名变量或函数，实际使用的将是你自己定义的内容。因此，你最后可能会碰到一个相当让人困惑的逻辑错误。<strong>标准库中我唯一推荐全盘导入的模块只有Tkinter</strong>。</p><p>如果你正好要写自己的模块或包，有人会建议你在<code>__init__.py</code>文件中导入所有内容，让模块或者包使用起来更方便。我个人更喜欢显示地导入，而非隐式地导入。</p><p>你也可以采取折中方案，从一个包中导入多个项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from os import path, walk, unlink</span><br><span class="line">from os import uname, remove</span><br></pre></td></tr></table></figure><p>在上述代码中，我们从<code>os</code>模块中导入了5个函数。你可能注意到了，我们是通过多次从同一个模块中导入实现的。当然，如果你愿意的话，你也可以使用圆括号一次性导入多个项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from os import (path, walk, unlink, uname, </span><br><span class="line">                remove, rename)</span><br></pre></td></tr></table></figure><p>这是一个有用的技巧，不过你也可以换一种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from os import path, walk, unlink, uname, \</span><br><span class="line">                remove, rename</span><br></pre></td></tr></table></figure><p>上面的反斜杠是Python中的续行符，告诉解释器这行代码延续至下一行。</p><h2 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h2><p><a href="https://www.python.org/dev/peps/pep-0328/" target="_blank" rel="noopener">PEP 328</a>介绍了引入相对导入的原因，以及选择了哪种语法。具体来说，是使用句点来决定如何相对导入其他包或模块。这么做的原因是为了避免偶然情况下导入标准库中的模块产生冲突。这里我们以PEP 328中给出的文件夹结构为例，看看相对导入是如何工作的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_package/</span><br><span class="line">    __init__.py</span><br><span class="line">    subpackage1/</span><br><span class="line">        __init__.py</span><br><span class="line">        module_x.py</span><br><span class="line">        module_y.py</span><br><span class="line">    subpackage2/</span><br><span class="line">        __init__.py</span><br><span class="line">        module_z.py</span><br><span class="line">    module_a.py</span><br></pre></td></tr></table></figure><p>在本地磁盘上找个地方创建上述文件和文件夹。在顶层的<code>__init__.py</code>文件中，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import subpackage1</span><br><span class="line">from . import subpackage2</span><br></pre></td></tr></table></figure><p>接下来进入<code>subpackage1</code>文件夹，编辑其中的<code>__init__.py</code>文件，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import module_x</span><br><span class="line">from . import module_y</span><br></pre></td></tr></table></figure><p>现在编辑<code>module_x.py</code>文件，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from .module_y import spam as ham</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ham()</span><br></pre></td></tr></table></figure><p>最后编辑<code>module_y.py</code>文件，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def spam():</span><br><span class="line">    print(&apos;spam &apos; * 3)</span><br></pre></td></tr></table></figure><p>打开终端，<code>cd</code>至<code>my_package</code>包所在的文件夹，但不要进入<code>my_package</code>。在这个文件夹下运行Python解释器。我使用的是IPython，因为它的自动补全功能非常方便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import my_package</span><br><span class="line"></span><br><span class="line">In [2]: my_package.subpackage1.module_x</span><br><span class="line">Out[2]: &lt;module &apos;my_package.subpackage1.module_x&apos; from &apos;my_package/subpackage1/module_x.py&apos;&gt;</span><br><span class="line"></span><br><span class="line">In [3]: my_package.subpackage1.module_x.main()</span><br><span class="line">spam spam spam</span><br></pre></td></tr></table></figure><p>相对导入适用于你最终要放入包中的代码。如果你编写了很多相关性强的代码，那么应该采用这种导入方式。<strong>你会发现PyPI上有很多流行的包也是采用了相对导入</strong>。还要注意一点，如果你想要跨越多个文件层级进行导入，只需要使用多个句点即可。不过，<strong>PEP 328建议相对导入的层级不要超过两层</strong>。</p><p>还要注意一点，如果你往<code>module_x.py</code>文件中添加了<code>if __name__ == ‘__main__’</code>，然后试图运行这个文件，你会碰到一个很难理解的错误。编辑一下文件，试试看吧！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from . module_y import spam as ham</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ham()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # This won&apos;t work!</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>现在从终端进入<code>subpackage1</code>文件夹，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python module_x.py</span><br></pre></td></tr></table></figure><p>如果你使用的是Python 2，你应该会看到下面的错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;module_x.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from . module_y import spam as ham</span><br><span class="line">ValueError: Attempted relative import in non-package</span><br></pre></td></tr></table></figure><p>如果你使用的是Python 3，错误信息大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;module_x.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from . module_y import spam as ham</span><br><span class="line">SystemError: Parent module &apos;&apos; not loaded, cannot perform relative import</span><br></pre></td></tr></table></figure><p>这指的是，<code>module_x.py</code>是某个包中的一个模块，而你试图以脚本模式执行，但是<strong>这种模式不支持相对导入</strong>。</p><p>如果你想在自己的代码中使用这个模块，那么你必须将其添加至Python的导入检索路径（import search path）。最简单的做法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&apos;/path/to/folder/containing/my_package&apos;)</span><br><span class="line">import my_package</span><br></pre></td></tr></table></figure><p>注意，你需要添加的是<code>my_package</code>的上一层文件夹路径，而不是<code>my_package</code>本身。原因是<code>my_package</code>就是我们想要使用的包，所以如果你添加它的路径，那么将无法使用这个包。</p><p>我们接下来谈谈可选导入。</p><h2 id="可选导入（Optional-imports）"><a href="#可选导入（Optional-imports）" class="headerlink" title="可选导入（Optional imports）"></a>可选导入（Optional imports）</h2><p>如果你希望优先使用某个模块或包，但是同时也想在没有这个模块或包的情况下有备选，你就可以使用可选导入这种方式。这样做可以导入支持某个软件的多种版本或者实现性能提升。以<a href="http://pythonhosted.org/github2/_modules/github2/request.html" target="_blank" rel="noopener">github2包</a>中的代码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    # For Python 3</span><br><span class="line">    from http.client import responses</span><br><span class="line">except ImportError:  # For Python 2.5-2.7</span><br><span class="line">    try:</span><br><span class="line">        from httplib import responses  # NOQA</span><br><span class="line">    except ImportError:  # For Python 2.4</span><br><span class="line">        from BaseHTTPServer import BaseHTTPRequestHandler as _BHRH</span><br><span class="line">        responses = dict([(k, v[0]) for k, v in _BHRH.responses.items()])</span><br></pre></td></tr></table></figure><p><code>lxml</code>包也有使用可选导入方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    from urlparse import urljoin</span><br><span class="line">    from urllib2 import urlopen</span><br><span class="line">except ImportError:</span><br><span class="line">    # Python 3</span><br><span class="line">    from urllib.parse import urljoin</span><br><span class="line">    from urllib.request import urlopen</span><br></pre></td></tr></table></figure><p>正如以上示例所示，<strong>可选导入的使用很常见，是一个值得掌握的技巧</strong>。</p><h2 id="局部导入"><a href="#局部导入" class="headerlink" title="局部导入"></a>局部导入</h2><p>当你在局部作用域中导入模块时，你执行的就是局部导入。如果你在Python脚本文件的顶部导入一个模块，那么你就是在将该模块导入至全局作用域，这意味着之后的任何函数或方法都可能访问该模块。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import sys  # global scope</span><br><span class="line"></span><br><span class="line">def square_root(a):</span><br><span class="line">    # This import is into the square_root functions local scope</span><br><span class="line">    import math</span><br><span class="line">    return math.sqrt(a)</span><br><span class="line"></span><br><span class="line">def my_pow(base_num, power):</span><br><span class="line">    return math.pow(base_num, power)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print(square_root(49))</span><br><span class="line">    print(my_pow(2, 3))</span><br></pre></td></tr></table></figure><p>这里，我们将<code>sys</code>模块导入至全局作用域，但我们并没有使用这个模块。然后，在<code>square_root</code>函数中，我们将<code>math</code>模块导入至该函数的局部作用域，这意味着<code>math</code>模块只能在<code>square_root</code>函数内部使用。如果我们试图在<code>my_pow</code>函数中使用<code>math</code>，会引发<code>NameError</code>。试着执行这个脚本，看看会发生什么。</p><p>使用局部作用域的好处之一，是你使用的模块可能需要很长时间才能导入，如果是这样的话，将其放在某个不经常调用的函数中或许更加合理，而不是直接在全局作用域中导入。老实说，我几乎从没有使用过局部导入，主要是因为如果模块内部到处都有导入语句，会很难分辨出这样做的原因和用途。<strong>根据约定，所有的导入语句都应该位于模块的顶部</strong>。</p><h2 id="导入注意事项"><a href="#导入注意事项" class="headerlink" title="导入注意事项"></a>导入注意事项</h2><p>在导入模块方面，有几个程序员常犯的错误。这里我们介绍两个。</p><ul><li>循环导入（circular imports）</li><li>覆盖导入（Shadowed imports，暂时翻译为覆盖导入）</li></ul><p>先来看看循环导入。</p><h3 id="循环导入"><a href="#循环导入" class="headerlink" title="循环导入"></a>循环导入</h3><p>如果你创建两个模块，二者相互导入对方，那么就会出现循环导入。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># a.py</span><br><span class="line">import b</span><br><span class="line"></span><br><span class="line">def a_test():</span><br><span class="line">    print(&quot;in a_test&quot;)</span><br><span class="line">    b.b_test()</span><br><span class="line"></span><br><span class="line">a_test()</span><br></pre></td></tr></table></figure><p>然后在同个文件夹中创建另一个模块，将其命名为<code>b.py</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import a</span><br><span class="line"></span><br><span class="line">def b_test():</span><br><span class="line">    print(&apos;In test_b&quot;&apos;)</span><br><span class="line">    a.a_test()</span><br><span class="line"></span><br><span class="line">b_test()</span><br></pre></td></tr></table></figure><p>如果你运行任意一个模块，都会引发<code>AttributeError</code>。这是因为这两个模块都在试图导入对方。简单来说，模块<code>a</code>想要导入模块<code>b</code>，但是因为模块<code>b</code>也在试图导入模块<code>a</code>（这时正在执行），模块<code>a</code>将无法完成模块<code>b</code>的导入。我看过一些解决这个问题的破解方法（hack），但是<strong>一般来说，你应该做的是重构代码，避免发生这种情况</strong>。</p><h3 id="覆盖导入"><a href="#覆盖导入" class="headerlink" title="覆盖导入"></a>覆盖导入</h3><p>当你创建的模块与标准库中的模块同名时，如果你导入这个模块，就会出现覆盖导入。举个例子，创建一个名叫<code>math.py</code>的文件，在其中写入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line">def square_root(number):</span><br><span class="line">    return math.sqrt(number)</span><br><span class="line"></span><br><span class="line">square_root(72)</span><br></pre></td></tr></table></figure><p>现在打开终端，试着运行这个文件，你会得到以下回溯信息（traceback）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;math.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    import math</span><br><span class="line">  File &quot;/Users/michael/Desktop/math.py&quot;, line 6, in &lt;module&gt;</span><br><span class="line">    square_root(72)</span><br><span class="line">  File &quot;/Users/michael/Desktop/math.py&quot;, line 4, in square_root</span><br><span class="line">    return math.sqrt(number)</span><br><span class="line">AttributeError: module &apos;math&apos; has no attribute &apos;sqrt&apos;</span><br></pre></td></tr></table></figure><p>这到底是怎么回事？其实，你运行这个文件的时候，Python解释器首先在当前运行脚本所处的的文件夹中查找名叫<code>math</code>的模块。在这个例子中，解释器找到了我们正在执行的模块，试图导入它。但是我们的模块中并没有叫<code>sqrt</code>的函数或属性，所以就抛出了<code>AttributeError</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们讲了很多有关导入的内容，但是还有部分内容没有涉及。<a href="https://www.python.org/dev/peps/pep-0302/" target="_blank" rel="noopener">PEP 302</a>中介绍了导入钩子（import hooks），支持实现一些非常酷的功能，比如说直接从github导入。Python标准库中还有一个<a href="https://docs.python.org/3/library/importlib.html" target="_blank" rel="noopener">importlib</a>模块，值得查看学习。当然，你还可以多看看别人写的代码，不断挖掘更多好用的妙招。</p>]]></content>
    
    <summary type="html">
    
      python import模块相关问题
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>运维事故记录</title>
    <link href="http://yoursite.com/2018/08/13/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95/%E8%BF%90%E7%BB%B4%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/08/13/IT科学技术知识体系结构-Linux运维方向/运维事故记录/运维事故记录/</id>
    <published>2018-08-13T08:42:08.000Z</published>
    <updated>2018-08-13T08:42:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CDH-服务器负载飙升"><a href="#CDH-服务器负载飙升" class="headerlink" title="CDH 服务器负载飙升"></a>CDH 服务器负载飙升</h1><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>es057服务器在9:52开始，系统负载飙升到14.74，CPU的空闲率（idle）降至0.28%</p><h2 id="问题排查及处理解决"><a href="#问题排查及处理解决" class="headerlink" title="问题排查及处理解决"></a>问题排查及处理解决</h2><ol><li><p>内存使用率正常，无任何异常</p></li><li><p>网络流量正常，无任何异常</p></li><li><p>网络连接数正常，无任何异常</p></li><li><p>CPU使用率 从09:52:18开始飙升，直到10：03：18开始恢复</p><ul><li>CPU每秒的中断数从2000飙升到3W4，升高了12.68倍</li></ul></li></ol><ol><li><p>磁盘</p><ul><li>operations read per seconde on / 从0提高到了8</li></ul></li></ol><h2 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h2><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="问题现象-1"><a href="#问题现象-1" class="headerlink" title="问题现象"></a>问题现象</h2><h2 id="问题排查及处理解决-1"><a href="#问题排查及处理解决-1" class="headerlink" title="问题排查及处理解决"></a>问题排查及处理解决</h2><h2 id="问题反思-1"><a href="#问题反思-1" class="headerlink" title="问题反思"></a>问题反思</h2>]]></content>
    
    <summary type="html">
    
      运维事故记录-错题集
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="运维事故记录" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="运维事故记录" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>MAC操作技巧</title>
    <link href="http://yoursite.com/2018/08/11/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/MAC%E4%BD%BF%E7%94%A8/MAC%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2018/08/11/常用软件工具/MAC使用/MAC操作技巧/</id>
    <published>2018-08-11T10:21:58.000Z</published>
    <updated>2018-08-11T10:21:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美式键盘对应关系"><a href="#美式键盘对应关系" class="headerlink" title="美式键盘对应关系"></a>美式键盘对应关系</h1><p>参考链接：<a href="https://support.apple.com/zh-cn/HT202676" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT202676</a></p><p>在Mac的快捷键中经常会有一些符号，比如⌘、⌥、⇧、⌃等，而Mac下只有command键上有一个⌘的符号，而其他按键均没有符号，很多人可能不知道这是什么意思，之所以只有command键上有一个符号，而其他按键上没有，是因为：</p><ul><li>只有command健才是Mac下唯一独有的一个特殊按键，而shift、alt（option）、control、caps lock、tab等在其他系统下都有，所以Mac在command键上做一个符号，用于表示这一按键的特殊性；</li></ul><p>我们在生活中能接触到的外接键盘基本上都是美式键盘，下面是两种键盘的布局对应关系，在使用外接键盘的时候，需要有充分的了解。</p><p><strong>文字描述：</strong></p><p>⌘ —— Command (Windows键)</p><p>⌃ —— Control(Ctrl键)</p><p>⌥ —— Option (Alt)</p><p>⇧ —— Shift</p><p>⇪ —— Caps Lock</p><p>FN —— FN(Insert)</p><p>括号里面是Windows对应的按键。以前Ctrl+C,Ctrl+V 现在要用Win+C,Win+V。</p><p><strong>图形展示：</strong></p><p><strong>Windows 标志：</strong>按下 Command (⌘) 键<br><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-windows-logo.png" alt=" "></p><p><strong>退格或删除：</strong>按下 Delete 键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-backspace-delete.png" alt=" "></p><p><strong>回车或 ⏎：</strong>按下 Return 键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-enter.png" alt=" "></p><p><strong>Alt（左）：</strong>按下 Option 键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-alt-left.png" alt=" "></p><p><strong>Alt GR（右）：</strong>按下 Option + Control 组合键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-alt-right.png" alt=" "></p><p><strong>应用程序：</strong>Apple 键盘上没有这个按键</p><p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/keyboards/pc-mac-key-mapping-applications.png" alt=" "></p><h1 id="MAC常用快捷键"><a href="#MAC常用快捷键" class="headerlink" title="MAC常用快捷键"></a>MAC常用快捷键</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>先来一张图</p><p><img src="http://picture.watchmen.xin/MAC/mac_key.png" alt=""></p><h2 id="全局操作"><a href="#全局操作" class="headerlink" title="全局操作"></a>全局操作</h2><ul><li>⌃⌘ + f: 进入全屏模式</li></ul><h2 id="强制退出应用"><a href="#强制退出应用" class="headerlink" title="强制退出应用"></a>强制退出应用</h2><p>如果 Mac 上的某个应用停止响应，并且您无法正常退出该应用，则可以使用“强制退出”来关闭该应用。</p><p>同时按住三个按键：Option、Command 和 Esc (Escape) 键。这类似于在 PC 上按下 Control-Alt-Delete。或者，在屏幕左上角的苹果 () 菜单中选取“强制退出”。</p><h2 id="强制刷新页面"><a href="#强制刷新页面" class="headerlink" title="强制刷新页面"></a>强制刷新页面</h2><ul><li><p>正常刷新：command+r</p></li><li><p>强制刷新页面（刷新页面缓存）：command+shift+r</p></li></ul><h2 id="切换全屏页面"><a href="#切换全屏页面" class="headerlink" title="切换全屏页面"></a>切换全屏页面</h2><p>ctrl+方向键的左右</p><h2 id="控制中心"><a href="#控制中心" class="headerlink" title="控制中心"></a>控制中心</h2><p>ctrl+上箭头</p><h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><p>MAC上管理软件包我们一般使用Homebrew来实现</p><p>Homebrew是MAC必备神器之一，作为Mac OSX上的软件包管理工具，它能在Mac中方便的安装软件或者卸载软件， 简单到只需要一个命令。</p><p><strong>安装：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p><strong>命令参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">brew install安装软件</span><br><span class="line">brew list列出已安装的软件</span><br><span class="line">brew update更新brew</span><br><span class="line">brew home用浏览器打开brew的官方网站</span><br><span class="line">brew info显示软件信息</span><br><span class="line">brew deps显示包依赖</span><br></pre></td></tr></table></figure><h1 id="MAC下实现AutoHotKey功能"><a href="#MAC下实现AutoHotKey功能" class="headerlink" title="MAC下实现AutoHotKey功能"></a>MAC下实现AutoHotKey功能</h1><p>在MAC下没有类似autohotkey的软件，但是它给我们提供了相应的工具，我们可以自定义的去实现功能</p><p><strong>步骤1：</strong>从其他中进入automator（中文版的名称为：“自动操作”）</p><p>就是下面这位仁兄：</p><p><img src="http://picture.watchmen.xin/MAC/automator.png" alt=""></p><p><strong>步骤2：</strong>创建服务</p><p><img src="http://picture.watchmen.xin/MAC/automator_new_services.png" alt=""></p><p><strong>步骤3：</strong> 创建applescript，如下图所示，用鼠标将applescript选中并拖到右栏中</p><p>注意，需要先将服务收到一栏中从文本修改为没有输入</p><p><img src="http://picture.watchmen.xin/MAC/automator_new_applescript.png" alt=""></p><p><strong>步骤4：</strong>编辑applescript</p><p>有关applescript的相关内容，网友可以自行查找，网上有非常多的资料。</p><p>简单说明下：</p><ul><li>tell语句，在这里调用谷歌浏览器程序（程序的实际名称可以打开终端，进入/Applications目录下ls查看）</li><li>activate语句，这这里将调用出来的窗口显示在最前端</li><li>open location 语句，实际的操作，后面的参数是具体的链接地址</li><li>end tell语句，结束调用<br><img src="http://picture.watchmen.xin/MAC/applescript.png" alt=""></li></ul><p><strong>步骤5：</strong>运行测试</p><p><img src="http://picture.watchmen.xin/MAC/runapplescript.png" alt=""></p><p>点击两个运行中任一一个，可以看到网页会在最前端弹出，代码执行成功之后，缩进和颜色都会发生相应的变化。</p><p><strong>步骤6：</strong> 保存为服务</p><p>输入command+s，在弹出的对话框中，输入自定义的名称</p><p><img src="http://picture.watchmen.xin/MAC/saveapplescript.png" alt=""></p><p><strong>步骤7：</strong>设置快捷键</p><p>打开系统偏好设置–&gt;键盘—&gt;快捷键–&gt;服务–&gt;通用—&gt;选中刚才保存的服务–&gt;双击—&gt;在编辑器中，敲下自定义的快捷键，系统将会自动识别显示，如下图所示：</p><p><img src="http://picture.watchmen.xin/MAC/config_applescript.png" alt=""></p><p>这个时候，设置就全部完毕，接下来我们就可以随时根据快捷键调用浏览器打开网页。</p><h1 id="Iterm2操作"><a href="#Iterm2操作" class="headerlink" title="Iterm2操作"></a>Iterm2操作</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><strong>标签</strong></p><ul><li>新建标签：command + t</li><li>关闭标签：command + w</li><li>切换标签：command + 数字 command + 左右方向键</li><li>切换全屏：command + enter</li><li>查找：command + f</li></ul><p><strong>分屏</strong></p><ul><li>垂直分屏：command + d</li><li>水平分屏：command + shift + d</li><li>切换屏幕：command + option + 方向键 或者 command + [ ]</li></ul><p><strong>命令</strong></p><ul><li>查看历史命令：command + ;</li><li>查看剪贴板历史：command + shift + h</li><li>上一条命令：ctrl + p</li><li>搜索命令历史：ctrl + r</li></ul><p><strong>行内</strong></p><ul><li>清除当前行：ctrl + u</li><li>到行首：ctrl + a</li><li>到行尾：ctrl + e</li><li>前进后退：ctrl + f/b (相当于左右方向键)</li><li>删除当前光标的字符：ctrl + d</li><li>删除光标之前的字符：ctrl + h</li><li>删除光标之前的单词：ctrl + w</li><li>删除到文本末尾：ctrl + k</li><li>交换光标处文本：ctrl + t</li></ul><p><strong>其他</strong></p><ul><li>清屏1：command + r</li><li>清屏2：ctrl + l</li><li>清屏3：clear</li><li>进入和退出全屏: Command + Enter</li><li>查看当前终端中光标的位置: Command + /</li><li>开启和关闭背景半透明: Command + u</li><li>清屏（重置当前终端）: Command + r</li></ul><h2 id="连接jumpserver"><a href="#连接jumpserver" class="headerlink" title="连接jumpserver"></a>连接jumpserver</h2><ol><li><p>Profile -&gt; Open Profiles… -&gt; Edit Profiles…</p></li><li><p>点击左下角+号</p></li><li><p>输入Profile Name，比如jumper</p></li><li><p>右边Command下选择Command，然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i /Users/yourname/.ssh/id_rsa  username@ip -p port</span><br></pre></td></tr></table></figure></li><li><p>关闭所有窗口</p></li><li><p>在Iterm2的一个窗口中选择右键New Tab或者command+o,在弹出的页面中选择刚创建的jumper，然后回车就登录上了。</p></li></ol><p>注意，如果给RSA秘钥设置了密码，又不想每次在登录的时候都输出密码，这个时候我们可以在命令行中输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -K /Users/yourname/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>输入一次之后，后续就不用再次输入。</p><h2 id="实现rz-sz功能"><a href="#实现rz-sz功能" class="headerlink" title="实现rz/sz功能"></a>实现rz/sz功能</h2><p>Mac上iTerm原生不支持rz/sz命令，也就是不支持Zmodem来进行文件传输，不过只要通过简单的配置就可以实现。网上的教程一大把，这里就简单的记录一下过程。</p><h3 id="安装lrzsz"><a href="#安装lrzsz" class="headerlink" title="安装lrzsz"></a>安装lrzsz</h3><p>首先安装Homebrew(这里不写这个过程)，然后通过它先给Mac安装lrzsz。在终端下输入brew install lrzsz，静等一会即可安装完毕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure><h3 id="下载iTerm2辅助文件"><a href="#下载iTerm2辅助文件" class="headerlink" title="下载iTerm2辅助文件"></a>下载iTerm2辅助文件</h3><p>iTerm不能直接使用lrzsz，不过网上有大神提供了两个辅助脚本。我们只需要把文件下载到 /usr/local/bin/目录下并赋予可执行权限即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">wget https://raw.githubusercontent.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh</span><br><span class="line">wget https://raw.githubusercontent.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh</span><br><span class="line"></span><br><span class="line">chmod +x iterm2-recv-zmodem.sh iterm2-send-zmodem.sh</span><br></pre></td></tr></table></figure><p>这两个脚本实际是使用AppleScript来弹出文件选择窗口，然后把选中的文件名称传递给rzsz命令。我们打开其中一个看下代码。如果这一部分看不懂没关系，直接跳过即可，对后续的配置使用没有任何不良影响 </p><h3 id="配置iTerm2触发器"><a href="#配置iTerm2触发器" class="headerlink" title="配置iTerm2触发器"></a>配置iTerm2触发器</h3><p>这一步最关键，是在iTerm里面配置触发器，当监控到特定字符串的时候执行刚才下载的两个文件。为了使用方便，我专门建立了一个Profile配置，名字是Remote，并且配合后面的autossh使用。</p><p>打开iTerm2 -&gt; Preferences -&gt; Profiles 选择 Advanced 设置 Triggers ，点击 Edit</p><p><img src="http://picture.watchmen.xin/MAC/config_lrzsz.png" alt=""></p><p>在弹出窗口中进行如下配置，最后的<strong>Instant</strong>一定要勾选上。</p><p><img src="http://picture.watchmen.xin/MAC/config_lrzsz_triggers.png" alt=""></p><p>配置的具体内容在这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Regular expression: rz waiting to receive.\*\*B0100</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line"></span><br><span class="line">Regular expression: \*\*B00000000000000</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/local/bin/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure><p>重新启动iTerm之后，rz/sz就应该可以正常使用了。</p><h1 id="Forklift操作"><a href="#Forklift操作" class="headerlink" title="Forklift操作"></a>Forklift操作</h1><p>在文件夹中搜索文件：command+s</p><p>常用文件夹-Favorites：alt+command+f</p><p>ftp等传输工具：command+k</p><p>前进/后退：command+[/]</p><h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><h2 id="pycharm-光标变粗问题"><a href="#pycharm-光标变粗问题" class="headerlink" title="pycharm-光标变粗问题"></a>pycharm-光标变粗问题</h2><p>mac下默认的pycharm的光标是为粗体的改写模式，这是因为安装的时候装了ideaVim插件，改为竖线光标的方法：把ideaVim插件去掉（点击pycharm–&gt;preference–&gt;plugins–&gt;搜索ideavim，然后将该插件勾除掉即可） </p><h2 id="MAC版本snipaste截图后无法输入中文问题"><a href="#MAC版本snipaste截图后无法输入中文问题" class="headerlink" title="MAC版本snipaste截图后无法输入中文问题"></a>MAC版本snipaste截图后无法输入中文问题</h2><p>参考资料：<a href="https://jingyan.baidu.com/article/c1a3101e635d6ade646deb56.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/c1a3101e635d6ade646deb56.html</a></p><ol><li>点击菜单栏截图软件的图标，选择退出软件。</li></ol><ol><li><p>接着按键盘上面的control+space ，选择拼音输入法。</p></li><li><p>这个时候就可以启动截图软件了，按键盘上的cmmand+space，在黑色框输入软件的名字回车。</p></li></ol><ol><li>点击软件图标，选择截图或者是按fn+f1，进行桌面的截图。</li></ol><ol><li>在截图上面，按空格键调出截图软件工具条，然后点击工具条上面的T，这个时候就可以在图片上面进行中文的标注了。总结就是用不了重启软件即可。</li></ol>]]></content>
    
    <summary type="html">
    
      MAC操作技巧
    
    </summary>
    
      <category term="常用软件工具" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="MAC操作技巧" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/MAC%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="MAC" scheme="http://yoursite.com/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>day05-常用模块学习</title>
    <link href="http://yoursite.com/2018/08/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day05-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/08/08/编程语言/Python/老男孩视频学习笔记/day05-常用模块学习/</id>
    <published>2018-08-08T12:29:08.000Z</published>
    <updated>2018-08-08T12:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ol><li><p>定义</p><blockquote><p>模块：本质就是.py结尾的python文件</p><p>用来从逻辑上组织python代码（变量、函数、类、逻辑），目的是实现功能</p><p>包：用来从逻辑上组织模块，本质就是一个目录，必须带有一个<strong>init</strong>.py文件</p><p>导入包的本质其实就是执行该包下的<strong>init</strong>.py文件。</p></blockquote></li><li><p>导入/使用方法</p><blockquote><p>From import和import的区别？</p><p>因为存在定义同名方法等的问题，因此不建议使用import*</p></blockquote></li><li><p>import本质（路径搜索和搜索路径）</p><blockquote><p>导入模块的本质就是把python文件再解释一遍</p></blockquote></li><li><p>导入优化</p></li><li><p>模块的分类</p><blockquote><ul><li>标准库</li><li>开源模块</li><li>自定义模块</li></ul></blockquote></li></ol><h1 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h1><h2 id="time与datetime"><a href="#time与datetime" class="headerlink" title="time与datetime"></a>time与datetime</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"># print(time.clock()) #返回处理器时间,3.3开始已废弃 , 改成了time.process_time()测量处理器运算时间,不包括sleep时间,不稳定,mac上测不出来</span><br><span class="line"># print(time.altzone)  #返回与utc时间的时间差,以秒计算\</span><br><span class="line"># print(time.asctime()) #返回时间格式&quot;Fri Aug 19 11:14:16 2016&quot;,</span><br><span class="line"># print(time.localtime()) #返回本地时间 的struct time对象格式</span><br><span class="line"># print(time.gmtime(time.time()-800000)) #返回utc时间的struc时间对象格式</span><br><span class="line"></span><br><span class="line"># print(time.asctime(time.localtime())) #返回时间格式&quot;Fri Aug 19 11:14:16 2016&quot;,</span><br><span class="line">#print(time.ctime()) #返回Fri Aug 19 12:38:29 2016 格式, 同上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 日期字符串 转成  时间戳</span><br><span class="line"># string_2_struct = time.strptime(&quot;2016/05/22&quot;,&quot;%Y/%m/%d&quot;) #将 日期字符串 转成 struct时间对象格式</span><br><span class="line"># print(string_2_struct)</span><br><span class="line"># #</span><br><span class="line"># struct_2_stamp = time.mktime(string_2_struct) #将struct时间对象转成时间戳</span><br><span class="line"># print(struct_2_stamp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#将时间戳转为字符串格式</span><br><span class="line"># print(time.gmtime(time.time()-86640)) #将utc时间戳转换成struct_time格式</span><br><span class="line"># print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.gmtime()) ) #将utc struct_time格式转成指定的字符串格式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#时间加减</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># print(datetime.datetime.now()) #返回 2016-08-19 12:47:03.941925</span><br><span class="line">#print(datetime.date.fromtimestamp(time.time()) )  # 时间戳直接转成日期格式 2016-08-19</span><br><span class="line"># print(datetime.datetime.now() )</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(3)) #当前时间+3天</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(-3)) #当前时间-3天</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(hours=3)) #当前时间+3小时</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(minutes=30)) #当前时间+30分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># c_time  = datetime.datetime.now()</span><br><span class="line"># print(c_time.replace(minute=3,hour=2)) #时间替换</span><br></pre></td></tr></table></figure><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">随机数</span><br><span class="line"></span><br><span class="line">mport random</span><br><span class="line">print random.random()  随机浮点数，生产0-1之间的随机数，可以查看帮助文档 </span><br><span class="line">print random.randint(1,2) 生成指定范围内的整数 -</span><br><span class="line">print random.randrange(1,10，2) 在指定范围内取值，并且是递增关系，同时不会取最后一个数，间隔是2</span><br><span class="line">print random.choice(&apos;wxh&apos;) 随机取出一个字符</span><br><span class="line"></span><br><span class="line">shufflp用于将一个列表中的元素打乱，执行之后，原有的列表内容将会被改变</span><br><span class="line">p = [&apos;this&apos;,&apos;is&apos;,&apos;for&apos;,&apos;test&apos;]</span><br><span class="line">random.shuffle(p)</span><br><span class="line">print (p)     </span><br><span class="line">执行之后的输出为：[&apos;this&apos;, &apos;for&apos;, &apos;test&apos;, &apos;is&apos;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">random.sample 从指定序列中随机获取指定长度的片断</span><br><span class="line">p = [&apos;this&apos;,&apos;is&apos;,&apos;for&apos;,&apos;test&apos;]</span><br><span class="line">res = random.sample(p,3)</span><br><span class="line">print (res)</span><br><span class="line">print (p)</span><br><span class="line">执行之后的输出为：</span><br><span class="line">[&apos;is&apos;, &apos;for&apos;, &apos;this&apos;]</span><br><span class="line">[&apos;this&apos;, &apos;is&apos;, &apos;for&apos;, &apos;test&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">生成随机验证码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import random</span><br><span class="line">checkcode = &apos;&apos;</span><br><span class="line">for i in range(4):</span><br><span class="line">    current = random.randrange(0,4)</span><br><span class="line">    if current != i:</span><br><span class="line">        temp = chr(random.randint(65,90))</span><br><span class="line">    else:</span><br><span class="line">        temp = random.randint(0,9)</span><br><span class="line">    checkcode += str(temp)</span><br><span class="line">print checkcode</span><br></pre></td></tr></table></figure><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>参考链接：<a href="https://docs.python.org/3/library/string.html?highlight=string#module-string" target="_blank" rel="noopener">https://docs.python.org/3/library/string.html?highlight=string#module-string</a></p><p>string.ascii_lowercase        生成小写字母串</p><p>The lowercase letters <code>&#39;abcdefghijklmnopqrstuvwxyz&#39;</code>. This value is not locale-dependent and will not change.</p><p>string.ascii_uppercase        生成大写字母串<br>The uppercase letters <code>&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code>. This value is not locale-dependent and will not change.</p><p>string.digits        生成数字串</p><p>The string <code>&#39;0123456789&#39;</code>.</p><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><p>This module provides a portable way of using operating system dependent functionality</p><p>os模块主要用于和操作系统之间的交互，这个模块提供了一种方便的使用操作系统函数的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</span><br><span class="line">os.chdir(&quot;dirname&quot;)  改变当前脚本工作目录；相当于shell下cd</span><br><span class="line">os.curdir  返回当前目录: (&apos;.&apos;)</span><br><span class="line">os.pardir  获取当前目录的父目录字符串名：(&apos;..&apos;)</span><br><span class="line">os.makedirs(&apos;dirname1/dirname2&apos;)    可生成多层递归目录</span><br><span class="line">os.removedirs(&apos;dirname1&apos;)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</span><br><span class="line">os.mkdir(&apos;dirname&apos;)    生成单级目录；相当于shell中mkdir dirname</span><br><span class="line">os.rmdir(&apos;dirname&apos;)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</span><br><span class="line">os.listdir(&apos;dirname&apos;)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印，相当于ls -la</span><br><span class="line">os.remove()  删除一个文件</span><br><span class="line">os.rename(&quot;oldname&quot;,&quot;newname&quot;)  重命名文件/目录</span><br><span class="line">os.stat(&apos;path/filename&apos;)  获取文件/目录信息,相当于shell中的stat命令，会显示各种事件信息</span><br><span class="line">os.sep    输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;</span><br><span class="line">os.linesep    输出当前平台使用的行终止符，win下为&quot;\t\n&quot;,Linux下为&quot;\n&quot;</span><br><span class="line">os.pathsep    输出用于分割文件路径的字符串</span><br><span class="line">os.name    输出字符串指示当前使用平台。win-&gt;&apos;nt&apos;; Linux-&gt;&apos;posix&apos;</span><br><span class="line">os.system(&quot;bash command&quot;)  运行shell命令，直接显示</span><br><span class="line">os.environ  获取系统环境变量</span><br><span class="line">os.path.abspath(path)  返回path规范化的绝对路径</span><br><span class="line">os.path.split(path)  将path分割成目录和文件名二元组返回</span><br><span class="line">os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素</span><br><span class="line">os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span><br><span class="line">os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False</span><br><span class="line">os.path.isabs(path)  如果path是绝对路径，返回True</span><br><span class="line">os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False</span><br><span class="line">os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False</span><br><span class="line">os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span><br><span class="line">os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间</span><br><span class="line">os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</span><br></pre></td></tr></table></figure><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><p>This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.</p><p>sys模块主要用于和python解释器之间的交互，这个模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sys.argv           命令行参数List，第一个元素是程序本身路径</span><br><span class="line">sys.exit(n)        退出程序，正常退出时exit(0)</span><br><span class="line">sys.version        获取Python解释程序的版本信息</span><br><span class="line">sys.maxint         最大的Int值</span><br><span class="line">sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值,获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。</span><br><span class="line"></span><br><span class="line">sys.platform       返回操作系统平台名称</span><br><span class="line">sys.stdout.write(&apos;please:&apos;)</span><br><span class="line">val = sys.stdin.readline()[:-1]</span><br></pre></td></tr></table></figure><h2 id="shutil-模块"><a href="#shutil-模块" class="headerlink" title="shutil 模块"></a>shutil 模块</h2><p>高级的 文件、文件夹、压缩包 处理模块</p><p><strong>shutil.copyfileobj(fsrc, fdst[, length])</strong><br>将文件内容拷贝到另一个文件中，可以部分内容</p><p><strong>shutil.copyfile(src, dst)</strong><br>拷贝文件</p><p><strong>shutil.copymode(src, dst)</strong><br>仅拷贝权限。内容、组、用户均不变</p><p><strong>shutil.copystat(src, dst)</strong><br>拷贝状态的信息，包括：mode bits, atime, mtime, flags</p><p><strong>shutil.copy(src, dst)</strong><br>拷贝文件和权限</p><p><strong>shutil.copy2(src, dst)</strong><br>拷贝文件和状态信息</p><p><strong>shutil.ignore_patterns(*patterns)</strong><br><strong>shutil.copytree(src, dst, symlinks=False, ignore=None)</strong><br>递归的去拷贝文件</p><p>例如：copytree(source, destination, ignore=ignore_patterns(‘<em>.pyc’, ‘tmp</em>‘))</p><p><strong>shutil.rmtree(path[, ignore_errors[, onerror]])</strong><br>递归的去删除文件</p><p><strong>shutil.move(src, dst)</strong><br>递归的去移动文件</p><p><strong>shutil.make_archive(base_name, format,…)</strong></p><p>创建压缩包并返回文件路径，例如：zip、tar</p><ul><li>base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，<br>如：www                        =&gt;保存至当前路径<br>如：/Users/wupeiqi/www =&gt;保存至/Users/wupeiqi/<br>   format：    压缩包种类，“zip”, “tar”, “bztar”，“gztar”<br>   root_dir：    要压缩的文件夹路径（默认当前目录）<br>   owner：    用户，默认当前用户<br>   group：    组，默认当前组<br>   logger：    用于记录日志，通常是logging.Logger对象</li></ul><p>shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的，详细：</p><h2 id="json-amp-pickle-模块"><a href="#json-amp-pickle-模块" class="headerlink" title="json &amp; pickle 模块"></a>json &amp; pickle 模块</h2><p>用于序列化的两个模块</p><ul><li>json，用于字符串 和 python数据类型间进行转换</li><li>pickle，用于python特有的类型 和 python的数据类型间进行转换</li></ul><p>Json模块提供了四个功能：dumps、dump、loads、load</p><p>pickle模块提供了四个功能：dumps、dump、loads、load</p><p><img src="https://images2015.cnblogs.com/blog/425762/201511/425762-20151114231017087-842020084.png" alt="img"></p><p>json的作用是把数据进行序列化，一个在内存中的数据对象，比如说是字典、列表等，不能直接写到文件里面，因此要把数据写入到文件里面，那么这个文件只能存byte类型或者是字符串，那就就需要把这些数据转换成为字符串。</p><p>将这些数据转换成为字符串之后，以后想要再加载这些数据的时候，因此需要确保文件中的内容的数据类型没有被破坏</p><p>json：帮助你把python中的内存数据转成字符串；想在其他的程序内再调用这些数据的时候，load一下就可以使用了。</p><p>这解决了：不同的语言，不同的平台之间的数据交换，使python可以和php、java等语言的数据进行交换</p><p>json这一部分还需要再深入下</p><h2 id="shelve-模块"><a href="#shelve-模块" class="headerlink" title="shelve 模块"></a>shelve 模块</h2><p>shelve模块是一个简单的k,v将内存数据通过文件持久化的模块，可以持久化任何pickle可支持的python数据格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import shelve</span><br><span class="line"></span><br><span class="line">#写</span><br><span class="line"></span><br><span class="line">s = shelve.open(&apos;shelve.txt&apos;)</span><br><span class="line"></span><br><span class="line">class Test():</span><br><span class="line">    def __init__(self,n):</span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">t = Test(1233)</span><br><span class="line"></span><br><span class="line">t2 = Test(1111)</span><br><span class="line"></span><br><span class="line">name = [&apos;111&apos;,&apos;sdaf&apos;,&apos;sd&apos;]</span><br><span class="line"></span><br><span class="line">s[&quot;test&quot;] = name</span><br><span class="line"></span><br><span class="line">s[&quot;t1&quot;] = t</span><br><span class="line"></span><br><span class="line">s[&quot;t2&quot;] = t2</span><br><span class="line"></span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line"># 读</span><br><span class="line">d = shelve.open(&apos;shelve.txt&apos;)</span><br><span class="line"></span><br><span class="line">print (d.get(&quot;test&quot;))</span><br><span class="line"></span><br><span class="line">d.close()</span><br></pre></td></tr></table></figure><h2 id="xml处理模块"><a href="#xml处理模块" class="headerlink" title="xml处理模块"></a><strong>xml处理模块</strong></h2><p>xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，古时候，在json还没诞生的黑暗年代，大家只能选择用xml呀，至今很多传统公司如金融行业的很多系统的接口还主要是xml。</p><p>xml的格式如下，就是通过&lt;&gt;节点来区别数据结构的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;country name=&quot;Liechtenstein&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;2&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2008&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;141100&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Austria&quot; direction=&quot;E&quot;/&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Switzerland&quot; direction=&quot;W&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">    &lt;country name=&quot;Singapore&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;5&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2011&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;59900&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Malaysia&quot; direction=&quot;N&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">    &lt;country name=&quot;Panama&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;69&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2011&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;13600&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Costa Rica&quot; direction=&quot;W&quot;/&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Colombia&quot; direction=&quot;E&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure><p>xml协议在各个语言里的都 是支持的，在python中可以用以下模块操作xml 　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)</span><br><span class="line">root = tree.getroot()</span><br><span class="line">print(root.tag)</span><br><span class="line"> </span><br><span class="line">#遍历xml文档</span><br><span class="line">for child in root:</span><br><span class="line">    print(child.tag, child.attrib)</span><br><span class="line">    for i in child:</span><br><span class="line">        print(i.tag,i.text)</span><br><span class="line"> </span><br><span class="line">#只遍历year 节点</span><br><span class="line">for node in root.iter(&apos;year&apos;):</span><br><span class="line">    print(node.tag,node.text)</span><br></pre></td></tr></table></figure><p>修改和删除xml文档内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)</span><br><span class="line">root = tree.getroot()</span><br><span class="line"> </span><br><span class="line">#修改</span><br><span class="line">for node in root.iter(&apos;year&apos;):</span><br><span class="line">    new_year = int(node.text) + 1</span><br><span class="line">    node.text = str(new_year)</span><br><span class="line">    node.set(&quot;updated&quot;,&quot;yes&quot;)</span><br><span class="line"> </span><br><span class="line">tree.write(&quot;xmltest.xml&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#删除node</span><br><span class="line">for country in root.findall(&apos;country&apos;):</span><br><span class="line">   rank = int(country.find(&apos;rank&apos;).text)</span><br><span class="line">   if rank &gt; 50:</span><br><span class="line">     root.remove(country)</span><br><span class="line"> </span><br><span class="line">tree.write(&apos;output.xml&apos;)</span><br></pre></td></tr></table></figure><p>自己创建xml文档</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">new_xml = ET.Element(&quot;namelist&quot;)</span><br><span class="line">name = ET.SubElement(new_xml,&quot;name&quot;,attrib=&#123;&quot;enrolled&quot;:&quot;yes&quot;&#125;)</span><br><span class="line">age = ET.SubElement(name,&quot;age&quot;,attrib=&#123;&quot;checked&quot;:&quot;no&quot;&#125;)</span><br><span class="line">sex = ET.SubElement(name,&quot;sex&quot;)</span><br><span class="line">sex.text = &apos;33&apos;</span><br><span class="line">name2 = ET.SubElement(new_xml,&quot;name&quot;,attrib=&#123;&quot;enrolled&quot;:&quot;no&quot;&#125;)</span><br><span class="line">age = ET.SubElement(name2,&quot;age&quot;)</span><br><span class="line">age.text = &apos;19&apos;</span><br><span class="line"> </span><br><span class="line">et = ET.ElementTree(new_xml) #生成文档对象</span><br><span class="line">et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;,xml_declaration=True)</span><br><span class="line"> </span><br><span class="line">ET.dump(new_xml) #打印生成的格式</span><br></pre></td></tr></table></figure><h2 id="ConfigParser模块"><a href="#ConfigParser模块" class="headerlink" title="ConfigParser模块"></a><strong>ConfigParser模块</strong></h2><p>用于生成和修改常见配置文档，当前模块的名称在 python 3.x 版本中变更为 小写的configparser。</p><p>来看一个好多软件的常见文档格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">ServerAliveInterval = 45</span><br><span class="line">Compression = yes</span><br><span class="line">CompressionLevel = 9</span><br><span class="line">ForwardX11 = yes</span><br><span class="line"> </span><br><span class="line">[bitbucket.org]</span><br><span class="line">User = hg</span><br><span class="line"> </span><br><span class="line">[topsecret.server.com]</span><br><span class="line">Port = 50022</span><br><span class="line">ForwardX11 = no</span><br></pre></td></tr></table></figure><p>如果想用python生成一个这样的文档怎么做呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import configparser</span><br><span class="line"> </span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config[&quot;DEFAULT&quot;] = &#123;&apos;ServerAliveInterval&apos;: &apos;45&apos;,</span><br><span class="line">                      &apos;Compression&apos;: &apos;yes&apos;,</span><br><span class="line">                     &apos;CompressionLevel&apos;: &apos;9&apos;&#125;</span><br><span class="line"> </span><br><span class="line">config[&apos;bitbucket.org&apos;] = &#123;&#125;</span><br><span class="line">config[&apos;bitbucket.org&apos;][&apos;User&apos;] = &apos;hg&apos;</span><br><span class="line">config[&apos;topsecret.server.com&apos;] = &#123;&#125;</span><br><span class="line">topsecret = config[&apos;topsecret.server.com&apos;]</span><br><span class="line">topsecret[&apos;Host Port&apos;] = &apos;50022&apos;     # mutates the parser</span><br><span class="line">topsecret[&apos;ForwardX11&apos;] = &apos;no&apos;  # same here</span><br><span class="line">config[&apos;DEFAULT&apos;][&apos;ForwardX11&apos;] = &apos;yes&apos;</span><br><span class="line">with open(&apos;example.ini&apos;, &apos;w&apos;) as configfile:</span><br><span class="line">   config.write(configfile)</span><br></pre></td></tr></table></figure><p>写完了还可以再读出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import configparser</span><br><span class="line">&gt;&gt;&gt; config = configparser.ConfigParser()</span><br><span class="line">&gt;&gt;&gt; config.sections()</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; config.read(&apos;example.ini&apos;)</span><br><span class="line">[&apos;example.ini&apos;]</span><br><span class="line">&gt;&gt;&gt; config.sections()</span><br><span class="line">[&apos;bitbucket.org&apos;, &apos;topsecret.server.com&apos;]</span><br><span class="line">&gt;&gt;&gt; &apos;bitbucket.org&apos; in config</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &apos;bytebong.com&apos; in config</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; config[&apos;bitbucket.org&apos;][&apos;User&apos;]</span><br><span class="line">&apos;hg&apos;</span><br><span class="line">&gt;&gt;&gt; config[&apos;DEFAULT&apos;][&apos;Compression&apos;]</span><br><span class="line">&apos;yes&apos;</span><br><span class="line">&gt;&gt;&gt; topsecret = config[&apos;topsecret.server.com&apos;]</span><br><span class="line">&gt;&gt;&gt; topsecret[&apos;ForwardX11&apos;]</span><br><span class="line">&apos;no&apos;</span><br><span class="line">&gt;&gt;&gt; topsecret[&apos;Port&apos;]</span><br><span class="line">&apos;50022&apos;</span><br><span class="line">&gt;&gt;&gt; for key in config[&apos;bitbucket.org&apos;]: print(key)</span><br><span class="line">...</span><br><span class="line">user</span><br><span class="line">compressionlevel</span><br><span class="line">serveraliveinterval</span><br><span class="line">compression</span><br><span class="line">forwardx11</span><br><span class="line">&gt;&gt;&gt; config[&apos;bitbucket.org&apos;][&apos;ForwardX11&apos;]</span><br><span class="line">&apos;yes&apos;</span><br></pre></td></tr></table></figure><p>configparser增删改查语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[section1]</span><br><span class="line">k1 = v1</span><br><span class="line">k2:v2</span><br><span class="line">  </span><br><span class="line">[section2]</span><br><span class="line">k1 = v1</span><br><span class="line"> </span><br><span class="line">import ConfigParser</span><br><span class="line">  </span><br><span class="line">config = ConfigParser.ConfigParser()</span><br><span class="line">config.read(&apos;i.cfg&apos;) </span><br><span class="line">  </span><br><span class="line"># ########## 读 ##########</span><br><span class="line">#secs = config.sections()</span><br><span class="line">#print secs</span><br><span class="line">#options = config.options(&apos;group2&apos;)</span><br><span class="line">#print options</span><br><span class="line">  </span><br><span class="line">#item_list = config.items(&apos;group2&apos;)</span><br><span class="line">#print item_list</span><br><span class="line">  </span><br><span class="line">#val = config.get(&apos;group1&apos;,&apos;key&apos;)</span><br><span class="line">#val = config.getint(&apos;group1&apos;,&apos;key&apos;)</span><br><span class="line">  </span><br><span class="line"># ########## 改写 ##########</span><br><span class="line">#sec = config.remove_section(&apos;group1&apos;)</span><br><span class="line">#config.write(open(&apos;i.cfg&apos;, &quot;w&quot;))</span><br><span class="line">  </span><br><span class="line">#sec = config.has_section(&apos;wupeiqi&apos;)</span><br><span class="line">#sec = config.add_section(&apos;wupeiqi&apos;)</span><br><span class="line">#config.write(open(&apos;i.cfg&apos;, &quot;w&quot;))</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">#config.set(&apos;group2&apos;,&apos;k1&apos;,11111)</span><br><span class="line">#config.write(open(&apos;i.cfg&apos;, &quot;w&quot;))</span><br><span class="line">  </span><br><span class="line">#config.remove_option(&apos;group2&apos;,&apos;age&apos;)</span><br><span class="line">#config.write(open(&apos;i.cfg&apos;, &quot;w&quot;))</span><br></pre></td></tr></table></figure><h2 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块　　"></a><strong>hashlib模块</strong>　　</h2><p>用于加密相关的操作，3.x里代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"> </span><br><span class="line">m = hashlib.md5()</span><br><span class="line">m.update(b&quot;Hello&quot;)</span><br><span class="line">m.update(b&quot;It&apos;s me&quot;)</span><br><span class="line">print(m.digest())</span><br><span class="line">m.update(b&quot;It&apos;s been a long time since last time we ...&quot;)</span><br><span class="line"> </span><br><span class="line">print(m.digest()) #2进制格式hash</span><br><span class="line">print(len(m.hexdigest())) #16进制格式hash</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def digest(self, *args, **kwargs): # real signature unknown</span><br><span class="line">    &quot;&quot;&quot; Return the digest value as a string of binary data. &quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">def hexdigest(self, *args, **kwargs): # real signature unknown</span><br><span class="line">    &quot;&quot;&quot; Return the digest value as a string of hexadecimal digits. &quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">import hashlib</span><br><span class="line"> </span><br><span class="line"># ######## md5 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.md5()</span><br><span class="line">hash.update(&apos;admin&apos;)</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha1 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha1()</span><br><span class="line">hash.update(&apos;admin&apos;)</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha256 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha256()</span><br><span class="line">hash.update(&apos;admin&apos;)</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># ######## sha384 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha384()</span><br><span class="line">hash.update(&apos;admin&apos;)</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha512 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha512()</span><br><span class="line">hash.update(&apos;admin&apos;)</span><br><span class="line">print(hash.hexdigest())</span><br></pre></td></tr></table></figure><p>还不够吊？python 还有一个 hmac 模块，它内部对我们创建 key 和 内容 再进行处理然后再加密</p><p>散列消息鉴别码，简称HMAC，是一种基于消息鉴别码MAC（Message Authentication Code）的鉴别机制。使用HMAC时,消息通讯的双方，通过验证消息中加入的鉴别密钥K来鉴别消息的真伪；</p><p>一般用于网络通信中消息加密，前提是双方先要约定好key,就像接头暗号一样，然后消息发送把用key把消息加密，接收方用key ＋ 消息明文再加密，拿加密后的值 跟 发送者的相对比是否相等，这样就能验证消息的真实性，及发送者的合法性了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import hmac</span><br><span class="line">h = hmac.new(b&apos;天王盖地虎&apos;, b&apos;宝塔镇河妖&apos;)</span><br><span class="line">print h.hexdigest()</span><br></pre></td></tr></table></figure><p>更多关于md5,sha1,sha256等介绍的文章看这里<a href="https://www.tbs-certificates.co.uk/FAQ/en/sha256.html" target="_blank" rel="noopener">https://www.tbs-certificates.co.uk/FAQ/en/sha256.html</a> </p><h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块　　"></a>re模块　　</h2><p>常用正则表达式符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos;     默认匹配除\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行</span><br><span class="line">&apos;^&apos;     匹配字符开头，若指定flags MULTILINE,这种也可以匹配上(r&quot;^a&quot;,&quot;\nabc\neee&quot;,flags=re.MULTILINE)</span><br><span class="line">&apos;$&apos;     匹配字符结尾，或e.search(&quot;foo$&quot;,&quot;bfoo\nsdfsf&quot;,flags=re.MULTILINE).group()也可以</span><br><span class="line">&apos;*&apos;     匹配*号前的字符0次或多次，re.findall(&quot;ab*&quot;,&quot;cabb3abcbbac&quot;)  结果为[&apos;abb&apos;, &apos;ab&apos;, &apos;a&apos;]</span><br><span class="line">&apos;+&apos;     匹配前一个字符1次或多次，re.findall(&quot;ab+&quot;,&quot;ab+cd+abb+bba&quot;) 结果[&apos;ab&apos;, &apos;abb&apos;]</span><br><span class="line">&apos;?&apos;     匹配前一个字符1次或0次</span><br><span class="line">&apos;&#123;m&#125;&apos;   匹配前一个字符m次</span><br><span class="line">&apos;&#123;n,m&#125;&apos; 匹配前一个字符n到m次，re.findall(&quot;ab&#123;1,3&#125;&quot;,&quot;abb abc abbcbbb&quot;) 结果&apos;abb&apos;, &apos;ab&apos;, &apos;abb&apos;]</span><br><span class="line">&apos;|&apos;     匹配|左或|右的字符，re.search(&quot;abc|ABC&quot;,&quot;ABCBabcCD&quot;).group() 结果&apos;ABC&apos;</span><br><span class="line">&apos;(...)&apos; 分组匹配，re.search(&quot;(abc)&#123;2&#125;a(123|456)c&quot;, &quot;abcabca456c&quot;).group() 结果 abcabca456c</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&apos;\A&apos;    只从字符开头匹配，re.search(&quot;\Aabc&quot;,&quot;alexabc&quot;) 是匹配不到的</span><br><span class="line">&apos;\Z&apos;    匹配字符结尾，同$</span><br><span class="line">&apos;\d&apos;    匹配数字0-9</span><br><span class="line">&apos;\D&apos;    匹配非数字</span><br><span class="line">&apos;\w&apos;    匹配[A-Za-z0-9]</span><br><span class="line">&apos;\W&apos;    匹配非[A-Za-z0-9]</span><br><span class="line">&apos;s&apos;     匹配空白字符、\t、\n、\r , re.search(&quot;\s+&quot;,&quot;ab\tc1\n3&quot;).group() 结果 &apos;\t&apos;</span><br><span class="line"> </span><br><span class="line">&apos;(?P&lt;name&gt;...)&apos; 分组匹配 </span><br><span class="line">re.search(&quot;(?P&lt;province&gt;[0-9]&#123;4&#125;)(?P&lt;city&gt;[0-9]&#123;2&#125;)(?P&lt;birthday&gt;[0-9]&#123;4&#125;)&quot;,&quot;371481199306143242&quot;).groupdict(&quot;city&quot;) </span><br><span class="line"></span><br><span class="line">结果&#123;&apos;province&apos;: &apos;3714&apos;, &apos;city&apos;: &apos;81&apos;, &apos;birthday&apos;: &apos;1993&apos;&#125;</span><br><span class="line"></span><br><span class="line">匹配分割</span><br><span class="line">import re</span><br><span class="line">res = re.split(&quot;[0-9]&quot;,&quot;wang123xiao123hua&quot;)</span><br><span class="line">print (res)</span><br><span class="line">输出为：[&apos;wang&apos;, &apos;&apos;, &apos;&apos;, &apos;xiao&apos;, &apos;&apos;, &apos;&apos;, &apos;hua&apos;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">匹配替换</span><br><span class="line">import re</span><br><span class="line">res = re.sub(&quot;[0-9]&quot;,&quot;#&quot;,&quot;wang123xiao123hua123@wangxiaohua123&quot;,count=2)</span><br><span class="line">print (res)</span><br><span class="line">输出为：wang##3xiao123hua123@wangxiaohua123</span><br></pre></td></tr></table></figure><p>最常用的匹配语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">re.match 从头开始匹配</span><br><span class="line">re.search 匹配包含</span><br><span class="line">re.findall 把所有匹配到的字符放到以列表中的元素返回</span><br><span class="line">re.splitall 以匹配到的字符当做列表分隔符</span><br><span class="line">re.sub      匹配字符并替换</span><br></pre></td></tr></table></figure><p>反斜杠的困扰<br>与大多数编程语言相同，正则表达式里使用”\”作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\”，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r”\“表示。同样，匹配一个数字的”\d”可以写成r”\d”。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。</p><p>仅需轻轻知道的几个匹配模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）</span><br><span class="line">M(MULTILINE): 多行模式，改变&apos;^&apos;和&apos;$&apos;的行为（参见上图）</span><br><span class="line">S(DOTALL): 点任意匹配模式，改变&apos;.&apos;的行为</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res = re.search(&quot;[a-z]+&quot;,&quot;abcdA&quot;)</span><br><span class="line">print (res)</span><br><span class="line">执行后输出为：</span><br><span class="line">&lt;re.Match object; span=(0, 4), match=&apos;abcd&apos;&gt;</span><br><span class="line"></span><br><span class="line">修改后：</span><br><span class="line">res = re.search(&quot;[a-z]+&quot;,&quot;abcdA&quot;,flags=re.I)</span><br><span class="line">print (res)</span><br><span class="line">执行后输出为：</span><br><span class="line">&lt;re.Match object; span=(0, 5), match=&apos;abcdA&apos;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">res = re.search(&quot;^a&quot;,&quot;\nabcd\nioush&quot;)</span><br><span class="line">print (res)</span><br><span class="line">None</span><br><span class="line"></span><br><span class="line">res = re.search(&quot;^a&quot;,&quot;\nabcd\nioush&quot;,flags=re.M)</span><br><span class="line">print (res)</span><br><span class="line">执行后输出为：</span><br><span class="line">&lt;re.Match object; span=(1, 2), match=&apos;a&apos;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res = re.search(&quot;.+&quot;,&quot;\nabcd\nghde&quot;)</span><br><span class="line">print (res)</span><br><span class="line">&lt;re.Match object; span=(1, 5), match=&apos;abcd&apos;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = re.search(&quot;.+&quot;,&quot;\nabcd\nghde&quot;,flags=re.S)</span><br><span class="line">print (res)</span><br><span class="line">执行后输出为：</span><br><span class="line">&lt;re.Match object; span=(0, 10), match=&apos;\nabcd\nghde&apos;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      day05-常用模块学习
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>day04-函数装饰器迭代器生成器</title>
    <link href="http://yoursite.com/2018/07/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day04-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2018/07/13/编程语言/Python/老男孩视频学习笔记/day04-函数装饰器迭代器生成器/</id>
    <published>2018-07-13T12:43:08.000Z</published>
    <updated>2018-07-13T12:43:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>器：代表函数的意思。也就是说，装饰器本质是函数，基本语法都是使用def关键字去定义的</p><p>那么它的本质是函数，它的功能是什么？</p><p>定义：装饰器的本质是函数：装饰其他函数的函数【就是为其他函数添加附加功能】</p><p>在实际生产环境中，需要新增功能的时候，有以下原则</p><ol><li>不能修改现有函数的源代码</li><li>函数一旦写好了，原则上就不能再去修改它的源代码</li><li>函数的调用方式也不能被修改</li></ol><p>装饰器有自己独特的需要遵循的原则：</p><ol><li><strong>不能修改被装饰的函数的源代码</strong></li><li><strong>不能修改被装饰的函数的调用方式</strong></li></ol><p>也就是，被装饰的函数式完全透明的（调用函数的一方不知道这个函数被装饰过，函数本身也感知不到装饰器的存在）</p><p>实现装饰器的知识储备：</p><ol><li><p>函数即“变量”</p></li><li><p>高阶函数</p><ul><li><p>把一个函数名都当做实参传递给另外一个函数【在一般的函数使用中，给形参传递的都是<code>实参变量</code>，那么，函数即变量之后，就可以把==函数==当做一个<code>变量实参</code>传递给另外一个函数】</p><p>这一步可以做到，在不修改被装饰函数源代码的情况下，为其添加功能</p></li><li><p>返回值中包含函数名【一般函数的返回值中吗，可以是字符串，列表，数字等等，因为函数是变量，那么在返回值中是也可以包含函数的】</p><p>不修改函数的调用方式</p></li></ul></li><li><p>函数嵌套</p><ul><li>函数嵌套指的是，在一个函数的函数体之内用def去声明一个新的函数，而不是去调用它</li></ul></li></ol><p>高阶函数+嵌套函数==》装饰器</p><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test1&quot;)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test2&quot;)</span><br><span class="line"></span><br><span class="line">def timer(func):</span><br><span class="line">    def deco():</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print (&quot;func is cost &#123;cost&#125;&quot;.format(cost=stop_time-start_time))</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line"># 返回该函数（这里是deco函数）的内存地址</span><br><span class="line"></span><br><span class="line">test1 = timer(test1)</span><br><span class="line">test1()</span><br><span class="line">#test1执行，实际上是在执行deco这个函数</span><br></pre></td></tr></table></figure><p>执行后的输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in the test1</span><br><span class="line">func is cost 1.0031695365905762</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>函数的执行，主要是执行函数体中的内容，而我们在真正执行函数的时候，是通过函数名称进行调用的（也就是一个变量），因此，在函数真正执行之前，我们可以<strong>修改这个函数名称对应的函数体中的内容</strong></p><p>装饰器的编写步骤：</p><ol><li>首先编写一个函数，其中调用这个被装饰的函数，并在其中添加上新的功能</li><li>将这个函数的函数体，也就是<strong>内存地址</strong>拿出来，重新赋值给这个被装饰的函数</li><li>实现第2步，就需要使用函数的嵌套，以此来返回这个函数的内存地址（函数嵌套了函数之后，是直接将子函数的内存地址返回，而没有执行这个子函数）</li><li>而将这个被装饰的源函数传递给这个装饰函数执行，就需要使用高阶函数</li></ol><h3 id="改良"><a href="#改良" class="headerlink" title="改良"></a>改良</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def timer(func):</span><br><span class="line">    def deco():</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print (&quot;func is cost &#123;cost&#125;&quot;.format(cost=stop_time-start_time))</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def test1():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test1&quot;)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test2&quot;)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>在这里，@timer=test1 = timer(test1)</p><p>注意，使用这种方式的时候，timer函数的定义要在这些被装饰函数的前方</p><p>如果函数还涉及到参数，那么，我们就需要重新编写定义装饰器，将它写成通用的方式，不管被装饰的函数传递的是几个函数（0个或多个），都能够正确的读取。</p><p><strong>添加函数传递功能</strong></p><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = lambda x:x*3</span><br><span class="line">print (res(3))</span><br><span class="line"></span><br><span class="line">执行后输出结果为：9</span><br></pre></td></tr></table></figure><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>通过列表生成式【列表解析】，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种<strong><code>一边循环一边计算</code></strong>的<strong>机制</strong>，称为生成器：generator。</p><p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [i*2 for i in range(11)]</span><br><span class="line">b = (i*2 for i in range(11))</span><br><span class="line">print (a)</span><br><span class="line">print (b)</span><br><span class="line"></span><br><span class="line">执行后输出如下所示：</span><br><span class="line">[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x058D5360&gt;</span><br></pre></td></tr></table></figure><p>注意，在进行调用的时候，传统的方式能够直接通过列表下标的方式获取到相应的元素【因为元素已经生成并存在于内存当中】，但是生成器是只有你调用到我这一次的时候，我才会生成这一个，也就是必须循环到这个指定的下标的时候，我才会产生这个元素的值，因此，在前面的数据没有生成的情况下，直接调用中间的某个元素，因为不存在这个元素，因此就会产生报错,不支持这种数据获取方式</p><p>调用生成器的时候，只能使用for循环的方式一个个取用，当不想要获取全部的数据，只需要获取部分数据的时候，使用生成器提供的next方法进行操作【next方法获取当前】。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.__next()__()</span><br></pre></td></tr></table></figure><p>注意：没有previous方法用户获取上一个值，因为，生成器只会当前的位置，不知道前边和后边</p><p><strong>总结：</strong></p><ul><li>生成器只有在调用时，才会生成相应的数据</li><li>只会记录当前位置</li><li>只有一个<code>__next__()</code>方法（2.7中为next()）</li></ul><p>我们创建了一个generator后，基本上永远不会调用<code>next()</code>，而是通过<code>for</code>循环来迭代它，并且不需要关心<code>StopIteration</code>的错误。</p><p>generator非常强大。如果推算的算法比较复杂，用类似列表生成式的<code>for</code>循环无法实现的时候，还可以用函数来实现。</p><p>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p><p>1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p><p>yield的作用：保存函数的中断状态，yield返回当前状态的值，并且将函数保持停留在这里</p><p>对生成器使用send()方法，可以将参数传递给这个生成器，yield就会接受到这个参数</p><p>next()只是单纯的调用yield，它不会给yield传值；send()给yield传值，同时调用yield</p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：</p><p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p><p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p><p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p><p><strong>重点：</strong></p><ul><li><p>可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code></p></li><li><p>生成器不但可以作用于<code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值了。</p></li><li>可以被next()方法调用并不断返回下一个值的对象称为迭代器：<strong><code>Iterator</code></strong>。</li></ul><p>迭代器和next()方法相关联，有next()方法的才能称之为迭代器</p><p>查看一个对象能够调用的所有方法：dir(a)</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象【是否是<strong>迭代器</strong>对象】：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print (isinstance([1,2,3],Iterator))</span><br><span class="line">print (isinstance([],Iterator))</span><br><span class="line">print (isinstance((x for x in range(10)),Iterator))</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">a = [1,2,3]</span><br><span class="line">b = iter(a)</span><br><span class="line">print (isinstance(b,Iterator))</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p><p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p><p>你可能会问，为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？</p><p>这是因为Python的<code>Iterator</code>对象表示的是一个数据流，Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p><code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><h1 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h1><p>python中有以下内置函数</p><table><thead><tr><th></th><th>Built-in Functions</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#abs" target="_blank" rel="noopener"><code>abs()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#delattr" target="_blank" rel="noopener"><code>delattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#hash" target="_blank" rel="noopener"><code>hash()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-memoryview" target="_blank" rel="noopener"><code>memoryview()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-set" target="_blank" rel="noopener"><code>set()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#all" target="_blank" rel="noopener"><code>all()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-dict" target="_blank" rel="noopener"><code>dict()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#help" target="_blank" rel="noopener"><code>help()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#min" target="_blank" rel="noopener"><code>min()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#setattr" target="_blank" rel="noopener"><code>setattr()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#any" target="_blank" rel="noopener"><code>any()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#dir" target="_blank" rel="noopener"><code>dir()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#hex" target="_blank" rel="noopener"><code>hex()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#next" target="_blank" rel="noopener"><code>next()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#slice" target="_blank" rel="noopener"><code>slice()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#ascii" target="_blank" rel="noopener"><code>ascii()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#divmod" target="_blank" rel="noopener"><code>divmod()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#id" target="_blank" rel="noopener"><code>id()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#object" target="_blank" rel="noopener"><code>object()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#sorted" target="_blank" rel="noopener"><code>sorted()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#bin" target="_blank" rel="noopener"><code>bin()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#input" target="_blank" rel="noopener"><code>input()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#oct" target="_blank" rel="noopener"><code>oct()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#staticmethod" target="_blank" rel="noopener"><code>staticmethod()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#bool" target="_blank" rel="noopener"><code>bool()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#eval" target="_blank" rel="noopener"><code>eval()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#int" target="_blank" rel="noopener"><code>int()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#open" target="_blank" rel="noopener"><code>open()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-str" target="_blank" rel="noopener"><code>str()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#breakpoint" target="_blank" rel="noopener"><code>breakpoint()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#exec" target="_blank" rel="noopener"><code>exec()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#ord" target="_blank" rel="noopener"><code>ord()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#sum" target="_blank" rel="noopener"><code>sum()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-bytearray" target="_blank" rel="noopener"><code>bytearray()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#filter" target="_blank" rel="noopener"><code>filter()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#issubclass" target="_blank" rel="noopener"><code>issubclass()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#pow" target="_blank" rel="noopener"><code>pow()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#super" target="_blank" rel="noopener"><code>super()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-bytes" target="_blank" rel="noopener"><code>bytes()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#float" target="_blank" rel="noopener"><code>float()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#iter" target="_blank" rel="noopener"><code>iter()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#print" target="_blank" rel="noopener"><code>print()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-tuple" target="_blank" rel="noopener"><code>tuple()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#callable" target="_blank" rel="noopener"><code>callable()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#format" target="_blank" rel="noopener"><code>format()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#len" target="_blank" rel="noopener"><code>len()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#property" target="_blank" rel="noopener"><code>property()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#type" target="_blank" rel="noopener"><code>type()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#chr" target="_blank" rel="noopener"><code>chr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-frozenset" target="_blank" rel="noopener"><code>frozenset()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-list" target="_blank" rel="noopener"><code>list()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-range" target="_blank" rel="noopener"><code>range()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#vars" target="_blank" rel="noopener"><code>vars()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#classmethod" target="_blank" rel="noopener"><code>classmethod()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#getattr" target="_blank" rel="noopener"><code>getattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#locals" target="_blank" rel="noopener"><code>locals()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#repr" target="_blank" rel="noopener"><code>repr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#zip" target="_blank" rel="noopener"><code>zip()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#compile" target="_blank" rel="noopener"><code>compile()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#globals" target="_blank" rel="noopener"><code>globals()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#map" target="_blank" rel="noopener"><code>map()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#reversed" target="_blank" rel="noopener"><code>reversed()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#__import__" target="_blank" rel="noopener"><code>__import__()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#complex" target="_blank" rel="noopener"><code>complex()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#hasattr" target="_blank" rel="noopener"><code>hasattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#max" target="_blank" rel="noopener"><code>max()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#round" target="_blank" rel="noopener"><code>round()</code></a></td></tr></tbody></table><ul><li><p>all()：判断输出的值是否都为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print (all([9,3]))</span><br><span class="line">print (all([0,9,3]))</span><br><span class="line"></span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p>any()：一个数据为真，就返回真，如果可迭代对象为空，返回也为False</p></li></ul><ul><li>eval()：将字符串变成字典</li></ul><h1 id="json序列化"><a href="#json序列化" class="headerlink" title="json序列化"></a>json序列化</h1><p>序列化：把内存中的数据对象变成字符串</p><p>反序列化： 把磁盘中的数据加载到内存当中</p><p>注意：json只能处理简单的数据类型，列表、字典、字符串等，因为json是所有语言都通用的，json主要的作用是用于不同语言之间进行数据交互，因为一些复杂的东西，例如python和java里面，类的定义和使用方式、一些特性等等，各语言之间很多东西都有很大的差异性，如果需要转换类、函数等对象就会变得相当复杂。所以，json默认只是支持这些比较简单的。</p><ul><li><p>xml知识补充：xml正在逐渐的被json所取代</p><blockquote><p>xml是一种标记语言，</p></blockquote></li></ul><h1 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h1><p>pickle的用法和json完全一样，但是它在序列化的时候，会把内存转换成为二进制的形式，所以在操作文件的时候，需要在序列化和反序列化的时候使用的方法为：wb和rb</p><p>pickle有自己的一套语法映射关系，将数据转换为二进制数据，因此系统的字符集识别之后将会显示为乱码</p><h1 id="dumps-和dump-以及loads-和load-区别"><a href="#dumps-和dump-以及loads-和load-区别" class="headerlink" title="dumps()和dump()以及loads()和load()区别"></a>dumps()和dump()以及loads()和load()区别</h1><p>注意，在序列化的时候，使用dumps和loads操作文件的时候，需要使用文件本身的f.write()或者f.read()方法；但是如果使用dump()和load()的时候，该方法中就可以嵌入了对文件的操作，也就是说不需要再额外的使用以上两个文件方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f.write(pickle.dumps(info))</span><br><span class="line">等价于</span><br><span class="line">pickle.dump(info,f)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">data = pickle.loads(f.read())</span><br><span class="line">等价于</span><br><span class="line">data = pickle.load(f)</span><br></pre></td></tr></table></figure><p>注意，我们可以dump很多次，但是dump很多次之后的这个文件，直接使用load是打不开的。</p><p>也就是说，在python3中，最多只能dump一次。</p><p><strong>在编写程序时的一个准则：</strong></p><ul><li>只dump一次，只load一次</li><li>如果还是想使用原来的文件，那么就把原来的内容覆盖掉 </li><li>例如虚拟机的快照，虚拟机的快照是每一个快照都会对应一个文件，而不是把所有的快照内容都存在一起</li><li>如果想保存好几个状态，那么就dump好几个文件。</li></ul><h1 id="软件目录结构规范"><a href="#软件目录结构规范" class="headerlink" title="软件目录结构规范"></a>软件目录结构规范</h1><h4 id="为什么要设计好目录结构"><a href="#为什么要设计好目录结构" class="headerlink" title="为什么要设计好目录结构?"></a>为什么要设计好目录结构?</h4><p>“设计项目目录结构”，就和”代码编码风格”一样，属于个人风格问题。对于这种风格上的规范，一直都存在两种态度:</p><ol><li>一类同学认为，这种个人风格问题”无关紧要”。理由是能让程序work就好，风格问题根本不是问题。</li><li>另一类同学认为，规范化能更好的控制程序结构，让程序具有更高的可读性。</li></ol><p>我是比较偏向于后者的，因为我是前一类同学思想行为下的直接受害者。我曾经维护过一个非常不好读的项目，其实现的逻辑并不复杂，但是却耗费了我非常长的时间去理解它想表达的意思。从此我个人对于提高项目可读性、可维护性的要求就很高了。”项目目录结构”其实也是属于”可读性和可维护性”的范畴，我们设计一个层次清晰的目录结构，就是为了达到以下两点:</p><ol><li>可读性高: 不熟悉这个项目的代码的人，一眼就能看懂目录结构，知道程序启动脚本是哪个，测试目录在哪儿，配置文件在哪儿等等。从而非常快速的了解这个项目。</li><li>可维护性高: 定义好组织规则后，维护者就能很明确地知道，新增的哪个文件和代码应该放在什么目录之下。这个好处是，随着时间的推移，代码/配置的规模增加，项目结构不会混乱，仍然能够组织良好。</li></ol><p>所以，我认为，保持一个层次清晰的目录结构是有必要的。更何况组织一个良好的工程目录，其实是一件很简单的事儿。</p><h4 id="目录组织方式"><a href="#目录组织方式" class="headerlink" title="目录组织方式"></a>目录组织方式</h4><p>关于如何组织一个较好的Python工程目录结构，已经有一些得到了共识的目录结构。在Stackoverflow的<a href="http://stackoverflow.com/questions/193161/what-is-the-best-project-structure-for-a-python-application" target="_blank" rel="noopener">这个问题</a>上，能看到大家对Python目录结构的讨论。</p><p>这里面说的已经很好了，我也不打算重新造轮子列举各种不同的方式，这里面我说一下我的理解和体会。</p><p>假设你的项目名为foo, 我比较建议的最方便快捷目录结构这样就足够了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Foo/</span><br><span class="line">|-- bin/</span><br><span class="line">|   |-- foo</span><br><span class="line">|</span><br><span class="line">|-- foo/</span><br><span class="line">|   |-- tests/</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- test_main.py</span><br><span class="line">|   |</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- main.py</span><br><span class="line">|</span><br><span class="line">|-- docs/</span><br><span class="line">|   |-- conf.py</span><br><span class="line">|   |-- abc.rst</span><br><span class="line">|</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- requirements.txt</span><br><span class="line">|-- README</span><br></pre></td></tr></table></figure><p>简要解释一下:</p><ol><li><code>bin/</code>: 存放项目的一些可执行文件，当然你可以起名<code>script/</code>之类的也行。</li><li><code>foo/</code>: 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录<code>tests/</code>存放单元测试代码； (3) 程序的入口最好命名为<code>main.py</code>。</li><li><code>docs/</code>: 存放一些文档。</li><li><code>setup.py</code>: 安装、部署、打包的脚本。</li><li><code>requirements.txt</code>: 存放软件依赖的外部Python包列表。</li><li><code>README</code>: 项目说明文件。</li></ol><p>除此之外，有一些方案给出了更加多的内容。比如<code>LICENSE.txt</code>,<code>ChangeLog.txt</code>文件等，我没有列在这里，因为这些东西主要是项目开源的时候需要用到。如果你想写一个开源软件，目录该如何组织，可以参考<a href="http://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/" target="_blank" rel="noopener">这篇文章</a>。</p><p>下面，再简单讲一下我对这些目录的理解和个人要求吧。</p><p><strong>注意：</strong>有<code>__init__.py</code>这个空文件的目录就叫做包，没有的就叫做目录</p><h4 id="关于README的内容"><a href="#关于README的内容" class="headerlink" title="关于README的内容"></a>关于README的内容</h4><p><strong>这个我觉得是每个项目都应该有的一个文件</strong>，目的是能简要描述该项目的信息，让读者快速了解这个项目。</p><p>它需要说明以下几个事项:</p><ol><li>软件定位，软件的基本功能。</li><li>运行代码的方法: 安装环境、启动命令等。</li><li>简要的使用说明。</li><li>代码目录结构说明，更详细点可以说明软件的基本原理。</li><li>常见问题说明。</li></ol><p>我觉得有以上几点是比较好的一个<code>README</code>。在软件开发初期，由于开发过程中以上内容可能不明确或者发生变化，并不是一定要在一开始就将所有信息都补全。但是在项目完结的时候，是需要撰写这样的一个文档的。</p><p>可以参考Redis源码中<a href="https://github.com/antirez/redis#what-is-redis" target="_blank" rel="noopener">Readme</a>的写法，这里面简洁但是清晰的描述了Redis功能和源码结构。</p><h4 id="关于requirements-txt和setup-py"><a href="#关于requirements-txt和setup-py" class="headerlink" title="关于requirements.txt和setup.py"></a>关于requirements.txt和setup.py</h4><h4 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a>setup.py</h4><p>一般来说，用<code>setup.py</code>来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具<a href="https://pythonhosted.org/setuptools/setuptools.html#developer-s-guide" target="_blank" rel="noopener">setuptools</a>来管理这些事情。这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，<strong>一个项目一定要有一个安装部署工具</strong>，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。</p><p>这个我是踩过坑的。</p><p>我刚开始接触Python写项目的时候，安装环境、部署代码、运行程序这个过程全是手动完成，遇到过以下问题:</p><ol><li>安装环境时经常忘了最近又添加了一个新的Python包，结果一到线上运行，程序就出错了。</li><li>Python包的版本依赖问题，有时候我们程序中使用的是一个版本的Python包，但是官方的已经是最新的包了，通过手动安装就可能装错了。</li><li>如果依赖的包很多的话，一个一个安装这些依赖是很费时的事情。</li><li>新同学开始写项目的时候，将程序跑起来非常麻烦，因为可能经常忘了要怎么安装各种依赖。</li></ol><p><code>setup.py</code>可以将这些事情自动化起来，提高效率、减少出错的概率。”复杂的东西自动化，能自动化的东西一定要自动化。”是一个非常好的习惯。</p><p>setuptools的<a href="https://pythonhosted.org/setuptools/setuptools.html#developer-s-guide" target="_blank" rel="noopener">文档</a>比较庞大，刚接触的话，可能不太好找到切入点。学习技术的方式就是看他人是怎么用的，可以参考一下Python的一个Web框架，flask是如何写的: <a href="https://github.com/mitsuhiko/flask/blob/master/setup.py" target="_blank" rel="noopener">setup.py</a></p><p>当然，简单点自己写个安装脚本（<code>deploy.sh</code>）替代<code>setup.py</code>也未尝不可。</p><h4 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a>requirements.txt</h4><p>这个文件存在的目的是:</p><ol><li>方便开发者维护软件的包依赖。将开发过程中新增的包添加进这个列表中，避免在<code>setup.py</code>安装依赖时漏掉软件包。</li><li>方便读者明确项目使用了哪些Python包。</li></ol><p>这个文件的格式是每一行包含一个包依赖的说明，通常是<code>flask&gt;=0.10</code>这种格式，要求是这个格式能被<code>pip</code>识别，这样就可以简单的通过 <code>pip install -r requirements.txt</code>来把所有Python包依赖都装好了。具体格式说明： <a href="https://pip.readthedocs.org/en/1.1/requirements.html" target="_blank" rel="noopener">点这里</a>。</p><h4 id="关于配置文件的使用方法"><a href="#关于配置文件的使用方法" class="headerlink" title="关于配置文件的使用方法"></a>关于配置文件的使用方法</h4><h4 id="注意，在上面的目录结构中，没有将conf-py放在源码目录下，而是放在docs-目录下。"><a href="#注意，在上面的目录结构中，没有将conf-py放在源码目录下，而是放在docs-目录下。" class="headerlink" title="注意，在上面的目录结构中，没有将conf.py放在源码目录下，而是放在docs/目录下。"></a>注意，在上面的目录结构中，没有将<code>conf.py</code>放在源码目录下，而是放在<code>docs/</code>目录下。</h4><p>很多项目对配置文件的使用做法是:</p><ol><li>配置文件写在一个或多个python文件中，比如此处的conf.py。</li><li>项目中哪个模块用到这个配置文件就直接通过<code>import conf</code>这种形式来在代码中使用配置。</li></ol><p>这种做法我不太赞同:</p><ol><li>这让单元测试变得困难（因为模块内部依赖了外部配置）</li><li>另一方面配置文件作为用户控制程序的接口，应当可以由用户自由指定该文件的路径。</li><li>程序组件可复用性太差，因为这种贯穿所有模块的代码硬编码方式，使得大部分模块都依赖<code>conf.py</code>这个文件。</li></ol><p>所以，我认为配置的使用，更好的方式是，</p><ol><li>模块的配置都是可以灵活配置的，不受外部配置文件的影响。</li><li>程序的配置也是可以灵活控制的。</li></ol><p>能够佐证这个思想的是，用过nginx和mysql的同学都知道，nginx、mysql这些程序都可以自由的指定用户配置。</p><p>所以，不应当在代码中直接<code>import conf</code>来使用配置文件。上面目录结构中的<code>conf.py</code>，是给出的一个配置样例，不是在写死在程序中直接引用的配置文件。可以通过给<code>main.py</code>启动参数指定配置路径的方式来让程序读取配置内容。当然，这里的<code>conf.py</code>你可以换个类似的名字，比如<code>settings.py</code>。或者你也可以使用其他格式的内容来编写配置文件，比如<code>settings.yaml</code>之类的。</p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p>作业需求：</p><p>模拟实现一个ATM + 购物商城程序</p><ol><li>额度 15000或自定义</li><li>实现购物商城，买东西加入 购物车，调用信用卡接口结账</li><li>可以提现，手续费5%</li><li>每月22号出账单，每月10号为还款日，过期未还，按欠款总额 万分之5 每日计息</li><li>支持多账户登录</li><li>支持账户间转账</li><li>记录每月日常消费流水</li><li>提供还款接口</li><li>ATM记录操作日志 </li><li>提供管理接口，包括添加账户、用户额度，冻结账户等。。。</li><li>用户认证用装饰器</li></ol><p><strong>相关代码及说明记录在pycharm当中</strong></p>]]></content>
    
    <summary type="html">
    
      day04-函数装饰器迭代器生成器
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>内核模块操作命令-lsmod+rmmod+modinfo+modprobe</title>
    <link href="http://yoursite.com/2018/07/13/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-lsmod+rmmod+modinfo+modprobe/"/>
    <id>http://yoursite.com/2018/07/13/IT科学技术知识体系结构-Linux运维方向/Linux基础知识/Linux常用命令/内核模块操作命令-lsmod+rmmod+modinfo+modprobe/</id>
    <published>2018-07-13T07:23:11.000Z</published>
    <updated>2018-07-13T07:23:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要讲解和Linux内核模块相关的操作命令</p><hr><h1 id="lsmod-查看内核模块信息"><a href="#lsmod-查看内核模块信息" class="headerlink" title="lsmod-查看内核模块信息"></a>lsmod-查看内核模块信息</h1><p><strong>lsmod命令</strong>用于显示已经加载到内核中的模块的状态信息。执行lsmod命令后会列出所有已载入系统的模块。</p><p>Linux操作系统的核心具有模块化的特性，应此在编译核心时，可以不用把全部的功能都放入核心，而是将这些功能编译成一个个单独的模块，待需要时再分别载入使用。 </p><p>命令的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# lsmod </span><br><span class="line">Module                  Size  Used by</span><br><span class="line">iptable_nat             5923  0 </span><br><span class="line">nf_nat                 22676  1 iptable_nat</span><br><span class="line">nf_conntrack_ipv4       9186  3 iptable_nat,nf_nat</span><br><span class="line">nf_conntrack           79537  3 iptable_nat,nf_nat,nf_conntrack_ipv4</span><br><span class="line">nf_defrag_ipv4          1483  1 nf_conntrack_ipv4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# lsmod | grep ip_vs</span><br><span class="line">ip_vs_rr                1420  0 </span><br><span class="line">ip_vs                 126705  2 ip_vs_rr</span><br><span class="line">libcrc32c               1246  1 ip_vs</span><br><span class="line">ipv6                  336368  913 ip_vs,ib_ipoib,ib_addr</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>第1列：表示模块的名称。</li><li>第2列：表示模块的大小。</li><li>第3列：表示该模块调用其他模块的个数</li><li>第4列：显示该模块被其他什么模块调用</li></ul><p>通常在使用lsmod命令时，都会采用类似<code>lsmod | grep -i ipvs</code>这样的命令来查询当前系统是否加载了某些模块。</p><h1 id="modinfo-查看内核模块信息"><a href="#modinfo-查看内核模块信息" class="headerlink" title="modinfo-查看内核模块信息"></a>modinfo-查看内核模块信息</h1><p>modinfo会显示kernel模块的对象文件，以显示该模块的相关信息。 </p><p>modinfo列出Linux内核中命令行指定的模块的信息。若模块名不是一个文件名，则会在/lib/modules/version 目录中搜索，就像modprobe一样。</p><p>modinfo默认情况下，为了便于阅读，以下面的格式列出模块的每个属性：fieldname : value。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">参　　数：</span><br><span class="line">  -a或--author 　显示模块开发人员。 </span><br><span class="line">  -d或--description 　显示模块的说明。 </span><br><span class="line">  -h或--help 　显示modinfo的参数使用方法。 </span><br><span class="line">  -p或--parameters 　显示模块所支持的参数。 </span><br><span class="line">  -V或--version 　显示版本信息。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# modinfo ip_vs</span><br><span class="line">filename:       /lib/modules/2.6.32-696.el6.x86_64/kernel/net/netfilter/ipvs/ip_vs.ko</span><br><span class="line">license:        GPL</span><br><span class="line">srcversion:     0FB85919D62C4255E412E5C</span><br><span class="line">depends:        ipv6,libcrc32c</span><br><span class="line">vermagic:       2.6.32-696.el6.x86_64 SMP mod_unload modversions </span><br><span class="line">parm:           conn_tab_bits:Set connections&apos; hash size (int)</span><br></pre></td></tr></table></figure><p>注意，使用lsmod不能看到内核的相关参数配置，而使用modinfo命令则可以显示</p><h1 id="rmmod-卸载内核模块"><a href="#rmmod-卸载内核模块" class="headerlink" title="rmmod-卸载内核模块"></a>rmmod-卸载内核模块</h1><p><strong>rmmod命令</strong> 用于从当前运行的内核中移除指定的内核模块。</p><p>执行rmmod指令，可删除不需要的模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选项信息：</span><br><span class="line">-v：显示指令执行的详细信息；</span><br><span class="line">-f：强制移除模块，使用此选项比较危险；</span><br><span class="line">-w：等待着，直到模块能够被除时在移除模块；</span><br><span class="line">-s：向系统日志（syslog）发送错误信息。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# rmmod ip_vs</span><br><span class="line">ERROR: Module ip_vs is in use by ip_vs_rr</span><br></pre></td></tr></table></figure><p>使用rmmod卸载模块的时候，提示信息会比使用modprobe -r 的输出更详细，此时会显示该模块的被调用情况</p><h1 id="insmod-载入内核模块"><a href="#insmod-载入内核模块" class="headerlink" title="insmod-载入内核模块"></a>insmod-载入内核模块</h1><p>insmod(install module)命令用于载入模块。</p><p>Linux有许多功能是通过模块的方式，在需要时才载入kernel。如此可使kernel较为精简，进而提高效率，以及保有较大的弹性。这类可载入的模块，通常是设备驱动程序。</p><p><strong>语法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod [-fkmpsvxX][-o &lt;模块名称&gt;][模块文件][符号名称 = 符号值]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">-f 　不检查目前kernel版本与模块编译时的kernel版本是否一致，强制将模块载入。</span><br><span class="line">-k 　将模块设置为自动卸除。</span><br><span class="line">-m 　输出模块的载入信息。</span><br><span class="line">-o&lt;模块名称&gt; 　指定模块的名称，可使用模块文件的文件名。</span><br><span class="line">-p 　测试模块是否能正确地载入kernel。</span><br><span class="line">-s 　将所有信息记录在系统记录文件中。</span><br><span class="line">-v 　执行时显示详细的信息。</span><br><span class="line">-x 　不要汇出模块的外部符号。</span><br><span class="line">-X 　汇出模块所有的外部符号，此为预设置。</span><br></pre></td></tr></table></figure><p>在Linux中，modprobe和insmod都可以用来加载module，不过现在一般都推荐使用modprobe而不是insmod了。<br><strong>modprobe和insmod的区别是什么呢？</strong></p><ul><li>modprobe可以解决load module时的依赖关系，比如load moudleA就必须先load mouduleB之类的，它是通过/lib/modules//modules.dep文件来查找依赖关系的。而insmod不能解决依赖问题。</li><li>modprobe默认会去/lib/modules/目录下面查找module，而insmod只在给它的参数中去找module（默认在当前目录找）。</li></ul><p>但是insmod也有它的有用之处，举个例子吧。</p><p>有/root/my-mod.ko这个module，cd /root/，然后用insmod my-mod.ko(insmod /root/my-mod.ko)就可以insert这个module了，</p><p>但是用modprobe my-mod.ko(modprobe /root/my-mod.ko)却提示”FATAL: Module my-mod.ko not found”，这就是因为modprobe是到/lib/modules/<code>uname -r</code>/下去找module的，如果没找到就是这样了。</p><h1 id="depmod-分析模块依赖性"><a href="#depmod-分析模块依赖性" class="headerlink" title="depmod-分析模块依赖性"></a>depmod-分析模块依赖性</h1><h1 id="modprobe-内核模块操作"><a href="#modprobe-内核模块操作" class="headerlink" title="modprobe-内核模块操作"></a>modprobe-内核模块操作</h1><p><strong>modprobe命令</strong>用于智能地向内核中加载模块或者从内核中移除模块。</p><p>modprobe可载入指定的个别模块，或是载入一组相依的模块。</p><p>modprobe会根据<a href="http://man.linuxde.net/depmod" target="_blank" rel="noopener">depmod</a>所产生的相依关系，决定要载入哪些模块。若在载入过程中发生错误，在modprobe会卸载整组的模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数选项</span><br><span class="line"></span><br><span class="line">-a或--all：载入全部的模块/指定模块；</span><br><span class="line">-c或--show-conf：显示所有模块的设置信息；</span><br><span class="line">-d或--debug：使用排错模式；</span><br><span class="line">-l或--list：显示可用的模块；</span><br><span class="line">-r或--remove：卸载模块；</span><br><span class="line">-t或--type：指定模块类型；</span><br><span class="line">-v或--verbose：执行时显示详细的信息；</span><br><span class="line">-V或--version：显示版本信息；</span><br><span class="line">-help：显示帮助。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">卸载：modprobe -r ip_vs </span><br><span class="line">载入：modprobe -a ip_vs</span><br></pre></td></tr></table></figure><h1 id="get-module"><a href="#get-module" class="headerlink" title="get_module"></a>get_module</h1><p>需要安装sysfsutils包之后才能产生该命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install sysfsutils</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# get_module ip_vs</span><br><span class="line">initstate            : live</span><br><span class="line">refcnt               : 2</span><br><span class="line">srcversion           : 0FB85919D62C4255E412E5C</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">conn_tab_bits        : 12</span><br><span class="line">Sections:</span><br><span class="line">.altinstr_replacement : 0xffffffffa039c2b8</span><br><span class="line">.altinstructions     : 0xffffffffa039ef98</span><br><span class="line">.bss                 : 0xffffffffa03a1c60</span><br><span class="line">.data                : 0xffffffffa039ff00</span><br><span class="line">.data.cacheline_aligned : 0xffffffffa03a1580</span><br><span class="line">.data.read_mostly    : 0xffffffffa03a1040</span><br><span class="line">.exit.text           : 0xffffffffa039c40e</span><br><span class="line">.gnu.linkonce.this_module : 0xffffffffa03a1a20</span><br><span class="line">.init.text           : 0xffffffffa03aa000</span><br><span class="line">.note.gnu.build-id   : 0xffffffffa039c454</span><br><span class="line">.rheldata            : 0xffffffffa039fee0</span><br><span class="line">.rodata              : 0xffffffffa039c480</span><br><span class="line">.rodata.str1.1       : 0xffffffffa039d6e8</span><br><span class="line">.rodata.str1.8       : 0xffffffffa039dc90</span><br><span class="line">.smp_locks           : 0xffffffffa039eb68</span><br><span class="line">.strtab              : 0xffffffffa03ae2f8</span><br><span class="line">.symtab              : 0xffffffffa03aa4d0</span><br><span class="line">.text                : 0xffffffffa038a000</span><br><span class="line">__kcrctab_gpl        : 0xffffffffa039f540</span><br><span class="line">__kcrctab            : 0xffffffffa039fe80</span><br><span class="line">__ksymtab_gpl        : 0xffffffffa039f4f0</span><br><span class="line">__ksymtab_strings    : 0xffffffffa039f590</span><br><span class="line">__ksymtab            : 0xffffffffa039fdc0</span><br><span class="line">__mcount_loc         : 0xffffffffa039f6e8</span><br><span class="line">__param              : 0xffffffffa039f568</span><br><span class="line">__verbose            : 0xffffffffa03a1980</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      内核模块操作-lsmod+rmmod+modinfo+modprobe
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="Linux基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Linux常用命令" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="lsmod" scheme="http://yoursite.com/tags/lsmod/"/>
    
  </entry>
  
  <entry>
    <title>python常见模块+方法+函数记录</title>
    <link href="http://yoursite.com/2018/07/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/python%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/07/11/编程语言/Python/基础知识/python模块/</id>
    <published>2018-07-11T09:43:49.000Z</published>
    <updated>2018-07-11T09:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p>在平常的代码中，我们常常需要与时间打交道。在Python中，与时间处理有关的模块包括：time，datetime以及calendar。</p><p>在开始之前，首先要说明这几点：</p><ol><li><p>在Python中，通常有这几种方式来表示时间：</p><p>1）时间戳 </p><p>2）格式化的时间字符串 </p><p>3）元组（struct_time）共九个元素。由于Python的time模块实现主要调用C库，所以各个平台可能有所不同。</p></li></ol><ol><li>UTC（Coordinated Universal Time，世界协调时）亦即格林威治天文时间，世界标准时间。在中国为UTC+8。DST（Daylight Saving Time）即夏令时。</li></ol><ol><li>时间戳（timestamp）的方式：通常来说，时间戳表示的是从<strong>1970年1月1日00:00:00</strong>开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。返回时间戳方式的函数主要有time()，clock()等。</li></ol><ol><li>元组（struct_time）方式：struct_time元组共有9个元素，返回struct_time的函数主要有gmtime()，localtime()，strptime()。下面列出这种方式元组中的几个元素：</li></ol><table><thead><tr><th>索引（Index）</th><th>属性（Attribute）</th><th>值（Values）</th></tr></thead><tbody><tr><td>0</td><td>tm_year（年）</td><td>比如2011</td></tr><tr><td>1</td><td>tm_mon（月）</td><td>1 - 12</td></tr><tr><td>2</td><td>tm_mday（日）</td><td>1 - 31</td></tr><tr><td>3</td><td>tm_hour（时）</td><td>0 - 23</td></tr><tr><td>4</td><td>tm_min（分）</td><td>0 - 59</td></tr><tr><td>5</td><td>tm_sec（秒）</td><td>0 - 61</td></tr><tr><td>6</td><td>tm_wday（weekday）</td><td>0 - 6（0表示周日）</td></tr><tr><td>7</td><td>tm_yday（一年中的第几天）</td><td>1 - 366</td></tr><tr><td>8</td><td>tm_isdst（是否是夏令时）</td><td>默认为-1</td></tr></tbody></table><h3 id="获取当前时间戳"><a href="#获取当前时间戳" class="headerlink" title="获取当前时间戳"></a>获取当前时间戳</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.time())</span><br><span class="line">输出如下：</span><br><span class="line">1531317129.0039742</span><br></pre></td></tr></table></figure><h3 id="时间元祖"><a href="#时间元祖" class="headerlink" title="时间元祖"></a>时间元祖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.localtime())</span><br><span class="line">输出如下：</span><br><span class="line">time.struct_time(tm_year=2018, tm_mon=7, tm_mday=11, tm_hour=22, tm_min=4, tm_sec=18, tm_wday=2, tm_yday=192, tm_isdst=0)</span><br></pre></td></tr></table></figure><h3 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h3><p>最简单的获取可读模式的方法是asctime()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.asctime())</span><br><span class="line">输出如下：</span><br><span class="line">Wed Jul 11 21:52:09 2018</span><br></pre></td></tr></table></figure><p><strong>使用指定的格式输出</strong>，在这里，使用strftime方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.localtime()))</span><br><span class="line">输入如下：</span><br><span class="line">2018-07-11 22:02:27</span><br></pre></td></tr></table></figure><p><strong>补充-python中时间日期格式化符号</strong></p><p>python中时间日期格式化符号：</p><ul><li>%y 两位数的年份表示（00-99）</li><li>%Y 四位数的年份表示（000-9999）</li><li>%m 月份（01-12）</li><li>%d 月内中的一天（0-31）</li><li>%H 24小时制小时数（0-23）</li><li>%I 12小时制小时数（01-12）</li><li>%M 分钟数（00=59）</li><li>%S 秒（00-59）</li><li>%a 本地简化星期名称</li><li>%A 本地完整星期名称</li><li>%b 本地简化的月份名称</li><li>%B 本地完整的月份名称</li><li>%c 本地相应的日期表示和时间表示</li><li>%j 年内的一天（001-366）</li><li>%p 本地A.M.或P.M.的等价符</li><li>%U 一年中的星期数（00-53）星期天为星期的开始</li><li>%w 星期（0-6），星期天为星期的开始</li><li>%W 一年中的星期数（00-53）星期一为星期的开始</li><li>%x 本地相应的日期表示</li><li>%X 本地相应的时间表示</li><li>%Z 当前时区的名称</li><li>%% %号本身</li></ul><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Python time sleep() 方法推迟调用线程的运行，可通过参数secs指秒数，表示进程挂起的时间。 </p><p>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.sleep(t)</span><br></pre></td></tr></table></figure><h2 id="commands模块-3-x已废弃"><a href="#commands模块-3-x已废弃" class="headerlink" title="commands模块-3.x已废弃"></a>commands模块-3.x已废弃</h2><p>用Python写运维脚本时，经常需要执行linux shell的命令，Python中的commands模块专门用于调用Linux shell命令，并返回状态和结果。</p><p>下面是commands模块的几个主要方法： </p><h3 id="commands-getoutput-‘shell-command’"><a href="#commands-getoutput-‘shell-command’" class="headerlink" title="commands.getoutput(‘shell command’)"></a>commands.getoutput(‘shell command’)</h3><p>执行shell命令，返回结果（string类型）</p><p>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输出指定进程的pid</span><br><span class="line"></span><br><span class="line">wxh@wxh-virtual-machine:~/python_files$ cat tt.py</span><br><span class="line">#!/usr/bin/env python2</span><br><span class="line">import sys,commands</span><br><span class="line">cmdline = sys.argv[1]</span><br><span class="line">cmdline1 = sys.argv[2]</span><br><span class="line"></span><br><span class="line">cmd = &quot;ps -ef|grep &quot; + cmdline + &quot;|grep &quot; + cmdline1 + &quot;|grep -v grep|grep -v python|awk &apos;&#123;print $2&#125;&apos;&quot;</span><br><span class="line"></span><br><span class="line">c1 = commands.getoutput(cmd)</span><br><span class="line">print (c1)</span><br><span class="line">print (type(c1))</span><br></pre></td></tr></table></figure><p>执行后输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-virtual-machine:~/python_files$ python2 ./tt.py unity-panel-service lockscreen-mode</span><br><span class="line"></span><br><span class="line">126263</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="commands-getstatusoutput-‘shell-command’"><a href="#commands-getstatusoutput-‘shell-command’" class="headerlink" title="commands.getstatusoutput(‘shell command’)"></a>commands.getstatusoutput(‘shell command’)</h3><p>执行shell命令, 返回两个元素的元组tuple(status, result)，status为int类型，result为string类型。</p><p>因为cmd的执行方式是{ cmd ; } 2&gt;&amp;1, 故返回结果包含标准输出和标准错误.</p><ul><li>第一个值为命令执行的返回状态码，执行成功则返回的是0，不成功则返回的是非0</li></ul><p>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-virtual-machine:~/python_files$ cat tt.py </span><br><span class="line">#!/usr/bin/env python2</span><br><span class="line">import sys,commands</span><br><span class="line">cmdline = sys.argv[1]</span><br><span class="line">cmdline1 = sys.argv[2]</span><br><span class="line"></span><br><span class="line">cmd = &quot;ps -ef|grep &quot; + cmdline + &quot;|grep &quot; + cmdline1 + &quot;|grep -v grep|grep -v python|awk &apos;&#123;print $2&#125;&apos;&quot;</span><br><span class="line">res = commands.getstatusoutput(cmd)</span><br><span class="line">print (res)</span><br></pre></td></tr></table></figure><p>执行后输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-virtual-machine:~/python_files$ python2 ./tt.py unity-panel-service lockscreen-mode</span><br><span class="line">(0, &apos;126263&apos;)</span><br></pre></td></tr></table></figure><h1 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h1><p>用于检测linux进程的状态</p><p>实例如下：</p><pre><code>def redis_status(new_port):    p = subprocess.Popen([&quot;netstat&quot;, &quot;-unptl&quot;], stdout=subprocess.PIPE)    out, err = p.communicate()    if (new_port in str(out) ):        print (&quot;redis {PORT} instance is running...&quot;.format(PORT=new_port))    else:        print (&quot;start redis {PORT} faild.please check again...&quot;.format(PORT=new_port))</code></pre><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="truncate-方法"><a href="#truncate-方法" class="headerlink" title="truncate() 方法"></a>truncate() 方法</h3><p><strong>truncate()</strong> 方法用于截断文件，如果指定了可选参数 size，则表示截断文件的 size 个字符。 </p><p>如果没有指定 size，则从当前位置起截断（截断余下的所有字符）；截断之后 size 后面的所有字符被删除。 </p><h3 id="seek-方法"><a href="#seek-方法" class="headerlink" title="seek()方法"></a>seek()方法</h3>]]></content>
    
    <summary type="html">
    
      python模块
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>网卡中断与CPU绑定</title>
    <link href="http://yoursite.com/2018/07/11/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E4%B8%8ECPU%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/07/11/IT科学技术知识体系结构-Linux运维方向/性能调优/网络调优/网卡中断与CPU绑定/</id>
    <published>2018-07-11T07:01:32.000Z</published>
    <updated>2018-07-11T07:01:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><p><a href="https://www.cnblogs.com/bamanzi/p/linux-irq-and-cpu-affinity.html" target="_blank" rel="noopener">Linux 性能调优] 网卡中断与CPU的绑定问题</a></p></li><li><p><a href="http://noican.blog.51cto.com/4081966/1355357" target="_blank" rel="noopener">简单介绍下linux下的中断（interrupt）- 一切皆有可能 - 51CTO技术博客</a></p></li><li><a href="https://segmentfault.com/a/1190000006178824" target="_blank" rel="noopener">把网卡中断绑定到CPU,最大化网卡的吞吐量 - SegmentFault</a></li><li><a href="http://www.vpsee.com/2010/07/load-balancing-with-irq-smp-affinity/" target="_blank" rel="noopener">Linux 多核下绑定硬件中断到不同 CPU（IRQ Affinity） | vpsee.com</a></li><li><p><a href="http://www.jianshu.com/p/6beacca6fdcd" target="_blank" rel="noopener">Linux系统CPU的性能监控及调优 - 简书</a></p></li><li><p><a href="https://www.chinanetcloud.com/en/info-center/blog/tech-items-linux-nic-interrupts-overloading-single-cpus/" target="_blank" rel="noopener">Tech Items - Linux NIC Interrupts Overloading Single CPUs - ChinaNetCloud</a> </p></li><li><p><a href="http://www.tuicool.com/articles/naUnia" target="_blank" rel="noopener">Linux网卡中断使单个CPU过载 - 推酷</a> </p></li><li><p><a href="http://wwdhks.blog.51cto.com/839773/1218785" target="_blank" rel="noopener">网卡软中断调优 - deven的博客 - 51CTO技术博客</a> </p></li></ul><p><strong>除了不让多个中断集中到单个CPU，还有更进一步的方法:</strong>  </p><p>调整网卡驱动参数使之采用多个队列，这样多个CPU可以各自处理一个队列。</p><p>当然，这依赖于网卡是否支持 </p><ul><li><a href="http://www.ywnds.com/?p=4380" target="_blank" rel="noopener">多队列网卡及网卡中断绑定阐述 – 运维那点事</a> (这篇文章讲得很全面，推荐阅读） </li><li><a href="http://blog.csdn.net/wyaibyn/article/details/14109325" target="_blank" rel="noopener">网卡多队列及中断绑定 - wyaibyn的专栏 - CSDN博客</a> </li><li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rss.html" target="_blank" rel="noopener">8.6. Receive-Side Scaling (RSS) - Performance Tuning Guide - Red Hat Enterprise Linux 6</a>  </li></ul><p>即使网卡只支持单个队列，我们可以在系统层面模拟层多个队列，这个涉及到被称为Receive Packet Steering (RFS)和Receive Flow Steering (RFS）的两个技术  </p><ul><li><p><a href="http://www.ywnds.com/?p=4380" target="_blank" rel="noopener">多队列网卡及网卡中断绑定阐述 – 运维那点事</a> </p></li><li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rps.html" target="_blank" rel="noopener">8.7. Receive Packet Steering (RPS) - Performance Tuning Guide - Red Hat Enterprise Linux 6</a></p></li><li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rfs.html" target="_blank" rel="noopener">8.8. Receive Flow Steering (RFS) - Performance Tuning Guide - Red Hat Enterprise Linux 6</a> </li></ul><hr><p>在Linux的网络调优方面，如果你发现网络流量上不去，那么有一个方面需要去查一下：网卡处理网络请求的中断是否被绑定到单个CPU（或者说跟处理其它中断的是同一个CPU）。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>网卡与操作系统的交互一般有两种方式：</p><ul><li>一种是中断（IRQ，网卡在收到了网络信号之后，主动发送中断到CPU，而CPU将会立即停下手边的活以便对这个中断信号进行分析），</li><li>另一种叫DMA（Direct Memory Access, 也就是允许硬件在无CPU干预的情况下将数据缓存在指定的内存空间内，在CPU合适的时候才处理）</li></ul><p>在网卡方面，大部分还是在用IRQ方式（据说DMA技术仅仅被应用在少数高端网卡上; 另一个说法是：DMA方式会使外部设备的控制器独占PCI总线，从而CPU无法与外部设备进行交互，这对通用型操作系统Linux来说，是很难接收的，所以DMA方式在Linux内核里使用得很少）。</p><p>但是（再来一个但是），在现在的对称多核处理器（SMP）上，一块网卡的IRQ还是只有一个CPU来响应，其它CPU无法参与，如果这个CPU还要忙其它的中断（其它网卡或者其它使用中断的外设（比如磁盘）），那么就会形成瓶颈。</p><h1 id="问题判定"><a href="#问题判定" class="headerlink" title="问题判定"></a>问题判定</h1><p>网上不少讲这个问题的文章都是直接让查询IRQ跟CPU的绑定情况，甚至直接修改。但我们应该先判断我们的系统是不是受这个问题影响，然后再来看怎么解决。</p><p>首先，让你的网络跑满（比如对于MySQL/MongoDB服务，可以通过客户端发起密集的读操作; 或者执行一个i大文件传送任务）</p><p>第一个要查明的是：<strong>是不是某个CPU在一直忙着处理IRQ？</strong></p><p>这个问题我们可以从 <code>mpstat -P ALL 1</code> 的输出中查明：里面的 <code>%irq</code>一列即说明了CPU忙于处理中断的时间占比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">18:20:33     CPU   %user   %nice    %sys %iowait    %irq   %soft  %steal   %idle    intr/s</span><br><span class="line">18:20:33     all    0,23    0,00    0,08    0,11    6,41    0,02    0,00   93,16   2149,29</span><br><span class="line">18:20:33       0    0,25    0,00    0,12    0,07    0,01    0,05    0,00   99,49    127,08</span><br><span class="line">18:20:33       1    0,14    0,00    0,03    0,04    0,00    0,00    0,00   99,78      0,00</span><br><span class="line">18:20:33       2    0,23    0,00    0,02    0,03    0,00    0,00    0,00   99,72      0,02</span><br><span class="line">18:20:33       3    0,28    0,00    0,15    0,28   25,63    0,03    0,00   73,64   2022,19</span><br></pre></td></tr></table></figure><p>上面的例子中，第四个CPU有25.63%时间在忙于处理中断（这个数值还不算高，如果高达80%（而同时其它CPU这个数值很低）以上就说明有问题了），后面那个 intr/s 也说明了CPU每秒处理的中断数（从上面的数据也可以看出，其它几个CPU都不怎么处理中断）。</p><p>然后我们就要接着查另外一个问题：<strong>这个忙于处理中断的CPU都在处理哪个（些）中断？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupts </span><br><span class="line">           CPU0       CPU1       CPU2       CPU3       </span><br><span class="line">  0:        245          0          0    7134094    IO-APIC-edge  timer</span><br><span class="line">  8:          0          0         49          0    IO-APIC-edge  rtc</span><br><span class="line">  9:          0          0          0          0   IO-APIC-level  acpi</span><br><span class="line"> 66:         67          0          0          0   IO-APIC-level  ehci_hcd:usb2</span><br><span class="line"> 74:     902214          0          0          0         PCI-MSI  eth0</span><br><span class="line">169:          0          0         79          0   IO-APIC-level  ehci_hcd:usb1</span><br><span class="line">177:          0          0          0    7170885   IO-APIC-level  ata_piix, b4xxp</span><br><span class="line">185:          0          0          0      59375   IO-APIC-level  ata_piix</span><br><span class="line">NMI:          0          0          0          0 </span><br><span class="line">LOC:    7104234    7104239    7104243    7104218 </span><br><span class="line">ERR:          0</span><br><span class="line">MIS:          0</span><br></pre></td></tr></table></figure><p>这里记录的是自启动以来，每个CPU处理各类中断的数量（第一列是中断号，最后一列是对应的设备名）[详细说明: <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/s2-proc-interrupts.html" target="_blank" rel="noopener">E.2.10 /proc/interrupts - Deployment Guide - RedHat Enterprise Linux 6</a> )，从上面可以看到： <code>eth0</code>所出发的中断全部都是 <code>CPU0</code>在处理，而CPU0所处理的中断请求中，主要是eth0和LOC中断。</p><p>（有时我们会看到几个CPU对同一个中断类型所处理的的请求数相差无几（比如上面的LOC一行），这并不一定是说多个CPU会轮流处理同一个中断，而是因为这里记录的是“自启动以来”的统计，中间可能因为irq balancer重新分配过处理中断的CPU——当然，也可能是谁手工调节过）。</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>首先说明几点：</p><ol><li>首先应该根据上面的诊断方法查明当前系统是不是受这个原因影响，如果不是，那么就没有必要往下看了;</li><li>现在的多数Linux系统中已经有了IRQ Balance这个服务（服务程序一般是 <code>/usr/sbin/irqbalance</code>），它可以自动调节分配各个中断与CPU的绑定关系，以避免所有中断的处理都集中在少数几个CPU上;</li><li>在某些情况下，这个IRQ Balance反而会导致问题，会出现 irqbalance 这个进程反而自身占用了较高的CPU（当然也就影响了业务系统的性能）</li></ol><p>下面来说手工将中断限定到少数几个CPU的方法。</p><p>首先当然要查明，该网卡的中断当前是否已经限定到某些CPU了？具体是哪些CPU？</p><p>根据上面 <code>/proc/interrupts</code> 的内容我们可以看到 eth0 的中断号是74，然后我们来看看该中断号的CPU绑定情况（或者说叫亲和性 affinity）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /proc/irq/74/smp_affinity</span><br><span class="line">ffffff</span><br></pre></td></tr></table></figure><p>这个输出是一个16进制的数值，<code>0xffffff = ‘0b111111111111111111111111’</code>，这就意味着这里有24个CPU，所有位都为1表示所有CPU都可以被该中断干扰。</p><p>另一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /proc/irq/67/smp_affinity</span><br><span class="line">00000001</span><br></pre></td></tr></table></figure><p>这个例子说明，只有CPU0处理编号为67的中断。</p><p><strong>修改配置的方法</strong>：</p><p>我们可以用 <code>echo 2 &gt; /proc/irq/74/smp_affinity</code> 的方法来修改这个设置（设置为2表示将该中断绑定到CPU1上，0x2 = 0b10，而第一个CPU为CPU0）</p>]]></content>
    
    <summary type="html">
    
      网卡中断与CPU绑定
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="性能调优" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="网络调优" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>LVS性能指标及监控</title>
    <link href="http://yoursite.com/2018/07/10/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/4%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-LVS/LVS%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%8F%8A%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2018/07/10/IT科学技术知识体系结构-Linux运维方向/高并发/负载均衡/4层负载均衡-LVS/LVS性能指标及监控/</id>
    <published>2018-07-10T08:08:26.000Z</published>
    <updated>2018-07-10T08:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考文献：</strong></p><ul><li><a href="http://kb.linuxvirtualserver.org/wiki/Performance_and_Tuning" target="_blank" rel="noopener">Performance and Tuning - LVSKB</a></li></ul><h1 id="性能参数"><a href="#性能参数" class="headerlink" title="性能参数"></a>性能参数</h1><p>LVS 的性能主要通过以下几个方面来提高</p><h2 id="ipvs-connection-table-size-最大连接数"><a href="#ipvs-connection-table-size-最大连接数" class="headerlink" title="ipvs connection table size-最大连接数"></a>ipvs connection table size-最大连接数</h2><p>官方的解释如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">The IPVS connection hash table uses the chaining scheme to handle</span><br><span class="line">hash collisions. Using a big IPVS connection hash table will greatly</span><br><span class="line">reduce conflicts when there are hundreds of thousands of connections</span><br><span class="line">in the hash table.</span><br><span class="line"></span><br><span class="line">Note the table size must be power of 2. The table size will be the</span><br><span class="line">value of 2 to the your input number power. The number to choose is</span><br><span class="line">from 8 to 20, the default number is 12, which means the table size</span><br><span class="line">is 4096. Don&apos;t input the number too small, otherwise you will lose</span><br><span class="line">performance on it. You can adapt the table size yourself, according</span><br><span class="line">to your virtual server application. It is good to set the table size</span><br><span class="line">not far less than the number of connections per second multiplying</span><br><span class="line">average lasting time of connection in the table.  For example, your</span><br><span class="line">virtual server gets 200 connections per second, the connection lasts</span><br><span class="line">for 200 seconds in average in the connection table, the table size</span><br><span class="line">should be not far less than 200x200, it is good to set the table</span><br><span class="line">size 32768 (2**15).</span><br><span class="line"></span><br><span class="line">Another note that each connection occupies 128 bytes effectively and</span><br><span class="line">each hash entry uses 8 bytes, so you can estimate how much memory is</span><br><span class="line">needed for your box.</span><br><span class="line"></span><br><span class="line">You can overwrite this number setting conn_tab_bits module parameter</span><br><span class="line">or by appending ip_vs.conn_tab_bits=? to the kernel command line</span><br><span class="line">if IP VS was compiled built-in.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><p>LVS的连接信息使用<code>IPVS connection hash table</code>这个哈希表去保存，它记录每个进来的连接及路由去向的信息 </p><blockquote><p>任何一个报文到达都需要查找连接Hash表。Hash表的查找复杂度为O(n/m)，其中n为Hash表中对象的个数，m为Hash表的桶个数。当对象在Hash表中均匀分布和Hash表的桶个数与对象个数一样多时，Hash表的查找复杂度可以接近O(1)。 </p></blockquote></li><li><p><code>table size</code>使用2的幂次方进行配置指定，范围为8-20，也就是说连接数的取值范围为：2^8-2^20</p></li><li><p>默认配置为2^12，也就是4096个连接数上限</p></li><li><p>在生产环境中，我们一般设置为最大值，也就是2^20（1048576）</p></li><li><p>注意，这些连接是需要占用内存的，因此要考虑到内存大小的因素</p><blockquote><p>每一个TCP连接需要占用约128字节，哈希表的每个条目需要占用8字节</p><p>以设置为最大值为例，那么，这些连接以及条目共占用内存如下：</p><p>2^20*(128byte+8byte) = 142606336byte = 136MB</p></blockquote></li></ul><p><strong>配置：</strong></p><p>在/etc/modprobe.d/目录下添加文件ip_vs.conf，内容为：</p><p>options ip_vs conn_tab_bits=22（文档中写的上限是20，但是实际配置的时候发现22也是可以的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;options ip_vs conn_tab_bits=22&apos; &gt; /etc/modprobe.d/ipvs.conf</span><br><span class="line">modprobe -r ip_vs &amp;&amp; modprobe -a ip_vs</span><br><span class="line">ipvsadm -Ln</span><br></pre></td></tr></table></figure><p>注意，在卸载内核模块的时候，可能会有依赖关系，这时候使用lsmod先查看依赖调用关系，将调用的模块卸载之后再进行操作，例如，这里的操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# modprobe -r ip_vs_rr</span><br><span class="line">[root@lvs001 modprobe.d]# modprobe -r ip_vs</span><br><span class="line">[root@lvs001 modprobe.d]# modprobe -a ip_vs</span><br><span class="line">[root@lvs001 modprobe.d]# modprobe -a ip_vs_rr</span><br></pre></td></tr></table></figure><h2 id="CPU-Soft-Interrupt-CPU软中断"><a href="#CPU-Soft-Interrupt-CPU软中断" class="headerlink" title="CPU Soft Interrupt -CPU软中断"></a>CPU Soft Interrupt -CPU软中断</h2><p>在Linux的网络调优方面，如果你发现网络流量上不去，那么有一个方面需要去查一下：<strong>网卡处理网络请求的中断是否被绑定/发送到单个CPU，导致只有一个CPU处理网络请求</strong></p><p>但是，在当前的对称多核处理器服务器上，一块网卡的IRQ还是只有一个CPU来响应，其它CPU无法参与，如果这个CPU还要忙其它的中断（其它网卡或者其它使用中断的外设（比如磁盘）），那么就会形成瓶颈。 </p><p><strong>动态查看CPU的irq情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令：mpstat -P ALL 1 </span><br><span class="line">%irq一列即说明了CPU忙于处理中断的时间占比</span><br></pre></td></tr></table></figure><p><strong>查看CPU处理中断的情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupts </span><br><span class="line">这里记录的是自启动以来，每个CPU处理各类中断的数量（第一列是中断号，最后一列是对应的设备名）</span><br></pre></td></tr></table></figure><p>我们进行过滤，获取网卡的中断号，然后再分析CPU的中断情况</p><p>获取对应的中断号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 ~]# cat /proc/interrupts  | egrep &apos;em1|em2|p1p1|p1p2&apos; | awk &apos;&#123;print $1&#125;&apos;</span><br><span class="line">157:</span><br><span class="line">158:</span><br><span class="line">159:</span><br><span class="line">160:</span><br><span class="line">161:</span><br><span class="line">162:</span><br><span class="line">163:</span><br><span class="line">164:</span><br><span class="line">165:</span><br><span class="line">166:</span><br><span class="line">167:</span><br><span class="line">168:</span><br><span class="line">169:</span><br><span class="line">170:</span><br><span class="line">171:</span><br><span class="line">172:</span><br><span class="line">173:</span><br><span class="line">174:</span><br><span class="line">175:</span><br><span class="line">176:</span><br></pre></td></tr></table></figure><p>获取CPU的处理信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 ~]# for i in &#123;157..176&#125;;do cat /proc/interrupts  | egrep -w $i ;done</span><br><span class="line"> 157:   13529132          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-tx-0</span><br><span class="line"> 158:   32642550          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-1</span><br><span class="line"> 159:   30481981          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-2</span><br><span class="line"> 160:   15555217          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-3</span><br><span class="line"> 161:   25509530          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-4</span><br><span class="line"> 162:   13538297          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-tx-0</span><br><span class="line"> 163:   25653580          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-1</span><br><span class="line"> 164:   25741710          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-2</span><br><span class="line"> 165:   35448970          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-3</span><br><span class="line"> 166:   25494937          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-4</span><br><span class="line"> 167:     256824          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-tx-0</span><br><span class="line"> 168:     281534          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-1</span><br><span class="line"> CAL:        133     863797        189        189        189        189        188        189        189        189        189        189        189        189        189        189        188        188        168        185        188        186        188        188        188        188        188        188        188        189        187        130   Function call interrupts</span><br><span class="line"> 169:      64639          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-2</span><br><span class="line"> 170:      65879          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-3</span><br><span class="line"> 171:     425700          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-4</span><br><span class="line"> 172:     256754          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-tx-0</span><br><span class="line"> 173:      43230          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-1</span><br><span class="line"> 174:          4          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-2</span><br><span class="line"> 175:          5          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-3</span><br><span class="line"> 176:          3          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-4</span><br><span class="line">[root@lvs001 ~]#</span><br></pre></td></tr></table></figure><p>这里显示不友好，建议复制到编辑器中查看</p><p>可以看到，这些网卡的中断都是由CPU0来处理的</p><p><strong>查看</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs002 ~]# for i in &#123;157..176&#125;;do cat /proc/irq/$i/smp_affinity;done</span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;157..176&#125;;do echo ffffffff &gt; /proc/irq/$i/smp_affinity;done</span><br></pre></td></tr></table></figure><h2 id="Netfilter-Connection-Track-连接跟踪"><a href="#Netfilter-Connection-Track-连接跟踪" class="headerlink" title="Netfilter Connection Track-连接跟踪"></a>Netfilter Connection Track-连接跟踪</h2><p><strong>原文：</strong></p><p><a href="http://kb.linuxvirtualserver.org/wiki/IPVS" target="_blank" rel="noopener">IPVS</a> uses its own simple and fast connection tracking for performance reasons, instead of using netfilter connection tracking. So, if you don’t use firewalling feature at <a href="http://kb.linuxvirtualserver.org/wiki/Load_balancer" target="_blank" rel="noopener">load balancer</a> and you need an extremely fast load balancer, do not load netfilter conntrack modules into you system, because there is no need to do double tracking. Note that <a href="http://kb.linuxvirtualserver.org/wiki/LVS/NAT" target="_blank" rel="noopener">LVS/NAT</a> should work too without the conntrack modules.</p><p>Julian compared the performance of IPVS with ip_conntrack and without ip_conntrack. See <a href="http://archive.linuxvirtualserver.org/html/lvs-users/2001-12/msg00141.html" target="_blank" rel="noopener">http://archive.linuxvirtualserver.org/html/lvs-users/2001-12/msg00141.html</a></p><p>默认情况下LVS自身会记录连接信息，但是 iptables 也会记录 connection 的状态，但是很多情况下，我们并不需要 iptables 来做这件事，</p><p>我们可以告诉它 NOTRACK，不要记录这些信息。</p><p><strong>配置：</strong></p><p>增加raw表，在其他表处理之前，-j NOTRACK跳过其它表处理 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -t raw -A PREROUTING -d 103.13.244.16/29 -p tcp --dport 80 -j NOTRACK </span><br><span class="line">iptables -t raw -A OUTPUT -d 103.13.244.16/29 -p tcp --dport 80 -j NOTRACK </span><br><span class="line">iptables -t raw -A PREROUTING -d 103.13.244.16/29 -p tcp --dport 443 -j NOTRACK </span><br><span class="line">iptables -t raw -A OUTPUT -d 103.13.244.16/29 -p tcp --dport 443 -j NOTRACK </span><br><span class="line"></span><br><span class="line">[root@lvs002 ~]# /etc/init.d/iptables  save</span><br></pre></td></tr></table></figure><p>与之同时，因为涉及到内网之间的通信，因此这里也将连接跟踪表进行调大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">net.netfilter.nf_conntrack_max = 3065536 </span><br><span class="line">net.nf_conntrack_max = 3065536 </span><br><span class="line"></span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure><h2 id="Real-Server-syn-cookie参数"><a href="#Real-Server-syn-cookie参数" class="headerlink" title="Real Server - syn cookie参数"></a>Real Server - syn cookie参数</h2><p>参考链接：</p><ul><li><a href="https://link.zhihu.com/?target=http%3A//archive.linuxvirtualserver.org/html/lvs-users/2013-05/msg00020.html" target="_blank" rel="noopener">lvs-users IPVS SYN-cookies</a>  </li></ul><p>SYN Cookie是对TCP服务器端的<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">三次握手协议</a>作一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP ACK包时，TCP服务器在根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。 </p><p>SYN Flood攻击利用的是IPv4中TCP协议的<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" target="_blank" rel="noopener">三次握手</a>（Three-Way Handshake）过程进行的攻击。TCP协议规定，一端向另一端发起TCP连接时，它需要首先发送SYN 包到对方，对方收到后发送一个SYN+ACK包回来，发起方再发送 ACK包回去，这样<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" target="_blank" rel="noopener">三次握手</a>就结束了。我们把TCP连接的发起方叫作”TCP客户机（TCP Client）”，TCP连接的接收方叫作”TCP服务器（TCP Server）”。值得注意的是在TCP服务器收到TCP SYN request包时，在发送TCP SYN+ACK包回TCP客户机前，TCP服务器要先分配好一个数据区专门服务于这个即将形成的TCP连接。一般把收到SYN包而还未收到ACK包时的连接状态称为半开连接（Half-open Connection）。</p><p>在最常见的SYN Flood攻击中，攻击者在短时间内发送大量的TCP SYN包给受害者，这时攻击者是TCP客户机，受害者是TCP服务器。根据上面的描述，受害者会为每个TCP SYN包分配一个特定的数据区，只要这些SYN包具有不同的源地址（这一点对于攻击者来说是很容易伪造的）。这将给TCP<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">服务器系统</a>造成很大的系统负担，最终导致系统不能正常工作。</p><p><a href="https://github.com/torvalds/linux/blob/6b15d6650c5301ce023d8df0cc3a60b1a76d377e/Documentation/networking/ip-sysctl.txt#L66" target="_blank" rel="noopener">内核文档说明</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">tcp_syncookies - BOOLEAN</span><br><span class="line">Only valid when the kernel was compiled with CONFIG_SYN_COOKIES</span><br><span class="line">Send out syncookies when the syn backlog queue of a socket</span><br><span class="line">overflows. This is to prevent against the common &apos;SYN flood attack&apos;</span><br><span class="line">Default: 1</span><br><span class="line"></span><br><span class="line">Note, that syncookies is fallback facility.</span><br><span class="line">It MUST NOT be used to help highly loaded servers to stand</span><br><span class="line">against legal connection rate. If you see SYN flood warnings</span><br><span class="line">in your logs, but investigationshows that they occur</span><br><span class="line">because of overload with legal connections, you should tune</span><br><span class="line">another parameters until this warning disappear.</span><br><span class="line">See: tcp_max_syn_backlog, tcp_synack_retries, tcp_abort_on_overflow.</span><br><span class="line"></span><br><span class="line">syncookies seriously violate TCP protocol, do not allow</span><br><span class="line">to use TCP extensions, can result in serious degradation</span><br><span class="line">of some services (f.e. SMTP relaying), visible not by you,</span><br><span class="line">but your clients and relays, contacting you. While you see</span><br><span class="line">SYN flood warnings in logs not being really flooded, your server</span><br><span class="line">is seriously misconfigured.</span><br><span class="line"></span><br><span class="line">If you want to test which effects syncookies have to your</span><br><span class="line">network connections you can set this knob to 2 to enable</span><br><span class="line">unconditionally generation of syncookies.</span><br></pre></td></tr></table></figure><p>注意，即使开启该机制并不意味着所有的连接都是用SYN cookies机制来完成连接的建立，只有在半连接队列已满的情况下才会触发SYN cookies机制。由于SYN cookies机制严重违背TCP协议，不允许使用TCP扩展，可能对某些服务造成严重的性能影响（如SMTP转发），对于防御SYN flood攻击的确有效。对于没有收到攻击的高负载服务器，不要开启此选项，可以通过修改tcp_max_syn_backlog、tcp_synack_retries和tcp_abort_on_overflow系统参数来调节。</p><p>tcp_max_syn_backlog变量告诉你在内存中可以缓存多少个SYN请求。该变量需要打开tcp_syncookies才有效。如果服务器负载很高，可以尝试提高该变量的值。</p><p>tcp_synack_retries变量用于TCP三次握手机制中第二次握手，当收到客户端发来的SYN连接请求后，服务端将回复SYN+ACK包，这时服务端处于SYN_RCVD状态，并等 待客户端发来的回复ACK包。如果服务端没有收到客户端的ACK包，会重新发送SYN+ACK包，直到收到客户端的ACK包。该变量设置发送 SYN+ACK包的次数，超过这个次数，服务端将放弃连接。默认值是5。</p><p>tcp_abort_on_overflow变量的值是个布尔值，默认值为0（FALSE关闭）。如果开启，当服务端接收新连接的速度变慢时，服务端会发送RST包（reset包）给客户端，令客户端 重新连接。这意味着如果突然发生溢出，将重获连接。仅当你真的确定不能通过调整监听进程使接收连接的速度变快，可以启用该选项。该选项会影响到客户的连接。</p><p><strong>配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sysctl.conf </span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 2048</span><br><span class="line">保存退出后，执行：</span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><p>net.ipv4.tcp_syncookies = 1<br>#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN<em>*</em>，默认为0，表示关闭；</p><p>net.ipv4.tcp_tw_reuse = 1<br>#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；为1，开启；</p><p>这个酌情开启，这里暂时不开启</p><p>net.ipv4.tcp_tw_recycle = 1<br>#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；为1，开启；</p><p>net.ipv4.tcp_fin_timeout</p><p>#修改系統默认的 TIMEOUT 时间，<strong>这里根据服务器的实际情况设置</strong>。默认为60秒</p><p>  另外细心的朋友可能发现了，报错信息： Possible SYN flooding on port 13370. Sending cookies.后面跟了句”Check SNMP counters”。这句我当时差点被误导，因为我的服务器上正好跑了一个snmp抓流量的服务，开始以为是它导致的，后来一想那是udp的协议，和tcp没关系呀。查了<a href="https://github.com/torvalds/linux/blob/797cee982eef9195736afc5e7f3b8f613c41d19a/net/ipv4/tcp_input.c" target="_blank" rel="noopener">kernel</a>的代码发现，原来那是print打印的固定info输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static bool tcp_syn_flood_action(const struct sock *sk,</span><br><span class="line">                const struct sk_buff *skb,</span><br><span class="line">                const char *proto)</span><br><span class="line">&#123;</span><br><span class="line">    struct request_sock_queue *queue = &amp;inet_csk(sk)-&gt;icsk_accept_queue;</span><br><span class="line">    const char *msg = &quot;Dropping request&quot;;</span><br><span class="line">    bool want_cookie = false;</span><br><span class="line">    struct net *net = sock_net(sk);</span><br><span class="line">#ifdef CONFIG_SYN_COOKIES</span><br><span class="line">    if (net-&gt;ipv4.sysctl_tcp_syncookies) &#123;</span><br><span class="line">        msg = &quot;Sending cookies&quot;;</span><br><span class="line">        want_cookie = true;</span><br><span class="line">        __NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPREQQFULLDOCOOKIES);</span><br><span class="line">    &#125; else</span><br><span class="line">#endif</span><br><span class="line">        __NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPREQQFULLDROP);</span><br><span class="line">    if (!queue-&gt;synflood_warned &amp;&amp;</span><br><span class="line">    net-&gt;ipv4.sysctl_tcp_syncookies != 2 &amp;&amp;</span><br><span class="line">    xchg(&amp;queue-&gt;synflood_warned, 1) == 0)</span><br><span class="line">        pr_info(&quot;%s: Possible SYN flooding on port %d. %s.  Check SNMP counters.\n&quot;,</span><br><span class="line">            proto, ntohs(tcp_hdr(skb)-&gt;dest), msg);</span><br><span class="line">    return want_cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭网卡LRO和GRO"><a href="#关闭网卡LRO和GRO" class="headerlink" title="关闭网卡LRO和GRO"></a>关闭网卡LRO和GRO</h2><p>现在大多数网卡都具有LRO/GRO功能，即 网卡收包时将同一流的小包合并成大包 （tcpdump抓包可以看到&gt;MTU 1500bytes的数据包）交给 内核协议栈；LVS内核模块在处理&gt;MTU的数据包时，会丢弃；</p><p>因此，如果我们用LVS来传输大文件，很容易出现丢包，传输速度慢；</p><p>解决方法，关闭LRO/GRO功能，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ethtool -k eth0 查看LRO/GRO当前是否打开</span><br><span class="line">ethtool -K eth0 lro off 关闭GRO</span><br><span class="line">ethtool -K eth0 gro off 关闭GRO</span><br><span class="line"></span><br><span class="line">查看：</span><br><span class="line">[root@lvs001 ~]# ethtool -k p1p1 | grep offload</span><br><span class="line">[root@lvs001 ~]# ethtool -k p1p2 | grep offload</span><br><span class="line"></span><br><span class="line">配置：</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p1 lro off</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p1 gro off</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p2 lro off</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p2 gro off</span><br></pre></td></tr></table></figure><p>offload特性，主要是指将原本在协议栈中进行的IP分片、TCP分段、重组、checksum校验等操作，转移到网卡硬件中进行，降低系统CPU的消耗，提高处理性能。 </p><p>包括 LSO/LRO、GSO/GRO、TSO/UFO 等。</p><p><strong>LSO/LRO</strong></p><p>分别对应到发送和接收两个方向，是 Large Segment Offload 和 Large Receive Offload。</p><p>首先来看 LSO。我们知道计算机网络上传输的数据基本单位是离散的网包，既然是网包，就有大小限制，这个限制就是 MTU（Maximum Transmission Unit）的大小，一般是1518字节。比如我们想发送很多数据出去，经过os协议栈的时候，会自动帮你拆分成几个不超过MTU的网包。然而，这个拆分是比较费计算资源的（比如很多时候还要计算分别的checksum），由 CPU 来做的话，往往会造成使用率过高。那可不可以把这些简单重复的操作 offload 到网卡上呢？</p><p>于是就有了 LSO，在发送数据超过 MTU 限制的时候（太容易发生了），OS 只需要提交一次传输请求给网卡，网卡会自动的把数据拿过来，然后进行切，并封包发出，发出的网包不超过 MTU 限制。</p><p>接下来看 LSO，当网卡收到很多碎片包的时候，LRO 可以辅助自动组合成一段较大的数据，一次性提交给 OS处理。</p><p>一般的，LSO 和 LRO 主要面向 TCP 报文。</p><p><strong>GSO/GRO</strong></p><p>Generic Segmentation Offload 和 Generic Receive Offload，分别比 LSO 和 LRO 更通用，自动检测网卡支持特性，支持分包则直接发给网卡，否则先分包后发给网卡。新的驱动一般用 GSO/GRO。 </p><p><strong>TSO/UFO</strong></p><p>TCP Segmentation Offload 和 UDP fragmentation offload，分别对应 TCP 报文和 UDP 报文。</p><p>很典型的，TCP 协议中就考虑了分片存在的情况，往往是切分 TCP 的数据包，叫做 TSO。而一般的情况，则称为 LSO 或者 GSO。</p><p>对于其他不支持切片的协议例如 UDP，则只能进行 IP 层上的切片。</p><p><strong>检查与开关</strong></p><p>可以通过 <code>ethtool -k eth0</code> 命令来查看各个选项的当前状态，注意输出中各种 off-load 选项的状态。 </p><p><strong>总结</strong></p><p>也就是说，在将数据包转发出去的时候，包的大小必须小于1500字节，但是在处理收到的数据包的时候，包的大小没有1500字节的限制</p><ul><li>发送模式：<ul><li>TSO</li><li>GSO</li><li>UFO</li></ul></li><li>接收模式：<ul><li>LRO</li><li>GRO</li><li>RSS</li></ul></li></ul><p><strong>注意</strong></p><p>目前常用的抓包工具大部分都是从协议栈中（如数据链路层）捕获数据包，而网卡的offload特性会将数据包的分片、重组等工作转移到协议栈以下的硬件层面进行，因此在开启TSO、GRO等机制的情况下，我们使用tcpdump、wireshark等工具抓取到的数据包往往不能真实反应链路上实际的数据帧，给网络流量特征的分析造成不利影响。</p><p>在某些情况下，例如分片攻击等攻击方式，甚至可能会因为网卡设备的offload机制处理，而规避防火墙、IDS以及人工的检查。针对这些情况，可以选择关闭网卡offload的相关选项，或者在链路的其他节点进行抓包。</p><h2 id="proc下的IP-VS参数设置"><a href="#proc下的IP-VS参数设置" class="headerlink" title="/proc下的IP_VS参数设置"></a>/proc下的IP_VS参数设置</h2><p>根据前文的介绍，可以通过ipvsadm命令和LVS内核打交道；</p><p>除此之外，我们还可以通过proc参数，来 配置全局参数 和 获取统计信息；</p><ul><li>配置全局参数，位于目录/proc/sys/net/ipv4/vs/下；</li><li>获取统计信息，位于目录/proc/net/下；</li></ul><p>参考资料：<a href="https://github.com/torvalds/linux/blob/master/Documentation/networking/ipvs-sysctl.txt#L41" target="_blank" rel="noopener">官方内核文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 ~]# ll /proc/sys/net/ipv4/vs | awk &apos;&#123;print $9&#125;&apos;</span><br><span class="line">am_droprate</span><br><span class="line">amemthresh</span><br><span class="line">cache_bypass</span><br><span class="line">conn_reuse_mode</span><br><span class="line">drop_entry</span><br><span class="line">drop_packet</span><br><span class="line">expire_nodest_conn</span><br><span class="line">expire_quiescent_template</span><br><span class="line">nat_icmp_send</span><br><span class="line">secure_tcp</span><br><span class="line">sync_qlen_max</span><br><span class="line">sync_refresh_period</span><br><span class="line">sync_retries</span><br><span class="line">sync_sock_size</span><br><span class="line">sync_threshold</span><br><span class="line">sync_version</span><br></pre></td></tr></table></figure><p>有一些几个参数需要进行调整</p><ul><li><p>cache_bypass </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cache_bypass - BOOLEAN</span><br><span class="line">        0 - disabled (default)</span><br><span class="line">        not 0 - enabled</span><br><span class="line"></span><br><span class="line">        If it is enabled, forward packets to the original destination</span><br><span class="line">        directly when no cache server is available and destination</span><br><span class="line">        address is not local (iph-&gt;daddr is RTN_UNICAST). It is mostly</span><br><span class="line">        used in transparent web cache cluster.</span><br></pre></td></tr></table></figure><p>主要用于缓存体系，enable之后，当后端配置的是缓存系统的时候，当没有可用的sever时，直接将数据包转发给后端的数据产生节点</p></li></ul><ul><li><p>conn_reuse_mode </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">conn_reuse_mode - INTEGER</span><br><span class="line">1 - default</span><br><span class="line"></span><br><span class="line">Controls how ipvs will deal with connections that are detected</span><br><span class="line">port reuse. It is a bitmap, with the values being:</span><br><span class="line"></span><br><span class="line">0: disable any special handling on port reuse. The new</span><br><span class="line">connection will be delivered to the same real server that was</span><br><span class="line">servicing the previous connection. This will effectively</span><br><span class="line">disable expire_nodest_conn.</span><br><span class="line"></span><br><span class="line">bit 1: enable rescheduling of new connections when it is safe.</span><br><span class="line">That is, whenever expire_nodest_conn and for TCP sockets, when</span><br><span class="line">the connection is in TIME_WAIT state (which is only possible if</span><br><span class="line">you use NAT mode).</span><br><span class="line"></span><br><span class="line">bit 2: it is bit 1 plus, for TCP connections, when connections</span><br><span class="line">are in FIN_WAIT state, as this is the last state seen by load</span><br><span class="line">balancer in Direct Routing mode. This bit helps on adding new</span><br><span class="line">real servers to a very busy cluster.</span><br></pre></td></tr></table></figure><p>用户后端server开启端口reuse（端口复用，服务器上启动多个进程监听同一个端口，在tenginx中使用时能够极大的提高性能）的情况。</p><p>当设置enable的时候，接受到新连接之后，将进行重新调度，将连接请求分发到启动该端口的其他进程上</p></li><li><p>expire_nodest_conn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">expire_nodest_conn - BOOLEAN</span><br><span class="line">        0 - disabled (default)</span><br><span class="line">        not 0 - enabled</span><br><span class="line"></span><br><span class="line">        The default value is 0, the load balancer will silently drop</span><br><span class="line">        packets when its destination server is not available. It may</span><br><span class="line">        be useful, when user-space monitoring program deletes the</span><br><span class="line">        destination server (because of server overload or wrong</span><br><span class="line">        detection) and add back the server later, and the connections</span><br><span class="line">        to the server can continue.</span><br><span class="line"></span><br><span class="line">        If this feature is enabled, the load balancer will expire the</span><br><span class="line">        connection immediately when a packet arrives and its</span><br><span class="line">        destination server is not available, then the client program</span><br><span class="line">        will be notified that the connection is closed. This is</span><br><span class="line">        equivalent to the feature some people requires to flush</span><br><span class="line">        connections when its destination is not available.</span><br></pre></td></tr></table></figure><p>设置为0时，当后端的server被检测为不可用时，不会立即将连接断开，而是会保持一段时间，让其自然过期失效，如果在这个过程当中，server又恢复正常，那么将继续使用这个连接</p><p>当设置为为enable（非0）时，当检测到后端的server不可用时，将会立即将这个连接关闭。</p></li><li><p>expire_quiescent_template </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">expire_quiescent_template - BOOLEAN</span><br><span class="line">0 - disabled (default)</span><br><span class="line">not 0 - enabled</span><br><span class="line"></span><br><span class="line">When set to a non-zero value, the load balancer will expire</span><br><span class="line">persistent templates when the destination server is quiescent.</span><br><span class="line">This may be useful, when a user makes a destination server</span><br><span class="line">quiescent by setting its weight to 0 and it is desired that</span><br><span class="line">subsequent otherwise persistent connections are sent to a</span><br><span class="line">different destination server.  By default new persistent</span><br><span class="line">connections are allowed to quiescent destination servers.</span><br><span class="line"></span><br><span class="line">If this feature is enabled, the load balancer will expire the</span><br><span class="line">persistence template if it is to be used to schedule a new</span><br><span class="line">connection and the destination server is quiescent.</span><br></pre></td></tr></table></figure><p>默认值为0，当RS的weight为0时（例如健康监测失败时，LB会将RS的权重重置为0），会话保持的新建连接还会继续调度到该RS上</p><p>如果设置为非0，那么当weight为0时，LB会将话保持的连接模板置为无效，重新调度新的RS； </p></li><li><p>sync_threshold</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sync_threshold - vector of 2 INTEGERs: sync_threshold, sync_period</span><br><span class="line">default 3 50</span><br><span class="line"></span><br><span class="line">It sets synchronization threshold, which is the minimum number</span><br><span class="line">of incoming packets that a connection needs to receive before</span><br><span class="line">the connection will be synchronized. A connection will be</span><br><span class="line">synchronized, every time the number of its incoming packets</span><br><span class="line">modulus sync_period equals the threshold. The range of the</span><br><span class="line">threshold is from 0 to sync_period.</span><br><span class="line"></span><br><span class="line">When sync_period and sync_refresh_period are 0, send sync only</span><br><span class="line">for state changes or only once when pkts matches sync_threshold</span><br></pre></td></tr></table></figure><p> 同步阈值设置，该文件中的值为两个整数，默认为3 50 </p><p>数值表示含义如下（以3 50为例）：接受到3个数据包及以上，该连接就可以被同步</p></li></ul><h2 id="Linux系统调优-网络内核参数"><a href="#Linux系统调优-网络内核参数" class="headerlink" title="Linux系统调优-网络内核参数"></a>Linux系统调优-网络内核参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_recyle=1</span><br><span class="line">net.ipv4.tcp_tw_reuse=1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=8192</span><br><span class="line">net.ipv4.tcp_keepalive_time=1800</span><br><span class="line">net.ipv4.tcp_fin_timeout=30</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.ipv4.tcp_rmem=4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem=4096 65536 16777216</span><br><span class="line">net.core.netdev_max_backlog=3000</span><br></pre></td></tr></table></figure><h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><p><strong>SH调度算法</strong>-<strong>尽量不要采用</strong>  </p><p>一些业务为了支持会话保持，选择SH调度算法，以实现 同一源ip的请求调度到同一台RS上；但 SH算法本省没有实现一致性hash，一旦一台RS down，当前所有连接都会断掉；如果配置了inhibit_on_failure，那就更悲剧了，调度到该RS上的流量会一直损失；     实际线上使用时，如需<strong>会话保持</strong>，建议配置<strong>persistence_timeout参数，</strong>保证一段时间同一源ip的请求到同一RS上； </p><p><strong>WLC调度算法-注意RS donw-&gt;up的影响</strong>    </p><p>WLC算法下，RS一旦出现down后up的情况，瞬间所有的新建连接都会调度到该RS上，可能会超过该RS处理请求的上限；  </p><h2 id="快速配置"><a href="#快速配置" class="headerlink" title="快速配置"></a>快速配置</h2><p>[root@lvs002 ~]# vim /etc/sysctl.conf </p><p>[root@lvs002 ~]# sysctl  -p</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">kernel.sysrq = 0</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line">net.core.netdev_max_backlog = 2048</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 462144</span><br><span class="line">vm.swappiness = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 65535</span><br><span class="line">net.core.somaxconn = 32768</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.netfilter.nf_conntrack_max = 3065536</span><br><span class="line">net.nf_conntrack_max = 3065536</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1800</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 16777216</span><br><span class="line">net.core.netdev_max_backlog = 3000</span><br></pre></td></tr></table></figure><h1 id="LVS监控"><a href="#LVS监控" class="headerlink" title="LVS监控"></a>LVS监控</h1><p>一般情况下，我们可以通过watch ipvsadm -ln来监视lvs的当前状态，但如果我们想分析一段时间（一周，一月或者更长）的连接数情况，ipvsadm就无能为力了。我们可以借助一个叫lvs-rrd的小工具来达到这个目的。</p><p>lvs-rrd官网链接：<a href="http://tepedino.org/lvs-rrd/" target="_blank" rel="noopener">http://tepedino.org/lvs-rrd/</a></p><p>但是在这里，由于这个工具只能收集连接数的数据，因此我们还是采用zabbix进行集中监控</p><h2 id="使用lvs-rrd监控lvs状态"><a href="#使用lvs-rrd监控lvs状态" class="headerlink" title="使用lvs-rrd监控lvs状态"></a>使用lvs-rrd监控lvs状态</h2><p><a href="http://www.tepedino.org/lvs-rrd/" target="_blank" rel="noopener">lvs_rrd</a>工具实现了网页的形式来查看lvs状态功能。</p><p>其主要有两个脚本组成：信息收集脚本和图像绘制脚本。</p><p>信息收集脚本是将lvs的信息生成rrd格式的数据文件，然后利用图像绘制脚本生成图像，并生成一个php页面，这个页面中引用其所生成的图像，这样我们可以通过web页面的形式查看生成的php页面，就可以时时的查看lvs的状态信息。</p><p>lvs_rrd需要部署在LVS-Master和LVS-Backup上，更准确的说lvs_rrd中的信息收集脚本一定要在LVS director 上运行（不能安装在其他服务器上）。</p><p>但是通过配置图像生成脚本和图像的生成目录，我们也可以将源数据时时的复制到其他的服务器中，再在其他服务器上生成图像展示</p><p>下面简单的介绍部署的步骤</p><p><strong>下载安装rrdtool（画图）工具</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://oss.oetiker.ch/rrdtool/pub/rrdtool-1.4.7.tar.gz</span><br><span class="line"></span><br><span class="line">yum -y install cairo-devel libxml2-devel pango-devel pango libpng-devel freetype freetype-devel libart_lgpl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker dejavu-lgc-sans-fonts</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/rrdtool</span><br><span class="line">make &amp;&amp;  make install </span><br><span class="line"></span><br><span class="line">echo &quot;/usr/local/rrdtool/lib&quot; &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><p><strong>安装nginx</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre pcre-devel php php-fpm</span><br><span class="line"></span><br><span class="line">useradd -s /sbin/nologin nginx</span><br><span class="line"></span><br><span class="line">wget https://nginx.org/download/nginx-1.14.0.tar.gz</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module --with-pcre</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>注意修改nginx的监听端口为非80</p><p><strong>nginx+php配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/php-fpm start</span><br><span class="line">chkconfig php-fpm on</span><br></pre></td></tr></table></figure><p>在nginx配置文件中添加以下内容</p><pre><code>location ~ \.php$ {    root           html;    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;    include        fastcgi_params;}</code></pre><p><strong>下载安装lvs-rrd工具</strong></p><p>这里使用最新的0.7版本，该版本要求rrdtool版本最低为： 1.2.x </p><p>将lvs-rrd-v0.7.tar.gz解压后将文件夹复制到/data/www/目录下并更名为lvs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://tepedino.org/lvs-rrd/lvs-rrd-v0.7.tar.gz</span><br><span class="line">tar -zxvf lvs-rrd-v0.7.tar.gz</span><br><span class="line"></span><br><span class="line">mv lvs-rrd-v0.7 /usr/local/nginx/html/lvs-rrd</span><br></pre></td></tr></table></figure><p>修改相应的脚本文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim lvs.rrd.update 修改以下内容</span><br><span class="line"></span><br><span class="line">RRDTOOL=&quot;/usr/local/rrdtool/bin/rrdtool&quot;#rrdtool可执行程序路径</span><br><span class="line">IPVSADM=&quot;/sbin/ipvsadm&quot;   #ipvsadm命令路径</span><br><span class="line">WORKDIR=&quot;/data1/lvs-rrd&quot;   #rrdtool收集的数据的存放路径</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim graph-lvs.sh 修改以下内容</span><br><span class="line"></span><br><span class="line"># WORKDIR must match the directory used in the update script.</span><br><span class="line">WORKDIR=&quot;/data1/lvs-rrd&quot;#rrdtool收集的数据的存放路径,同上面一致</span><br><span class="line">RRDTOOL=&quot;/usr/local/rrdtool/bin/rrdtool&quot;  #rrdtool可执行程序路径</span><br><span class="line"># Where to put the graphs. </span><br><span class="line">GRAPHS=&quot;/data1/lvs-rrd/graphs&quot;#生成的图片保存路径</span><br><span class="line">WEBPATH=&quot;/lvs-rrd/graphs&quot;#web访问的路径</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim lvs-rrd.php</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">header(&quot;Cache-Control: max-age=300, must-revalidate&quot;);</span><br><span class="line">system(&quot;/usr/local/nginx/html/lvs-rrd/graph-lvs.sh -H&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注意：WEBPATH的配置是浏览器实际访问时图片的访问路径，也就是<a href="http://ip:port/webpath/xxx.gif" target="_blank" rel="noopener">http://ip:port/webpath/xxx.gif</a></p><p>在日志中的输出显示为：</p><p>/usr/local/nginx/html/lvs-rrd/graphs/lvs.All.All.All.All.All-year.gif</p><p>因此需要手动在站点目录下创建该目录并创建软链接，将<code>生成的图片保存路径</code>链接到该目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/nginx/html/lvs-rrd/graphs</span><br><span class="line">ln -s /data1/lvs-rrd/graphs /usr/local/nginx/html/lvs-rrd/graphs</span><br></pre></td></tr></table></figure><p><strong>配置nginx认证</strong></p><p>在nginx配置文件的server中配置如下两行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth_basic              &quot;dwd&quot;;</span><br><span class="line">auth_basic_user_file    htpasswd;</span><br></pre></td></tr></table></figure><p>然后执行以下命令创建加密文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -bc htpasswd  ops-lvs Dwd_Ops_123</span><br></pre></td></tr></table></figure><p><strong>配置计划任务</strong></p><p>这里，将更新数据的间隔时间设置为30s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /usr/local/nginx/html/lvs-rrd/lvs.rrd.update &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * /usr/local/nginx/html/lvs-rrd/graph-lvs.sh -H &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * sleep 30 ; /usr/local/nginx/html/lvs-rrd/lvs.rrd.update &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * sleep 30 ; /usr/local/nginx/html/lvs-rrd/graph-lvs.sh -H &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="Zabbix监控LVS"><a href="#Zabbix监控LVS" class="headerlink" title="Zabbix监控LVS"></a>Zabbix监控LVS</h2><p><strong>监控指标：</strong></p><p>动态的数据：</p><ul><li>cps(connect per second) ，每秒的连接数情况</li><li>InPPS(input packge per second)，每秒的入向数据包数量情况</li><li>OutPPS(output packge per second)，每秒的出向数据包数量情况</li><li>InBPS（input byte per second）,每秒的流入字节数情况</li><li>OutBPS(output byte per second)，每秒的流出字节数情况</li><li>ActiveConn，处于ESAT的连接（使用系统的netstat无法看到）</li><li>InActConn，处于非ESAT的连接（使用系统的netstat无法看到）</li></ul><p>静态统计数据：</p><ul><li>Conns，自启动之后的总连接数</li><li>InPkts，自启动之后的总入向数据包数量统计</li><li>OutPkts，自启动之后的总出向数据包数量统计</li><li>InBytes，自启动之后的总入向字节数统计</li><li>OutBytes，自启动之后的总出向字节数统计</li></ul><p><strong>监控逻辑：</strong></p><p>使用ipvsadm命令从服务器中采集数据</p><p>所使用的命令分别为：</p><ul><li>ipvsadm -Ln –rate</li><li>ipvsadm -Ln –stats</li></ul><p><strong>注意：</strong>zabbix配置文件中需要打开sudo的权限，拥有root的权限之后才能执行ipvsadm命令去获取数据</p>]]></content>
    
    <summary type="html">
    
      LVS性能指标及监控
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="高并发" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="4层负载均衡-LVS" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/4%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-LVS/"/>
    
    
      <category term="LVS" scheme="http://yoursite.com/tags/LVS/"/>
    
  </entry>
  
  <entry>
    <title>day03-集合及文件操作知识补充+函数</title>
    <link href="http://yoursite.com/2018/07/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day03-%E9%9B%86%E5%90%88%E5%8F%8A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85+%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/07/08/编程语言/Python/老男孩视频学习笔记/day03-集合及文件操作知识补充+函数/</id>
    <published>2018-07-08T12:26:10.000Z</published>
    <updated>2018-07-08T12:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合是一个无序的，不重复的数据组合，它的主要作用如下：</p><ul><li>去重，把一个列表变成集合，就自动去重了</li><li>关系测试，测试两组数据之前的交集、差集、并集等关系</li></ul><p><strong>集合创建：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4,5,7,6,6,1,7,8]</span><br><span class="line">list_set = set(list)</span><br><span class="line">print (list_set,type(list_set))</span><br><span class="line"></span><br><span class="line">set1 = set()</span><br><span class="line">print (set1,type(set1))</span><br><span class="line"></span><br><span class="line">执行后输出如下：</span><br><span class="line">&#123;1, 2, 3, 4, 5, 6, 7, 8&#125; &lt;class &apos;set&apos;&gt;</span><br><span class="line">set() &lt;class &apos;set&apos;&gt;</span><br></pre></td></tr></table></figure><p><strong>高级操作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = t | s          # t 和 s的并集  </span><br><span class="line">  </span><br><span class="line">b = t &amp; s          # t 和 s的交集  </span><br><span class="line">  </span><br><span class="line">c = t – s          # 求差集（项在t中，但不在s中）  </span><br><span class="line">  </span><br><span class="line">d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中），也就是在并集中去除掉了交集</span><br></pre></td></tr></table></figure><p><strong>其他操作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.add(&apos;x&apos;)            # 添加一项  </span><br><span class="line">  </span><br><span class="line">s.update([10,37,42])  # 在s中添加多项</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用remove()可以删除一项：  </span><br><span class="line">  </span><br><span class="line">t.remove(&apos;H&apos;)  </span><br><span class="line"></span><br><span class="line">还有discard()方法可以删除，但是当元素不存在的时候，它不会和remove一样报错</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">len(s)  </span><br><span class="line">set 的长度  </span><br><span class="line">  </span><br><span class="line">x in s  </span><br><span class="line">测试 x 是否是 s 的成员  </span><br><span class="line">  </span><br><span class="line">x not in s  </span><br><span class="line">测试 x 是否不是 s 的成员  </span><br><span class="line">  </span><br><span class="line">s.issubset(t)  </span><br><span class="line">s &lt;= t  </span><br><span class="line">测试是否 s 中的每一个元素都在 t 中  </span><br><span class="line">  </span><br><span class="line">s.issuperset(t)  </span><br><span class="line">s &gt;= t  </span><br><span class="line">测试是否 t 中的每一个元素都在 s 中  </span><br><span class="line">  </span><br><span class="line">s.union(t)  </span><br><span class="line">s | t  </span><br><span class="line">返回一个新的 set 包含 s 和 t 中的每一个元素  </span><br><span class="line">  </span><br><span class="line">s.intersection(t)  </span><br><span class="line">s &amp; t  </span><br><span class="line">返回一个新的 set 包含 s 和 t 中的公共元素  </span><br><span class="line">  </span><br><span class="line">s.difference(t)  </span><br><span class="line">s - t  </span><br><span class="line">返回一个新的 set 包含 s 中有但是 t 中没有的元素  </span><br><span class="line">  </span><br><span class="line">s.symmetric_difference(t)  </span><br><span class="line">s ^ t  </span><br><span class="line">返回一个新的 set 包含 s 和 t 中不重复的元素  </span><br><span class="line">  </span><br><span class="line">s.copy()  </span><br><span class="line">返回 set “s”的一个浅复制  </span><br><span class="line"></span><br><span class="line">判断两个集合是否有交集</span><br><span class="line">s1 = set([1,2,3,4,5,6])</span><br><span class="line">s2 = set([2,4,6,8,10])</span><br><span class="line">s3 = set([11,22,44,55])</span><br><span class="line">print (s1.isdisjoint(s2))</span><br><span class="line">print (s1.isdisjoint(s3))</span><br><span class="line">输出为：</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="文件操作相关知识"><a href="#文件操作相关知识" class="headerlink" title="文件操作相关知识"></a>文件操作相关知识</h2><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>read()方法，一次性读取文件的所有内容，当文件非常大的时候非常不建议</p><p>readline()方法，一次只读取文件的一行，从上往下的顺序</p><p>readlines()方法，将文件的内容按行一次性重新输出为一个==列表==，每行一个元素</p><p>read()和readlines()方法都是一次性读取文件的全部内容，只适合于小文件，不适合大文件</p><p>readline()是一行一行的读取，在大文件的时候也是十分占用内存的</p><p>注意，以上这三种方法只适合读取小文件，在读取大文件的时候，不能够再使用这种方法。</p><p>思路：文件的内容，打印完一行之后就不再需要这一行了，因此已经读取的内容就没有必要再存储在内存当中，在内存中永远只保存一行</p><p>写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f =  open(r&apos;C:\Users\Administrator\PycharmProjects\files\login.txt&apos;, &apos;r&apos;)</span><br><span class="line">for line in f:</span><br><span class="line">    print(line)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="tell-和seek-文件位置"><a href="#tell-和seek-文件位置" class="headerlink" title="tell()和seek()-文件位置"></a>tell()和seek()-文件位置</h2><p>tell打印当前文件内容的输出位置，seek将当前光标重新定向到指定的位置</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(f.readline())</span><br><span class="line">print(f.readline())</span><br><span class="line">print (f.tell())</span><br><span class="line">f.seek(0)</span><br><span class="line">print (f.readline())</span><br><span class="line"></span><br><span class="line">执行后输出为：</span><br><span class="line">wxh:wxh123</span><br><span class="line">wsy:wsy123</span><br><span class="line">24</span><br><span class="line">wxh:wxh123</span><br></pre></td></tr></table></figure><h2 id="缓存区-flush"><a href="#缓存区-flush" class="headerlink" title="缓存区-flush()"></a>缓存区-flush()</h2><p>在进行循环等操作的时候，程序需要等循环完毕才输出，也就是缓存区满了之后再进行显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys,time</span><br><span class="line">for i in range(50):</span><br><span class="line">    sys.stdout.write(&quot;#&quot;)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    </span><br><span class="line">执行后的程序输出将会是持续的输出#</span><br></pre></td></tr></table></figure><p>使用flush()方法，可以在操作时立即输出</p><h1 id="程序练习"><a href="#程序练习" class="headerlink" title="程序练习"></a>程序练习</h1><h2 id="实现shell-sed替换功能"><a href="#实现shell-sed替换功能" class="headerlink" title="实现shell sed替换功能"></a>实现shell sed替换功能</h2><p>用户输入旧的需要替换的字符和新的字符，通过给脚本传入参数来实现</p><p>可以使用sys模块的argv进行参数获取，然后进行替换操作</p><h2 id="修改haproxy配置文件"><a href="#修改haproxy配置文件" class="headerlink" title="修改haproxy配置文件"></a>修改haproxy配置文件</h2><p>需求</p><ul><li>进入程序之后，可以选择：增、删、改、查等操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1、查</span><br><span class="line">    输入：www.oldboy.org</span><br><span class="line">    获取当前backend下的所有记录</span><br><span class="line"></span><br><span class="line">2、新建</span><br><span class="line">    输入：</span><br><span class="line">        arg = &#123;</span><br><span class="line">            &apos;bakend&apos;: &apos;www.oldboy.org&apos;,</span><br><span class="line">            &apos;record&apos;:&#123;</span><br><span class="line">                &apos;server&apos;: &apos;100.1.7.9&apos;,</span><br><span class="line">                &apos;weight&apos;: 20,</span><br><span class="line">                &apos;maxconn&apos;: 30</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">3、删除</span><br><span class="line">    输入：</span><br><span class="line">        arg = &#123;</span><br><span class="line">            &apos;bakend&apos;: &apos;www.oldboy.org&apos;,</span><br><span class="line">            &apos;record&apos;:&#123;</span><br><span class="line">                &apos;server&apos;: &apos;100.1.7.9&apos;,</span><br><span class="line">                &apos;weight&apos;: 20,</span><br><span class="line">                &apos;maxconn&apos;: 30</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>源文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">global       </span><br><span class="line">        log 127.0.0.1 local2</span><br><span class="line">        daemon</span><br><span class="line">        maxconn 256</span><br><span class="line">        log 127.0.0.1 local2 info</span><br><span class="line">defaults</span><br><span class="line">        log global</span><br><span class="line">        mode http</span><br><span class="line">        timeout connect 5000ms</span><br><span class="line">        timeout client 50000ms</span><br><span class="line">        timeout server 50000ms</span><br><span class="line">        option  dontlognull</span><br><span class="line"></span><br><span class="line">listen stats :8888</span><br><span class="line">        stats enable</span><br><span class="line">        stats uri       /admin</span><br><span class="line">        stats auth      admin:1234</span><br><span class="line"></span><br><span class="line">frontend oldboy.org</span><br><span class="line">        bind 0.0.0.0:80</span><br><span class="line">        option httplog</span><br><span class="line">        option httpclose</span><br><span class="line">        option  forwardfor</span><br><span class="line">        log global</span><br><span class="line">        acl www hdr_reg(host) -i www.oldboy.org</span><br><span class="line">        use_backend www.oldboy.org if www</span><br><span class="line"></span><br><span class="line">backend www.oldboy.org</span><br><span class="line">        server 100.1.7.9 100.1.7.9 weight 20 maxconn 3000</span><br></pre></td></tr></table></figure><p>使用eval实现</p><h1 id="函数基础知识"><a href="#函数基础知识" class="headerlink" title="函数基础知识"></a>函数基础知识</h1><h2 id="函数结构"><a href="#函数结构" class="headerlink" title="函数结构"></a>函数结构</h2><p>面向对象：类 class</p><p>面向过程：过程 def  【过程实际上可以理解为没有返回值的函数】</p><p>函数式编程：函数 def 【函数式逻辑结构化和过程化的一种编程方法】</p><p>注意，过程和函数的定义都是使用def进行标识的</p><p>在python中<strong>定义一个函数</strong>的结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def test(x):</span><br><span class="line">    &quot;&quot;&quot;define the function for test&quot;&quot;&quot;</span><br><span class="line">    x += 1</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line">a = test(1)</span><br><span class="line">print (a)</span><br></pre></td></tr></table></figure><ul><li>def：定义函数的关键字</li><li>test：函数名称</li><li>()：参数列表空间，内可定义形参</li><li>中间是代码块，用于实现程序处理逻辑</li><li>return：定义返回值</li></ul><p>在python当中，过程也是被当做函数来处理，python其实也给过程隐式的定义了返回值None，因此在调用过程的时候，我们也能看到返回值，但是返回值是None</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>将实参传递给形参的时候，有两种方法，</p><ul><li>一种是在括号中直接写实参，例如：test(1,2)，这个时候将会按照这个顺序进行参数的传递，与形参一一对应</li><li>一种是人为的指定赋值对象，例如：test1(x=2,y=1)，这个时候将会按照指定的值进行赋值导入，与形参的顺序无关</li></ul><h3 id="函数为什么要有返回值"><a href="#函数为什么要有返回值" class="headerlink" title="函数为什么要有返回值"></a>函数为什么要有返回值</h3><p>函数有返回值的一个最主要的原因是，我想要这个函数整个的执行结果</p><p>后面的处理逻辑需要根据这个返回值的结果进行相应的操作</p><h2 id="定义不限制数量的函数形参个数"><a href="#定义不限制数量的函数形参个数" class="headerlink" title="定义不限制数量的函数形参个数"></a>定义不限制数量的函数形参个数</h2><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">输出为元祖类型：</span><br><span class="line"></span><br><span class="line">def test(x,*wxh):</span><br><span class="line">    print (x)</span><br><span class="line">    print (wxh)</span><br><span class="line"></span><br><span class="line">test(1,2,2,34,45)</span><br><span class="line">执行后输出如下所示：</span><br><span class="line">1</span><br><span class="line">(2, 2, 34, 45)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出为字典类型：</span><br><span class="line">def test(x,**wxh):</span><br><span class="line">    print (x)</span><br><span class="line">    print (wxh)</span><br><span class="line"></span><br><span class="line">test(1,name=&quot;wxh&quot;,age=6)</span><br><span class="line">执行后输出如下所示：</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">&#123;&apos;name&apos;: &apos;wxh&apos;, &apos;age&apos;: 6&#125;</span><br></pre></td></tr></table></figure><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>测试代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def change_name(name):</span><br><span class="line">    print (&quot;befor change&quot;,name)</span><br><span class="line">    name = &quot;wang xiao hua&quot;</span><br><span class="line">    print (&quot;after change&quot;,name)</span><br><span class="line">name = &quot;wxh&quot;</span><br><span class="line">a1= change_name(name)</span><br><span class="line">print (name)</span><br><span class="line">print (a1)</span><br><span class="line"></span><br><span class="line">执行后的输出如下所示:</span><br><span class="line"></span><br><span class="line">befor change wxh</span><br><span class="line">after change wang xiao hua</span><br><span class="line">wxh</span><br><span class="line">None</span><br></pre></td></tr></table></figure><p>这个测试的效果就是局部变量，局部变量只会在函数里面生效，可以理解为，这个函数就是这个变量的作用域，在这个函数之外</p><h2 id="函数内操作全局变量"><a href="#函数内操作全局变量" class="headerlink" title="函数内操作全局变量"></a>函数内操作全局变量</h2><p>默认情况下，在函数体中操作的都是局部变量，但是有些情况需要在函数体中操作全局变量，这个时候就需要在变量的前面加上标志信息：global</p><p>注意，在外部定义的全局变量，只有字符串和单独的整数这种是不能再函数中去修改的，而像列表字典元祖集合等比较复杂的数据类型，这些都是可以直接在局部里面直接修改全局的 </p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自己本身，那么这个函数就是递归函数。</p><h2 id="递归的特性"><a href="#递归的特性" class="headerlink" title="递归的特性"></a>递归的特性</h2><p>递归函数应该拥有以下特性：</p><ul><li>必须有一个明确的结束条件</li><li>每次进入更深一层的递归时，问题规模相比上次递归都应有所减少</li><li>递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用时通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。）</li></ul><p>演示代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def cal(n):</span><br><span class="line">    print (n)</span><br><span class="line">    if int(n/2)&gt;0:</span><br><span class="line">        return (cal(int(n/2)))</span><br><span class="line">cal(10)</span><br><span class="line">输出为：</span><br><span class="line">10</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">这就是一个有明确结束条件的递归函数</span><br></pre></td></tr></table></figure><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>演示代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def add(a,b,f):</span><br><span class="line">    return f(a),f(b)</span><br><span class="line"></span><br><span class="line">res = add(-5,-4,abs)</span><br><span class="line">print (res)</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">(5, 4)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      day03-集合及文件操作知识补充+函数
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>day02-模块初始及列表字典等深入</title>
    <link href="http://yoursite.com/2018/06/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day02-%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B/"/>
    <id>http://yoursite.com/2018/06/27/编程语言/Python/老男孩视频学习笔记/day02-模块初始/</id>
    <published>2018-06-27T13:54:39.000Z</published>
    <updated>2018-06-27T13:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h1><p>模块的简单介绍：用户写好了一堆功能，将其封装在一个文件当中，从网上下载下来之后，导入之后就可以使用，不用再去重新编写相对应的功能代码。这个文件就叫做模块，又可以叫做库</p><p>模块（库）主要分为两种：</p><ul><li>一个是标准库（不需要额外安装下载，就可以直接导入的库，比如说getpass,os,sys模块等）</li><li>一个是第三方库（必须要额外的下载安装之后，才可以使用，例如django）</li></ul><p>几个要点：</p><ul><li>模块在系统中是以.py结尾的文件方式存在的</li><li>这些模块文件在python有一个寻找路径/环境变量（存储路径可以通过sys模块的path方法进行查看，默认情况下，会最优先从当前目录下进行寻找）【这个是python的全局变量，和系统的path环境变量不一样】，这个python全局变量，存储的是路径信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;python</span><br><span class="line">Python 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 16:07:46) [MSC v.1900 32 bit (Intel)] on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; print (sys.path)</span><br><span class="line">[&apos;&apos;, &apos;D:\\software\\python\\python36.zip&apos;, &apos;D:\\software\\python\\DLLs&apos;, &apos;D:\\software\\python\\lib&apos;, &apos;D:\\software\\python&apos;, &apos;D:\\software\\python\\lib\\site-packages&apos;]</span><br></pre></td></tr></table></figure><p>一般情况下，python安装的第三方库都是存放在lib\site-packages路径下</p><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">print (sys.path)</span><br><span class="line">print(sys.argv)</span><br></pre></td></tr></table></figure><p>输出信息如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;C:\Users\Administrator\PycharmProjects\python14\day02&apos;, &apos;C:\Users\Administrator\PycharmProjects\python14&apos;, &apos;D:\software\python\python36.zip&apos;, &apos;D:\software\python\DLLs&apos;, &apos;D:\software\python\lib&apos;, &apos;D:\software\python&apos;, &apos;D:\software\python\lib\site-packages&apos;]</span><br><span class="line"></span><br><span class="line">[&apos;C:/Users/Administrator/PycharmProjects/python14/day02/moudles.py&apos;]</span><br></pre></td></tr></table></figure><ul><li>path方法输出python定义的环境变量信息</li><li>argv方法输出当前文件所在相对路径信息（注意是相对路径，这里输出是因为在IDE中调用的时候写的脚本名字的路径就是绝对路径，pycharm在调用的时候写的是绝对路径）</li></ul><h2 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h2><p>OS模块是跟操作系统进行交互</p><p>从python中调用shell的命令，或者在系统上创建一个文件、目录等</p><p>比如</p><p>执行命令，使用方法：os.system()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import os</span><br><span class="line">cmd_res = os.system(&quot;df -h&quot;)</span><br><span class="line">print (cmd_res)</span><br></pre></td></tr></table></figure><p>执行后的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@redis001 ~]# python test.py</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda2       197G  1.4G  186G   1% /</span><br><span class="line">tmpfs            63G   24K   63G   1% /dev/shm</span><br><span class="line">/dev/sda1       283M   37M  232M  14% /boot</span><br><span class="line">/dev/sda6       1.3T  203M  1.3T   1% /data1</span><br><span class="line">/dev/sda3        99G   60M   94G   1% /home</span><br><span class="line">/dev/sda5        50G   52M   47G   1% /tmp</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意：在使用os.system执行命令的时候，这个结果的输出是直接输出到屏幕上的，而不是存到这个变量中，所以输出之后就没有了</p><p>0 是命令执行成功与否的返回状态码</p><p>上面的system是执行命令，但是不保存结果</p><p>那么，我们就想保存结果的时候，该做什么操作？ 这个时候我们使用popen方法</p><p>popen()方法输出的是一个内存的对象地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@redis001 ~]# cat test.py </span><br><span class="line">#!/usr/bin/python</span><br><span class="line">import os</span><br><span class="line">cmd_res = os.popen(&quot;ls&quot;)</span><br><span class="line">print (cmd_res)</span><br><span class="line">[root@redis001 ~]# python test.py</span><br><span class="line">&lt;open file &apos;ls&apos;, mode &apos;r&apos; at 0x7ff2cce43c00&gt;</span><br><span class="line">ls: write error: Broken pipe</span><br></pre></td></tr></table></figure><p>那么，想要真正的结果，则需要再调用一下read()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@redis001 ~]# cat test.py </span><br><span class="line">#!/usr/bin/python</span><br><span class="line">import os</span><br><span class="line">cmd_res = os.popen(&quot;ls&quot;).read()</span><br><span class="line">print (cmd_res)</span><br><span class="line">[root@redis001 ~]# python test.py</span><br><span class="line">anaconda-ks.cfg</span><br><span class="line">install.log</span><br><span class="line">install.log.syslog</span><br><span class="line">test.py</span><br></pre></td></tr></table></figure><p>解析：在执行完popen()之后，这个结果是保存在内存的一个临时的地方，这个地方，必须通过read()方法，再去取出来</p><h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表切片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">print (list[1:3])</span><br><span class="line">输出为：</span><br><span class="line">[&apos;wsy&apos;, &apos;dabadou&apos;]</span><br></pre></td></tr></table></figure><p>打印列表中item的数量-使用count方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">print(list.count(&quot;wxh&quot;))</span><br></pre></td></tr></table></figure><p>清除列表-clear方法-注意这里只是清空了但是不会被删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.clear()</span><br></pre></td></tr></table></figure><p>列表反转-reverse()方法</p><p>列表合并-extend()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">list2 = [1,2,3,4]</span><br><span class="line">list.extend(list2)</span><br><span class="line">print (list)</span><br><span class="line">输出为：</span><br><span class="line">[&apos;wxh&apos;, &apos;wsy&apos;, &apos;dabadou&apos;, &apos;badou&apos;, &apos;wxh&apos;, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>列表删除-del命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list2 = [1,2,3,4]</span><br><span class="line">del list2</span><br><span class="line">print (list2)</span><br></pre></td></tr></table></figure><p>列表嵌套列表及子列表赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,[&quot;wxh&quot;,&quot;heheh&quot;,&quot;haha&quot;],&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">list[3][1] = &quot;WXH&quot;</span><br><span class="line">print(list)</span><br><span class="line">执行后输出为：</span><br><span class="line">[&apos;wxh&apos;, &apos;wsy&apos;, &apos;dabadou&apos;, [&apos;wxh&apos;, &apos;WXH&apos;, &apos;haha&apos;], &apos;badou&apos;, &apos;wxh&apos;]</span><br></pre></td></tr></table></figure><p>列表复制-使用copy模块的copy方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,[&quot;wxh&quot;,&quot;heheh&quot;,&quot;haha&quot;],&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">list2 = copy.copy(list)</span><br><span class="line">print (list2)</span><br><span class="line">输出为：</span><br><span class="line">[&apos;wxh&apos;, &apos;wsy&apos;, &apos;dabadou&apos;, [&apos;wxh&apos;, &apos;heheh&apos;, &apos;haha&apos;], &apos;badou&apos;, &apos;wxh&apos;]</span><br><span class="line"></span><br><span class="line">也可以使用下面这种方式：</span><br><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,[&quot;wxh&quot;,&quot;heheh&quot;,&quot;haha&quot;],&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">list2 = list[:]</span><br><span class="line">print (list2)</span><br></pre></td></tr></table></figure><p>使用这种列表再赋值的方式，可以拿来作为联合账号类功能，也就是说前者最开始的列表将会连带的影响所有的列表。</p><p>列表循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in list:</span><br><span class="line">print (i)</span><br></pre></td></tr></table></figure><p>在循环的时候-按照步长进行输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(list[0:-1:2])</span><br></pre></td></tr></table></figure><h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h2><p>元祖和列表差不多，只不过一旦创建之后就不能再次修改，因此又叫做只读列表</p><p>元祖使用()进行定义，而不是列表的[]</p><p>元祖只有两个方法，count和index方法</p><h2 id="购物车程序"><a href="#购物车程序" class="headerlink" title="购物车程序"></a>购物车程序</h2><p>需求如下：</p><ol><li>启动程序之后，让用户输入工资，然后打印商品列表</li><li>允许用户根据商品编号购买商品</li><li>用户选择商品后，检测余额是否足够，够久直接扣款，不够就提醒（不够的话可以选择便宜的，也就是说进入下一次循环）</li><li>可以随时退出，退出时，打印已经购买的商品和余额</li></ol><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Author:XiaoHua Wang</span><br><span class="line">goods = [(&quot;iphone&quot;,7000),(&quot;Ipad pro&quot;,5000),(&quot;Mac pro&quot;,22000),(&quot;tea&quot;,40),(&quot;bag&quot;,2000),(&quot;Nike&quot;,860),(&quot;book&quot;,105)]</span><br><span class="line">salary = int(input(&quot;Please input your salary: &quot;))</span><br><span class="line">message2 = &quot;Please choice which number to buy,enter q to quit in any time:&quot;</span><br><span class="line">buy_goods = []</span><br><span class="line">while True:</span><br><span class="line">    print(&quot;These are all goods you can buy:&quot;)</span><br><span class="line">#    for i in range(len(goods)):</span><br><span class="line">#        print(str(i) + &quot; &quot; + str(goods[i]))</span><br><span class="line">    for item in goods:</span><br><span class="line">        print (goods.index(item),item)</span><br><span class="line">    Tag = input(message2)</span><br><span class="line">    jude = Tag.isdigit()</span><br><span class="line">    if Tag == &quot;q&quot;:</span><br><span class="line">        break</span><br><span class="line">    if jude != True:</span><br><span class="line">        print (&quot;sorry,input error,please enter number or q&quot;)</span><br><span class="line">        break</span><br><span class="line">    consume_moneny = int(goods[int(Tag)][1])</span><br><span class="line">    salary1 = salary</span><br><span class="line">    salary = salary - consume_moneny</span><br><span class="line">    if  salary &lt; 0:</span><br><span class="line">        print (&quot;sorry,you The amount is not enough,please select again&quot;)</span><br><span class="line">        print( &quot;rest salary is &#123;Salary&#125;&quot;.format(Salary=salary1) )</span><br><span class="line">        salary = salary1</span><br><span class="line">        continue</span><br><span class="line">#    if salary == 0:</span><br><span class="line">    if salary == 0:</span><br><span class="line">        print(&quot;Add &quot; + str(goods[int(Tag)]) )</span><br><span class="line">        print(&quot;consume all money just right,&quot;+ &quot;rest salary is 0 . you can&apos;t buy again.&quot;)</span><br><span class="line">        buy_goods = buy_goods.append(goods[int(Tag)][0])</span><br><span class="line">        break</span><br><span class="line">    print(&quot;Add &quot; + str(goods[int(Tag)]))</span><br><span class="line">#    print(&quot;rest salary is &quot; + str(salary))</span><br><span class="line">    print(&quot;rest salary is &#123;Salary&#125;&quot;.format(Salary=salary))</span><br><span class="line">    buy_goods.append(goods[int(Tag)][0])</span><br><span class="line">    continue</span><br><span class="line">print (&quot;you have buy blow goods: &quot;)</span><br><span class="line">print (buy_goods)</span><br></pre></td></tr></table></figure><p>注意：匹配列表的索引和对应的值还可以使用下面的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">goods = [(&quot;iphone&quot;,7000),(&quot;Ipad pro&quot;,5000),(&quot;Mac pro&quot;,22000),(&quot;tea&quot;,40),(&quot;bag&quot;,2000),(&quot;Nike&quot;,860),(&quot;book&quot;,105)]</span><br><span class="line">for item in goods:</span><br><span class="line">    print(goods.index(item), item)</span><br><span class="line">#或者</span><br><span class="line">for index,item in enumerate(goods):</span><br><span class="line">    print (index,item)</span><br><span class="line"></span><br><span class="line">执行后输出如下：</span><br><span class="line">0 (&apos;iphone&apos;, 7000)</span><br><span class="line">1 (&apos;Ipad pro&apos;, 5000)</span><br><span class="line">2 (&apos;Mac pro&apos;, 22000)</span><br><span class="line">3 (&apos;tea&apos;, 40)</span><br><span class="line">4 (&apos;bag&apos;, 2000)</span><br><span class="line">5 (&apos;Nike&apos;, 860)</span><br><span class="line">6 (&apos;book&apos;, 105)</span><br><span class="line">0 (&apos;iphone&apos;, 7000)</span><br><span class="line">1 (&apos;Ipad pro&apos;, 5000)</span><br><span class="line">2 (&apos;Mac pro&apos;, 22000)</span><br><span class="line">3 (&apos;tea&apos;, 40)</span><br><span class="line">4 (&apos;bag&apos;, 2000)</span><br><span class="line">5 (&apos;Nike&apos;, 860)</span><br><span class="line">6 (&apos;book&apos;, 105)</span><br></pre></td></tr></table></figure><h2 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h2><p><strong>字符串对应位置替换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;wangxiaohua&quot;</span><br><span class="line">p = str.maketrans(&quot;abcdefg&quot;,&quot;1234567&quot;)</span><br><span class="line">print (name.translate(p))</span><br><span class="line"></span><br><span class="line">执行之后的输出如下所示：</span><br><span class="line">w1n7xi1ohu1</span><br></pre></td></tr></table></figure><p><strong>临时替换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print (&quot;wangxiaohua&quot;.replace(&apos;a&apos;,&apos;A&apos;,2))</span><br><span class="line">执行后输出如下：</span><br><span class="line">wAngxiAohua</span><br><span class="line"></span><br><span class="line">格式为：旧字符，新字符，替换的格式个数</span><br></pre></td></tr></table></figure><p><strong>split分割-按照字符</strong></p><p>将字符串的值，按照指定的分隔符号，重新定义为列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = &quot;1+2+3+4&quot;</span><br><span class="line">print (num.split(&quot;+&quot;))</span><br><span class="line">执行后输出如下：</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]</span><br></pre></td></tr></table></figure><p><strong>split分割-按照行</strong></p><p>split分割按照行来进行区分的时候，我们就需要使用splitlines()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num = &quot;1+2+3\n+4+\n5+6&quot;</span><br><span class="line">print (num)</span><br><span class="line">print (num.split(&quot;+&quot;))</span><br><span class="line">print (num.splitlines())</span><br><span class="line"></span><br><span class="line">执行后输出如下所示：</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3\n&apos;, &apos;4&apos;, &apos;\n5&apos;, &apos;6&apos;]</span><br><span class="line">[&apos;1+2+3&apos;, &apos;+4+&apos;, &apos;5+6&apos;]</span><br></pre></td></tr></table></figure><p>注意：在linux和windows平台上使用splitlines()方法的时候，它会自动的识别换行符（Linux和windows的换行符号是不一样的）</p><p><strong>Title格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;wang xiao hua&quot;</span><br><span class="line">name1 = &quot;wangxiaohua&quot;</span><br><span class="line">print (name.title())</span><br><span class="line">print (name1.title())</span><br><span class="line"></span><br><span class="line">执行后的输出如下所示：</span><br><span class="line">Wang Xiao Hua</span><br><span class="line">Wangxiaohua</span><br></pre></td></tr></table></figure><p>将输入的字符串输出为标题的格式，也就是首字母大写的格式</p><h2 id="字典操作"><a href="#字典操作" class="headerlink" title="字典操作"></a>字典操作</h2><p>字典的数据类型是一种key-value类型</p><p>字典的特性：</p><ul><li>dict是无序的</li><li>key必须是唯一的，因此字典天生就具备去重的功能</li><li>在输出的时候，默认是没有顺序的，因此可能写在最后的在最前面输出，因为字典没有下标信息，因为列表是通过索引下标进行查找，但是字典是通过key进行查找的</li><li>在取值的时候，用法和列表的相似，不过是在[]中将索引下标数字修改成为key值</li></ul><p>删除字典有几种方法，使用pop的时候，可以再进行赋值，使用del的时候就是真的删除了</p><p>字典的查找，可以使用get方法，也可以使用in的用法</p><p>字典中有该值则返回，没有的话则返回None</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangxiaohua&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;26&quot;,</span><br><span class="line">    &quot;sex&quot;:&quot;man&quot;</span><br><span class="line">&#125;</span><br><span class="line">print (info.get(&quot;name&quot;))</span><br><span class="line">print (info.get(&quot;named&quot;))</span><br><span class="line">if &quot;name&quot; in info:</span><br><span class="line">    print (&quot;Yes&quot;)</span><br><span class="line"></span><br><span class="line">执行后的输出如下所示：</span><br><span class="line">wangxiaohua</span><br><span class="line">None</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p>字典的特殊赋值-如果能取到值则返回取到的值，如果值不存在则创建一个新的-setdefault()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangxiaohua&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;26&quot;,</span><br><span class="line">    &quot;sex&quot;:&quot;man&quot;</span><br><span class="line">&#125;</span><br><span class="line">info.setdefault(&quot;name&quot;,&quot;hehe&quot;)</span><br><span class="line">print (info)</span><br><span class="line"></span><br><span class="line">执行后输出如下所示：</span><br><span class="line">&#123;&apos;name&apos;: &apos;wangxiaohua&apos;, &apos;age&apos;: &apos;26&apos;, &apos;sex&apos;: &apos;man&apos;&#125;</span><br></pre></td></tr></table></figure><p>字典的合并更新-存在交叉的key值进行覆盖，不存在的则进行插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangxiaohua&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;26&quot;,</span><br><span class="line">    &quot;sex&quot;:&quot;man&quot;</span><br><span class="line">&#125;</span><br><span class="line">info2 = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;dabadou&quot;,</span><br><span class="line">    &quot;city&quot;:&quot;hangzhou&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info.update(info2)</span><br><span class="line">print (info)</span><br><span class="line"></span><br><span class="line">执行后的输出如下所示：</span><br><span class="line">&#123;&apos;name&apos;: &apos;dabadou&apos;, &apos;age&apos;: &apos;26&apos;, &apos;sex&apos;: &apos;man&apos;, &apos;city&apos;: &apos;hangzhou&apos;&#125;</span><br></pre></td></tr></table></figure><p><strong>字典的循环</strong></p><p>字典的循环，一般使用的是items()方法，但是使用下面这种方法，会比items()方法高效很多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangxiaohua&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;26&quot;,</span><br><span class="line">    &quot;sex&quot;:&quot;man&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i in info:</span><br><span class="line">  print (i,info[i])</span><br><span class="line"></span><br><span class="line">for k,v in info.items():</span><br><span class="line">    print (k,v)</span><br><span class="line">    </span><br><span class="line">执行后的输出如下所示：</span><br><span class="line"></span><br><span class="line">name wangxiaohua</span><br><span class="line">age 26</span><br><span class="line">sex man</span><br><span class="line">name wangxiaohua</span><br><span class="line">age 26</span><br><span class="line">sex man</span><br></pre></td></tr></table></figure><p>上面的方式，是通过索引的形式（这里是key）就直接把value取出来了，但是下面这个items()相当于是把字典变成一个列表，因此就多了一个字典转换成列表的过程，在数据量大的时候，效率非常的差</p><p>因此字典的循环，最好使用上面的这种方式，尽量避免使用items()方法来实现</p><h2 id="三级菜单程序"><a href="#三级菜单程序" class="headerlink" title="三级菜单程序"></a>三级菜单程序</h2><ul><li>三级菜单【省市县】【例如，浙江省–&gt;杭州市–&gt;xx县/区】</li><li>可依次选择进入各个子菜单</li><li>所需新知识点：列表，字典</li></ul><p>打开程序，列出中国所有的省，选择一个省，列出下面所有的城市，选中一个城市，再列出下面所有的县</p><p>在任何一个级别，可以返回上一级</p><p>在任何一个级别的时候，可以整个退出程序，输入例如quit等退出程序</p>]]></content>
    
    <summary type="html">
    
      day02-模块初始
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器双网卡bond配置</title>
    <link href="http://yoursite.com/2018/06/26/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/2%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8C%E7%BD%91%E5%8D%A1bond%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/06/26/IT科学技术知识体系结构-Linux运维方向/高并发/负载均衡/2层负载均衡/Linux服务器双网卡bond配置/</id>
    <published>2018-06-26T02:04:42.000Z</published>
    <updated>2018-06-26T02:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考文献：</strong></p><ul><li><a href="https://www.jianshu.com/p/e7df65f996f4" target="_blank" rel="noopener">linux 网卡绑定 bonding</a></li><li><a href="https://www.cnblogs.com/wuxulei/p/3270256.html" target="_blank" rel="noopener">Linux网卡绑定探析</a></li><li><a href="https://www.linuxidc.com/Linux/2017-06/144865.htm" target="_blank" rel="noopener">Linux下网卡bonding配置</a></li><li><a href="https://blog.csdn.net/werm520/article/details/43953421" target="_blank" rel="noopener">LINUX-网卡Bond</a></li><li><a href="http://blog.51cto.com/lixin15/1769338" target="_blank" rel="noopener">Linux双网卡绑定bond详解</a></li><li><a href="http://blog.51cto.com/linuxnote/1680315" target="_blank" rel="noopener">Linux网卡bond的七种模式详解</a></li></ul><h1 id="基础知识概述"><a href="#基础知识概述" class="headerlink" title="基础知识概述"></a>基础知识概述</h1><h2 id="什么是bond"><a href="#什么是bond" class="headerlink" title="什么是bond"></a>什么是bond</h2><p>网卡bond是通过多张网卡绑定为一个逻辑网卡，实现本地网卡的<strong><code>冗余，带宽扩容和负载均衡</code></strong>，在生产场景中是一种常用的技术。</p><p>通俗点讲就是两块网卡具有相同的IP地址而并行链接聚合成一个逻辑链路工作。</p><p>其实这项技术在Sun和Cisco中早已存在，被称为Trunking和Etherchannel 技术，在Linux的2.4.x的内核中开始采用这这种技术，被称为bonding。 </p><h2 id="内核支持"><a href="#内核支持" class="headerlink" title="内核支持"></a>内核支持</h2><p>在Linux Kernels 2.4.12及以后的版本均供bonding模块，以前的版本可以通过patch实现。可以通过以下命令确定内核是否支持 bonding： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 ~]# cat /boot/config-2.6.32-696.el6.x86_64 | grep -i bond</span><br><span class="line"># CONFIG_PATA_WINBOND is not set</span><br><span class="line">CONFIG_BONDING=m</span><br><span class="line">CONFIG_WINBOND_840=m</span><br><span class="line">CONFIG_INPUT_WINBOND_CIR=m</span><br><span class="line">CONFIG_IR_WINBOND_CIR=m</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">[root@nginx001 ~]# cat /boot/config-2.6.32-696.el6.x86_64 | grep -i bonding</span><br><span class="line">CONFIG_BONDING=m</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">[root@ network-scripts]# modinfo bonding</span><br><span class="line">filename:       /lib/modules/2.6.32-696.el6.x86_64/kernel/drivers/net/bonding/bonding.ko</span><br><span class="line">author:         Thomas Davis, tadavis@lbl.gov and many others</span><br><span class="line">description:    Ethernet Channel Bonding Driver, v3.7.1</span><br><span class="line">version:        3.7.1</span><br><span class="line">license:        GPL</span><br><span class="line">alias:          rtnl-link-bond</span><br><span class="line">srcversion:     454FF5806F146AD7FB41356</span><br><span class="line">depends:        </span><br><span class="line">vermagic:       2.6.32-696.el6.x86_64 SMP mod_unload modversions </span><br><span class="line">parm:           max_bonds:Max number of bonded devices (int)</span><br><span class="line">parm:           tx_queues:Max number of transmit queues (default = 16) (int)</span><br><span class="line">parm:           num_grat_arp:Number of peer notifications to send on failover event (alias of num_unsol_na) (int)</span><br><span class="line">parm:           num_unsol_na:Number of peer notifications to send on failover event (alias of num_grat_arp) (int)</span><br><span class="line">parm:           miimon:Link check interval in milliseconds (int)</span><br><span class="line">parm:           updelay:Delay before considering link up, in milliseconds (int)</span><br><span class="line">parm:           downdelay:Delay before considering link down, in milliseconds (int)</span><br><span class="line">parm:           use_carrier:Use netif_carrier_ok (vs MII ioctls) in miimon; 0 for off, 1 for on (default) (int)</span><br><span class="line">parm:           mode:Mode of operation; 0 for balance-rr, 1 for active-backup, 2 for balance-xor, 3 for broadcast, 4 for 802.3ad, 5 for balance-tlb, 6 for balance-alb (charp)</span><br><span class="line">parm:           primary:Primary network device to use (charp)</span><br><span class="line">parm:           primary_reselect:Reselect primary slave once it comes up; 0 for always (default), 1 for only if speed of primary is better, 2 for only on active slave failure (charp)</span><br><span class="line">parm:           lacp_rate:LACPDU tx rate to request from 802.3ad partner; 0 for slow, 1 for fast (charp)</span><br><span class="line">parm:           ad_select:803.ad aggregation selection logic; 0 for stable (default), 1 for bandwidth, 2 for count (charp)</span><br><span class="line">parm:           min_links:Minimum number of available links before turning on carrier (int)</span><br><span class="line">parm:           xmit_hash_policy:balance-xor and 802.3ad hashing method; 0 for layer 2 (default), 1 for layer 3+4, 2 for layer 2+3 (charp)</span><br><span class="line">parm:           arp_interval:arp interval in milliseconds (int)</span><br><span class="line">parm:           arp_ip_target:arp targets in n.n.n.n form (array of charp)</span><br><span class="line">parm:           arp_validate:validate src/dst of ARP probes; 0 for none (default), 1 for active, 2 for backup, 3 for all (charp)</span><br><span class="line">parm:           arp_all_targets:fail on any/all arp targets timeout; 0 for any (default), 1 for all (charp)</span><br><span class="line">parm:           fail_over_mac:For active-backup, do not set all slaves to the same MAC; 0 for none (default), 1 for active, 2 for follow (charp)</span><br><span class="line">parm:           all_slaves_active:Keep all frames received on an interface by setting active flag for all slaves; 0 for never (default), 1 for always. (int)</span><br><span class="line">parm:           resend_igmp:Number of IGMP membership reports to send on link failure (int)</span><br><span class="line">parm:           packets_per_slave:Packets to send per slave in balance-rr mode; 0 for a random slave, 1 packet per slave (default), &gt;1 packets per slave. (int)</span><br><span class="line">parm:           lp_interval:The number of seconds between instances where the bonding driver sends learning packets to each slaves peer switch. The default is 1. (uint)</span><br></pre></td></tr></table></figure><p>当看到有相关配置输出的时候则说明当前操作系统的内核版本是支持bond的</p><h2 id="bond模式"><a href="#bond模式" class="headerlink" title="bond模式"></a>bond模式</h2><p><strong>bonding的七种工作模式:</strong> </p><p>bonding技术提供了七种工作模式，在使用的时候需要指定一种，每种有各自的优缺点.</p><ol><li>balance-rr (mode=0)       默认, 有高可用 (容错) 和负载均衡的功能,  需要交换机的配置，每块网卡轮询发包 (流量分发比较均衡).</li><li>active-backup (mode=1)  只有高可用 (容错) 功能, 不需要交换机配置, 这种模式只有一块网卡工作, 对外只有一个mac地址。缺点是端口利用率比较低</li><li>balance-xor (mode=2)     不常用</li><li>broadcast (mode=3)        不常用</li><li>802.3ad (mode=4)          IEEE 802.3ad 动态链路聚合，需要交换机配置，没用过</li><li>balance-tlb (mode=5)      不常用</li><li>balance-alb (mode=6)     有高可用 ( 容错 )和负载均衡的功能，不需要交换机配置  (流量分发到每个接口不是特别均衡)</li></ol><p>具体的网上有很多资料，了解每种模式的特点根据自己的选择就行, 一般会用到0、1、4、6这几种模式。</p><p>一般常用的常用的有两种：</p><p>  <strong>mode=0（balance-rr）</strong></p><p>​    表示负载分担round-robin，并且是轮询的方式比如第一个包走eth0，第二个包走eth1，直到数据包发送完毕。</p><p>​    优点：流量提高一倍</p><p>​    缺点：需要接入交换机做端口聚合，否则可能无法使用</p><p>  <strong>mode=1（active-backup）</strong></p><p>​    表示主备模式，即同时只有1块网卡在工作。</p><p>​    优点：冗余性高</p><p>​    缺点：链路利用率低，两块网卡只有1块在工作</p><h1 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h1><h2 id="配置子网卡"><a href="#配置子网卡" class="headerlink" title="配置子网卡"></a>配置子网卡</h2><p><strong>源文件内容：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 network-scripts]# cat ifcfg-p1p1</span><br><span class="line">DEVICE=&quot;p1p1&quot;</span><br><span class="line">BOOTPROTO=&quot;dhcp&quot;</span><br><span class="line">DHCP_HOSTNAME=&quot;bigdata&quot;</span><br><span class="line">HWADDR=&quot;D0:94:66:5B:76:89&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;no&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">UUID=&quot;9126f785-f642-4ce4-84d8-558284f17623&quot;</span><br></pre></td></tr></table></figure><p><strong>修改后的文件内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 network-scripts]# cat ifcfg-p1p1</span><br><span class="line">DEVICE=&quot;p1p1&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">DHCP_HOSTNAME=&quot;bigdata&quot;</span><br><span class="line">HWADDR=&quot;D0:94:66:5B:76:89&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">UUID=&quot;9126f785-f642-4ce4-84d8-558284f17623&quot;</span><br><span class="line">MASTER=bond1</span><br><span class="line">SLAVE=yes</span><br></pre></td></tr></table></figure><p>同样的，在第二块网卡上进行配置，配置之后的文件内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 network-scripts]# cat  ifcfg-p1p2</span><br><span class="line">DEVICE=&quot;p1p2&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">DHCP_HOSTNAME=&quot;bigdata&quot;</span><br><span class="line">HWADDR=&quot;D0:94:66:5B:76:8A&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">UUID=&quot;a89099a9-0852-4c43-bef3-07e3999ec597&quot;</span><br><span class="line">MASTER=bond1</span><br><span class="line">SLAVE=yes</span><br></pre></td></tr></table></figure><h2 id="配置bond网卡"><a href="#配置bond网卡" class="headerlink" title="配置bond网卡"></a>配置bond网卡</h2><p>子网卡配置完毕之后，我们开始配置bond网卡，vim创建文件，填入以下内容之后，保存退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 network-scripts]# vim ifcfg-bond1</span><br><span class="line">DEVICE=&quot;bond1&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">MTU=&quot;1500&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">IPADDR=103.13.244.21</span><br><span class="line">NETMASK=255.255.255.248</span><br><span class="line">GATEWAY=103.13.244.17</span><br><span class="line">DNS1=223.5.5.5</span><br><span class="line">DNS2=223.6.6.6</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Linux服务器双网卡bond配置
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="高并发" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="2层负载均衡" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/2%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="负载均衡" scheme="http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Chrome常用操作</title>
    <link href="http://yoursite.com/2018/06/25/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Chrome/Chrome%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/06/25/常用软件工具/Chrome/Chrome常用操作/</id>
    <published>2018-06-25T07:39:26.000Z</published>
    <updated>2018-06-25T07:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考文献：</strong></p><ul><li><a href="https://support.google.com/chrome/answer/157179?hl=zh-Hans" target="_blank" rel="noopener">chrome键盘快捷键</a></li></ul><hr><h2 id="Windows和Linux"><a href="#Windows和Linux" class="headerlink" title="Windows和Linux"></a>Windows和Linux</h2><p><strong>标签页和窗口快捷键</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开新窗口</td><td><strong>Ctrl + n</strong></td></tr><tr><td>在无痕模式下打开新窗口</td><td><strong>Ctrl + Shift + n</strong></td></tr><tr><td>打开新的标签页，并跳转到该标签页</td><td><strong>Ctrl + t</strong></td></tr><tr><td>重新打开最后关闭的标签页，并跳转到该标签页</td><td><strong>Ctrl + Shift + t</strong></td></tr><tr><td>跳转到下一个打开的标签页</td><td><strong>Ctrl + Tab</strong> 或 <strong>Ctrl + PgDn</strong></td></tr><tr><td>跳转到上一个打开的标签页</td><td><strong>Ctrl + Shift + Tab</strong> 或 <strong>Ctrl + PgUp</strong></td></tr><tr><td>跳转到特定标签页</td><td><strong>Ctrl + 1</strong> 到 <strong>Ctrl + 8</strong></td></tr><tr><td>跳转到最后一个标签页</td><td><strong>Ctrl + 9</strong></td></tr><tr><td>在当前标签页中打开主页</td><td><strong>Alt + Home</strong></td></tr><tr><td>打开当前标签页浏览记录中记录的上一个页面</td><td><strong>Alt + 向左箭头键</strong></td></tr><tr><td>打开当前标签页浏览记录中记录的下一个页面</td><td><strong>Alt + 向右箭头键</strong></td></tr><tr><td>关闭当前标签页</td><td><strong>Ctrl + w</strong> 或 <strong>Ctrl + F4</strong></td></tr><tr><td>关闭当前窗口</td><td><strong>Ctrl + Shift + w</strong></td></tr><tr><td>最小化当前窗口</td><td><strong>Alt + 空格键 + n</strong></td></tr><tr><td>最大化当前窗口</td><td><strong>Alt + 空格键 + x</strong></td></tr><tr><td>关闭当前窗口</td><td><strong>Alt + F4</strong></td></tr><tr><td>退出 Google Chrome</td><td><strong>Ctrl + Shift + q</strong></td></tr></tbody></table><p><strong>Google Chrome 功能快捷键</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开 Chrome 菜单</td><td><strong>Alt + f</strong> 或 <strong>Alt + e</strong> 或 <strong>F10 + Enter 键</strong></td></tr><tr><td>显示或隐藏书签栏</td><td><strong>Ctrl + Shift + b</strong></td></tr><tr><td>打开书签管理器</td><td><strong>Ctrl + Shift + o</strong></td></tr><tr><td>在新标签页中打开“历史记录”页</td><td><strong>Ctrl + h</strong></td></tr><tr><td>在新标签页中打开“下载内容”页</td><td><strong>Ctrl + j</strong></td></tr><tr><td>打开 Chrome 任务管理器</td><td><strong>Shift + Esc</strong></td></tr><tr><td>将焦点放置在 Chrome 工具栏中的第一项上</td><td><strong>Shift + Alt + t</strong></td></tr><tr><td>将焦点放置在 Chrome 工具栏中的最后一项上</td><td><strong>F10</strong></td></tr><tr><td>将焦点移到未聚焦于的对话框（如果显示）中</td><td><strong>F6</strong></td></tr><tr><td>打开查找栏搜索当前网页</td><td><strong>Ctrl + f</strong> 或 <strong>F3</strong></td></tr><tr><td>跳转到与查找栏中搜索字词相匹配的下一条内容</td><td><strong>Ctrl + g</strong></td></tr><tr><td>跳转到与查找栏中搜索字词相匹配的上一条内容</td><td><strong>Ctrl + Shift + g</strong></td></tr><tr><td>打开“开发者工具”</td><td><strong>Ctrl + Shift + j</strong> 或 <strong>F12</strong></td></tr><tr><td>打开“清除浏览数据”选项</td><td><strong>Ctrl + Shift + Delete</strong></td></tr><tr><td>在新标签页中打开 Chrome 帮助中心</td><td><strong>F1</strong></td></tr><tr><td>使用其他帐号登录或以访客身份浏览</td><td><strong>Ctrl + Shift + m</strong></td></tr><tr><td>打开反馈表单</td><td><strong>Alt + Shift + i</strong></td></tr></tbody></table><p><strong>地址栏快捷键</strong></p><p>在地址栏中可使用以下快捷键：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>使用默认搜索引擎进行搜索</td><td>输入搜索字词并按 <strong>Enter</strong> 键</td></tr><tr><td>使用其他搜索引擎进行搜索</td><td>输入搜索引擎名称，然后按 <strong>Tab</strong> 键</td></tr><tr><td>为网站名称添加 <code>www.</code> 和 <code>.com</code>，并在当前标签页中打开该网站</td><td>输入网站名称并按 <strong>Ctrl + Enter</strong> 键</td></tr><tr><td>打开新的标签页并执行 Google 搜索</td><td>输入搜索字词并按 <strong>Alt + Enter</strong> 键</td></tr><tr><td>跳转到地址栏</td><td><strong>Ctrl + l</strong>、<strong>Alt + d</strong> 或 <strong>F6</strong></td></tr><tr><td>从页面中的任意位置搜索</td><td><strong>Ctrl + k</strong> 或 <strong>Ctrl + e</strong></td></tr><tr><td>从地址栏中移除联想查询内容</td><td>按<strong>向下箭头键</strong>以突出显示相应内容，然后按 <strong>Shift + Delete</strong> 键</td></tr></tbody></table><p><strong>网页快捷键</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开选项以打印当前网页</td><td><strong>Ctrl + p</strong></td></tr><tr><td>打开选项以保存当前网页</td><td><strong>Ctrl + s</strong></td></tr><tr><td>重新加载当前网页</td><td><strong>F5</strong> 或 <strong>Ctrl + r</strong></td></tr><tr><td>重新加载当前网页（忽略缓存的内容）</td><td><strong>Shift + F5</strong> 或 <strong>Ctrl + Shift + r</strong></td></tr><tr><td>停止加载网页</td><td><strong>Esc</strong></td></tr><tr><td>浏览下一个可点击项</td><td><strong>Tab</strong></td></tr><tr><td>浏览上一个可点击项</td><td><strong>Shift + Tab</strong></td></tr><tr><td>使用 Chrome 打开计算机中的文件</td><td>按住 <strong>Ctrl + o</strong> 键并选择文件</td></tr><tr><td>显示当前网页的 HTML 源代码（不可修改）</td><td><strong>Ctrl + u</strong></td></tr><tr><td>将当前网页保存为书签</td><td><strong>Ctrl + d</strong></td></tr><tr><td>将所有打开的标签页以书签的形式保存在新文件夹中</td><td><strong>Ctrl + Shift + d</strong></td></tr><tr><td>开启或关闭全屏模式</td><td><strong>F11</strong></td></tr><tr><td>放大网页上的所有内容</td><td><strong>Ctrl 和 +</strong></td></tr><tr><td>缩小网页上的所有内容</td><td><strong>Ctrl 和 -</strong></td></tr><tr><td>将网页上的所有内容恢复到默认大小</td><td><strong>Ctrl + 0</strong></td></tr><tr><td>向下滚动网页，一次一个屏幕</td><td><strong>空格键</strong>或 <strong>PgDn</strong></td></tr><tr><td>向上滚动网页，一次一个屏幕</td><td><strong>Shift + 空格键</strong>或 <strong>PgUp</strong></td></tr><tr><td>转到网页顶部</td><td><strong>首页</strong></td></tr><tr><td>转到网页底部</td><td><strong>末尾</strong></td></tr><tr><td>在网页上水平滚动</td><td>按住 <strong>Shift</strong> 键并滚动鼠标滚轮</td></tr><tr><td>将光标移到文本字段中的上一个字词前面</td><td><strong>Ctrl + 向左箭头键</strong></td></tr><tr><td>将光标移到文本字段中的上一个字词后面</td><td><strong>Ctrl + 向右箭头键</strong></td></tr><tr><td>删除文本字段中的上一个字词</td><td><strong>Ctrl + Backspace</strong></td></tr><tr><td>在当前标签页中打开主页</td><td><strong>Alt + Home</strong></td></tr></tbody></table><p><strong>鼠标快捷键</strong></p><p>以下快捷键要求您使用鼠标：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>在当前标签页中打开链接（仅限鼠标）</td><td>将链接拖到标签页中</td></tr><tr><td>在新的后台标签页中打开链接</td><td>按住 <strong>Ctrl</strong> 键的同时点击链接</td></tr><tr><td>打开链接，并跳转到该链接</td><td>按住 <strong>Ctrl + Shift</strong> 键的同时点击链接</td></tr><tr><td>打开链接，并跳转到该链接（仅使用鼠标）</td><td>将链接拖到标签栏的空白区域</td></tr><tr><td>在新窗口中打开链接</td><td>按住 <strong>Shift</strong> 键的同时点击链接</td></tr><tr><td>在新窗口中打开标签页（仅使用鼠标）</td><td>将标签页拖出标签栏</td></tr><tr><td>将标签页移至当前窗口（仅限鼠标）</td><td>将标签页拖到现有窗口中</td></tr><tr><td>将标签页移回其原始位置</td><td>拖动标签页的同时按 <strong>Esc</strong></td></tr><tr><td>将当前网页保存为书签</td><td>将相应网址拖动到书签栏中</td></tr><tr><td>下载链接目标</td><td>按住 <strong>Alt</strong> 键的同时点击链接</td></tr><tr><td>显示浏览记录</td><td>右键点击“后退”箭头 <img src="https://lh3.googleusercontent.com/u8GsV4Wm3XNjCmpc3qkbAIPf2Tmily1qNewCqzlV9L32bAeITAp7AWsD9IvYjJVjfx0=w18-h18" alt="返回"> 或“前进”箭头 <img src="https://lh3.googleusercontent.com/2XV3kvUf2fdl-UElXpPIVaqjdNC_fzLbBnWlPmj2_4BnsqX7pYcf-qF0n62Xo2ZxFg=w18-h18" alt="Next">，或者点击（按住鼠标按键别松手）“后退”箭头 <img src="https://lh3.googleusercontent.com/u8GsV4Wm3XNjCmpc3qkbAIPf2Tmily1qNewCqzlV9L32bAeITAp7AWsD9IvYjJVjfx0=w18-h18" alt="返回"> 或“前进”箭头 <img src="https://lh3.googleusercontent.com/2XV3kvUf2fdl-UElXpPIVaqjdNC_fzLbBnWlPmj2_4BnsqX7pYcf-qF0n62Xo2ZxFg=w18-h18" alt="Next"></td></tr><tr><td>在最大化模式和窗口模式间切换</td><td>双击标签栏的空白区域</td></tr><tr><td>放大网页上的所有内容</td><td>按住 <strong>Ctrl</strong> 键的同时向上滚动鼠标滚轮</td></tr><tr><td>缩小网页上的所有内容</td><td>按住 <strong>Ctrl</strong> 键的同时向下滚动鼠标滚轮</td></tr></tbody></table><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p><strong>标签页和窗口快捷键</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开新窗口</td><td><strong>⌘ + n</strong></td></tr><tr><td>在无痕模式下打开新窗口</td><td><strong>⌘ + Shift + n</strong></td></tr><tr><td>打开新的标签页，并跳转到该标签页</td><td><strong>⌘ + t</strong></td></tr><tr><td>重新打开最后关闭的标签页，并跳转到该标签页</td><td><strong>⌘ + Shift + t</strong></td></tr><tr><td>跳转到下一个打开的标签页</td><td><strong>⌘ + Option + 向右箭头键</strong></td></tr><tr><td>跳转到上一个打开的标签页</td><td><strong>⌘ + Option + 向左箭头键</strong></td></tr><tr><td>跳转到特定标签页</td><td><strong>⌘ + 1</strong> 到 <strong>⌘ + 8</strong></td></tr><tr><td>跳转到最后一个标签页</td><td><strong>⌘ + 9</strong></td></tr><tr><td>打开当前标签页浏览记录中记录的上一个页面</td><td><strong>⌘ + [</strong> 或 <strong>⌘ + 向左箭头键</strong></td></tr><tr><td>打开当前标签页浏览记录中记录的下一个页面</td><td><strong>⌘ + ]</strong> 或 <strong>⌘ + 向右箭头键</strong></td></tr><tr><td>关闭当前标签页或弹出式窗口</td><td><strong>⌘ + w</strong></td></tr><tr><td>关闭当前窗口</td><td><strong>⌘ + Shift + w</strong></td></tr><tr><td>最小化窗口</td><td><strong>⌘ + m</strong></td></tr><tr><td>隐藏 Google Chrome</td><td><strong>⌘ + h</strong></td></tr><tr><td>退出 Google Chrome</td><td><strong>⌘ + q</strong></td></tr></tbody></table><p><strong>Google Chrome 功能快捷键</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>显示或隐藏书签栏</td><td><strong>⌘ + Shift + b</strong></td></tr><tr><td>打开书签管理器</td><td><strong>⌘ + Option + b</strong></td></tr><tr><td>在新标签页中打开“设置”页</td><td><strong>⌘ + ,</strong></td></tr><tr><td>在新标签页中打开“历史记录”页</td><td><strong>⌘ + y</strong></td></tr><tr><td>在新标签页中打开“下载内容”页</td><td><strong>⌘ + Shift + j</strong></td></tr><tr><td>打开查找栏搜索当前网页</td><td><strong>⌘ + f</strong></td></tr><tr><td>跳转到与查找栏中搜索字词相匹配的下一条内容</td><td><strong>⌘ + g</strong></td></tr><tr><td>跳转到与查找栏中搜索字词相匹配的上一条内容</td><td><strong>⌘ + Shift + g</strong></td></tr><tr><td>打开查找栏后，搜索选定文本</td><td><strong>⌘ + e</strong></td></tr><tr><td>打开“开发者工具”</td><td><strong>⌘ + Option + i</strong></td></tr><tr><td>打开“清除浏览数据”选项</td><td><strong>⌘ + Shift + Delete</strong></td></tr><tr><td>使用其他帐号登录或以访客身份浏览</td><td><strong>⌘ + Shift + m</strong></td></tr></tbody></table><p><strong>地址栏快捷键</strong></p><p>在地址栏中可使用以下快捷键：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>使用默认搜索引擎进行搜索</td><td>输入搜索字词并按 <strong>Enter</strong> 键</td></tr><tr><td>使用其他搜索引擎进行搜索</td><td>输入搜索引擎名称，然后按 <strong>Tab</strong> 键</td></tr><tr><td>为网站名称添加 <code>www.</code> 和 <code>.com</code>，并在当前标签页中打开该网站</td><td>输入网站名称并按 <strong>Control + Enter</strong> 键</td></tr><tr><td>为网站名称添加 <code>www.</code> 和 <code>.com</code>，并在新标签页中打开该网站</td><td>输入网站名称并按 <strong>Control + Shift + Enter</strong> 键</td></tr><tr><td>在新的后台标签页中打开网站</td><td>输入网址并按 <strong>⌘ + Enter</strong> 键</td></tr><tr><td>跳转到地址栏</td><td><strong>⌘ + l</strong></td></tr><tr><td>从地址栏中移除联想查询内容</td><td>按<strong>向下箭头键</strong>以突出显示相应内容，然后按 <strong>Shift + fn + Delete</strong> 键</td></tr></tbody></table><p><strong>网页快捷键</strong></p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>打开选项以打印当前网页</td><td><strong>⌘ + p</strong></td></tr><tr><td>打开选项以保存当前网页</td><td><strong>⌘ + s</strong></td></tr><tr><td>打开“页面设置”对话框</td><td><strong>⌘ + Option + p</strong></td></tr><tr><td>重新加载当前网页（忽略缓存的内容）</td><td><strong>⌘ + Shift + r</strong></td></tr><tr><td>停止加载网页</td><td><strong>Esc</strong></td></tr><tr><td>浏览下一个可点击项</td><td><strong>Tab</strong></td></tr><tr><td>浏览上一个可点击项</td><td><strong>Shift + Tab</strong></td></tr><tr><td>使用 Google Chrome 打开计算机中的文件</td><td>按住 <strong>⌘ + o</strong> 键并选择文件</td></tr><tr><td>显示当前网页的 HTML 源代码（不可修改）</td><td><strong>⌘ + Option + u</strong></td></tr><tr><td>打开 JavaScript 控制台</td><td><strong>⌘ + Option + j</strong></td></tr><tr><td>将当前网页保存为书签</td><td><strong>⌘ + d</strong></td></tr><tr><td>将所有打开的标签页以书签的形式保存在新文件夹中</td><td><strong>⌘ + Shift + d</strong></td></tr><tr><td>开启或关闭全屏模式</td><td><strong>⌘ + Ctrl + f</strong></td></tr><tr><td>放大网页上的所有内容</td><td><strong>⌘ 和 +</strong></td></tr><tr><td>缩小网页上的所有内容</td><td><strong>⌘ 和 -</strong></td></tr><tr><td>将网页上的所有内容恢复到默认大小</td><td><strong>⌘ + 0</strong></td></tr><tr><td>向下滚动网页，一次一个屏幕</td><td><strong>空格键</strong></td></tr><tr><td>向上滚动网页，一次一个屏幕</td><td><strong>Shift + 空格键</strong></td></tr><tr><td>搜索网络</td><td><strong>⌘ + Option + f</strong></td></tr><tr><td>将光标移到文本字段中的上一个字词前面</td><td><strong>Option + 向左箭头键</strong></td></tr><tr><td>将光标移到文本字段中的上一个字词后面</td><td><strong>Option + 向右箭头键</strong></td></tr><tr><td>删除文本字段中的上一个字词</td><td><strong>Option + Delete</strong></td></tr><tr><td>在当前标签页中打开主页</td><td><strong>⌘ + Shift + h</strong></td></tr></tbody></table><p><strong>鼠标快捷键</strong></p><p>以下快捷键要求您使用鼠标：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>快捷键</strong></th></tr></thead><tbody><tr><td>在当前标签页中打开链接（仅限鼠标）</td><td>将链接拖到标签页中</td></tr><tr><td>在新的后台标签页中打开链接</td><td>按住 <strong>⌘</strong> 键的同时点击链接</td></tr><tr><td>打开链接，并跳转到该链接</td><td>按住 <strong>⌘ + Shift</strong> 键的同时点击链接</td></tr><tr><td>打开链接，并跳转到该链接（仅使用鼠标）</td><td>将链接拖到标签栏的空白区域</td></tr><tr><td>在新窗口中打开链接</td><td>按住 <strong>Shift</strong> 键的同时点击链接</td></tr><tr><td>在新窗口中打开标签页（仅使用鼠标）</td><td>将标签页拖出标签栏</td></tr><tr><td>将标签页移至当前窗口（仅限鼠标）</td><td>将标签页拖到现有窗口中</td></tr><tr><td>将标签页移回其原始位置</td><td>拖动标签页的同时按 <strong>Esc</strong></td></tr><tr><td>将当前网页保存为书签</td><td>将相应网址拖动到书签栏中</td></tr><tr><td>下载链接目标</td><td>按住 <strong>Option</strong> 键的同时点击链接</td></tr><tr><td>显示浏览记录</td><td>右键点击“后退”箭头 <img src="https://lh3.googleusercontent.com/u8GsV4Wm3XNjCmpc3qkbAIPf2Tmily1qNewCqzlV9L32bAeITAp7AWsD9IvYjJVjfx0=w18-h18" alt="返回"> 或“前进”箭头 <img src="https://lh3.googleusercontent.com/2XV3kvUf2fdl-UElXpPIVaqjdNC_fzLbBnWlPmj2_4BnsqX7pYcf-qF0n62Xo2ZxFg=w18-h18" alt="Next">，或者点击（按住鼠标按键别松手）“后退”箭头 <img src="https://lh3.googleusercontent.com/u8GsV4Wm3XNjCmpc3qkbAIPf2Tmily1qNewCqzlV9L32bAeITAp7AWsD9IvYjJVjfx0=w18-h18" alt="返回"> 或“前进”箭头<img src="https://lh3.googleusercontent.com/2XV3kvUf2fdl-UElXpPIVaqjdNC_fzLbBnWlPmj2_4BnsqX7pYcf-qF0n62Xo2ZxFg=w18-h18" alt="Next"></td></tr><tr><td>将窗口高度最大化</td><td>双击标签栏的空白区域</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Chrome常用操作
    
    </summary>
    
      <category term="常用软件工具" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Chrome" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Chrome/"/>
    
    
      <category term="Chrome" scheme="http://yoursite.com/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>第1章：中国人学习英语的误区</title>
    <link href="http://yoursite.com/2018/06/24/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%B7%9F%E6%81%B6%E9%AD%94%E5%A5%B6%E7%88%B8%E5%AD%A6%E8%8B%B1%E8%AF%AD/%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD%E7%9A%84%E8%AF%AF%E5%8C%BA/"/>
    <id>http://yoursite.com/2018/06/24/个人知识体系/英语学习/跟恶魔奶爸学英语/第1章：中国人学习英语的误区/</id>
    <published>2018-06-24T12:20:41.000Z</published>
    <updated>2018-06-24T12:20:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神功大力丸思想"><a href="#神功大力丸思想" class="headerlink" title="神功大力丸思想"></a>神功大力丸思想</h1><p>大部分人幻想通过一套教材就能够解决英语的所有问题，幻想简单、高效、快速、直接的一种方法，解决学习英语中遇到的所有难题</p><p>国内这种大力丸的思想的起源基本是来自于老师群体，培训机构的老师群体，把这种理念和方法进行包装，试图以一种简单的策略来解决所有的英语问题</p><p>语言学习是一个复杂的整体，分为不同的阶段，每个阶段的重点都不一样，需要选用的教材，方法，策略也都不一样。并且，因为每个人的学习习惯和作息习惯都不一样，因此选用的学习策略自然也不应该相同</p><p>在整个英语学习过程当中，需要输入大量的听力和阅读材料，不能只靠一套课本就彻底解决所有问题，你需要认真分析你所处的水平基础（每个人的水平和基础不一样），灵活选择不同的教材和不同的方法策略</p><p>国内的学习者总是喜欢想当然，一定要在某种方法和达到某种水平之间建立因果关系，也就是说，他们做了某事，就一定可以收获什么，如果说我不能收获到成果，可能不是因为方法材料不适合，而只是因为我不够努力和坚持。盲目应用不适合自己的方法和教材</p><p><img src="http://picture.watchmen.xin/naiba/allinone.png" alt="allinone"></p><h1 id="坚持一切以考试为核心"><a href="#坚持一切以考试为核心" class="headerlink" title="坚持一切以考试为核心"></a>坚持一切以考试为核心</h1>]]></content>
    
    <summary type="html">
    
      第1章：中国人学习英语的误区
    
    </summary>
    
      <category term="个人知识体系" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
      <category term="英语学习" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="跟恶魔奶爸学英语" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%B7%9F%E6%81%B6%E9%AD%94%E5%A5%B6%E7%88%B8%E5%AD%A6%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="英语学习" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>每日碎片知识梳理-2018年</title>
    <link href="http://yoursite.com/2018/06/24/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%AF%8F%E6%97%A5%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/2018%E5%B9%B4/%E6%AF%8F%E6%97%A5%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86-2018%E5%B9%B4/"/>
    <id>http://yoursite.com/2018/06/24/个人知识体系/每日碎片知识梳理/2018年/每日碎片知识梳理-2018年/</id>
    <published>2018-06-24T05:52:04.000Z</published>
    <updated>2018-06-24T05:52:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018年6月"><a href="#2018年6月" class="headerlink" title="2018年6月"></a>2018年6月</h1><h2 id="6月24日"><a href="#6月24日" class="headerlink" title="6月24日"></a>6月24日</h2><p><strong>标题：为泡妞之成功而读书</strong></p><ul><li>来源：《得到》-逻辑思维-第20期</li></ul><p><strong>内容：</strong></p><ul><li>传统的知识构成和今天我们要面对的知识构成是有区别的</li></ul><blockquote><p>近代化以来，教育是人类一项沉重的负担，因为随着工业化的发展，各个门类的知识持续增长，所以就必须建立一个体系，将这些知识灌输给年轻人</p></blockquote><h2 id="6月25日"><a href="#6月25日" class="headerlink" title="6月25日"></a>6月25日</h2>]]></content>
    
    <summary type="html">
    
      每日碎片知识梳理-2018年
    
    </summary>
    
      <category term="个人知识体系" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    
      <category term="每日碎片知识梳理" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%AF%8F%E6%97%A5%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
      <category term="2018年" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E6%AF%8F%E6%97%A5%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/2018%E5%B9%B4/"/>
    
    
      <category term="每日碎片知识梳理" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%97%A5%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
  </entry>
  
</feed>
