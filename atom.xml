<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watchmen1992&#39;s Blog</title>
  
  <subtitle>锦瑟年华当与书香为度，是为不负天地人生。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-10T05:31:50.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>XiaoHua WANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>onenote从入门到实践</title>
    <link href="http://yoursite.com/2018/06/10/onenote%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/06/10/onenote从入门到实践/</id>
    <published>2018-06-10T05:31:50.000Z</published>
    <updated>2018-06-10T05:31:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><a href="https://support.office.com/zh-cn/onenote" target="_blank" rel="noopener">OneNote-Microsoft官方文档</a></li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>onenote中的关系是（三级目录）：</p><p>笔记本–&gt;分区–&gt;页</p><h1 id="入门实践"><a href="#入门实践" class="headerlink" title="入门实践"></a>入门实践</h1><h2 id="设置密码保护"><a href="#设置密码保护" class="headerlink" title="设置密码保护"></a>设置密码保护</h2><p>参考文献：</p><ul><li><a href="https://support.office.com/zh-cn/article/%E7%94%A8%E5%AF%86%E7%A0%81%E4%BF%9D%E6%8A%A4%E6%82%A8%E7%9A%84%E7%AC%94%E8%AE%B0-e5ffd8fd-e811-441a-aa02-e13f0f445933#PASSWORDS=2016%E3%80%812013_%E5%92%8C_2010" target="_blank" rel="noopener">用密码保护您的笔记</a></li></ul><p>OneNote 中的密码保护功能旨在帮助确保笔记的安全，防止他人窥探。无论是在学校将 OneNote 用于课堂笔记、在工作场所将其用于会议笔记、在家将其用于个人日记或博客，还是将其用于你自己或亲朋好友的个人信息，密码都在控制对这些笔记的访问权限方面发挥着重要作用。</p><p>通过使用密码保护 OneNote 笔记本分区，可帮助确保私人笔记免遭他人窥探。当分区受密码保护时，其所有页面均处于锁定状态，直到输入正确的密码。</p><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p><strong>步骤如下：</strong></p><ol><li><p>右键单击要保护的<font color="red"><strong><code>分区</code></strong></font>选项卡，然后选择“用密码保护此分区”。</p></li><li><p>如何在 OneNote 2016 中使用密码保护分区的屏幕截图。</p></li><li><p>在“密码保护”任务窗格中，选择“设置密码”。</p></li><li><p>在“密码保护”对话框中，在“输入密码”框中键入所需的密码。</p></li><li><p>在“确认密码”框中再次键入该密码进行确认，然后单击“确定”。</p></li></ol><p><img src="http://picture.watchmen.xin/onenote/password.png" alt="password"></p><blockquote><p><strong>注意:</strong> 请仔细选择密码。如果忘记了密码，任何人都无法为你解锁笔记（甚至 Microsoft 技术支持也不能）。</p></blockquote><h3 id="锁定笔记本中受保护的分区"><a href="#锁定笔记本中受保护的分区" class="headerlink" title="锁定笔记本中受保护的分区"></a>锁定笔记本中受保护的分区</h3><p>如果您为笔记本中的多个分区应用了密码，则可以同时锁定所有这些分区。</p><ol><li><p>右键单击任何受保护的（但当前未锁定的）分区选项卡，然后选择“用密码保护此分区”。</p></li><li><p>在“密码保护”任务窗格中，选择“全部锁定”。</p></li></ol><p><strong>也就是说，一次锁定一个笔记本中的所有有密码保护的分区</strong></p><h3 id="更改受保护分区的密码"><a href="#更改受保护分区的密码" class="headerlink" title="更改受保护分区的密码"></a>更改受保护分区的密码</h3><ol><li><p>右键单击要更改密码的分区选项卡，然后选择“用密码保护此分区”。</p></li><li><p>在“密码保护”任务窗格中，选择“更改密码”。（如果此选项不可用，则表示该分区无密码。）</p></li><li><p>在“更改密码”对话框中，在“旧密码”框中键入当前的密码。</p></li><li><p>在“输入新密码”框中键入新密码。</p></li><li><p>在“确认密码”框中键入该密码进行确认，然后单击“确定”。</p></li></ol><h3 id="删除受保护分区的密码"><a href="#删除受保护分区的密码" class="headerlink" title="删除受保护分区的密码"></a>删除受保护分区的密码</h3><ol><li><p>右键单击要删除密码的分区选项卡，然后单击“用密码保护此分区”。</p></li><li><p>在“密码保护”任务窗格中，单击“删除密码”。（如果此选项不可用，则表示该分区无密码。）</p></li><li><p>在“取消密码”对话框中，键入当前密码，然后单击“确定”。</p></li></ol><h3 id="设置密码保护选项"><a href="#设置密码保护选项" class="headerlink" title="设置密码保护选项"></a>设置密码保护选项</h3><p>如果您在一段时间内没有使用已解锁的受密码保护分区，此类分区将再次自动锁定。 您可以自定义这段时间，并且可以设置应用于受保护分区的密码保护方式的其他选项。</p><ol><li><p>选择“文件”&gt;“选项”。</p></li><li><p>在“OneNote 选项”对话框中，选择“高级”。</p></li><li><p>在右侧的“密码”下，执行下列任一操作：</p></li><li><p>若要在指定的一段时间后锁定笔记本分区，请选中“在以下时间内未对受密码保护的分区进行操作即将其锁定”，然后选择所需的时间。</p></li><li><p>若要在完成使用笔记本分区后立即将其锁定，请选中“离开受密码保护的分区时即将其锁定”。</p></li><li><p>若要使受密码保护的分区中的笔记暂时对其他程序可用，请选中“允许加载项程序访问解除锁定的受密码保护的分区”。</p></li><li><p>单击“确定”应用首选项。</p></li></ol><h3 id="有关密码的一些重要说明"><a href="#有关密码的一些重要说明" class="headerlink" title="有关密码的一些重要说明"></a>有关密码的一些重要说明</h3><ul><li>密码只能应用于笔记本分区，不能应用于整个笔记本。</li></ul><ul><li>密码区分大小写。创建或输入密码前，请确保关闭 Caps Lock 键。</li></ul><ul><li>OneNote 使用加密来保护受密码保护的分区。如果忘记了密码，任何人都无法为你解锁笔记（甚至 Microsoft 技术支持也不能）。因此，向笔记本分区分配密码和更改密码时，需要特别小心。</li></ul><ul><li>笔记本搜索中不包括受密码保护的分区。 若要在搜索中包括受保护的分区，您必须首先将对应分区解锁。</li></ul><ul><li>除非已解除受保护分区的锁定，否则在任何受保护分区内的页面上使用的笔记标记不会包含在笔记标记摘要中。</li></ul>]]></content>
    
    <summary type="html">
    
      OneNote从入门到实践
    
    </summary>
    
      <category term="常用软件工具" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="OneNote" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/OneNote/"/>
    
    
      <category term="OneNote" scheme="http://yoursite.com/tags/OneNote/"/>
    
  </entry>
  
  <entry>
    <title>高速通道从入门到实践</title>
    <link href="http://yoursite.com/2018/06/08/%E9%AB%98%E9%80%9F%E9%80%9A%E9%81%93%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/06/08/高速通道从入门到实践/</id>
    <published>2018-06-08T04:12:15.000Z</published>
    <updated>2018-06-08T04:12:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>阿里云高速通道（Express Connect）服务，帮助您在VPC间、VPC与本地数据中心间搭建私网通信通道，提高网络拓扑的灵活性和跨网络通信的质量和安全性。使用高速通道可以使您避免绕行公网带来的网络质量不稳定问题，同时可以免去数据在传输过程中被窃取的风险。</p><p><strong>VPC间内网通信</strong></p><ul><li>高速通道支持位于相同地域或不同地域，同一账号或不同账号的VPC之间进行内网互通。</li></ul><ul><li>阿里云通过在<strong><code>两侧VPC的路由器上分别创建路由器接口</code></strong>，以及自有的骨干传输网络来搭建高速通道，轻松实现两个VPC之间安全可靠，方便快捷的通信。</li></ul><p><strong>本地数据中心和阿里云上VPC间内网通信</strong></p><ul><li>您可以通过物理专线在物理层面上连接您的本地数据中心到阿里云，然后建立边界路由器和路由器接口来连接数据中心与阿里云VPC。</li></ul><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>基于软件自定义网络（Software Defined Network，简称SDN）架构下的三层Overlay技术和交换机虚拟化技术，阿里云将客户的物理专线接入的端口隔离起来，并抽象成边界路由器。通过目前主流的隧道技术，阿里云将客户的数据包在交换机内部进行封装，在用户的物理专线和VPC的路由器之间加上隧道封装，然后将数据传输到VPC内。</p><p><img src="http://picture.watchmen.xin/channel/base.png" alt="base"></p><h2 id="路由器接口"><a href="#路由器接口" class="headerlink" title="路由器接口"></a>路由器接口</h2><p>路由器接口是一种虚拟设备，具备搭建通信通道并控制其工作状态的功能。</p><p>高速通道通过在两侧的VPC路由器上分别创建路由器接口为两个VPC之间搭建内网通信通道。</p><p>在两个路由器接口建立连接后，两侧的路由器可以通过建立的通道相互发送消息。因此，两个VPC中的资源（比如ECS实例）就可以通过内网进行通信了。</p><p><img src="http://picture.watchmen.xin/channel/interface.png" alt=""></p><h3 id="发起端和接受端"><a href="#发起端和接受端" class="headerlink" title="发起端和接受端"></a>发起端和接受端</h3><p>当两个路由器接口进行互连时，一个扮演连接发起端角色，另一个扮演连接接受端角色。只有发起端路由器接口才可以发起连接，接受端路由器接口只能等待发起端发起连接。发起端和接受端仅用于控制连接建立的过程，在实际进行网络通信时，通信链路是双向的，发起端和接受端没有任何差别。</p><p>对于同账号VPC互通，高速通道提供了同时创建两端的选项。在这种情况下，您不需要手动发起连接，系统会自动发起并建立连接。对于跨账号VPC互通，您必须手动发起路由器接口间的连接。</p><p>发起端与接受端的对比如下表所示。</p><p><img src="http://picture.watchmen.xin/channel/duibi.png" alt="duibi"></p><p><strong>注意：</strong></p><p>和我们传统的路由器的发起和接受概念有点不一样，这里需要明确的指定</p><ul><li>发起端需要指定接受端的路由器接口</li></ul><ul><li>接收端需要指定发起端的路由器接口</li></ul><p>也就是说，这两个接口只能是给这一条通道使用</p><h3 id="连接过程和连接状态"><a href="#连接过程和连接状态" class="headerlink" title="连接过程和连接状态"></a>连接过程和连接状态</h3><p>路由器接口的连接过程为：发起端路由器接口发起连接 &gt; 接受端路由器接口接受连接 &gt; 连接成功。</p><p>在不同的连接过程和阶段，路由器接口的状态也不同如下表所示。路由器接口创建后的初始状态为未连接。</p><blockquote><p>说明：在创建路由器接口时，如果您选择了同时创建两端，系统会自动发起并建立连接，此种情况下路由器接口直接变为已激活状态。</p></blockquote><p><img src="http://picture.watchmen.xin/channel/status.png" alt=""></p><p>整个连接过程如下所示：</p><p><img src="http://picture.watchmen.xin/channel/process.png" alt=""></p><h3 id="路由器接口规格"><a href="#路由器接口规格" class="headerlink" title="路由器接口规格"></a>路由器接口规格</h3><p>高速通道提供小型（10MB-50MB）、中型（100MB-900MB）和大型（1GB-4.5GB）三种规格的路由器接口。</p><p>可选择的路由器接口规格在不同连接场景和不同地域中并不相同。您可以根据具体的配置在购买页面选择合适的路由器接口规格。同地域间VPC互连的路由器接口规格默认为大型2档（2GB）。</p><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><ul><li><font color="red"><strong>两个VPC之间只能有一对连接成功的路由器接口。</strong></font></li><li><p>路由器接口创建后无法修改连接角色。</p></li><li><p>边界路由器（VBR）必须是发起端。</p></li></ul><h2 id="物理专线"><a href="#物理专线" class="headerlink" title="物理专线"></a>物理专线</h2><p>物理专线是对阿里云接入点和本地数据中心之间建立的网络线路的抽象。您需要通过租用一条运营商的专线将本地数据中心连接到阿里云接入点，建立专线连接。</p><p>专线接入后，您可以创建一个边界路由器（VBR）将您本地数据中心和阿里云连接起来，构建混合云环境，使云上资源可以绕过公网通过私网访问本地数据中心。</p><p>物理专线的私网连接不通过公网，因此与传统的公网连接相比，物理专线连接更加安全、可靠、速度更快、延迟更低。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>高速通道物理专线提供以下功能：</p><p><strong>多种连接方式</strong></p><p>您可以选择使用点对点以太网连接或MPLS VPN连接。物理专线支持以太格式的RJ45电口和LC模式光口, 可以提供1Mbps至10Gbps的传输速率。</p><p><strong>冗余连接</strong></p><p>物理专线通过等价路由实现两条物理线路冗余：</p><ul><li><p>如果两条专线接入同地域下不同接入点，则两条线路形成天然冗余。</p></li><li><p>如果两条专线接入同地域下同一个接入点，您可以在申请第二条物理专线时，将第一条物理专线作为冗余线路。</p></li></ul><h3 id="使用限制-1"><a href="#使用限制-1" class="headerlink" title="使用限制"></a>使用限制</h3><p>物理专线使用限制如下：</p><p>物理专线不支持SDH的G.703、V.35格式接口。</p><p>阿里云在每个可接入的地域提供一个或多个接入点，不同的接入点有运营商限制。在申请专线接入前，您需要提交工单获取接入点以及运营商限制信息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在物理专线接入之后，你会得到一个边界路由器</p><p>边界路由器（VBR）必须是发起端。</p><p>购买物理专线之后，其实不是直接连接到阿里云的机房，而是连接到这个边界路由器，边界路由器的对端再连接VPC的路由器</p><h2 id="边界路由器"><a href="#边界路由器" class="headerlink" title="边界路由器"></a>边界路由器</h2><p>边界路由器（Virtual border router, VBR）是您申请的物理专线接入交换机的产品映射，可以看做是CPE（Customer-premises equipment）设备和VPC之间的一个路由器，作为数据从VPC到本地数据中心的转发桥梁。</p><p>边界路由器同VPC中的路由器一样，同样管理一个路由表。在该路由表中配置路由条目，可以对边界路由器中的流量转发进行管理。</p><p><img src="http://picture.watchmen.xin/channel/vbr.png" alt=""></p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>边界路由器提供如下功能：</p><ul><li>作为VPC和本地数据中心的中间路由器，交换数据包。</li></ul><ul><li>在三层子接口模式下，可以识别或附加VLAN(Virtual Local Area Network)标签。</li></ul><ul><li>决定物理专线端口模式：三层路由接口或基于VLAN的三层子接口。</li></ul><ul><li>支持添加BGP动态路由。</li></ul><h3 id="使用限制-2"><a href="#使用限制-2" class="headerlink" title="使用限制"></a>使用限制</h3><ul><li>目前不支持源地址策略路由。</li></ul><ul><li>每个边界路由器有且只有1个路由表。</li></ul><ul><li>每个路由表支持48条自定义路由条目。</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="VPC私网互连"><a href="#VPC私网互连" class="headerlink" title="VPC私网互连"></a>VPC私网互连</h3><p>您可以使用高速通道实现两个VPC间的的私网通信需求，既可以避免绕行公网带来的网络质量不稳定问题，也可以免去数据在传输过程中被窃取的风险。详情请参考跨地域VPC互连和跨账号VPC互连。</p><h3 id="本地数据中心专线接入VPC"><a href="#本地数据中心专线接入VPC" class="headerlink" title="本地数据中心专线接入VPC"></a>本地数据中心专线接入VPC</h3><p>如果您的本地数据中心需要与VPC进行私网通信，您可以使用<strong><code>高速通道的物理专线功能实现两侧的私网通信</code></strong>，您可以选择自行搭建专线接入阿里云或让阿里巴巴的合作伙伴为您搭建物理专线。通过物理专线可以实现本地数据中心和VPC间高质量、高可靠且安全性高的私网通信。您可以使用高速通道实现两个VPC间的的私网通信需求，既可以避免绕行公网带来的网络质量不稳定问题，也可以免去数据在传输过程中被窃取的风险。详情请参考同账号专线接入和跨账号专线接入。</p><h3 id="两个VPC共用NAT网关"><a href="#两个VPC共用NAT网关" class="headerlink" title="两个VPC共用NAT网关"></a>两个VPC共用NAT网关</h3><p>如果您需要两个VPC共用一个NAT网关进行公网通信，您可以使用高速通道实现同两个VPC使用同一个NAT网关来访问公网。</p><p><img src="http://picture.watchmen.xin/channel/vpc_nat.jpg" alt=""></p><h2 id="使用限制-3"><a href="#使用限制-3" class="headerlink" title="使用限制"></a>使用限制</h2><ul><li>同一个路由器上的路由器接口不能互连。</li></ul><ul><li><font color="red"><strong>边界路由器上的路由器接口只能作为发起端。</strong></font></li></ul><ul><li>一对VPC之间只能同时存在一对互连的路由器接口。</li></ul><ul><li>一条物理专线上最多可以存在的边界路由器个数：50个。</li></ul><ul><li>一个用户名下最多可以存在的已激活的路由器接口个数：5个。</li></ul><ul><li>一个路由器上最多可以存在的已激活的路由器接口个数：5个。</li></ul><ul><li>一个账号最多可以在一个接入点接入的物理专线条数：2条。</li></ul><ul><li>一个账号下最多可以存在的空闲边界路由器（没有接口的边界路由器）个数：2个。</li></ul><h1 id="入门实践"><a href="#入门实践" class="headerlink" title="入门实践"></a>入门实践</h1><h2 id="跨地域VPC互连"><a href="#跨地域VPC互连" class="headerlink" title="跨地域VPC互连"></a>跨地域VPC互连</h2><p>本操作以如下同一个账号下的两个VPC为例演示如何使用高速通道实现VPC私网互通。</p><blockquote><p>说明：同账号下同地域和跨地域VPC互连的操作步骤一样。</p></blockquote><p>前提条件</p><ul><li>确保要进行互连的VPC或交换机的网段不冲突。</li></ul><p>文章内容：<a href="https://help.aliyun.com/document_detail/44842.html?spm=a2c4g.11186623.6.550.zI2Wp5" target="_blank" rel="noopener">跨地域VPC互连</a></p><h2 id="跨账号VPC互连"><a href="#跨账号VPC互连" class="headerlink" title="跨账号VPC互连"></a>跨账号VPC互连</h2><p>前提条件</p><ul><li>两个VPC中交换机地址不能冲突。</li></ul><ul><li>已获取双方的阿里云账号ID和路由器ID。</li></ul><p>文章内容：<a href="https://help.aliyun.com/document_detail/44843.html?spm=a2c4g.11186623.6.551.PoqdWg" target="_blank" rel="noopener">跨账号VPC互连</a></p><h2 id="物理专线-1"><a href="#物理专线-1" class="headerlink" title="物理专线"></a>物理专线</h2><p>文章内容：<a href="https://help.aliyun.com/document_detail/44844.html?spm=a2c4g.11186623.6.552.0hqrXn" target="_blank" rel="noopener">物理专线接入</a></p>]]></content>
    
    <summary type="html">
    
      高速通道从入门到实践
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="公有云产品" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"/>
    
      <category term="阿里云" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="高速通道" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/%E9%98%BF%E9%87%8C%E4%BA%91/%E9%AB%98%E9%80%9F%E9%80%9A%E9%81%93/"/>
    
    
      <category term="高速通道" scheme="http://yoursite.com/tags/%E9%AB%98%E9%80%9F%E9%80%9A%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>软件开发环境－开发环境、测试环境、灰发环境、生产环境的区别</title>
    <link href="http://yoursite.com/2018/06/07/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%8D%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%81%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E3%80%81%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/06/07/软件开发环境－开发环境、测试环境、生产环境的区别/</id>
    <published>2018-06-07T14:25:59.000Z</published>
    <updated>2018-06-07T14:25:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发环境(Software Development Environment，SDE)是指在基本硬件和宿主软件的基础上，为支持系统软件和应用软件的工程化开发和维护而使用的一组软件，简称SDE。它由软件工具和环境集成机制构成，前者用以支持软件开发的相关过程、活动和任务，后者为工具集成和软件的开发、维护及管理提供统一的支持。</p><p>项目部署环境一般可分为四种：</p><ul><li>开发环境</li><li>测试环境</li><li>灰发环境/预生产环境</li><li>生产环境</li></ul><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>开发环境时程序猿们专门用于开发的服务器，配置可以比较随意，为了开发调试方便，一般打开全部错误报告和测试工具，是最基础的环境。开发环境的分支，一般是feature分支。</p><h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h1><p>测试环境就是上线前的测试。一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产服务器上，是开发环境到生产环境的过度环境。测试环境的分支一般是develop分支，部署到公司私有的服务器或者局域网服务器上，主要用于测试是否存在bug，一般会不让用户和其他人看到，并且测试环境会尽量与生产环境相似。</p><h1 id="灰发环境-预生产环境"><a href="#灰发环境-预生产环境" class="headerlink" title="灰发环境/预生产环境"></a>灰发环境/预生产环境</h1><p>1、什么是预发布环境?<br>预发布环境，就是线上环境、正式生产环境，为避免因为测试环境和线上环境的差异性等带来的缺陷漏测而设立的一套环境，其配置等基本和线上一致，只是预发布环境web服务器不在线上集成服务器范围之内，为单独的一台机器；</p><p>2、预发布环境不能被线上用户访问<br>通常这里的技术实现是这样的：把预发布环境的访问域名设置成和线上环境的不一样，通过配置host来访问预发布环境；</p><p>3、预发布环境和线上环境公用数据库，即预发布环境使用的是线上的数据库<br>问题：如果新版本程序需要更改表结构等，比如加个表字段，那么，部署到预发布环境时也需要更改表字段，这个可能会影响线上环境程序代码的运行，咋解决？</p><p>答案：<br>3.1 先把预发布环境使用的数据库切换为测试环境使用的数据库<br>3.2 根据实际部署过程，如果有必要，接着，可有针对性的测试下数据库的变更是否会影响线上当前代码程序的运行(注：个人想法)<br>3.3 把新代码部署到预发布环境，测试程序是否正常运行<br>3.4预发布测试完毕，如果没问题，先上线数据库，即在正式环境执行对应的数据库变更操作<br>3.5 紧接着，把预发布环境连接的数据库切换为线上环境使用的数据库，再次进行预发布环境的测试<br>3.6 最后，如果预发布环境测试通过，则把预发布环境的代码部署到线上生产环境。</p><p>注：<br>1、如果不需要更改数据库表结构等，则无需切换预发布环境环境使用的数据库，即预发布使用线上的数据库。</p><p>2、这里，因为预发布环境本身就是线上环境，测试完预发布，也基本代表线上环境测试完成。这样还可以避免发布到正式环境还得再测一遍的情况</p><p><strong>总结</strong></p><p>预发布环境不能被线上用户访问 </p><p>通常这里的技术实现是这样的：把预发布环境的访问域名设置成和线上环境的不一样，通过配置host来访问预发布环境；</p><p>也就是说，预发布环境其实就是生产环境，只是其所在的服务器，没有被添加到生产服务器所在的负载均衡中，因此从公网是无法直接通过原来的方式进行访问的，在这种情况，我们通过配置hosts等方式来定向的访问这一台</p><h1 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h1><p>生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志，是最重要的环境。部署分支一般为master分支。</p><p>三个环境也可以说是系统开发的三个阶段：开发-&gt;测试-&gt;上线，其中生产环境也就是通产说的真实的环境，最后交给用户的环境。</p><h1 id="补充：灰度发布"><a href="#补充：灰度发布" class="headerlink" title="补充：灰度发布"></a>补充：灰度发布</h1><p>预发布环境过后，就是灰度发布了。由于一个项目，一般会部署到多台机器，所以灰度1台至3台，看看新功能是否ok，如果失败则只需要回滚几台，比较方便。注意，由于是灰度发布几种几台，所以一般会使用跳板机，然后进行域名绑定，这样才可以保证只访问有最新代码的服务器。</p><p><strong>什么是灰度发布？</strong></p><p>灰度发布，又名金丝雀发布，或者灰度测试，是指在黑与白之间能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</p><p>灰度发布是对某一产品的发布逐步扩大使用群体范围，也叫灰度放量。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p><p><strong>灰度期：</strong>灰度发布开始到结束期间的这一段时间，称为灰度期。</p><p><strong>灰度发布的意义</strong></p><p>灰度发布能及早获得用户的意见反馈，完善产品功能，提升产品质量，让用户参与产品测试，加强与用户互动，降低产品升级所影响的用户范围。</p><p><strong>灰度发布的实现</strong></p><p>待补充</p>]]></content>
    
    <summary type="html">
    
      软件开发环境－开发环境、测试环境、灰发环境生产环境的区别
    
    </summary>
    
      <category term="IT基础知识" scheme="http://yoursite.com/categories/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="软件开发环境" scheme="http://yoursite.com/categories/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="软件开发环境" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>高并发之分流限流与降级</title>
    <link href="http://yoursite.com/2018/06/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%88%86%E6%B5%81%E9%99%90%E6%B5%81%E4%B8%8E%E9%99%8D%E7%BA%A7/"/>
    <id>http://yoursite.com/2018/06/07/高并发之分流限流与降级/</id>
    <published>2018-06-07T13:05:28.000Z</published>
    <updated>2018-06-07T13:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><a href="http://www.cnblogs.com/duanxz/p/3465559.html" target="_blank" rel="noopener">高可用服务设计之二：Rate limiting 限流与降级</a></li><li><a href="http://www.cnblogs.com/duanxz/p/4123068.html" target="_blank" rel="noopener">限流算法之漏桶算法、令牌桶算法</a></li></ul><h1 id="分流"><a href="#分流" class="headerlink" title="分流"></a>分流</h1><p>分流一般是指使用7层负载均衡技术，在前端使用正则表达式，匹配相对应的接口URL串，然后将该接口的流量负载转发到后端的指定服务器上【前提是微服务，将接口进行拆分】</p><h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>在开发高并发系统时，有很多手段保护系统，比如缓存、分流、降级和限流。缓存的目的是提升系统访问速度和增大系统处理能力，可谓是抗高并发的银弹。而降级是当服务出问题或者影响到核心流程的性能，需要暂时屏蔽掉，待高峰过去或者问题解决后再打开的场景。而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页）等。因此，需要有一种手段来限制这些场景下的并发/请求量，这种手段就是限流。</p><p>限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的请求进行限速来保护系统，一旦达到限速速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或者默认数据，如商品详情页库存默认有货）。在压测时，我们能找出每个系统的处理峰值，然后通过设定峰值阈值，当系统过载时，通过拒绝过载的请求来保障系统可用。另外，也可以根据系统的吞吐量、响应时间、可用率来动态调整限流阈值。</p><p>一般开发高并发系统场景的限流有：<strong><code>限制总并发数</code></strong>（比如数据库连接池、线程池）、<strong><code>限制瞬时并发数</code></strong>（如Nginx的limit_conn模块，用来限制瞬间并发连接数）、<strong><code>限制时间窗口内的平均速率</code></strong>（如Guava的RateLimiter、Nginx的limit_req模块，用来限制每秒的平均速率），以及限制远程接口调用速率、限制MQ的消费速率等。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</p><p>Rate limiting 在 Web 架构中非常重要，是互联网架构可靠性保证重要的一个方面。</p><p>从最终用户访问安全的角度看，设想有人想暴力碰撞网站的用户密码；或者有人攻击某个很耗费资源的接口；或者有人想从某个接口大量抓取数据。大部分人 都知道应该增加 Rate limiting，做请求频率限制。从安全角度，这个可能也是大部分能想到，但不一定去做的薄弱环节。</p><p>从整个架构的稳定性角度看，一般 SOA 架构（service-oriented architecture面向服务的架构）的每个接口的有限资源的情况下，所能提供的单位时间服务能力是有限的。假如超过服务能力，一般会造成整个接口服务停顿，或者应用 Crash，或者带来连锁反应，将延迟传递给服务调用方造成整个系统的服务能力丧失。有必要在服务能力超限的情况下 Fail Fast。</p><p>另外，根据排队论，由于 API 接口服务具有延迟随着请求量提升迅速提升的特点，为了保证 SLA 的低延迟，需要控制单位时间的请求量。这也是 Little’s law 所说的。</p><h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><p>常见的限流算法有：令牌桶、漏桶。计数器也可以用来进行粗暴限流实现。</p><ul><li><a href="http://www.cnblogs.com/duanxz/p/4123068.html" target="_blank" rel="noopener">限流算法之漏桶算法、令牌桶算法</a></li></ul><p><strong>令牌桶算法</strong></p><p>令牌桶算法，是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：</p><ul><li>假设限制2r/s，则按照500毫秒的固定速率往桶内添加令牌。</li></ul><ul><li>桶中最多存放b个令牌，当桶满时，新添加的令牌会被丢弃或拒绝。</li></ul><ul><li>当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上。</li></ul><ul><li>如果桶中的令牌不足n个，则不会删除令牌，且该数据包被限流（要么丢弃，要么在缓冲区等待）。</li></ul><p><strong>漏桶算法</strong></p><p>漏桶作为计量工具时，可以用于流量整形和流量控制，漏桶算法的描述如下：</p><ul><li>一个固定容量的漏桶，按照常量固定速率流出水滴。</li></ul><ul><li>如果桶是空的，则不需流出水滴。</li></ul><ul><li>可以以任意速率流入水滴到漏桶。</li></ul><ul><li>如果流入水滴超过了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。</li></ul><p><strong>令牌桶和漏桶对比</strong></p><ul><li>令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时，则拒绝新的请求。</li></ul><ul><li>漏桶则是按照常量固定速率流出请求，请求流入速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝。</li></ul><ul><li>令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿多个令牌），并允许一定程序的突发流量。</li></ul><ul><li>漏桶限制的是常量流出速率（即流出速率是一个固定常量值，比如都是1的速率流出，而不能一次是1，下次又是2），从而平滑突发流入速率。</li></ul><ul><li>令牌桶允许一定程序的突发，而漏桶主要目的是平滑流入速率。</li></ul><ul><li>两个算法实现可以一样，但是方向是相反的，对于相同的参数得到的限流效果是一样的。</li></ul><h2 id="应用级限流"><a href="#应用级限流" class="headerlink" title="应用级限流"></a>应用级限流</h2><p><strong>限制总并发/连接/请求数</strong></p><p>对于一个应用系统来说，一定会有极限并发/请求数，即总有一个<strong><code>TPS/QPS</code></strong>阈值，如果超了阈值，则系统就会不影响用户请求或响应得非常慢。因此，我们最好进行过载保护，以防止大量请求涌入击垮系统。</p><p>如MQ（max_connections）、Redis（tcp-backlog）都会有类似的限制连接数的配置。</p><p><strong>限制总资源数</strong></p><p>如果有的资源是稀缺资源（如数据库连接、线程），而且可能有多个系统都会去使用它，那么需要加以限制。可以使用池化技术来限制总资源数，如连接池、线程池。假设分配给每个应用的数据库连接是100，那么本应用最多可以使用100个资源，超出则可以等待或者抛异常。</p><p><strong>限制某个接口的总并发/请求数</strong></p><p>如果接口可能会有并发流量，但又担心访问量太大造成奔溃，那么久需要限制这个接口的总并发/请求数了。因为粒度比较细，可以为每个接口设置相应的阈值。可以使用Java中的AtomicLong或者Semaphore进行限流。Hystrix在信号量模式下也使用Semaphore限制每个接口的总请求数。</p><p>一种实现方式如下：</p><pre><code>try {    if (atomic.incrementAndGet() &gt; 限流数) {        //拒绝请求    }    //处理请求} finally {    atomic.decrementAndGet();}</code></pre><p><strong>限制某个接口的时间窗请求数</strong></p><p>即限制某个接口/服务每秒/每分钟/每天的请求数/调用量。一种实现方式如下：</p><pre><code>LoadingCache&lt;Long, AtomicLong&gt; counter =        CacheBuilder.newBuilder()        .expireAfterWrite(2, TimeUnit.SECONDS)        .build(new CacheLoader&lt;Long, AtomicLong&gt;() {            @Override            public AtomicLong load(Long aLong) throws Exception {                return new AtomicLong(0);            }        });long limit = 1000;while (true) {    long currentSeconds = System.currentTimeMillis() / 1000;    if (counter.get(currentSeconds).incrementAndGet() &gt; limit) {        logger.info(&quot;被限流了:{}&quot;, currentSeconds);        continue;    }    //业务处理}</code></pre><p><strong>平滑限流某个接口的请求数</strong></p><p>Guava RateLimiter提供的令牌桶算法可用于平滑突发限流（SmoothBursty）和平滑预热限流（SmoothWarmingUp）实现。</p><p><strong>分布式限流</strong></p><p>分布式限流最关键的是要将限流服务做成原子化，而解决方案可以使用Redis+Lua或者Nginx+Lua技术进行实现，通过这两种技术可以实现高并发和高性能。</p><p><strong>节流</strong></p><p>有时候我们想在特定时间窗口内对重复的相同事件最多只处理一次，或者想限制多个连续相同事件最小执行时间间隔，那么可使用节流（Throttle）实现，其防止多个相同事件连续重复执行。节流主要有如下几种用法：throttleFirst、throttleLast、throttleWithTimeout。</p><font color="red"><strong>总结方法：</strong></font><p>常见的 Rate limiting 的实现方式</p><p>Proxy 层的实现，针对部分 URL 或者 API 接口进行访问频率限制</p><p><strong>Nginx 模块</strong></p><pre><code>limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;server {    location /search/ {        limit_req zone=one burst=5;    }</code></pre><p>详细参见：<a href="http://www.cnblogs.com/duanxz/p/3977756.html" target="_blank" rel="noopener">《Nginx模块 ngx_http_limit_req_module 限制请求速率》</a></p><p><strong>Haproxy 提供的功能</strong></p><p>详细参见：<a href="http://blog.serverfault.com/2010/08/26/1016491873/" target="_blank" rel="noopener">Haproxy Rate limit 模块</a></p><p><strong>Java、Scala JVM 系应用层实现</strong></p><p>Google Guava 提供了一个 RateLimiter 实现。使用方式简单明了，在自己的应用中简单封装即可，放到 HTTP 服务或者其他逻辑接口调用的前端。</p><p>final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is “2 permits per second” void submitTasks(List<runnable> tasks, Executor executor) { for(Runnable task : tasks) { rateLimiter.acquire(); // may wait executor.execute(task);} }</runnable></p><p><strong>基于 Redis 功能的实现</strong></p><p>这个在 Redis 官方文档有非常详细的实现。一般适用于所有类型的应用，比如 PHP、Python 等等。Redis 的实现方式可以支持分布式服务的访问频率的集中控制。Redis 的频率限制实现方式还适用于在应用中无法状态保存状态的场景。</p><h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>当访问量剧增、服务出现问题（如响应时间长或者不响应）或非核心服务影响到核心服务的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键参数进行自动降级，也可以配合开关实现人工降级。</p><p><strong>降级的最终目的是保证核心服务可用</strong>，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。降级也需要根据系统的吞吐量、响应时间、可用率等条件进行手工降级或自动降级。</p><h2 id="降级预案"><a href="#降级预案" class="headerlink" title="降级预案"></a>降级预案</h2><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保车，从而梳理出哪些必须誓死保护，哪些可以降级。比如，可以参考日志级别设置预案：</p><ul><li>一般：比如，有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级。</li></ul><ul><li>警告：有些服务在一段时间内成功率有波动（如在95%~100%之间），可以自动降级或人工降级并发送告警。</li></ul><ul><li>错误：比如，可用率低于90%，或者数据库连接池用完了，或者访问量突然猛增到系统能承受的最大阈值，此时可以根据情况自动降级或人工降级。</li></ul><ul><li>严重错误：比如，因为特殊原因数据出现错误，此时需要紧急人工降级。</li></ul><p><strong>降级分类</strong></p><ul><li>降级按照是否自动化可分为：自动开关降级和人工开关降级。</li></ul><ul><li>降级按照功能可分为：读服务降级和写服务降级。</li></ul><ul><li>降级按照处于的系统层次可分为：多级降级。</li></ul><p>降级的功能点主要从服务器端链路考虑，即根据用户访问的服务调用链路来梳理哪里需要降级。</p><ul><li>页面降级。</li></ul><ul><li>页面片段降级。</li></ul><ul><li>页面异步请求降级。</li></ul><ul><li><p>服务功能降级。</p></li><li><p>读降级。比如多级缓存模式，如果后端服务有问题，则可以降级为只读缓存，这种方式是用于对读一致性要求不高的场景。</p></li></ul><ul><li>写降级。比如秒杀抢购我们可以只进行Cache的更新，然后异步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。</li></ul><ul><li>爬虫降级。</li></ul><ul><li>风控降级。</li></ul><p><strong>自动开关降级</strong></p><p>自动降级是根据系统负载、资源使用情况、SLA等指标进行降级。</p><ul><li>超时降级</li></ul><ul><li>统计失败次数降级</li></ul><ul><li>故障降级</li></ul><ul><li>限流降级</li></ul><p><strong>人工开关降级</strong></p><p>比如，上线新功能时进行灰度测试，当新服务有问题时通过开关切换回老服务。</p><h1 id="补充：超时与重试机制"><a href="#补充：超时与重试机制" class="headerlink" title="补充：超时与重试机制"></a>补充：超时与重试机制</h1><p>如果应用不设置超时，可能会导致请求响应慢，慢请求累积导致连锁效应，甚至造成应用雪崩。而有些中间件或框架在超时后会进行重试（如设置超时自动重试两次），读服务天然适合重试，但写服务大多不能重试（如写订单，如果写服务是幂等的，则重试是允许的），重试次数太多会导致多倍请求流量，即模拟了DDoS攻击，后果可能是灾难。因此，务必设置合理的重试机制，并且应该和熔断、快速失败机制配合。在进行代码Review时，一定记得Review超时与重试机制。</p><p>对于非幂等写服务应避免重试，或者考虑提前生成唯一流水号来保证写服务操作通过判断流水号来实现幂等操作。</p><p>在进行数据库/缓存服务器操作时，要经常检查慢查询，慢查询通常是引起服务出问题的罪魁祸首。也要考虑在超时严重时，直接将该服务降级，待该服务修复后再取消降级。</p><h1 id="补充：回滚机制"><a href="#补充：回滚机制" class="headerlink" title="补充：回滚机制"></a>补充：回滚机制</h1><p>回滚是指当程序或数据出错时，将程序或数据恢复到最近的一个正确版本的行为。通过回滚机制可保证系统在某些场景下的高可用。常见的回滚如下：</p><ul><li>事务回滚</li></ul><ul><li>代码库回滚</li></ul><ul><li>部署版本回滚</li></ul><ul><li>数据版本回滚</li></ul><ul><li>静态资源版本回滚。</li></ul><h1 id="补充：压测与预案"><a href="#补充：压测与预案" class="headerlink" title="补充：压测与预案"></a>补充：压测与预案</h1><p>在大促来临之前，研发人员需要对现有系统进行梳理，发现系统瓶颈和问题，然后进行系统调优来提升系统的健壮性和处理能力。一般通过系统压测来发现系统瓶颈和问题，然后进行系统优化和容灾（系统参数调整、单机房容灾、多机房容灾等）。</p><h2 id="系统压测"><a href="#系统压测" class="headerlink" title="系统压测"></a>系统压测</h2><p>压测一般是指性能压力测试，用来评估系统的稳定性和性能，通过压测数据进行系统容量评估，从而决定是否需要进行扩容或缩容。</p><p>压测之前要有压测方案（如压测接口、并发量、压测策略[突发、逐步加压、并发量]、压测指标[机器负载、QPS/TPS]、响应时间[平均、最小、最大]、成功率、相关参数[JVM参数、压缩参数]等），最后根据压测报告分析的结果进行系统优化和容灾。</p>]]></content>
    
    <summary type="html">
    
      高并发之分流限流与降级
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="高并发" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="分流限流与降级" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%88%86%E6%B5%81%E9%99%90%E6%B5%81%E4%B8%8E%E9%99%8D%E7%BA%A7/"/>
    
    
      <category term="高并发" scheme="http://yoursite.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>python基本用法</title>
    <link href="http://yoursite.com/2018/06/07/python%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/06/07/python基本用法/</id>
    <published>2018-06-07T12:13:31.000Z</published>
    <updated>2018-06-07T12:13:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><p>输出目标：</p><pre><code>-------- info of  $ -------Name:Age:Job:Salary:&apos;&apos;&apos;</code></pre><p>让输出的内容按照指定的格式进行输出</p><p><strong>传统方式：使用字符串拼接实现</strong></p><p>代码如下：</p><pre><code>name = input(&quot;name: &quot;)age = input(&quot;age: &quot;)job = input(&quot;job:&quot;)salary = input(&quot;salary:&quot;)info = &apos;&apos;&apos;-------- info of &apos;&apos;&apos; +  name +  &quot;&quot;&quot; ------- Name:&quot;&quot;&quot; + name  + &quot;&quot;&quot;Age: &quot;&quot;&quot; + age   + &quot;&quot;&quot;Job: &quot;&quot;&quot; +  job  +  &quot;&quot;&quot;Salary: &quot;&quot;&quot; + salaryprint (info)</code></pre><p>使用注释拼接上变量的形式来创建指定的格式，不建议使用字符串拼接的方式去实现，因为它会开辟好几块的内存空间，效率比较低下</p><p><strong>更高效简单的方法-参数替换</strong></p><p>在shell脚本中，我们使用$符号引用外面定义的变量，在python中也提供了类似的功能。</p><p>在python中使用%s，占位符，相当于$的存在</p><p>代码如下：</p><pre><code>name = input(&quot;name: &quot;)age = int(input(&quot;age: &quot;))job = input(&quot;job:&quot;)salary = input(&quot;salary:&quot;)print(&quot;name&quot;)info = &quot;&quot;&quot;-------- info of %s -----name: %sage: %djob: %ssalary: %s&quot;&quot;&quot;%(name,name,age,job,salary)print (info)</code></pre><p><strong>解释：</strong></p><p>在这里</p><ul><li>%s代表的是string</li><li>%d代表的是 digital</li><li>%f代表的是 float</li><li>int代表的是整型  integer</li></ul><p>注意，在定义age的时候，使用的强制类型转换，因为如果不进行强制类型定义的话，则输入的会使默认的字符类型</p><p>如果想要知道输入的值在程序运行的时候的是什么类型，则可以使用type函数进行查看</p><pre><code>print (type(name))</code></pre><p>因为python是一个强类型定义语言，所以在第一次赋值之后，这个变量的数据类型就固定了，要么强制转换，不然的话就一直是这个数据类型</p><p><strong>更高效简单的方法-format方式</strong></p><p>代码如下：</p><pre><code>name = input(&quot;name: &quot;)age = input(&quot;age: &quot;)job = input(&quot;job: &quot;)salary = input(&quot;salary: &quot;)info = &quot;&quot;&quot;--- info of {_name} ---name: {_name}age: {_age}job: {_job}salary: {_salary}&quot;&quot;&quot; .format(_name = name,            _age = age,            _job = job,            _salary = salary)print (info)</code></pre><p>在日常开发中，建议使用这种方式去格式化输出内容</p><h1 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h1><pre><code>username = input(&quot;username: &quot;)password = input(&quot;password: &quot;)print (username + &quot; &quot; + password )</code></pre><p>当使用input函数的时候，我们在输入内容的时候，所输入的内容是直接在屏幕明文显示的</p><p>因此，这里需要隐藏输入的明文显示，此时，使用标准库中的一个模块：getpass</p><p>标准库：直接import就能使用标准库中的模块，不需要再额外安装，因此在安装python的时候，就已经默认安装集成了这个标准库</p><p>我们从标准库中import getpass模块之后，直接调用它的方法</p><p>修改之后的代码如下所示：</p><pre><code>import getpassusername = input(&quot;username: &quot;)password = getpass.getpass(&quot;password: &quot;)print (username,password)</code></pre><p><strong>注意：</strong> getpass在pycharm中有bug，在进行验证的时候可以使用cmd来进行</p><p>输出如下：</p><pre><code>C:\Users\Administrator\PycharmProjects\python14\day1&gt;python password.pyusername: wxhpassword:wxh wxh</code></pre><p><strong>优化之后的代码：</strong></p><pre><code>import getpass_username = &quot;wxh&quot;_password = &quot;wxh123&quot;username = input(&quot;username: &quot;)password = getpass.getpass(&quot;password: &quot;)if username == _username and password == _password :    print (&quot;Welcome user {name} login...&quot;.format(name=username))    print (username,password)else:    print (&quot;Invalid username or password! &quot;)</code></pre><p>输出 如下：</p><pre><code>C:\Users\Administrator\PycharmProjects\python14\day1&gt;python password.pyusername: wxhpassword:Invalid username or password!C:\Users\Administrator\PycharmProjects\python14\day1&gt;python password.pyusername: wxhpassword:Welcome user wxh login...wxh wxh123C:\Users\Administrator\PycharmProjects\python14\day1&gt;</code></pre><h1 id="模块初始"><a href="#模块初始" class="headerlink" title="模块初始"></a>模块初始</h1><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><pre><code>wxh_age = 23print (type(wxh_age))message = &quot;Please input the number of wxh&apos;s age: &quot;guess_age = int(input (message))if guess_age == wxh_age:    print (&quot;yes,you got it. &quot;)elif guess_age &gt; wxh_age:    print (&quot;think smaller...&quot;)else:    print (&quot;think bigger...&quot;)print (&quot;the right answer is {Age}&quot;.format(Age=wxh_age))</code></pre><p>注意：当给变量赋值字符的时候，一定要记得带上引号，不带引号的话表示的是变量。</p>]]></content>
    
    <summary type="html">
    
      python基本用法
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="day01" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day01/"/>
    
      <category term="Python基本用法" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day01/Python%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>VPC+IDC构建企业混合云</title>
    <link href="http://yoursite.com/2018/06/07/VPC-IDC%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E6%B7%B7%E5%90%88%E4%BA%91/"/>
    <id>http://yoursite.com/2018/06/07/VPC-IDC构建企业混合云/</id>
    <published>2018-06-07T11:38:39.000Z</published>
    <updated>2018-06-07T11:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<font color="red"><strong>文章编写大纲：</strong></font><ul><li>是什么？结果导向，最终实现了什么样的架构？</li><li>为什么？为什么需要这套环境？</li><li>怎么做？如何实现？</li></ul><hr><p>参考文献：</p><ul><li><a href="https://help.aliyun.com/product/27782.html?spm=a2c4g.750001.3.5.2lfVeu" target="_blank" rel="noopener">高速通道-阿里云官方文档</a></li></ul><h1 id="目标结果-最终架构"><a href="#目标结果-最终架构" class="headerlink" title="目标结果-最终架构"></a>目标结果-最终架构</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>每个环境的情况和机房所在地</p><p><strong>混合云就绪</strong></p><ul><li>实现阿里公有云上海、杭州Region与线下IDC环境业务互连</li></ul><h2 id="承载业务"><a href="#承载业务" class="headerlink" title="承载业务"></a>承载业务</h2><h3 id="上海IDC机房承载业务"><a href="#上海IDC机房承载业务" class="headerlink" title="上海IDC机房承载业务"></a>上海IDC机房承载业务</h3><ul><li><p><strong>大数据分析平台业务</strong></p></li><li><p><strong>部分生产及办公应用系统</strong></p><ul><li>将从目前杭州阿里云环境迁移至此</li><li>主要系统有：</li></ul></li></ul><h3 id="上海阿里云环境承载业务"><a href="#上海阿里云环境承载业务" class="headerlink" title="上海阿里云环境承载业务"></a>上海阿里云环境承载业务</h3><h3 id="杭州IDC机房承载业务"><a href="#杭州IDC机房承载业务" class="headerlink" title="杭州IDC机房承载业务"></a>杭州IDC机房承载业务</h3><h3 id="杭州阿里云环境承载业务"><a href="#杭州阿里云环境承载业务" class="headerlink" title="杭州阿里云环境承载业务"></a>杭州阿里云环境承载业务</h3><ul><li><strong>生产系统</strong></li></ul><h2 id="线路"><a href="#线路" class="headerlink" title="线路"></a>线路</h2><p>如架构图所示，整个架构中有以下几条重要线路</p><ul><li><p>上海IDC机房至杭州IDC机房的专线连接</p></li><li><p>上海IDC机房内业务的BGP互联网出口带宽</p></li><li><p>GDS CX专线接入阿里云</p></li><li><p>GDS CX专线接入饿了么</p></li></ul><p>问题</p><ol><li>现在公司的整体机房、网络等的情况【目前杭州的自建IDC机房是什么情况、有哪些阿里云和IDC，我们现在的zabbix不是也是有3套吗】</li><li>上海IDC要连接的杭州IDC指的是现在公司的自建机房还是杭州的阿里云机房（这个的机房在哪里?是在东冠机房吗）</li><li>阿里云华东2 也就是上海阿里云是什么情况？</li><li>IDC和阿里云的专线连接是怎么样子的？是直接连接到阿里云所在可用区的物理机房吗？ 还是通过高速通道的这种方式连接到VPC的高速通道的边界路由器的路由器接口  </li><li>本地IDC和本地阿里云的，也就是杭州的IDC和阿里云以及上海的IDC和上海的阿里云有做专线吗？</li><li>本地IDC有必要和跨地域的阿里云连接吗?也就是说，是不是IDC和阿里云两两之间都需要连通</li><li>2/5Gbps专线是什么意思 ？ 2.5Gb的带宽吗 还是是主备的模式 主是5Gb,备是2Gb</li><li>服务器安装的系统 应用服务器还是安装6吗？怎么做初始化</li><li>现在现在上海的混合云架构和异地多活改造的关系是什么样子，也就是现在这个上海机房处于一个什么位置，是异地多活的开始吗，最终的异地多活是什么样子的？</li><li>上海机房建设的进度安排，什么时间点要完成什么任务 我们要做什么？</li><li>混合之后的网段划分，不能是同一网段</li></ol><h1 id="为什么需要这套环境？-需求分析"><a href="#为什么需要这套环境？-需求分析" class="headerlink" title="为什么需要这套环境？-需求分析"></a>为什么需要这套环境？-需求分析</h1><h1 id="架构实现"><a href="#架构实现" class="headerlink" title="架构实现"></a>架构实现</h1><h2 id="项目进度时间轴"><a href="#项目进度时间轴" class="headerlink" title="项目进度时间轴"></a>项目进度时间轴</h2><h2 id="架构规划"><a href="#架构规划" class="headerlink" title="架构规划"></a>架构规划</h2><p><strong>网络设备及服务器：</strong></p><ul><li><p>网络设备</p></li><li><p>服务器：</p><ul><li>服务器总共120台</li><li>70台DELL R730</li><li>50台DELL R630</li></ul></li></ul><p><strong>线路</strong></p><p>默认情况下，本地IDC网络中心和专有网络之间不能通信，您可以通过以下途径打通本地IDC与VPC之间的通信：</p><ul><li>您可以使用高速通道的物理专线来连通本地IDC到阿里云的专线接入点，并建立虚拟边界路由器作为VPC到IDC的数据转发桥梁。详情参考专线接入。</li></ul><p><img src="http://picture.watchmen.xin/vpc/vpc_idc.png" alt=""></p><ul><li>您可以使用VPN网关来实现本地IDC网络中心与专有网络的互通，详情参考搭建VPN网关。</li></ul>]]></content>
    
    <summary type="html">
    
      点我达-阿里云VPC+自建IDC构建企业混合云建设方案
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="运维架构" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E6%9E%B6%E6%9E%84/"/>
    
      <category term="混合云" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E6%9E%B6%E6%9E%84/%E6%B7%B7%E5%90%88%E4%BA%91/"/>
    
    
      <category term="混合云" scheme="http://yoursite.com/tags/%E6%B7%B7%E5%90%88%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>OSS从入门到实践</title>
    <link href="http://yoursite.com/2018/06/07/OSS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/06/07/OSS从入门到实践/</id>
    <published>2018-06-07T07:50:51.000Z</published>
    <updated>2018-06-07T07:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><a href="https://help.aliyun.com/product/31815.html?spm=a2c4g.750001.2.13.1OtZY6" target="_blank" rel="noopener">阿里云官方资料</a></li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。它具有与平台无关的RESTful API接口，能够提供99.999999999%（11个9）的数据可靠性和99.99%的服务可用性。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p><p>您可以使用阿里云提供的API/SDK接口或者OSS迁移工具轻松地将海量数据移入或移出阿里云OSS。数据存储到阿里云OSS以后，您可以选择标准类型（Standard）的阿里云OSS服务作为移动应用、大型网站、图片分享或热点音视频的主要存储方式，也可以选择成本更低、存储期限更长的低频访问类型（Infrequent Access）和归档类型（Archive）的阿里云OSS服务作为不经常访问数据的备份和归档。</p><p>您可以通过 OSS Learning Path 快速了解 OSS，学习相关的基础操作，并利用丰富的 API SDK 包和便捷工具进行二次开发。</p>]]></content>
    
    <summary type="html">
    
      OSS从入门到实践
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="公有云产品" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"/>
    
      <category term="阿里云" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="OSS" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/%E9%98%BF%E9%87%8C%E4%BA%91/OSS/"/>
    
    
      <category term="tag1" scheme="http://yoursite.com/tags/tag1/"/>
    
  </entry>
  
  <entry>
    <title>网络专线</title>
    <link href="http://yoursite.com/2018/06/06/%E7%BD%91%E7%BB%9C%E4%B8%93%E7%BA%BF/"/>
    <id>http://yoursite.com/2018/06/06/网络专线/</id>
    <published>2018-06-06T06:47:50.000Z</published>
    <updated>2018-06-06T06:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%B8%93%E7%BA%BF" target="_blank" rel="noopener">百度百科</a></li></ul><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是网络专线？"><a href="#什么是网络专线？" class="headerlink" title="什么是网络专线？"></a>什么是网络专线？</h2><p>笼统来说，网络专线就是为某个机构拉一条独立的网线，也就是一个独立的局域网，例如军事，银行等，让用户的数据传输变得可靠可信，专线的优点就是安全性好，QoS（ quality of service 服务质量）可以得到保证。不过，专线租用价格也相对比较高，而且管理也需要专业人员。</p><p><strong>网络专线主要有两种信道：</strong></p><ol><li><p>物理专用信道。物理专用信道就是在服务商到用户之间铺设有一条专用的线路，线路只给用户独立使用，其他的数据不能进入此线路，而一般的线路就允许多用户共享信道； 【独享物理线路的形式】</p></li><li><p>虚拟专用信道；虚拟专用信道就是在一般的信道上为用户保留一定的带宽，使用户可以独享这部分带宽，就像在公用信道上又开了一个通道，只让相应用户使用，而且用户的数据是加密的，以此来保证可靠性与安全性；【在共享物理上创建逻辑独享线路】</p></li></ol><p>这里连接的通道是用户端的出口网关设备（一般是路由器）到ISP的接入端这一段的线路。后续的上网还是通过ISP去实现</p><p>目前市面上的信道有：</p><ul><li>帧中继（Frame Relay）</li><li>数字数据网（DDN Digital Data Network）</li><li>异步传输模式（ATM Asynchronous Transfer Mode）</li><li>X.25（分组交换业务网）</li><li>第三代ADSL（非对称用户数字链路）</li><li>虚拟专用网络（VPN Virtual Private Network）以及E1等。</li></ul><h2 id="什么是互联网专线？"><a href="#什么是互联网专线？" class="headerlink" title="什么是互联网专线？"></a>什么是互联网专线？</h2><p>互联网专线接入业务是指为客户提供各种速率的专用链路（主要提供传输速率为2M及以上速率），直接连接IP骨干网络，实现方便快捷的高速互联网上网服务。互联网专线接入业务按照客户需求可提供更高速率的专线接入，主要有2Mb/s、10Mb/s、100Mb/s、1000Mb/s等等。</p><p><strong>和网络专线的区别</strong></p><blockquote><p>互联网专线跳过了ISP的环节，直接连接Internet骨干网络</p></blockquote><p><strong>主要特点</strong></p><p>1.与普通互联网接入相比，其特点是客户通过相对永久的通信线路接入Internet。</p><p>2.与拨号上网的最大区别是专线与Internet之间保持着永久、高速、稳定的连接，客户可以实现24小时对Internet的访问，随时获取全球信息资源，提高商务交易的效率。</p><p>3.专线客户拥有固定的真实IP地址，可以相对方便地向Internet上的其他客户提供信息服务。</p><p>4.专线具有误码率低，时延小的特点。</p><p>5.专有带宽的整条电路资源仅为一个客户服务，全程带宽完全独享。</p><h2 id="什么是裸光纤？"><a href="#什么是裸光纤？" class="headerlink" title="什么是裸光纤？"></a>什么是裸光纤？</h2><p>裸光纤就是指专线光纤。通俗又权威的说法：裸光纤就是中间没有连接/经过任何传输设备的光纤，也就是直通光缆。</p><p>一般来讲，用户向电信或其他公司租用裸光纤，就是指电信或其他公司只提供光纤物理通道，不提供数据处理等服务，整条光纤干线也不经过任何数据处理设备，由用户自行配置两地的收发设备。</p>]]></content>
    
    <summary type="html">
    
      网络专线知识从入门到实践
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="网络知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
      <category term="网络专线" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E4%B8%93%E7%BA%BF/"/>
    
    
      <category term="网络专线" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E4%B8%93%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>磁盘性能测试</title>
    <link href="http://yoursite.com/2018/06/03/%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/06/03/磁盘性能测试/</id>
    <published>2018-06-03T08:29:10.000Z</published>
    <updated>2018-06-03T08:29:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>文献资料：</p><ul><li><a href="https://help.aliyun.com/document_detail/25382.html?spm=a2c4g.11186623.6.552.t1GC8q" target="_blank" rel="noopener">阿里云-ECS之-块存储性能</a></li></ul><h1 id="性能衡量指标"><a href="#性能衡量指标" class="headerlink" title="性能衡量指标"></a>性能衡量指标</h1><p>衡量存储产品的性能指标主要包括：</p><ul><li><p>IOPS </p></li><li><p>吞吐量</p></li><li><p>访问时延。</p></li></ul><p>IOPS和Throughput吞吐量两个参数是衡量存储性能的主要指标，两者在不同的情况下都能表示存储的性能状况，但应用的场景不尽相同。同时，两者之间也存在着相互的联系</p><h2 id="IOPS"><a href="#IOPS" class="headerlink" title="IOPS"></a>IOPS</h2><p>IOPS是Input/Output Operations per Second，即每秒能处理的I/O个数（也就是在一秒内，磁盘进行多少次 I/O 读写），用于表示块存储处理读写（输出/输入）的能力。<font color="red"><strong><code>如果要部署事务密集型应用，需要关注IOPS性能</code></strong></font>。</p><p><strong>ps:</strong>一次完整的读写（有读有写），才算一次</p><p>最普遍的IOPS性能指标是顺序操作和随机操作，如下表所示。</p><p><img src="http://picture.watchmen.xin/ECS/iops.png" alt="iops"></p><p>IOPS又可细分为如下几个指标：</p><ul><li>Toatal IOPS，混合读写和顺序随机I/O负载情况下的磁盘IOPS，这个与实际I/O情况最为相符，大多数应用关注此指标。</li><li>Random Read IOPS，100%随机读负载情况下的IOPS。</li><li>Random Write IOPS，100%随机写负载情况下的IOPS。</li><li>Sequential Read IOPS，100%顺序读负载情况下的IOPS。</li><li>Sequential Write IOPS，100%顺序写负载情况下的IOPS。</li></ul><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>吞吐量是指单位时间内可以成功传输的数据数量。</p><p><font color="red"><strong><code>如果要部署大量顺序读写的应用，需要关注吞吐量</code></strong></font>。</p><p>磁盘的吞吐量，也就是每秒磁盘 I/O 的流量，即磁盘写入加上读出的数据的大小。</p><p><strong>IOPS 与吞吐量的关系</strong></p><blockquote><p>每秒 I/O 吞吐量＝ IOPS* 平均 I/O SIZE。</p><p>从公式可以看出： I/O SIZE 越大，IOPS 越高，那么每秒 I/O 的吞吐量就越高。因此，我们会认为 IOPS 和吞吐量的数值越高越好。实际上，对于一个磁盘来讲，这两个参数均有其最大值，而且这两个参数也存在着一定的关系。</p></blockquote><h2 id="访问延迟"><a href="#访问延迟" class="headerlink" title="访问延迟"></a>访问延迟</h2><p>访问时延是指块存储处理一个I/O需要的时间。</p><p>如果您的应用对时延比较敏感，比如数据库（过高的时延会导致应用报错），建议您使用固态硬盘介质的SSD云盘、SSD共享块存储或本地SSD盘类产品。</p><p>如果您的应用更偏重存储吞吐能力，对时延不太敏感，比如Hadoop离线计算等吞吐密集型应用，建议您使用本地HDD盘类产品，如d1或d1ne大数据型实例。</p><h1 id="云盘性能"><a href="#云盘性能" class="headerlink" title="云盘性能"></a>云盘性能</h1><p>这里以目前主流的阿里云云盘系列产品进行说明</p><h2 id="云盘性能-1"><a href="#云盘性能-1" class="headerlink" title="云盘性能"></a>云盘性能</h2><p>三种云盘的性能对比如下表所示。</p><p><img src="http://picture.watchmen.xin/ECS/compare1.png" alt="iops"></p><p><strong>注意：</strong></p><blockquote><p>SSD云盘的性能因数据块大小而异，数据块越小，吞吐量越小，IOPS越高，如下表所示。只有挂载到I/O优化的实例时，SSD云盘才能获得期望的IOPS性能。挂载到非I/O优化的实例时，SSD云盘无法获得期望的IOPS性能。</p></blockquote><p><img src="http://picture.watchmen.xin/ECS/ssdiops.png" alt="iops"></p><p><strong>单盘性能计算公式说明：</strong></p><ul><li>以单块SSD云盘最大IOPS计算公式为例说明：起步1200 IOPS，每GiB增加30 IOPS，最高20000 IOPS。</li><li>以单块SSD云盘最大吞吐量计算公式为例说明：起步80 MBps，每GiB增加0.5 MBps，上限为 300 MBps的吞吐量。</li></ul><p><strong>不同云盘的单路访问时延如下：</strong></p><ul><li>SSD云盘：0.5−2 ms</li><li>高效云盘：1−3 ms</li><li>普通云盘：5−10 ms</li></ul><h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><p>根据ECS实例的操作系统不同，您可以使用不同的工具测试块存储性能：</p><ul><li>Linux实例：可以使用DD、fio或sysbench等工具测试块存储性能。</li><li>Windows实例：可以使用fio、Iometer等工具测试块存储性能。</li></ul><p>本文以Linux实例和fio为例，说明如何使用fio测试块存储性能。在进行测试前，请确保块存储已经4 KiB对齐。</p><p><strong>警告：</strong></p><blockquote><p>测试裸盘可以获得真实的块存储盘性能，但直接测试裸盘会破坏文件系统结构，请在测试前提前做好数据备份。建议您只在新购无数据的ECS实例上使用工具测试块存储性能，避免造成数据丢失。</p></blockquote><p><strong>测试随机写IOPS，运行以下命令：</strong></p><pre><code>fio -direct=1 -iodepth=128 -rw=randwrite -ioengine=libaio -bs=4k -size=1G -numjobs=1 -runtime=1000 -group_reporting -filename=iotest -name=Rand_Write_Testing</code></pre><p><strong>测试随机读IOPS，运行以下命令：</strong></p><pre><code>fio -direct=1 -iodepth=128 -rw=randread -ioengine=libaio -bs=4k -size=1G -numjobs=1 -runtime=1000 -group_reporting -filename=iotest -name=Rand_Read_Testing</code></pre><p><strong>测试顺序写吞吐量，运行以下命令：</strong></p><pre><code>fio -direct=1 -iodepth=64 -rw=write -ioengine=libaio -bs=1024k -size=1G -numjobs=1 -runtime=1000 -group_reporting -filename=iotest -name=Write_PPS_Testing</code></pre><p><strong>测试顺序读吞吐量，运行以下命令：</strong></p><pre><code>fio -direct=1 -iodepth=64 -rw=read -ioengine=libaio -bs=1024k -size=1G -numjobs=1 -runtime=1000 -group_reporting -filename=iotest -name=Read_PPS_Testing</code></pre><p>下表以测试随机写IOPS的命令为例，说明命令中各种参数的含义。</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">direct=1</td><td style="text-align:left">表示测试时忽略I/O缓存，数据直写。</td></tr><tr><td style="text-align:left">-iodepth=128</td><td style="text-align:left">表示使用AIO时，同时发出I/O数的上限为128。</td></tr><tr><td style="text-align:left">-rw=randwrite</td><td style="text-align:left">表示测试时的读写策略为随机写（random writes）。作其它测试时可以设置为：<br> - randread（随机读random reads）<br>- read（顺序读sequential reads）<br>- write（顺序写sequential writes）<br>- randrw（混合随机读写mixed random reads and writes）。</td></tr><tr><td style="text-align:left">-ioengine=libaio</td><td style="text-align:left">表示测试方式为libaio（Linux AIO，异步I/O）。应用使用I/O通常有二种方式：同步和异步。同步的I/O一次只能发出一个I/O请求，等待内核完成才返回。这样对于单个线程iodepth总是小于1，但是可以透过多个线程并发执行来解决。通常会用 16−32 根线程同时工作将iodepth塞满。异步则通常使用libaio这样的方式一次提交一批I/O请求，然后等待一批的完成，减少交互的次数，会更有效率。</td></tr><tr><td style="text-align:left">-bs=4k</td><td style="text-align:left">表示单次I/O的块文件大小为4k。未指定该参数时的默认大小也是4k。测试IOPS时，建议将<strong><code>bs</code></strong>设置为一个比较小的值，如本示例中的4k。测试吞吐量时，建议将<strong><code>bs</code></strong>设置为一个较大的值，如本示例中的1024k。</td></tr><tr><td style="text-align:left">-size=1G</td><td style="text-align:left">表示测试文件大小为1G。</td></tr><tr><td style="text-align:left">-numjobs=1</td><td style="text-align:left">表示测试线程数为1。</td></tr><tr><td style="text-align:left">-runtime=1000</td><td style="text-align:left">表示测试时间为1000秒。如果未配置，则持续将前述-size指定大小的文件，以每次-bs值为分块大小写完</td></tr><tr><td style="text-align:left">-group_reporting</td><td style="text-align:left">表示测试结果里汇总每个进程的统计信息，而非以不同job汇总展示信息。</td></tr><tr><td style="text-align:left">-filename=iotest</td><td style="text-align:left">指定测试文件的名称，比如iotest。测试裸盘可以获得真实的磁盘性能，但直接测试裸盘会破坏文件系统结构，请在测试前提前做好数据备份。</td></tr><tr><td style="text-align:left">-name=Rand_Write_Testing</td><td style="text-align:left">表示测试任务名称为Rand_Write_Testing，可以随意设定。</td></tr></tbody></table><p>以下以一块800 GiB SSD云盘随机读IOPS性能的测试结果为例，说明如何理解fio测试结果。</p><pre><code>Rand_Read_Testing: (g=0): rw=randread, bs=4K-4K/4K-4K/4K-4K, ioengine=libaio, iodepth=128fio-2.2.8Starting 1 processJobs: 1 (f=1): [r(1)] [21.4% done] [80000KB/0KB/0KB /s] [20.0K/0/0 iops] [eta 00Jobs: 1 (f=1): [r(1)] [28.6% done] [80000KB/0KB/0KB /s] [20.0K/0/0 iops] [eta 00Jobs: 1 (f=1): [r(1)] [35.7% done] [80000KB/0KB/0KB /s] [20.0K/0/0 iops] [eta 00Jobs: 1 (f=1): [r(1)] [42.9% done] [80004KB/0KB/0KB /s] [20.1K/0/0 iops] [eta 00Jobs: 1 (f=1): [r(1)] [50.0% done] [80004KB/0KB/0KB /s] [20.1K/0/0 iops] [eta 00Jobs: 1 (f=1): [r(1)] [57.1% done] [80000KB/0KB/0KB /s] [20.0K/0/0 iops] [eta 00Jobs: 1 (f=1): [r(1)] [64.3% done] [80144KB/0KB/0KB /s] [20.4K/0/0 iops] [eta 00Jobs: 1 (f=1): [r(1)] [71.4% done] [80388KB/0KB/0KB /s] [20.1K/0/0 iops] [eta 00Jobs: 1 (f=1): [r(1)] [78.6% done] [80232KB/0KB/0KB /s] [20.6K/0/0 iops] [eta 00Jobs: 1 (f=1): [r(1)] [85.7% done] [80260KB/0KB/0KB /s] [20.7K/0/0 iops] [eta 00Jobs: 1 (f=1): [r(1)] [92.9% done] [80016KB/0KB/0KB /s] [20.4K/0/0 iops] [eta 00Jobs: 1 (f=1): [r(1)] [100.0% done] [80576KB/0KB/0KB /s] [20.2K/0/0 iops] [eta 00m:00s]Rand_Read_Testing: (groupid=0, jobs=1): err= 0: pid=9845: Tue Sep 26 20:21:01 2017  read : io=1024.0MB, bw=80505KB/s, iops=20126, runt= 13025msec    slat (usec): min=1, max=674, avg= 4.09, stdev= 6.11    clat (usec): min=172, max=82992, avg=6353.90, stdev=19137.18     lat (usec): min=175, max=82994, avg=6358.28, stdev=19137.16    clat percentiles (usec):     |  1.00th=[  454],  5.00th=[  668], 10.00th=[  812], 20.00th=[  996],     | 30.00th=[ 1128], 40.00th=[ 1256], 50.00th=[ 1368], 60.00th=[ 1480],     | 70.00th=[ 1624], 80.00th=[ 1816], 90.00th=[ 2192], 95.00th=[79360],     | 99.00th=[81408], 99.50th=[81408], 99.90th=[82432], 99.95th=[82432],     | 99.99th=[82432]    bw (KB  /s): min=79530, max=81840, per=99.45%, avg=80064.69, stdev=463.90    lat (usec) : 250=0.04%, 500=1.49%, 750=6.08%, 1000=12.81%    lat (msec) : 2=65.86%, 4=6.84%, 10=0.49%, 20=0.04%, 100=6.35%  cpu          : usr=3.19%, sys=10.95%, ctx=23746, majf=0, minf=160  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, &gt;=64=100.0%     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.1%     issued    : total=r=262144/w=0/d=0, short=r=0/w=0/d=0, drop=r=0/w=0/d=0     latency   : target=0, window=0, percentile=100.00%, depth=128Run status group 0 (all jobs):   READ: io=1024.0MB, aggrb=80504KB/s, minb=80504KB/s, maxb=80504KB/s, mint=13025msec, maxt=13025msecDisk stats (read/write):  vdb: ios=258422/0, merge=0/0, ticks=1625844/0, in_queue=1625990, util=99.30%</code></pre><p>输出结果中，主要关注以下这行内容：</p><pre><code>read : io=1024.0MB, bw=80505KB/s, iops=20126, runt= 13025msec</code></pre><p>这表示fio做了1 GiB I/O，速率约为80 MiB/s，总IOPS为20126，运行时间为13秒。由IOPS值可知，该SSD云盘的IOPS性能为 20126，而根据公式计算的数值为：</p><pre><code>min{1200+30 * 容量, 20000} = min{1200+30 * 800, 20000} = 20000</code></pre><p>测试结果与公式计算结果相近。</p>]]></content>
    
    <summary type="html">
    
      磁盘性能测试
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="服务器硬件" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="磁盘" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6/%E7%A3%81%E7%9B%98/"/>
    
    
      <category term="磁盘性能测试" scheme="http://yoursite.com/tags/%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ECS从入门到实践</title>
    <link href="http://yoursite.com/2018/06/03/ECS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/06/03/ECS从入门到实践/</id>
    <published>2018-06-03T02:33:20.000Z</published>
    <updated>2018-06-03T02:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><a href="https://help.aliyun.com/product/25365.html?spm=a2c4g.750001.2.1.X5t4pr" target="_blank" rel="noopener">阿里云官方文档</a></li></ul><h1 id="ECS基础知识"><a href="#ECS基础知识" class="headerlink" title="ECS基础知识"></a>ECS基础知识</h1><h2 id="ECS-概述"><a href="#ECS-概述" class="headerlink" title="ECS 概述"></a>ECS 概述</h2><p>云服务器Elastic Compute Service（ECS）是阿里云提供的一种基础云计算服务。使用云服务器ECS就像使用水、电、煤气等资源一样便捷、高效。您无需提前采购硬件设备，而是根据业务需要，随时创建所需数量的云服务器ECS实例。在使用过程中，随着业务的扩展，您可以随时扩容磁盘、增加带宽。如果不再需要云服务器，也能随时释放资源，节省费用。</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>在使用ECS之前，需要了解以下概念</p><ul><li>地域和可用区：是指ECS资源所在的物理位置。</li></ul><ul><li>实例：等同于一台虚拟机，包含CPU、内存、操作系统、网络、磁盘等最基础的计算组件。</li></ul><ul><li>实例规格：是指实例的不同配置，包括vCPU核数、内存、网络性能等。实例规格决定了ECS实例的计算和存储能力。</li></ul><ul><li>镜像：是指ECS实例运行环境的模板，一般包括操作系统和预装的软件。操作系统支持多种Linux发行版本和不同的Windows版本。</li></ul><ul><li>块存储：包括基于分布式存储架构的 弹性块存储，以及基于物理机本地硬盘的 本地存储。</li></ul><ul><li>快照：是指某一个时间点上一块弹性块存储的数据备份。</li></ul><ul><li>网络类型：包括</li></ul><pre><code>- 专有网络：基于阿里云构建的一个隔离的网络环境，专有网络之间逻辑上彻底隔离。更多信息，请参考专有网络VPC。- 经典网络：统一部署在阿里云公共基础内，规划和管理由阿里云负责。</code></pre><ul><li>安全组：由同一地域内具有相同保护需求并相互信任的实例组成，是一种虚拟防火墙，用于设置不同实例的网络访问控制。</li></ul><ul><li>SSH密钥对：远程登录Linux ECS实例的验证方式，阿里云存储公钥，您需要自己妥善保管私钥。您也可以选择使用 用户名密码 验证登录Linux ECS实例。</li></ul><ul><li>IP地址：包括用于 内网通信 的内网IP或私有IP，以及用于访问Internet的公网IP。</li></ul><ul><li>弹性公网IP：可以与实例反复绑定或解绑的静态公网IP地址。</li></ul><ul><li>云服务器管理控制台：是指ECS的Web操作界面。</li></ul><h3 id="ECS的优势"><a href="#ECS的优势" class="headerlink" title="ECS的优势"></a>ECS的优势</h3><p>与普通的IDC机房或服务器厂商相比，阿里云提供的云服务器ECS具有以下优势：</p><ul><li>高可用性</li></ul><ul><li>安全</li></ul><ul><li>弹性</li></ul><p><strong>高可用性</strong></p><p>相较于普通的IDC机房以及服务器厂商，阿里云会使用更严格的IDC标准、服务器准入标准以及运维标准，以保证云计算整个基础框架的高可用性、数据的可靠性以及云服务器的高可用性。</p><p>在此基础之上，阿里云所提供的每个地域都存在多可用区。当您需要更高的可用性时，可以利用阿里云的多可用区搭建自己的主备服务或者双活服务。对于面向金融领域的两地三中心的解决方案，您也可以通过<strong><code>多地域和多可用区</code></strong>搭建出更高的可用性服务。其中包括容灾、备份等服务，阿里云都有非常成熟的解决方案。</p><p>在阿里云的整个框架下，这些服务可以非常平滑地进行切换，相关的信息可以在阿里云行业解决方案中找到。无论是两地三中心，还是电子商务以及视频服务等，都可以在阿里云找到对应的行业解决方案。</p><p>此外，阿里云提供了如下三项支持：</p><ul><li>提升可用性的产品和服务，包括云服务器、负载均衡、多备份数据库服务以及数据迁移服务DTS等。</li></ul><ul><li>行业合作伙伴以及生态合作伙伴，帮助您完成更高、更稳定的架构，并且保证服务的永续性。</li></ul><ul><li>多种多样的培训服务，让您从业务端到底层的基础服务端，在整条链路上实现高可用。</li></ul><p><strong>安全性</strong></p><p>选择了云计算，最关心的问题就是云计算的安全与稳定。阿里云近期通过了很多的国际安全标准认证，包括ISO27001、MTCS等，这些所有的安全合规都要求对于用户数据的私密性、用户信息的私密性以及用户隐私的保护都有非常严格的要求。对于云计算，推荐您使用阿里云专有网络。</p><ul><li>在阿里云专有网络之上，可以产生更多的业务可能性。您只需进行简单配置，就可在自己的业务环境下，与全球所有机房进行串接，从而提高了业务的灵活性、稳定性以及业务的可发展性。</li></ul><ul><li>对于原来拥有自建的IDC机房，也不会产生问题。阿里云专有网络可以拉专线到原有的IDC机房，形成混合云的架构。阿里云可以提供各种混合云的解决方案和非常多的网络产品，形成强大的网络功能，让您的业务更加灵活。结合阿里云的生态，您可以在云上发展出意想不到的业务生态。</li></ul><ul><li><p>阿里云专有网络更加稳定和安全。</p><ul><li><p>稳定性：业务搭建在专有网络上，而网络的基础设施将会不停进化，使您每天都拥有更新的网络架构以及更新的网络功能，使得您的业务永远保持在一个稳定的状态。专有网络允许您自由地分割、配置和管理自己的网络。</p></li><li><p>安全性：面对互联网上不断的攻击流量，专有网络天然就具备流量隔离以及攻击隔离的功能。业务搭建在专有网络上后，专有网络会为业务筑起第一道防线。</p></li></ul></li></ul><p>总之，专有网络提供了稳定、安全、快速交付、自主可控的网络环境。对于传统行业以及未接触到云计算的行业和企业而言，借助专有网络混合云的能力和混合云的架构，它们将享受云计算所带来的技术红利。</p><p><strong>弹性</strong></p><p>云计算最大的优势就在于弹性。目前，阿里云已拥有在数分钟内开出一家中型互联网公司所需要的IT资源的能力，这就能够保证大部分企业在云上所构建的业务都能够承受巨大的业务量压力。</p><ul><li><p>计算弹性</p><ul><li><p>纵向弹性，即单个服务器的配置变更。传统IDC模式下，很难做到对单个服务器进行变更配置。而对于阿里云，当您购买了云服务器或者存储的容量后，可以根据业务量的增长或者减少自由变更自己的配置。关于纵向弹性的具体应用，详情请参考 升降配。</p></li><li><p>横向弹性。对于游戏应用或直播平台出现的高峰期，若在传统的IDC模式下，您根本无法立即准备资源；而云计算却可以使用弹性的方式帮助客户度过这样的高峰。当业务高峰消失时，您可以将多余的资源释放掉，以减少业务成本的开支。利用横向的扩展和缩减，配合阿里云的弹性伸缩，完全可以做到定时定量的伸缩，或者按照业务的负载进行伸缩。关于横向弹性的具体应用，详情请参考 弹性伸缩。</p></li><li><p>存储弹性。阿里云拥有很强的存储弹性。当存储量增多时，对于传统的IDC方案，您只能不断去增加服务器，而这样扩展的服务器数量是有限的。在云计算模式下，将为您提供海量的存储，当您需要时可以直接购买，为存储提供最大保障。关于存储弹性的具体应用，详情请参考磁盘扩容。</p></li><li><p>网络弹性。云上的网络也具有非常大的灵活性。只要您购买了阿里云的专有网络，那么所有的网络配置与线下IDC机房配置可以是完全相同的，并且可以拥有更多的可能性。可以实现各个机房之间的互联互通，各个机房之间的安全域隔离，对于专有网络内所有的网络配置和规划都会非常灵活。关于网络弹性的具体应用，详情请参考专有网络。</p></li></ul></li></ul><p>总之，对于阿里云的弹性而言，是计算的弹性、存储的弹性、网络的弹性以及您对于业务架构重新规划的弹性。您可以使用任意方式去组合自己的业务，阿里云都能够满足您的需求。</p><h2 id="块存储"><a href="#块存储" class="headerlink" title="块存储"></a>块存储</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>阿里云为您的云服务器ECS提供了丰富的块存储产品类型，包括基于分布式存储架构的弹性块存储产品，以及基于物理机本地硬盘的本地存储产品。其中：</p><p>弹性块存储，是阿里云为云服务器ECS提供的数据块级别的随机存储，具有低时延、持久性、高可靠等性能，采用 三副本的分布式机制，为ECS实例提供99.9999999%的数据可靠性保证。可以随时创建或释放，也可以随时扩容。</p><p>本地存储，也称为本地盘，是指挂载在ECS云服务器所在物理机（宿主机）上的本地硬盘，是一种临时块存储。是专为对存储I/O性能有极高要求的业务场景而设计的存储产品。该类存储为实例提供块级别的数据访问能力，具有低时延、高随机IOPS、高吞吐量的I/O能力。</p><h3 id="块存储、对象存储、文件存储的区别"><a href="#块存储、对象存储、文件存储的区别" class="headerlink" title="块存储、对象存储、文件存储的区别"></a>块存储、对象存储、文件存储的区别</h3><p>阿里云目前主要提供三种数据存储产品，分别是块存储、文件存储（NAS）和 对象存储（OSS）。</p><p>三者区别如下：</p><ul><li>块存储：是阿里云为ECS云服务器提供的块设备，高性能、低时延，满足随机读写，可以像使用物理硬盘一样格式化建文件系统使用。可用于大部分通用业务场景下的数据存储。</li></ul><ul><li>对象存储（OSS，Object Storage Service）：可以理解是一个海量的存储空间，最适合存储互联网上产生的图片、短视频、音频等海量非结构化数据，您可以通过API在任何时间、任何地点访问对象存储里的数据。常用于互联网业务网站搭建、动静资源分离、CDN加速等业务场景。</li></ul><ul><li>文件存储（NAS，Network Attached Storage）：类似于对象存储，适合存储非结构化的海量数据。但是您需要通过标准的文件访问协议访问这些数据，比如 Linux 系统需要使用Network File System (NFS)协议，Windows系统需要使用Common Internet File System (CIFS)协议。您可以通过设置权限让不同的客户端同时访问同一份文件。文件存储适合企业部门间文件共享、广电非线编、高性能计算、Docker等业务场景。</li></ul><h2 id="块存储性能"><a href="#块存储性能" class="headerlink" title="块存储性能"></a>块存储性能</h2><p>衡量块存储产品的性能指标主要包括：<strong><code>IOPS、吞吐量和访问时延。</code></strong></p><p><strong>IOPS</strong></p><p>IOPS是Input/Output Operations per Second，即每秒能处理的I/O个数，用于表示块存储处理读写（输出/输入）的能力。如果要部署事务密集型应用，需要关注IOPS性能。</p><p>最普遍的IOPS性能指标是顺序操作和随机操作，如下表所示。</p><p><img src="http://picture.watchmen.xin/ECS/iops.png" alt="iops"></p><p><strong>吞吐量</strong></p><p>吞吐量是指单位时间内可以成功传输的数据数量。</p><p>如果要部署大量顺序读写的应用，需要关注吞吐量。</p><p><strong>访问延迟</strong></p><p>访问时延是指块存储处理一个I/O需要的时间。</p><p>如果您的应用对时延比较敏感，比如数据库（过高的时延会导致应用报错），建议您使用固态硬盘介质的SSD云盘、SSD共享块存储或本地SSD盘类产品。</p><p>如果您的应用更偏重存储吞吐能力，对时延不太敏感，比如Hadoop离线计算等吞吐密集型应用，建议您使用本地HDD盘类产品，如d1或d1ne大数据型实例。</p><p>不同云盘之间的性能测试对比请看文档：<a href="https://help.aliyun.com/document_detail/25382.html?spm=a2c4g.11186623.6.552.L3qKVk" target="_blank" rel="noopener">云盘性能对比部分</a></p><h2 id="弹性块存储"><a href="#弹性块存储" class="headerlink" title="弹性块存储"></a>弹性块存储</h2><p>弹性块存储，是阿里云为云服务器ECS提供的数据块级别的随机存储，具有低时延、持久性、高可靠等性能，采用 分布式三副本机制，为ECS实例提供99.9999999%的数据可靠性保证。弹性块存储支持在可用区内自动复制您的数据，防止意外硬件故障导致的数据不可用，保护您的业务免于组件故障的威胁。就像硬盘一样，您可以对挂载到ECS实例上的弹性块存储做分区、创建文件系统等操作，并持久存储数据。</p><p>您可以根据业务需要随时扩容弹性块存储。具体操作，请参见 扩容数据盘 和 扩容系统盘。您也可以为弹性块存储创建快照，备份数据。关于快照的更多信息，参见 快照。</p><p>根据是否可挂载到多台ECS实例，弹性块存储可以分为：</p><ul><li>云盘：一块云盘只能挂载到同一地域、同一可用区的一台ECS实例。</li></ul><ul><li>共享块存储：一块共享块存储可以同时挂载到同一地域、同一可用区的16台ECS实例。<blockquote><p>说明：共享块存储目前仍处于公测阶段，公测期间支持最多同时挂载到4台ECS实例上。</p></blockquote></li></ul><p><strong>总结：</strong></p><blockquote><p>也就是说弹性块存储在使用的时候，可以被当做是本地的磁盘，也可以是当做网络存储，类似NFS等挂载到多台ECS主机上使用<br>区分云盘和共享块存储的方式是能否被多台ECS同时挂载</p></blockquote><h3 id="云盘"><a href="#云盘" class="headerlink" title="云盘"></a>云盘</h3><p><strong>根据性能分类</strong></p><p>根据性能不同，云盘可以分为：</p><ul><li><p>ESSD云盘：又称增强型SSD云盘，是阿里云全新推出的超高性能的云盘产品。基于新一代分布式块存储架构，结合25GE网络和RDMA技术，为您提供单盘高达100万的随机读写能力和低至100μs的单路时延能力。ESSD云盘处于邀测阶段，更多信息，请参见 ESSD云盘FAQ。</p></li><li><p>SSD云盘：采用固态硬盘作为存储介质，能够提供稳定的高随机I/O、高数据可靠性的高性能存储。</p></li><li><p>高效云盘：采用固态硬盘与机械硬盘的混合介质作为存储介质。</p></li><li><p>普通云盘：采用机械磁盘作为存储介质</p></li></ul><p><strong>根据用途分类</strong></p><p>根据用途不同，云盘可以作：</p><ul><li><p>系统盘：生命周期与系统盘所挂载的ECS实例相同，随实例一起创建和释放。不可共享访问。系统盘可选的容量范围与实例所选的镜像有关：</p><ul><li>Linux（不包括CoreOS）+ FreeBSD：20 GiB ~ 500 GiB</li><li>CoreOS：30 GiB ~ 500 GiB</li><li>Windows：40 GiB ~ 500 GiB</li></ul></li></ul><ul><li>数据盘：可以与ECS实例同时创建，也可以 单独创建，不可共享访问。与ECS实例同时创建的数据盘，生命同期与实例相同，随实例一起创建和释放。单独创建的数据盘，可以 单独释放，也可以 设置为随ECS实例一起释放。数据盘的容量由云盘类型决定，详细信息，请参见 块存储性能。<br>作数据盘用时，云盘与共享块存储共享数据盘配额，即一台实例最多挂载16块数据盘。</li></ul><h3 id="共享块存储"><a href="#共享块存储" class="headerlink" title="共享块存储"></a>共享块存储</h3><p>共享块存储是一种支持<strong><code>多台ECS实例并发读写访问</code></strong>的数据块级存储设备，具备多并发、高性能、高可靠等特性，数据可靠性可以达到 99.9999999%。单块共享块存储最多可以同时挂载到16台ECS实例。目前尚处于公测阶段（申请公测资格），最多同时挂载到4台ECS实例。</p><p><strong><code>共享块存储只能作数据盘用</code></strong>，只能单独创建，可以共享访问。您可以 设置共享块存储与挂载的ECS实例一起释放。</p><p>根据性能不同，共享块存储可以分为：</p><ul><li>SSD共享块存储：采用固态硬盘作为存储介质，能够提供稳定的高随机I/O、高数据可靠性的高性能存储。</li></ul><ul><li>高效共享块存储：采用固态硬盘与机械硬盘的混合介质作为存储介质。</li></ul><p>挂载到实例上时，共享块存储与云盘共享数据盘配额，即一台实例最多挂载16块数据盘。</p><p>更多共享块存储的信息，请参见 共享块存储FAQ。</p><h2 id="网络和安全性"><a href="#网络和安全性" class="headerlink" title="网络和安全性"></a>网络和安全性</h2><h3 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h3><p>目前阿里云的云服务器ECS内网间，非I/O优化的实例为千兆共享的带宽，I/O优化的实例为万兆共享的带宽，没有特殊限制。由于是共享网络，因此无法保证带宽速度是不变的。</p><p>如果两台同地域的ECS实例之间需要传输数据，一般建议使用内网连接。同时，云数据库RDS、负载均衡（SLB） 以及 对象存储（OSS） 相关的内网速度也都是千兆共享的环境。这些产品间也都可以使用内网相互连接使用。</p><p>目前只要是相同地域下，SLB、云数据库RDS、OSS与ECS之间都可以直接内网互通连接使用。</p><h3 id="弹性网卡"><a href="#弹性网卡" class="headerlink" title="弹性网卡"></a>弹性网卡</h3><p>弹性网卡（ENI）是一种可以附加到专有网络VPC类型ECS实例上的虚拟网卡，通过弹性网卡，您可以实现高可用集群搭建、低成本故障转移和精细化的网络管理。所有地域均支持弹性网卡。</p><p><strong>使用场景</strong><br>弹性网卡适用于以下几种场景：</p><ul><li>搭建高可用集群</li></ul><p>满足系统高可用架构对于单实例多网卡的需求。</p><ul><li>低成本故障迁移</li></ul><p>通过将弹性网卡从ECS实例分离后再附加到另外一台ECS实例，将故障实例上的业务流量快速迁移到备用实例，实现服务快速恢复。</p><ul><li>精细化网络管理</li></ul><p>可以为实例配置多个弹性网卡，例如用于内部管理的弹性网卡及用于面向公网业务访问的弹性网卡等，完成管理数据和业务数据间的隔离。可以根据源IP、协议、端口等对每张弹性网卡配置精准的安全组规则，从而对每张弹性网卡的流量进行安全访问控制。</p><p><strong>弹性网卡类型</strong></p><p>弹性网卡分为两种类型：</p><p>主网卡</p><p>在创建专有网络实例时随实例默认创建的弹性网卡称作主网卡。主网卡的生命周期和实例保持一致，您无法分离主网卡与实例。</p><p>辅助网卡</p><p>您可以创建辅助网卡，并将其附加到实例上或从实例上分离。每个实例能附加的网卡上限与实例规格相关，详细信息，请参考 实例规格族。</p><p><strong>弹性网卡属性</strong></p><pre><code>属性    数量主私有IP地址    1个MAC地址    1个安全组    至少1个，最多5个描述信息    1个网卡名称    1个</code></pre><p><strong>限制约束</strong></p><p>使用弹性网卡有如下限制：</p><ul><li>一个账号在一个地域内默认最多可创建100个弹性网卡。如果需要更多，请 提交工单 申请。</li></ul><ul><li>ECS实例与弹性网卡必须在同一VPC的同一可用区中，可以分属于不同交换机。</li></ul><ul><li>每台实例允许附加的弹性网卡数量由实例规格决定。详细信息，请参见 实例规格族。</li></ul><ul><li>非I/O优化实例规格不支持弹性网卡。</li></ul><ul><li>您不能在一个实例上附加多个弹性网卡来提高实例带宽。<blockquote><p>说明：实例的带宽能力由实例规格决定。</p></blockquote></li></ul><h3 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h3><p>安全组是一个逻辑上的分组，这个分组是由同一个地域（Region）内具有相同安全保护需求并相互信任的实例组成。<strong><code>每个实例至少属于一个安全组，在创建的时候就需要指定</code></strong>。同一安全组内的实例之间网络互通，不同安全组的实例之间默认内网不通。可以授权两个安全组之间互访。</p><p>安全组是一种虚拟防火墙，具备状态检测包过滤功能。安全组用于设置单台或多台云服务器的网络访问控制，它是重要的网络安全隔离手段，用于在云端划分安全域。</p><p><strong>安全组限制</strong></p><ul><li>单个安全组内的实例个数不能超过 1000。如果您有超过 1000 个实例需要内网互访，可以将他们分配到多个安全组内，并通过互相授权的方式允许互访。</li></ul><ul><li>每个实例最多可以加入 5 个安全组。</li></ul><ul><li>每个用户的安全组最多 100 个。</li></ul><ul><li>对安全组的调整操作，对用户的服务连续性没有影响。</li></ul><ul><li>安全组是有状态的。如果数据包在 Outbound 方向是被允许的，那么对应的此连接在 Inbound 方向也是允许的。</li></ul><ul><li>安全组的网络类型分为经典网络和专有网络。</li></ul><pre><code>- 经典网络类型的实例可以加入同一地域（Region）下经典网络类型的安全组。- 专有网络类型的实例可以加入同一专有网络（VPC）下的安全组。</code></pre><p><strong>安全组规则</strong></p><p>安全组规则可以允许或者禁止与安全组相关联的云服务器 ECS 实例的公网和内网的入出方向的访问。</p><p>您可以随时授权和取消安全组规则。您的变更安全组规则会自动应用于与安全组相关联的ECS实例上。</p><p>在设置安全组规则的时候，安全组的规则务必简洁。如果您给一个实例分配多个安全组，则该实例可能会应用多达数百条规则。访问该实例时，可能会出现网络不通的问题。</p><p><strong>安全组规则限制</strong></p><p>每个安全组最多有 100 条安全组规则。</p><h3 id="DDOS基础防护"><a href="#DDOS基础防护" class="headerlink" title="DDOS基础防护"></a>DDOS基础防护</h3><p>阿里云云盾默认为ECS实例免费提供5 Gbit/s恶意流量攻击，即 DDoS基础防护能力。这一功能可以有效防止云服务器ECS实例受到恶意攻击，从而保证ECS系统的稳定，即当流入ECS实例的流量超出实例规格对应的限制时，云盾就会帮助ECS实例限流，避免ECS系统出现问题。</p><h1 id="企业版入门"><a href="#企业版入门" class="headerlink" title="企业版入门"></a>企业版入门</h1><p>企业级用户在购买和使用云服务器ECS实例时，通常需考虑如下几点：</p><ul><li><p>配置选型</p></li><li><p>估算成本</p></li><li><p>网络规划</p></li><li><p>配置安全组</p></li><li><p>制定快照策略</p></li><li><p>镜像迁移</p></li><li><p>用负载均衡实现ECS的高可用性</p></li></ul><h2 id="配置选型"><a href="#配置选型" class="headerlink" title="配置选型"></a>配置选型</h2><p>参考资料：<a href="https://help.aliyun.com/document_detail/58291.html?spm=a2c4g.11186623.6.604.XRqStZ" target="_blank" rel="noopener">阿里云官方资料</a></p><h1 id="用户指南"><a href="#用户指南" class="headerlink" title="用户指南"></a>用户指南</h1><h2 id="安全组-1"><a href="#安全组-1" class="headerlink" title="安全组"></a>安全组</h2><h3 id="安全组限制"><a href="#安全组限制" class="headerlink" title="安全组限制"></a>安全组限制</h3><ul><li>单个安全组内的实例个数不能超过 1000。如果您有超过 1000 个实例需要内网互访，可以将他们分配到多个安全组内，并通过互相授权的方式允许互访。</li></ul><ul><li>每个实例最多可以加入 5 个安全组。</li></ul><ul><li>每个用户的安全组最多 100 个。</li></ul><ul><li>对安全组的调整操作，对用户的服务连续性没有影响。</li></ul><ul><li>安全组是有状态的。如果数据包在 Outbound 方向是被允许的，那么对应的此连接在 Inbound 方向也是允许的。</li></ul><ul><li>安全组的网络类型分为经典网络和专有网络。</li></ul><pre><code>- 经典网络类型的实例可以加入同一地域（Region）下经典网络类型的安全组。- 专有网络类型的实例可以加入同一专有网络（VPC）下的安全组。</code></pre><ul><li>每个安全组最多有 100 条安全组规则。</li></ul><h3 id="安全组注意事项"><a href="#安全组注意事项" class="headerlink" title="安全组注意事项"></a>安全组注意事项</h3><ul><li>出方向的端口25默认受限，无法通过安全组规则打开，但是您可以 <a href="https://help.aliyun.com/knowledge_detail/56130.html" target="_blank" rel="noopener">申请解封端口25</a>。</li></ul><h3 id="安全组实践的基本建议"><a href="#安全组实践的基本建议" class="headerlink" title="安全组实践的基本建议"></a>安全组实践的基本建议</h3><p>在开始安全组的实践之前，下面有一些基本的建议：</p><ul><li>最重要的规则：安全组应作为白名单使用。</li></ul><ul><li>开放应用出入规则时应遵循“最小授权”原则，例如，您可以选择开放具体的端口（如 80 端口）。</li></ul><ul><li>不应使用一个安全组管理所有应用，因为不同的分层一定有不同的需求。</li></ul><ul><li>对于分布式应用来说，不同的应用类型应该使用不同的安全组，例如，您应对 Web、Service、Database、Cache 层使用不同的安全组，暴露不同的出入规则和权限。</li></ul><ul><li>没有必要为每个实例单独设置一个安全组，控制管理成本。</li></ul><ul><li>优先考虑 VPC 网络。</li></ul><ul><li>不需要公网访问的资源不应提供公网 IP。</li></ul><ul><li>尽可能保持单个安全组的规则简洁。因为一个实例最多可以加入 5 个安全组，一个安全组最多可以包括 100 个安全组规则，所以一个实例可能同时应用数百条安全组规则。您可以聚合所有分配的安全规则以判断是否允许流入或留出，但是，如果单个安全组规则很复杂，就会增加管理的复杂度。所以，应尽可能地保持单个安全组的规则简洁。</li></ul><ul><li>调整线上的安全组的出入规则是比较危险的动作。如果您无法确定，不应随意更新安全组出入规则的设置。阿里云的控制台提供了克隆安全组和安全组规则的功能。如果您想要修改线上的安全组和规则，您应先克隆一个安全组，再在克隆的安全组上进行调试，从而避免直接影响线上应用。</li></ul><h3 id="设置安全组规则"><a href="#设置安全组规则" class="headerlink" title="设置安全组规则"></a>设置安全组规则</h3><h4 id="设置安全组的入网规则"><a href="#设置安全组的入网规则" class="headerlink" title="设置安全组的入网规则"></a>设置安全组的入网规则</h4><p><strong>不要使用 0.0.0.0/0 的入网规则</strong></p><p>允许全部入网访问是经常犯的错误。使用 0.0.0.0/0 意味着所有的端口都对外暴露了访问权限。这是非常不安全的。正确的做法是，先拒绝所有的端口对外开放。安全组应该是白名单访问。例如，如果您需要暴露 Web 服务，默认情况下可以只开放 80、8080 和 443 之类的常用TCP端口，其它的端口都应关闭。</p><pre><code>{ &quot;IpProtocol&quot; : &quot;tcp&quot;, &quot;FromPort&quot; : &quot;80&quot;, &quot;ToPort&quot; : &quot;80&quot;, &quot;SourceCidrIp&quot; : &quot;0.0.0.0/0&quot;, &quot;Policy&quot;: &quot;accept&quot;} ,{ &quot;IpProtocol&quot; : &quot;tcp&quot;, &quot;FromPort&quot; : &quot;8080&quot;, &quot;ToPort&quot; : &quot;8080&quot;, &quot;SourceCidrIp&quot; : &quot;0.0.0.0/0&quot;, &quot;Policy&quot;: &quot;accept&quot;} ,{ &quot;IpProtocol&quot; : &quot;tcp&quot;, &quot;FromPort&quot; : &quot;443&quot;, &quot;ToPort&quot; : &quot;443&quot;, &quot;SourceCidrIp&quot; : &quot;0.0.0.0/0&quot;, &quot;Policy&quot;: &quot;accept&quot;} ,</code></pre><p><strong>关闭不需要的入网规则</strong></p><p>如果您当前使用的入规则已经包含了 0.0.0.0/0，您需要重新审视自己的应用需要对外暴露的端口和服务。如果确定不想让某些端口直接对外提供服务，您可以加一条拒绝的规则。比如，如果您的服务器上安装了 MySQL 数据库服务，默认情况下您不应该将 3306 端口暴露到公网，此时，您可以添加一条拒绝规则，如下所示，并将其优先级设为100，即优先级最低。</p><pre><code>{ &quot;IpProtocol&quot; : &quot;tcp&quot;, &quot;FromPort&quot; : &quot;3306&quot;, &quot;ToPort&quot; : &quot;3306&quot;, &quot;SourceCidrIp&quot; : &quot;0.0.0.0/0&quot;, &quot;Policy&quot;: &quot;drop&quot;, Priority: 100} ,</code></pre><p>上面的调整会导致所有的端口都不能访问 3306 端口，极有可能会阻止您正常的业务需求。此时，您可以通过授权另外一个安全组的资源进行入规则访问。</p><p><strong>授权另外一个安全组入网访问</strong></p><p>不同的安全组按照最小原则开放相应的出入规则。对于不同的应用分层应该使用不同的安全组，不同的安全组应有相应的出入规则。</p><p>例如，如果是分布式应用，您会区分不同的安全组，但是，不同的安全组可能网络不通，此时您不应该直接授权 IP 或者 CIDR 网段，而是直接授权另外一个安全组 ID 的所有的资源都可以直接访问。比如，您的应用对 Web、Database 分别创建了不同的安全组：sg-web 和 sg-database。在sg-database 中，您可以添加如下规则，授权所有的 sg-web 安全组的资源访问您的 3306 端口。</p><pre><code>{ &quot;IpProtocol&quot; : &quot;tcp&quot;, &quot;FromPort&quot; : &quot;3306&quot;, &quot;ToPort&quot; : &quot;3306&quot;, &quot;SourceGroupId&quot; : &quot;sg-web&quot;, &quot;Policy&quot;: &quot;accept&quot;, Priority: 2} ,</code></pre><p><strong>授权另外一个 CIDR 可以入网访问</strong></p><p>经典网络中，因为网段不太可控，建议您使用安全组 ID 来授信入网规则。</p><p>VPC 网络中，您可以自己通过不同的 VSwitch 设置不同的 IP 域，规划 IP 地址。所以，在 VPC 网络中，您可以默认拒绝所有的访问，再授信自己的专有网络的网段访问，直接授信可以相信的 CIDR 网段。</p><pre><code>{ &quot;IpProtocol&quot; : &quot;icmp&quot;, &quot;FromPort&quot; : &quot;-1&quot;, &quot;ToPort&quot; : &quot;-1&quot;, &quot;SourceCidrIp&quot; : &quot;10.0.0.0/24&quot;, Priority: 2} ,{ &quot;IpProtocol&quot; : &quot;tcp&quot;, &quot;FromPort&quot; : &quot;0&quot;, &quot;ToPort&quot; : &quot;65535&quot;, &quot;SourceCidrIp&quot; : &quot;10.0.0.0/24&quot;, Priority: 2} ,{ &quot;IpProtocol&quot; : &quot;udp&quot;, &quot;FromPort&quot; : &quot;0&quot;, &quot;ToPort&quot; : &quot;65535&quot;, &quot;SourceCidrIp&quot; : &quot;10.0.0.0/24&quot;, Priority: 2} ,</code></pre><p><strong>总结：</strong></p><ol><li>安全组的实质是白名单</li><li>不适用0.0.0.0/0的入网规则</li><li>如果已经存在了0.0.0.0/0这种规则，那么需要设置关闭不安全的入网规则，例如关闭3306端口等，这里需要设置优先级为最小值100</li><li>不同应用使用不同的安全组，在这种情况下，需要在入向规则中添加安全组授权，比如数据库的安全组中授权web的安全组</li></ol><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1>]]></content>
    
    <summary type="html">
    
      ECS从入门到实践
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="公有云产品" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"/>
    
      <category term="阿里云" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="ECS" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/%E9%98%BF%E9%87%8C%E4%BA%91/ECS/"/>
    
    
      <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>带宽计算方法及B与b说明</title>
    <link href="http://yoursite.com/2018/05/30/%E5%B8%A6%E5%AE%BD%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E5%8F%8AB%E4%B8%8Eb%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/05/30/带宽计算方法及B与b说明/</id>
    <published>2018-05-30T12:55:38.000Z</published>
    <updated>2018-05-30T12:55:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><a href="https://blog.csdn.net/tianlesoftware/article/details/6909042" target="_blank" rel="noopener">带宽计算方法及大B与小b说明</a></li></ul><h1 id="bit与Byte的关系"><a href="#bit与Byte的关系" class="headerlink" title="bit与Byte的关系"></a>bit与Byte的关系</h1><p><strong>源信息</strong></p><p>在计算机科学中，bit（比特）是表示信息的最小单位，叫做二进制位；一般用0和1表示。</p><p>Byte叫做字节，由8个比特位（8bit）组成一个字节(1Byte)，用于表示计算机中的一个字符。</p><p>bit与Byte之间可以进行换算，其换算关系为：1Byte=8bit（或简写为：1B=8b）</p><p>在实际应用中一般用简称， 即1bit简写为1b(注意是小写英文字母b)，1Byte简写为1B（注意是大写英文字母B）。</p><p><strong>ISP的表示</strong></p><p>在计算机网络或者是网络运营商(Internet service provider)中，一般宽带速率的表示单位用bps(或b/s，小b)表示；</p><p>bps表示<strong><code>比特每秒</code></strong>即表示<strong><code>每秒钟传输多少位</code></strong>信息，是<strong><code>bit per second</code></strong>的缩写。在实际所说的1M带宽的意思是1Mbps（是兆比特每秒Mbps不是兆字节每秒MBps）</p><font color="red"><strong>换算公式:</strong></font><pre><code>1Byte    =    8bit1B    =    8b---------- 1B/s=8b/s(或1Bps=8bps)1KB    =    1024B---------- 1KB/s=1024B/s1MB    =    1024KB ---------- 1MB/s=1024KB/s最终：1Mbps =    1024*1024 bps = 1024 Kbps = 1024/8 KBps = 128KBps = 128KB/s</code></pre><p><strong>规范提示：</strong></p><blockquote><p>在实际书写中，B应表示Byte(字节)，b应表示bit(比特)，但是我们在实际书写中很容易把bit和Byte都混写为b ，如把Mb/s和MB/s都混写为Mb/s，导致人们在实际计算中因单位的混淆而出错。</p></blockquote><h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>在实际上网应用中，下载软件时常常看到诸如下载速度显示为128KB（KB/s），103KB/s等等宽带速率大小字样，因为ISP提供的线路带宽使用的单位是比特（bit，即小b），而一般下载软件显示的是字节（byte，1byte＝8bits），所以要通过换算，才能得实际值。</p><p>所以，我们可以按照公式换算一下：</p><pre><code>128KB/s=128×8(Kb/s)=1024Kb/s=1Mb/s即：128KB/s=1Mb/s。</code></pre><p>也就是说1Mb的带宽，下载速度为128KB/s秒</p><p>在一些软件的带宽的显示页面，通常的显示页面也是以bps的方式来显示，这个时候，我们就需要进行一下换算，例如下面的页面截图（阿里云带宽使用情况）</p><p><img src="http://picture.watchmen.xin/network/bandwidth.png" alt="带宽"></p><p>图中所选的这个值是：13272120 bps(bits/s)，我们下面进行换算：</p><pre><code>13272120 bps = 13272120/1024 Kbps = 13272120/1024/1024 Mbps = 12.65723 Mbps </code></pre><p>换算之后，我们可以看到这里显示的带宽是12.6M</p><h2 id="补充：ADSL宽带知识"><a href="#补充：ADSL宽带知识" class="headerlink" title="补充：ADSL宽带知识"></a>补充：ADSL宽带知识</h2><p>ADSL（Asymmetric Digital Subscriber Loop）技术是一种不对称数字用户线实现宽带接入互连网的技术，ADSL作为一种传输层的技术，充分利用现有的铜线资源，在一对双绞线上提供上行640kbps（理论上行1Mbps）下行8Mbps的带宽，从而克服了传统用户在”最后一公里”的”瓶颈”，实现了真正意义上的宽带接入。</p><p><strong>上行速率：</strong>是指用户电脑向网络发送信息时的数据传输速率。</p><p><strong>下行速率：</strong> 是指网络向用户电脑发送信息时的传输速率。比如用 FTP上传文件到网上去，影响上传速度的就是“上行速率”；而从网上下载文件，影响下载速度的就是“下行速率”。</p><p>当然，在实际上传下载过程中，线路、设备 (含计算机及其他设备)等的质量也会对速度造成或多或少的影响。</p><p><strong>上行速率对上行速率的影响</strong></p><p>TCP/IP规定，每一个封包，都需要有acknowledge信息的回传，也就是说，传输的资料，需要有一个收到资料的信息回复，才能决定后面的传输速度，并决定是否重新传输遗失的资料。　</p><p><font color="red">行的带宽一部分就是用来传输这些acknowledge(确认)资料的，当上行负载过大的时候，就会影响acknowledge资料的传送速度，并进而影响到下载速度。这对非对称数字环路也就是ADSL这种上行带宽远小于下载带宽的连接来说影响尤为明显。</font>　 </p><p>有试验证明，当上传满载时，下载速度讲变为理想速度的40%，这就可以解释为什么很多朋友用BT下载的时候稍微限速反而能够获得更大的下载速度。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在网络运营商提供的宽带速率单位中，”bps”是指”bit per second”</p><p>而我们在日常生活中，使用的一般是”Byte persecond”(Bps)</p><p>我们说的带宽几M几M指的是 2Mbps、8Mbps这种格式，为了便于更加直观的查看，我们会转回成为KB的形式，也就是说，我们拿到这个数字之后，需要先*1024，将M变成K，然后再/8，最后的单位就是我们最常使用的单位了</p><p>举个栗子：</p><pre><code>1M的带宽，理论的下载速度为：1*1024/8= 128KB/s8M的带宽，理论的下载速度为：8*1024/8 = 1024KB/s = 1MB/s</code></pre><p>在8M带宽之后，我们的换算，可以直接除以8来得到结果</p><pre><code>100M的带宽，理论的下载速度为： 100/8 = 12.5MB/s</code></pre>]]></content>
    
    <summary type="html">
    
      带宽计算方法及B与b说明
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="网络知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="带宽计算" scheme="http://yoursite.com/tags/%E5%B8%A6%E5%AE%BD%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Python基础知识</title>
    <link href="http://yoursite.com/2018/05/24/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/05/24/Python基础知识/</id>
    <published>2018-05-24T13:05:55.000Z</published>
    <updated>2018-05-24T13:05:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h1><h2 id="Python擅长领域"><a href="#Python擅长领域" class="headerlink" title="Python擅长领域"></a>Python擅长领域</h2><p><strong>Web开发</strong></p><ul><li>django</li><li>pyramid</li><li>tornado</li><li>bottle</li><li>flask</li><li>webpy</li></ul><p><strong>网络编程</strong></p><ul><li>twisted</li><li>request</li><li>scrapy</li><li>paramiko</li><li>scipy</li><li>pandas</li><li>ipython</li></ul><p><strong>GUI图形开发</strong></p><ul><li>wxpython</li><li>pyqt</li><li>kivy</li></ul><p><strong>运维自动化</strong></p><ul><li>openstack</li><li>saltstack</li><li>ansible</li><li>腾讯蓝鲸</li></ul><h2 id="编程语言概述"><a href="#编程语言概述" class="headerlink" title="编程语言概述"></a>编程语言概述</h2><p>编程语言主要从以下几个角度为进行分类：</p><ul><li><p>低级语言与高级语言</p></li><li><p>编译型和解释型</p></li><li><p>静态语言和动态语言</p></li><li><p>强类型定义语言和弱类型定义语言</p></li></ul><p>每个分类代表什么意思呢，我们一起来看一下。</p><h3 id="低级语言与高级语言"><a href="#低级语言与高级语言" class="headerlink" title="低级语言与高级语言"></a>低级语言与高级语言</h3><p><strong>低级语言</strong></p><p>最初的计算机程序都是使用0和1的序列表示的，程序员直接使用的是机器指令，无需翻译，从纸带打孔输入即可得到结果。后来为了记忆方便，就将用0、1序列表示的机器指令都用符号助记，这些与机器指令一一对应的助记符号就成为了汇编指令，从而诞生了汇编语言。</p><p>无论是机器指令还是汇编指令，都是面向机器的，这些统称为低级语言。因此是针对特定机器的机器指令的助记符，所以汇编语言是无法独立于机器（特定的CPU体系结构）的</p><p>但是汇编语言也是需要经过翻译才能转变为机器指令，所以也就有了将运行在一种机器上的汇编语言翻译成为另一类机器上的机器指令的方法，这被称之为：<strong><code>交叉汇编技术</code></strong></p><p><strong>高级语言</strong></p><p>高级语言是从人类的逻辑思维角度出发的计算机语言，因此，抽象程度大大提高，需要经过编译成特定机器上的目标代码才能执行，一条高级语言的语句往往需要若干条机器指令来完成。</p><p><font color="red"><strong><code>高级语言独立于机器的特性是靠编译器为不同机器生成不同的目标代码（或者机器指令）来实现的</code></strong></font>。具体来说，要将高级语言编译到什么程度，这跟编译的技术相挂钩，可以编译成为直接可以执行的目标代码，也可以变成成为一种中间表示，然后拿到不同的机器和系统上面去执行，这种情况通常是又需要支撑环境，比如解释器或者虚拟机的支持，Java程序编译成为bytecode，再由不同平台上的虚拟机执行就是很好的例子。</p><p>所以，<font color="red"><strong><code>说高级语言不依赖于机器，指的是在不同的机器或者平台上高级语言的程序本身不变，而通过编译器编译得到的目标代码去使用不同的机器。</code></strong></font><br>从这个意义来说，通过交叉编译，一些汇编程序也可以获得不同机器之间的可移植性，但是这种途径获得的移植性远远不如高级语言来的方便和实用。</p><p><strong>总结</strong></p><p>我们说的低级语言和高级语言，主要的区别点在于主要针对的对象，低级语言主要针对的对象是特定的机器，而高级语言，主要针对的对象是人类的逻辑。</p><h3 id="编译型和解释型"><a href="#编译型和解释型" class="headerlink" title="编译型和解释型"></a>编译型和解释型</h3><p><strong>概念</strong></p><p>编译器是把源程序的每一条语句都<strong><code>编译成机器语言</code></strong>,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快; </p><p>解释器则是只在执行程序时,才<strong><code>一条一条</code></strong>的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的. </p><p>这是因为计算机不能直接认识并执行我们写的语句,它只能认识机器语言(是二进制的形式)</p><p>以下是各语言的分类</p><p><img src="http://picture.watchmen.xin/python-14/lang.png" alt=""></p><p><strong>编译型and解释型</strong></p><ul><li>编译型</li></ul><p>优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，<strong><code>运行时不需要编译</code></strong>，所以编译型语言的程序执行效率高。<strong><code>可以脱离语言环境独立运行。</code></strong></p><p>缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。</p><p>也就是说，使用编译器将源代码文件进行编译之后，生成文件之后，计算机就可以直接运行，不再需要借助其他的东西，因此运行效率是最高的，但是这要求前期的准备工作必须做的非常完善，因为如果有代码需要修改的话，需要重新编译是生成执行文件。</p><ul><li>解释型</li></ul><blockquote><p>优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（一般我们也称之为虚拟机）。灵活，修改代码的时候可以直接修改，可以快速部署，不用停机维护</p><p>缺点：每次运行的时候都需要使用解释器解释一遍，因此在性能上是不如编译型语言的。</p><p>解释型语言可以无视运行的系统平台，只要有解释器的存在，能将源代码解释翻译成为计算机能够识别的机器语言即可。 </p></blockquote><p><strong>两者对比</strong></p><p>编译是将源程序翻译成可执行的目标代码，翻译与执行是分开的；而解释是对源程序的翻译与执行一次性完成，不生成可存储的目标代码。这只是表象，二者背后的最大区别是：<strong><code>对解释执行而言，程序运行时的控制权在解释器而不在用户程序；对编译执行而言，运行时的控制权在用户程序</code></strong>。</p><p>解释具有良好的动态特性和可移植性，比如在解释执行时可以动态改变变量的类型、对程序进行修改以及在程序中插入良好的调试诊断信息等，而将解释器移植到不同的系统上，则程序不用改动就可以在移植了解释器的系统上运行。同时解释器也有很大的缺点，比如执行效率低，占用空间大，因为不仅要给用户程序分配空间，解释器本身也占用了宝贵的系统资源。【这就是为什么JAVA虚拟机优化知识相当重要】</p><p>编译器是把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快;<br>而解释器则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的。</p><p><strong>深度扩展</strong></p><p>我们先看看编译型，其实它和汇编语言是一样的：也是有一个负责翻译的程序来对我们的源代码进行转换，生成相对应的可执行代码。这个过程说得专业一点，就称为编译（Compile），而负责编译的程序自然就称为编译器（Compiler）。如果我们写的程序代码都包含在一个源文件中，那么通常编译之后就会直接生成一个可执行文件，我们就可以直接运行了。但对于一个比较复杂的项目，为了方便管理，我们通常把代码分散在各个源文件中，作为不同的模块来组织。这时编译各个文件时就会生成目标文件（Object   file）而不是前面说的可执行文件。一般一个源文件的编译都会对应一个目标文件。这些目标文件里的内容基本上已经是可执行代码了，但由于只是整个项目的一部分，所以我们还不能直接运行。待所有的源文件的编译都大功告成，我们就可以最后把这些半成品的目标文件“打包”成一个可执行文件了，这个工作由另一个程序负责完成，由于此过程好像是把包含可执行代码的目标文件连接装配起来，所以又称为链接（Link），而负责链接的程序就叫……就叫链接程序（Linker）。链接程序除了链接目标文件外，可能还有各种资源，像图标文件啊、声音文件啊什么的，还要负责去除目标文件之间的冗余重复代码，等等，所以……也是挺累的。链接完成之后，一般就可以得到我们想要的可执行文件了。 </p><p>上面我们大概地介绍了编译型语言的特点，现在再看看解释型。噢，从字面上看，“编译”和“解释”的确都有“翻译”的意思，它们的区别则在于翻译的时机安排不大一样。打个比方：假如你打算阅读一本外文书，而你不知道这门外语，那么你可以找一名翻译，给他足够的时间让他从头到尾把整本书翻译好，然后把书的母语版交给你阅读；或者，你也立刻让这名翻译辅助你阅读，让他一句一句给你翻译，如果你想往回看某个章节，他也得重新给你翻译。 </p><p>两种方式，前者就相当于我们刚才所说的编译型：一次把所有的代码转换成机器语言，然后写成可执行文件；而后者就相当于我们要说的解释型：在程序运行的前一刻，还只有源程序而没有可执行程序；而程序每执行到源程序的某一条指令，则会有一个称之为解释程序的外壳程序将源代码转换成二进制代码以供执行，总言之，就是不断地解释、执行、解释、执行……所以，解释型程序是离不开解释程序的。像早期的BASIC就是一门经典的解释型语言，要执行BASIC程序，就得进入BASIC环境，然后才能加载程序源文件、运行。解释型程序中，由于程序总是以源代码的形式出现，因此只要有相应的解释器，移植几乎不成问题。编译型程序虽然源代码也可以移植，但前提是必须针对不同的系统分别进行编译，对于复杂的工程来说，的确是一件不小的时间消耗，况且很可能一些细节的地方还是要修改源代码。而且，解释型程序省却了编译的步骤，修改调试也非常方便，编辑完毕之后即可立即运行，不必像编译型程序一样每次进行小小改动都要耐心等待漫长的Compiling…Linking…这样的编译链接过程。不过凡事有利有弊，由于解释型程序是将编译的过程放到执行过程中，这就决定了解释型程序注定要比编译型慢上一大截，像几百倍的速度差距也是不足为奇的。 </p><p>编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object   Pascal（Delphi）、VB等基本都可视为编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如Java、JavaScript、VBScript、Perl、Python等等。 </p><p>但既然编译型与解释型各有优缺点又相互对立，所以一批新兴的语言都有把两者折衷起来的趋势，例如Java语言虽然比较接近解释型语言的特征，但在执行之前已经预先进行一次预编译，生成的代码是介于机器码和Java源代码之间的中介代码，运行的时候则由JVM（Java的虚拟机平台，可视为解释器）解释执行。它既保留了源代码的高抽象、可移植的特点，又已经完成了对源代码的大部分预编译工作，所以执行起来比“纯解释型”程序要快许多。而像VB6（或者以前版本）、C#这样的语言，虽然表面上看生成的是.exe可执行程序文件，但VB6编译之后实际生成的也是一种中介码，只不过编译器在前面安插了一段自动调用某个外部解释器的代码（该解释程序独立于用户编写的程序，存放于系统的某个DLL文件中，所有以VB6编译生成的可执行程序都要用到它），以解释执行实际的程序体。C#（以及其它.net的语言编译器）则是生成.net目标代码，实际执行时则由.net解释系统（就像JVM一样，也是一个虚拟机平台）进行执行。当然.net目标代码已经相当“低级”，比较接近机器语言了，所以仍将其视为编译语言，而且其可移植程度也没有Java号称的这么强大，Java号称是“一次编译，到处执行”，而.net则是“一次编码，到处编译”。呵呵，当然这些都是题外话了。总之，随着设计技术与硬件的不断发展，编译型与解释型两种方式的界限正在不断变得模糊。</p><h3 id="静态语言和动态语言"><a href="#静态语言和动态语言" class="headerlink" title="静态语言和动态语言"></a>静态语言和动态语言</h3><p>通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。【主要指的是数据类型】</p><ul><li>动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。</li></ul><ul><li>静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。</li></ul><h3 id="强类型定义语言和弱类型定义语言"><a href="#强类型定义语言和弱类型定义语言" class="headerlink" title="强类型定义语言和弱类型定义语言"></a>强类型定义语言和弱类型定义语言</h3><ul><li>强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。</li></ul><ul><li>弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。</li></ul><p>强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的！</p><p>例如：Python是动态语言，是强类型定义语言（类型安全的语言）; VBScript是动态语言，是弱类型定义语言（类型不安全的语言）; JAVA是静态语言，是强类型定义语言（类型安全的语言）。</p><p><strong>注意：</strong></p><blockquote><p>固定了数据类型，并不是说该变量就不能再被赋值了，如果变量被重新赋值了，那么相应的，它的数据类型也可能会发生变化。</p><p>这里说的是，赋值这个，数据类型就固定了，在后续使用这个变量的时候，数据类型不会发生改变。 </p></blockquote><p>通过上面这些介绍，我们可以得出，<font color="red"><strong><code>python是一门动态解释性的强类型定义高级语言</code></strong></font>。那这些基因成就了Python的哪些优缺点呢？我们继续往下看。</p><h2 id="Python的优缺点"><a href="#Python的优缺点" class="headerlink" title="Python的优缺点"></a>Python的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。</li></ul><ul><li>开发效率非常高，Python有非常强大的第三方库，基本上你想通过计算机实现任何功能，Python官方库里都有相应的模块进行支持，直接下载调用后，在基础库的基础上再进行开发，大大降低开发周期，避免重复造轮子。</li></ul><ul><li>高级语言————当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节</li></ul><ul><li>可移植性————由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工 作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就几乎可以在市场上所有的系统平台上运行<blockquote><p>比如某些程序，必须要调用windows的dll，那么就会依赖操作系统，因此我们要做的就是尽量避免依赖这些</p></blockquote></li></ul><ul><li>可扩展性————如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。</li></ul><ul><li>可嵌入性————你可以把Python嵌入你的C/C++程序，从而向你的程序用户提供脚本功能。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>速度慢，Python 的运行速度相比C语言确实慢很多，跟JAVA相比也要慢一些，因此这也是很多所谓的大牛不屑于使用Python的主要原因，但其实这里所指的运行速度慢在大多数情况下用户是无法直接感知到的，必须借助测试工具才能体现出来，比如你用C运一个程序花了0.01s,用Python是0.1s,这样C语言直接比Python快了10倍,算是非常夸张了，但是你是无法直接通过肉眼感知的，因为一个正常人所能感知的时间最小单位是0.15-0.4s左右，哈哈。其实在大多数情况下Python已经完全可以满足你对程序速度的要求，除非你要写对速度要求极高的搜索引擎等，这种情况下，当然还是建议你用C去实现的。</li></ul><ul><li>代码不能加密，因为PYTHON是解释性语言，它的源码都是以名文形式存放的，不过我不认为这算是一个缺点，如果你的项目要求源代码必须是加密的，那你一开始就不应该用Python来去实现。</li></ul><ul><li>线程不能利用多CPU问题，这是Python被人诟病最多的一个缺点，GIL即全局解释器锁（Global Interpreter Lock），是计算机程序设计语言解释器用于同步线程的工具，使得任何时刻仅有一个线程在执行，Python的线程是操作系统的原生线程。在Linux上为pthread，在Windows上为Win thread，完全由操作系统调度线程的执行。一个python解释器进程内有一条主线程，以及多条用户程序的执行线程。即使在多核CPU平台上，由于GIL的存在，所以禁止多线程的并行执行。关于这个问题的折衷解决方法，我们在以后线程和进程章节里再进行详细探讨。</li></ul><p>任何一门语言都不是完美的，都有擅长和不擅长做的事情，建议各位不要拿一个语言的劣势去跟另一个语言的优势来去比较，语言只是一个工具，是实现程序设计师思想的工具，就像我们之前中学学几何时，有的时候需要要圆规，有的时候需要用三角尺一样，拿相应的工具去做它最擅长的事才是正确的选择。</p><h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><p>当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。</p><p>由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。</p><p><strong>CPython</strong></p><p>当我们从Python官方网站下载并安装好Python 2.7后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。</p><p>CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。</p><p><strong>IPython</strong></p><p>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。</p><p>CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。</p><p><strong>PyPy</strong></p><p>PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术(即时编译技术)，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。</p><p>绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。</p><blockquote><p>Python创始人说：如果想代码跑的快，那就使用pypy</p></blockquote><p><strong>Jython</strong></p><p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p><p><strong>IronPython</strong></p><p>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p><p><strong>总结：</strong></p><p>Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</p><h2 id="变量和字符编码"><a href="#变量和字符编码" class="headerlink" title="变量和字符编码"></a>变量和字符编码</h2><p>变量的作用：存储数据，为了后面调用</p><p>变量存储在内存当中，每一个拥有独立的内存空间。</p><h3 id="Python变量的定义规则"><a href="#Python变量的定义规则" class="headerlink" title="Python变量的定义规则"></a>Python变量的定义规则</h3><ul><li>变量名只能是 字母、数字或下划线的任意组合</li></ul><ul><li>变量名的第一个字符不能是数字</li></ul><ul><li>以下关键字不能声明为变量名</li></ul><blockquote><p>[‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]</p></blockquote><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>注意，在C++等语言中可以定义常量，但是在python中没有常量的概念</p><p>那么，如果我们在python中想要定义一个常量，我们就将这个<font color="red"><strong><code>变量名大写</code></strong></font>。这是一种自发遵守的代码规范，并不是说不能再次修改，只是便于人类识别。 </p><p>例如：</p><pre><code>PIE = &quot;watchmen&quot;</code></pre><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机的底层就是电路，电路到最底层就只有两种状态，一种是通电，一种是不通电，那么也就是只能表示两种状态。</p><pre><code>128 64 32 16     8     4     2     1 1     1    1    1    1    1    1    1</code></pre><p>进位：后面的数字表示有上限之后，才进位到前面，例如：8+4+2+1=15，在表示16的时候，需要在前面表示进一位表示</p><p>第n位数表示的值：2^n-1,例如16=2^5-1=2^4 = 8+4+2+1+1</p><p>第n位数之前的值的总和是：2^n-1 -1。例如第5位数的前4位数的总和为：2^4-1=16-1</p><p>也就是说，我们可以通过这种方式来计算，n位数的总和：2^n-1</p><p>上面这些是二进制和数字的对应关系 </p><p>现在可以将数字和字符进行对应，指定某个数字对应某个字母</p><p>根据这种对应关系，人们就创建了ASCII编码方式</p><p>ASCII（American Standard Code for Information Interchange，<strong><code>美国标准信息交换代码</code></strong>）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，其最多只能用 8 位来表示（一个字节），即：2**8 = 256-1，所以，ASCII码最多只能表示 255 个符号。</p><p><img src="http://picture.watchmen.xin/python-14/ASCII.jpg" alt="ascii"></p><p>图中显示的是ASCII的上半部分，一共127个，剩余的128-255个是预留的。</p><p>预留的这128个空间，无法存储下中文，因此重新创造了编码方式（扩展编码）</p><p>将指定的空间，用来存储索引信息，只要是定位到这个空间，那么就将指向另外的一张中文表（大约7000+个汉字），这就是GB2312编码（1980年创建）</p><p>为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。</p><p>GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。</p><p>GB2312 支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。2000年的 GB18030是取代GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。</p><p>现在的PC平台必须支持GB18030，对嵌入式产品暂不作要求。所以手机、MP3一般只支持GB2312。</p><p>从ASCII、GB2312、GBK 到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。</p><p>有的中文Windows的缺省内码还是GBK，可以通过GB18030升级包升级到GB18030。不过GB18030相对GBK增加的字符，普通人是很难用到的，通常我们还是用GBK指代中文Windows内码。</p><p><strong>Unicode</strong></p><p>显然ASCII码无法将世界上的各种文字和符号全部表示，所以，就需要新出一种可以代表所有字符和符号的编码，即：Unicode</p><p>Unicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，规定虽有的字符和符号最少由 16 位来表示（2个字节），即：2 **16 = 65536，<br>注：此处说的的是最少2个字节，可能更多</p><p>UTF-8，是对Unicode编码的压缩和优化，他不再使用最少使用2个字节，而是将所有的字符和符号进行分类：</p><blockquote><p>ascii码中的内容用1个字节保存、欧洲的字符用2个字节保存，东亚的字符用3个字节保存..</p></blockquote><p>UTF-8，可以动态改变长度，可以动态变化的编码集 </p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释：  </p><pre><code># 被注释内容or&quot;被注释内容&quot;  也就是使用单引号或者双引号【注意，和shell不同，在python中，这两者没有区别】</code></pre><p>多行注释：</p><pre><code>&quot;&quot;&quot; 被注释内容 &quot;&quot;&quot;or&apos;&apos;&apos;被注释内容&apos;&apos;&apos;</code></pre><p>代码：</p><pre><code>message =&quot;&quot;&quot;line1line2line3&quot;&quot;&quot;print (message)</code></pre><p>程序输出为：</p><pre><code>line1line2line3</code></pre>]]></content>
    
    <summary type="html">
    
      Python基础知识
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="day01" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day01/"/>
    
      <category term="Python基础知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day01/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>IT类书籍资料</title>
    <link href="http://yoursite.com/2018/05/20/IT%E7%B1%BB%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%96%99/"/>
    <id>http://yoursite.com/2018/05/20/IT类书籍资料/</id>
    <published>2018-05-20T09:19:09.000Z</published>
    <updated>2018-05-20T09:19:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>从今天开始（2018年5月20日）记录个人运维职业成长过程中所看过的书籍资料情况</p><h1 id="科普读物"><a href="#科普读物" class="headerlink" title="科普读物"></a>科普读物</h1><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">作者</th><th style="text-align:center">出版年份</th><th style="text-align:center">阅读状态</th><th style="text-align:center">评级</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">浪潮之巅</td><td style="text-align:center">书籍</td><td style="text-align:center">吴军</td><td style="text-align:center"></td><td style="text-align:center">未读</td><td style="text-align:center">5星</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数学之美</td><td style="text-align:center">书籍</td><td style="text-align:center">吴军</td><td style="text-align:center"></td><td style="text-align:center">未读</td><td style="text-align:center"></td></tr></tbody></table><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><strong>Mysql：</strong></p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">作者</th><th style="text-align:center">出版年份</th><th style="text-align:center">阅读状态</th><th style="text-align:center">评级</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">MySQL技术内幕_InnoDB存储引擎.第2版</td><td style="text-align:center">书籍</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">高性能mysql</td><td style="text-align:center">书籍</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">MySQL 5.5从零开始学</td><td style="text-align:center">书籍</td></tr></tbody></table><p><strong>Redis</strong></p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">作者</th><th style="text-align:center">出版年份</th><th style="text-align:center">阅读状态</th><th style="text-align:center">评级</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">Redis运维与开发</td><td style="text-align:center">书籍</td><td style="text-align:center">付磊、张益军</td><td style="text-align:center">2017年4月</td><td style="text-align:center"><font color="red"><strong>精读，已看完</strong></font></td><td style="text-align:center">5星</td><td style="text-align:center">搜狐视频团队出品，其还开源了cachecloud云平台</td></tr></tbody></table><h1 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h1><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">作者</th><th style="text-align:center">出版年份</th><th style="text-align:center">阅读状态</th><th style="text-align:center">评级</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">SaltStack技术入门与实践</td><td style="text-align:center">书籍</td><td style="text-align:center">刘继伟、沈灿、赵舜东</td><td style="text-align:center">2016年1月</td><td style="text-align:center"></td></tr></tbody></table><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><p><strong>Python</strong></p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">作者</th><th style="text-align:center">出版年份</th><th style="text-align:center">阅读状态</th><th style="text-align:center">评级</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">Python编程从入门到实践</td><td style="text-align:center">书籍</td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      IT类书籍资料
    
    </summary>
    
      <category term="IT基础知识" scheme="http://yoursite.com/categories/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="IT类书籍资料" scheme="http://yoursite.com/categories/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/IT%E7%B1%BB%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%96%99/"/>
    
    
      <category term="IT书籍资料" scheme="http://yoursite.com/tags/IT%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Salt常用命令</title>
    <link href="http://yoursite.com/2018/05/20/Salt%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/05/20/Salt常用命令/</id>
    <published>2018-05-20T09:08:43.000Z</published>
    <updated>2018-05-20T09:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>有关SaltStack相关知识，可以看另一篇文章，本文只是记录常用命令，便于日常使用检索</p><p><a href="http://watchmen.xin/2018/05/20/SaltStack%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">SaltStack技术入门与实践</a></p><h1 id="Salt-master端命令"><a href="#Salt-master端命令" class="headerlink" title="Salt-master端命令"></a>Salt-master端命令</h1><ul><li><p><strong>查看证书签证情况</strong></p><p>  [root@master ~]# salt-key  -L </p></li><li><p><strong>同意签证所有没有接受的签证请求</strong></p></li></ul><pre><code>[root@master ~]# salt-key  -A -y </code></pre><p>在这里，A代表–accept-all的含义</p><h1 id="Salt-minion端命令"><a href="#Salt-minion端命令" class="headerlink" title="Salt-minion端命令"></a>Salt-minion端命令</h1>]]></content>
    
    <summary type="html">
    
      Salt常用命令
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="运维自动化" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="SaltStack" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/SaltStack/"/>
    
    
      <category term="SaltStack" scheme="http://yoursite.com/tags/SaltStack/"/>
    
  </entry>
  
  <entry>
    <title>常见应用程序/命令-协议/端口号对照表</title>
    <link href="http://yoursite.com/2018/05/20/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/20/常见网络应用端口号对照表/</id>
    <published>2018-05-20T08:36:46.000Z</published>
    <updated>2018-05-20T08:36:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络服务-端口对照关系表"><a href="#网络服务-端口对照关系表" class="headerlink" title="网络服务-端口对照关系表"></a>网络服务-端口对照关系表</h1><table><thead><tr><th style="text-align:left">应用程序API（命令）</th><th style="text-align:center">主流程序</th><th style="text-align:center">程序类别</th><th style="text-align:center">3层协议</th><th style="text-align:center">4层协议</th><th style="text-align:center">5层协议</th><th style="text-align:left">6层协议</th><th style="text-align:left">7层协议</th><th>默认服务端口</th><th>程序说明</th><th>其他信息</th></tr></thead><tbody><tr><td style="text-align:left">FTP数据端口</td><td style="text-align:center">vsftpd</td><td style="text-align:center">网络程序</td><td style="text-align:center">IP</td><td style="text-align:center">TCP</td><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:left">FTP</td><td>20</td><td>文件传输</td></tr><tr><td style="text-align:left">FTP连接控制认证</td><td style="text-align:center">vsftpd</td><td style="text-align:center">网络程序</td><td style="text-align:center">IP</td><td style="text-align:center">TCP</td><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:left">FTP</td><td>21</td><td>文件传输</td></tr><tr><td style="text-align:left">ssh</td><td style="text-align:center">openssh</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:left"></td><td>22</td><td>加固的远程连接</td></tr><tr><td style="text-align:left">sallt-key</td><td style="text-align:center">salt-master</td><td style="text-align:center">网络程序</td><td style="text-align:center">IP</td><td style="text-align:center">TCP</td><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:left"></td><td>4505</td><td>SaltStack-master端监听端口</td></tr><tr><td style="text-align:left">sallt-key</td><td style="text-align:center">salt-master</td><td style="text-align:center">网络程序</td><td style="text-align:center">IP</td><td style="text-align:center">TCP</td><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:left"></td><td>4506</td><td>SaltStack-master端监听端口</td></tr></tbody></table><h1 id="系统服务-协议对照关系表"><a href="#系统服务-协议对照关系表" class="headerlink" title="系统服务-协议对照关系表"></a>系统服务-协议对照关系表</h1><table><thead><tr><th style="text-align:left">应用程序/命令</th><th style="text-align:center">主流程序</th><th style="text-align:center">程序类别</th><th style="text-align:center">3层协议</th><th style="text-align:center">4层协议</th><th style="text-align:left">5层协议</th><th style="text-align:left">6层协议</th><th>7层协议</th><th>默认服务端口</th><th>程序说明</th><th>其他信息</th></tr></thead><tbody><tr><td style="text-align:left">ping命令</td><td style="text-align:center">iputils</td><td style="text-align:center">系统程序</td><td style="text-align:center">icmp</td><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:left"></td><td></td><td></td><td>探测主机到主机之间是否可通信</td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      常见应用程序/命令-协议/端口号对照表
    
    </summary>
    
      <category term="IT基础知识" scheme="http://yoursite.com/categories/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="应用协议端口对照表" scheme="http://yoursite.com/categories/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BA%94%E7%94%A8%E5%8D%8F%E8%AE%AE%E7%AB%AF%E5%8F%A3%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    
    
      <category term="常见应用程序/命令-协议/端口号对照表" scheme="http://yoursite.com/tags/%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E5%91%BD%E4%BB%A4-%E5%8D%8F%E8%AE%AE-%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Centos7安装Python3</title>
    <link href="http://yoursite.com/2018/05/20/Centos7%E5%AE%89%E8%A3%85Python3/"/>
    <id>http://yoursite.com/2018/05/20/Centos7安装Python3/</id>
    <published>2018-05-20T06:17:38.000Z</published>
    <updated>2018-05-20T06:17:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在centos 7中，默认安装的python版本为2.7,一般情况下，我们都需要对python进行升级</p><pre><code>[root@master ~]# cat /etc/redhat-release CentOS Linux release 7.3.1611 (Core)[root@master ~]# python --version Python 2.7.5</code></pre><h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><pre><code>[root@master ~]# which python /usr/bin/python[root@master ~]# ll /usr/bin/pythonlrwxrwxrwx 1 root root 7 Apr 13 16:50 /usr/bin/python -&gt; python2[root@master ~]# ll /usr/bin/python2lrwxrwxrwx 1 root root 9 Apr 13 16:50 /usr/bin/python2 -&gt; python2.7[root@master ~]# ll /usr/bin/python2.7-rwxr-xr-x 1 root root 7136 Aug  4  2017 /usr/bin/python2.7</code></pre><p>我们知道我们的python命令是在/usr/bin目录下</p><p>可以看到，python指向的是python2，python2指向的是python2.7</p><p>因此我们可以装个python3，然后将python指向python3，然后python2指向python2.7，那么两个版本的python就能共存了。</p><h1 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a>正式安装</h1><p><strong>下载python3的源码包</strong></p><pre><code>wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz</code></pre><p><strong>解压编译安装</strong></p><pre><code>[root@master software]# tar -zxvf Python-3.6.5.tgz [root@master software]# cd Python-3.6.5[root@master Python-3.6.5]# ./configure  --prefix=/usr/local/python3[root@master Python-3.6.5]# make &amp;&amp; make install</code></pre><p><strong>添加软链接</strong></p><pre><code>[root@master Python-3.6.5]# mv /usr/bin/python /usr/bin/python.bak[root@master Python-3.6.5]# ln -s /usr/local/python3/bin/python3.6 /usr/bin/python[root@master Python-3.6.5]# python --version Python 3.6.5</code></pre><h1 id="补充操作"><a href="#补充操作" class="headerlink" title="补充操作"></a>补充操作</h1><h2 id="更改yum配置"><a href="#更改yum配置" class="headerlink" title="更改yum配置"></a>更改yum配置</h2><p>安装完毕之后，我们需要修改yum的配置，因为其要使用python2执行，此时我们修改了python的指向路径，不修改则会导致yum无法正常使用。</p><p><strong>vim /usr/bin/yum</strong></p><pre><code>把#! /usr/bin/python修改为#! /usr/bin/python2</code></pre><p><strong>vim /usr/libexec/urlgrabber-ext-down</strong></p><pre><code>把#! /usr/bin/python 修改为#! /usr/bin/python2</code></pre>]]></content>
    
    <summary type="html">
    
      Centos7安装Python3
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="基础环境配置" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>SaltStack技术入门与实践</title>
    <link href="http://yoursite.com/2018/05/20/SaltStack%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/05/20/SaltStack技术入门与实践/</id>
    <published>2018-05-20T03:38:35.000Z</published>
    <updated>2018-05-20T03:38:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文件：</p><ul><li>书籍：《SaltStack技术入门与实践》</li></ul><h1 id="SaltStack基础入门"><a href="#SaltStack基础入门" class="headerlink" title="SaltStack基础入门"></a>SaltStack基础入门</h1><p>SlatStack是基于python开发的一套C/S架构配置管理工具，底层使用zeroMQ消息队列pub/sub的方式通信，使用SSL证书签发的方式进行认证管理，采用RSA Key方式确认身份，传输采用AES加密，这使得它的安全性有了一定的保障。</p><p>并且，SaltStack不止是一个配置管理工具，它还是一个做云计算与数据中心架构编排的利器-</p><p>重点：</p><ul><li>Python</li><li>C/S架构</li><li>Server和Client之间的通信采用ZeroMQ pub/sub通信方式</li><li>SSL证书提供加密传输</li></ul><h2 id="服务架构"><a href="#服务架构" class="headerlink" title="服务架构"></a>服务架构</h2><p>在slatstack架构中，服务端叫做Master，客户端叫做Minion（英文翻译为：奴才；仆从；宠臣）</p><p>在我们理解的C/S架构中，工作流程为：</p><blockquote><p>客户端发送请求给服务器端</p><p>服务器端接受请求并处理</p><p>处理完成之后，返回客户端</p></blockquote><p>在slatstack中，不仅有这种传统的C/S架构服务模式，而且还有消息队列中的发布/订阅(pub/sub)服务模式，这就使得saltstack的应用场景更加丰富。</p><p>目前在实际的环境中，一般使用C/S架构进行配置管理</p><p><strong>工作机制</strong></p><blockquote><p>Master和Minion端都是以守护进程的模式运行的，一直监听配置文件中定义的<strong><code>ret_port(接受minion请求)和publish_port（发布消息）的端口</code></strong></p><p>当Minion运行时会自动连接到配置文件里面定义的Master地址和ret_port端口进行连接认证。</p></blockquote><p>saltstack除了传统的的C/S架构，还有Masterless架构，如果采用该架构，我们就不需要单独安装一台salt-master机器，只需要在每台机器上安装Minion。然后采用本机只负责本机的配置管理工作机制服务模式。</p><h2 id="Saltstack架构安装"><a href="#Saltstack架构安装" class="headerlink" title="Saltstack架构安装"></a>Saltstack架构安装</h2><p>当前salt的安装一共有4四种方式：</p><ul><li>yum方式安装</li><li>pip方式安装</li><li>源码包方式安装</li><li>salt-bootstrap方式安装</li></ul><p>在这里，我们使用yum方式进行安装,另外3种方式可以参见书籍：《SaltStack技术入门与实践》</p><p>安装环境为：centos7+python3，如果不知道如何升级python，可以看我的另一篇文章：<a href="http://watchmen.xin/2018/05/20/Centos7%E5%AE%89%E8%A3%85Python3/" target="_blank" rel="noopener">Centos7安装Python3</a></p><p><strong>参考文献：</strong></p><ul><li><a href="https://repo.saltstack.com/#rhel" target="_blank" rel="noopener">官方安装指南</a></li></ul><h3 id="yum源安装"><a href="#yum源安装" class="headerlink" title="yum源安装"></a>yum源安装</h3><pre><code># yum -y install https://repo.saltstack.com/py3/redhat/salt-py3-repo-latest-2.el7.noarch.rpm </code></pre><h3 id="master端安装"><a href="#master端安装" class="headerlink" title="master端安装"></a>master端安装</h3><p><strong>安装</strong></p><pre><code># yum -y install salt-master</code></pre><p><strong>启动服务</strong></p><pre><code># systemctl start salt-master</code></pre><p><strong>额外操作</strong></p><p>如果是阿里云服务器，我们还要在安全组中开放4505和4506端口</p><h3 id="minion端安装配置"><a href="#minion端安装配置" class="headerlink" title="minion端安装配置"></a>minion端安装配置</h3><p><strong>安装</strong></p><pre><code># yum -y install salt-minion</code></pre><p>注意：minion端在安装之后还需要进行配置（在配置文件中添加Master端的相关信息）</p><pre><code># sed -i &apos;s/#master: salt/master: 47.93.54.101/g&apos; /etc/salt/minion</code></pre><p><strong>启动服务</strong></p><pre><code># systemctl  start salt-minion</code></pre><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>是否将服务设置为开机自动启动，请根据实际情况决定：</p><p>查看：</p><pre><code># systemctl is-enabled salt-master/salt-miniondisabled</code></pre><p>设置：</p><pre><code># systemctl enable salt-master/salt-minion</code></pre><hr><h2 id="开启SaltStack之旅"><a href="#开启SaltStack之旅" class="headerlink" title="开启SaltStack之旅"></a>开启SaltStack之旅</h2><h3 id="证书管理"><a href="#证书管理" class="headerlink" title="证书管理"></a>证书管理</h3><p>在前面的介绍中我们知道了saltstack使用SSL签证的方式进行安全认证，接下来我们就开始进行证书的管理</p><p>minion端服务启动之后，我们在master端就能看到Minion的证书签证请求，下面我们需要对这台Minion进行签售证书</p><pre><code>[root@master ~]# salt-key  -LAccepted Keys:Denied Keys:Unaccepted Keys:slave.kisspuppet.comRejected Keys:[root@master ~]# salt-key -A -y         #同意签证所有没有接受的请求The following keys are going to be accepted:Unaccepted Keys:slave.kisspuppet.comKey for minion slave.kisspuppet.com accepted.[root@master ~]# salt-key  -LAccepted Keys:slave.kisspuppet.comDenied Keys:Unaccepted Keys:Rejected Keys:</code></pre><p>证书签售成功之后，我们可以运行命令检测我们master与minion之间的通信是否正常</p><pre><code>[root@master ~]# salt slave.kisspuppet.com  test.ping slave.kisspuppet.com:    True</code></pre><h3 id="日常命令参数"><a href="#日常命令参数" class="headerlink" title="日常命令参数"></a>日常命令参数</h3><p>首先我们需要知道，我们在安装salt-master和salt-minion的时候都安装了哪些文件，这样有利于我们去了解SaltStack日后的一些日常操作。</p><h4 id="master端"><a href="#master端" class="headerlink" title="master端"></a>master端</h4><pre><code>[root@master ~]# rpm -ql salt-master/etc/salt/master            #salt master配置文件/etc/salt/master.d/etc/salt/pki/master/usr/bin/salt                #salt master核心操作命令/usr/bin/salt-cp            #salt 文件传输命令/usr/bin/salt-key            #salt 证书管理命令/usr/bin/salt-master/usr/bin/salt-run/usr/bin/salt-unity/usr/lib/systemd/system/salt-master.service/usr/share/man/man1/salt-cp.1.gz/usr/share/man/man1/salt-key.1.gz/usr/share/man/man1/salt-master.1.gz/usr/share/man/man1/salt-run.1.gz/usr/share/man/man1/salt-unity.1.gz/usr/share/man/man1/salt.1.gz/usr/share/man/man7/salt.7.gz</code></pre><p><strong>salt命令语法</strong></p><pre><code>Usage: salt [options] &apos;&lt;target&gt;&apos; &lt;function&gt; [arguments]</code></pre><p><strong>salt命令相关重要参数</strong></p><ul><li><p>-c CONFIG_DIR, –config-dir=CONFIG_DIR 指定配置文件目录（默认为/etc/salt）</p></li><li><p>–async  Run the salt command but don’t wait for a reply  异步执行</p></li><li><p>-d, –doc, –documentation   查看指定模块或者所有模块文档</p></li><li><p>–username=USERNAME        指定外部认证用户名</p></li><li>–password=PASSWORD        指定外部认证用户密码</li></ul><p>具体命令请看下面的输出：</p><pre><code>[root@master ~]# salt -hUsage: salt [options] &apos;&lt;target&gt;&apos; &lt;function&gt; [arguments]Salt allows for commands to be executed across a swath of remote systems inparallel, so they can be both controlled and queried with ease.Options:  --version             show program&apos;s version number and exit  -V, --versions-report                        Show program&apos;s dependencies version number and exit.  -h, --help            show this help message and exit  --saltfile=SALTFILE   Specify the path to a Saltfile. If not passed, one                        will be searched for in the current working directory.  -c CONFIG_DIR, --config-dir=CONFIG_DIR                        Pass in an alternative configuration directory.                        Default: &apos;/etc/salt&apos;.  -t TIMEOUT, --timeout=TIMEOUT                        Change the timeout, if applicable, for the running                        command (in seconds). Default: 5.  --args-stdin          Read additional options and/or arguments from stdin.                        Each entry is newline separated.  --hard-crash          Raise any original exception rather than exiting                        gracefully. Default: False.  --no-parse=argname1,argname2,...                        Comma-separated list of named CLI arguments (i.e.                        argname=value) which should not be parsed as Python                        data types  -s, --static          Return the data from minions as a group after they all                        return.  -p, --progress        Display a progress graph. Requires &quot;progressbar&quot;                        python package.  --failhard            Stop batch execution upon first &quot;bad&quot; return.  --async               Run the salt command but don&apos;t wait for a reply.  --subset=SUBSET       Execute the routine on a random subset of the targeted                        minions. The minions will be verified that they have                        the named function before executing.  -v, --verbose         Turn on command verbosity, display jid and active job                        queries.  --hide-timeout        Hide minions that timeout.  --show-jid            Display jid without the additional output of                        --verbose.  -b BATCH, --batch=BATCH, --batch-size=BATCH                        Execute the salt job in batch mode, pass either the                        number of minions to batch at a time, or the                        percentage of minions to have running.  --batch-wait=BATCH_WAIT                        Wait the specified time in seconds after each job is                        done before freeing the slot in the batch for the next                        one.  --batch-safe-limit=BATCH_SAFE_LIMIT                        Execute the salt job in batch mode if the job would                        have executed on more than this many minions.  --batch-safe-size=BATCH_SAFE_SIZE                        Batch size to use for batch jobs created by batch-                        safe-limit.  --return=RETURNER     Set an alternative return method. By default salt will                        send the return data from the command back to the                        master, but the return data can be redirected into any                        number of systems, databases or applications.  --return_config=RETURNER_CONF                        Set an alternative return method. By default salt will                        send the return data from the command back to the                        master, but the return data can be redirected into any                        number of systems, databases or applications.  --return_kwargs=RETURNER_KWARGS                        Set any returner options at the command line.  --module-executors=EXECUTOR_LIST                        Set an alternative list of executors to override the                        one set in minion config.  --executor-opts=EXECUTOR_OPTS                        Set alternate executor options if supported by                        executor. Options set by minion config are used by                        default.  -d, --doc, --documentation                        Return the documentation for the specified module or                        for all modules if none are specified.  --args-separator=ARGS_SEPARATOR                        Set the special argument used as a delimiter between                        command arguments of compound commands. This is useful                        when one wants to pass commas as arguments to some of                        the commands in a compound command.  --summary             Display summary information about a salt command.  --metadata=METADATA   Pass metadata into Salt, used to search jobs.  --output-diff         Report only those states that have changed.  --config-dump         Dump the master configuration values  --preview-target      Show the minions expected to match a target. Does not                        issue any command.  Logging Options:    Logging options which override any settings defined on the    configuration files.    -l LOG_LEVEL, --log-level=LOG_LEVEL                        Console logging log level. One of &apos;all&apos;, &apos;garbage&apos;,                        &apos;trace&apos;, &apos;debug&apos;, &apos;profile&apos;, &apos;info&apos;, &apos;warning&apos;,                        &apos;error&apos;, &apos;critical&apos;, &apos;quiet&apos;. Default: &apos;warning&apos;.    --log-file=LOG_FILE                        Log file path. Default: &apos;/var/log/salt/master&apos;.    --log-file-level=LOG_LEVEL_LOGFILE                        Logfile logging log level. One of &apos;all&apos;, &apos;garbage&apos;,                        &apos;trace&apos;, &apos;debug&apos;, &apos;profile&apos;, &apos;info&apos;, &apos;warning&apos;,                        &apos;error&apos;, &apos;critical&apos;, &apos;quiet&apos;. Default: &apos;warning&apos;.  Target Options:    Target selection options.    -H, --hosts         List all known hosts to currently visible or other                        specified rosters    -E, --pcre          Instead of using shell globs to evaluate the target                        servers, use pcre regular expressions.    -L, --list          Instead of using shell globs to evaluate the target                        servers, take a comma or space delimited list of                        servers.    -G, --grain         Instead of using shell globs to evaluate the target                        use a grain value to identify targets, the syntax for                        the target is the grain key followed by a                        globexpression: &quot;os:Arch*&quot;.    -P, --grain-pcre    Instead of using shell globs to evaluate the target                        use a grain value to identify targets, the syntax for                        the target is the grain key followed by a pcre regular                        expression: &quot;os:Arch.*&quot;.    -N, --nodegroup     Instead of using shell globs to evaluate the target                        use one of the predefined nodegroups to identify a                        list of targets.    -R, --range         Instead of using shell globs to evaluate the target                        use a range expression to identify targets. Range                        expressions look like %cluster.    -C, --compound      The compound target option allows for multiple target                        types to be evaluated, allowing for greater                        granularity in target matching. The compound target is                        space delimited, targets other than globs are preceded                        with an identifier matching the specific targets                        argument type: salt &apos;G@os:RedHat and webser* or                        E@database.*&apos;.    -I, --pillar        Instead of using shell globs to evaluate the target                        use a pillar value to identify targets, the syntax for                        the target is the pillar key followed by a glob                        expression: &quot;role:production*&quot;.    -J, --pillar-pcre   Instead of using shell globs to evaluate the target                        use a pillar value to identify targets, the syntax for                        the target is the pillar key followed by a pcre                        regular expression: &quot;role:prod.*&quot;.    -S, --ipcidr        Match based on Subnet (CIDR notation) or IP address.  Additional Target Options:    Additional options for minion targeting.    --delimiter=DELIMITER                        Change the default delimiter for matching in multi-                        level data structures. Default: &apos;:&apos;.  External Authentication:    -a EAUTH, --auth=EAUTH, --eauth=EAUTH, --external-auth=EAUTH                        Specify an external authentication system to use.    -T, --make-token    Generate and save an authentication token for re-use.                        The token is generated and made available for the                        period defined in the Salt Master.    --username=USERNAME                        Username for external authentication.    --password=PASSWORD                        Password for external authentication.  Output Options:    Configure your preferred output format.    --out=OUTPUT, --output=OUTPUT                        Print the output from the &apos;salt&apos; command using the                        specified outputter.    --out-indent=OUTPUT_INDENT, --output-indent=OUTPUT_INDENT                        Print the output indented by the provided value in                        spaces. Negative values disables indentation. Only                        applicable in outputters that support indentation.    --out-file=OUTPUT_FILE, --output-file=OUTPUT_FILE                        Write the output to the specified file.    --out-file-append, --output-file-append                        Append the output to the specified file.    --no-color, --no-colour                        Disable all colored output.    --force-color, --force-colour                        Force colored output.    --state-output=STATE_OUTPUT, --state_output=STATE_OUTPUT                        Override the configured state_output value for minion                        output. One of &apos;full&apos;, &apos;terse&apos;, &apos;mixed&apos;, &apos;changes&apos; or                        &apos;filter&apos;. Default: &apos;none&apos;.    --state-verbose=STATE_VERBOSE, --state_verbose=STATE_VERBOSE                        Override the configured state_verbose value for minion                        output. Set to True or False. Default: none.You can find additional help about salt issuing &quot;man salt&quot; or onhttp://docs.saltstack.com[root@master ~]# </code></pre><h4 id="minion端"><a href="#minion端" class="headerlink" title="minion端"></a>minion端</h4><pre><code>[root@slave ~]# rpm -ql salt-minion/etc/salt/minion/etc/salt/minion.d/etc/salt/pki/minion/etc/salt/proxy/usr/bin/salt-call/usr/bin/salt-minion/usr/bin/salt-proxy/usr/lib/systemd/system/salt-minion.service/usr/lib/systemd/system/salt-proxy@.service/usr/share/man/man1/salt-call.1.gz/usr/share/man/man1/salt-minion.1.gz/usr/share/man/man1/salt-proxy.1.gz</code></pre><p>Minio端主要介绍salt-call命令，因为salt-call命令的output和log相关参数与salt命令一样，这里就不对salt-call这两个参数进行讲解了，大家可以参照salt命令的output与log的相关参数</p><p><strong>salt-call命令语法</strong></p><pre><code>Usage: salt-call [options] &lt;function&gt; [arguments]</code></pre><ul><li>option:选项</li><li>target</li></ul><p><strong>salt-call命令相关重要参数</strong></p><ul><li><p>-c CONFIG_DIR, –config-dir=CONFIG_DIR 指定配置文件目录（默认为/etc/salt）</p></li><li><p>–master=MASTER       Specify the master to use 指定master信息</p></li><li><p>-d, –doc, –documentation   查看指定模块或者所有模块文档</p></li></ul><p><strong>命令输出如下：</strong></p><pre><code>[root@slave ~]# salt-call  -hUsage: salt-call [options] &lt;function&gt; [arguments]salt-call is used to execute module functions locally on a Salt MinionOptions:  --version             show program&apos;s version number and exit  -V, --versions-report                        Show program&apos;s dependencies version number and exit.  -h, --help            show this help message and exit  --saltfile=SALTFILE   Specify the path to a Saltfile. If not passed, one                        will be searched for in the current working directory.  -c CONFIG_DIR, --config-dir=CONFIG_DIR                        Pass in an alternative configuration directory.                        Default: &apos;/etc/salt&apos;.  --cachedir=CACHEDIR   Cache Directory  --args-stdin          Read additional options and/or arguments from stdin.                        Each entry is newline separated.  --hard-crash          Raise any original exception rather than exiting                        gracefully. Default: False.  --no-parse=argname1,argname2,...                        Comma-separated list of named CLI arguments (i.e.                        argname=value) which should not be parsed as Python                        data types  -g, --grains          Return the information generated by the salt grains.  -m MODULE_DIRS, --module-dirs=MODULE_DIRS                        Specify an additional directory to pull modules from.                        Multiple directories can be provided by passing `-m                        /--module-dirs` multiple times.  -d, --doc, --documentation                        Return the documentation for the specified module or                        for all modules if none are specified.  --master=MASTER       Specify the master to use. The minion must be                        authenticated with the master. If this option is                        omitted, the master options from the minion config                        will be used. If multi masters are set up the first                        listed master that responds will be used.  --return=RETURNER     Set salt-call to pass the return data to one or many                        returner interfaces.  --local               Run salt-call locally, as if there was no master                        running.  --file-root=FILE_ROOT                        Set this directory as the base file root.  --pillar-root=PILLAR_ROOT                        Set this directory as the base pillar root.  --states-dir=STATES_DIR                        Set this directory to search for additional states.  --retcode-passthrough                        Exit with the salt call retcode and not the salt                        binary retcode.  --metadata            Print out the execution metadata as well as the                        return. This will print out the outputter data, the                        return code, etc.  --set-metadata=METADATA                        Pass metadata into Salt, used to search jobs.  --id=ID               Specify the minion id to use. If this option is                        omitted, the id option from the minion config will be                        used.  --skip-grains         Do not load grains.  --refresh-grains-cache                        Force a refresh of the grains cache.  -t AUTH_TIMEOUT, --timeout=AUTH_TIMEOUT                        Change the timeout, if applicable, for the running                        command. Default: 60.  --output-diff         Report only those states that have changed.  Logging Options:    Logging options which override any settings defined on the    configuration files.    -l LOG_LEVEL, --log-level=LOG_LEVEL                        Console logging log level. One of &apos;all&apos;, &apos;garbage&apos;,                        &apos;trace&apos;, &apos;debug&apos;, &apos;profile&apos;, &apos;info&apos;, &apos;warning&apos;,                        &apos;error&apos;, &apos;critical&apos;, &apos;quiet&apos;. Default: &apos;warning&apos;.    --log-file=LOG_FILE                        Log file path. Default: &apos;/var/log/salt/minion&apos;.    --log-file-level=LOG_LEVEL_LOGFILE                        Logfile logging log level. One of &apos;all&apos;, &apos;garbage&apos;,                        &apos;trace&apos;, &apos;debug&apos;, &apos;profile&apos;, &apos;info&apos;, &apos;warning&apos;,                        &apos;error&apos;, &apos;critical&apos;, &apos;quiet&apos;. Default: &apos;warning&apos;.  Output Options:    Configure your preferred output format.    --out=OUTPUT, --output=OUTPUT                        Print the output from the &apos;salt-call&apos; command using                        the specified outputter.    --out-indent=OUTPUT_INDENT, --output-indent=OUTPUT_INDENT                        Print the output indented by the provided value in                        spaces. Negative values disables indentation. Only                        applicable in outputters that support indentation.    --out-file=OUTPUT_FILE, --output-file=OUTPUT_FILE                        Write the output to the specified file.    --out-file-append, --output-file-append                        Append the output to the specified file.    --no-color, --no-colour                        Disable all colored output.    --force-color, --force-colour                        Force colored output.    --state-output=STATE_OUTPUT, --state_output=STATE_OUTPUT                        Override the configured state_output value for minion                        output. One of &apos;full&apos;, &apos;terse&apos;, &apos;mixed&apos;, &apos;changes&apos; or                        &apos;filter&apos;. Default: &apos;none&apos;.    --state-verbose=STATE_VERBOSE, --state_verbose=STATE_VERBOSE                        Override the configured state_verbose value for minion                        output. Set to True or False. Default: none.  Profiling support:    --profiling-path=PROFILING_PATH                        Folder that will hold all stats generations path.                        Default: &apos;/tmp/stats&apos;.    --enable-profiling  Enable generating profiling stats. See also:                        --profiling-path.You can find additional help about salt-call issuing &quot;man salt-call&quot; or onhttp://docs.saltstack.com[root@slave ~]# </code></pre><h2 id="SaltStack配置文件"><a href="#SaltStack配置文件" class="headerlink" title="SaltStack配置文件"></a>SaltStack配置文件</h2><p>saltstack的配置文件分别为：</p><ul><li>Master： /etc/salt/master</li><li>Minion： /etc/salt/minion</li></ul><p>这两部分的内容详细可以看书</p><h3 id="master配置文件"><a href="#master配置文件" class="headerlink" title="master配置文件"></a>master配置文件</h3><p>这里只列出几个比较重要的参数</p><ul><li>#max_open_files: 100000    默认注释，根据master和minion的数量进行适当的调整</li><li>#timeout: 5    默认注释，根据master和minion的网络状况进行适当的调整</li><li>#auto_accept: False</li><li>#autosign_file: /etc/salt/autosign.conf  默认注释，这两个auto参数在大规模部署minion的时候可以设置自动签证（配置其中一个就可以生效）</li><li>master_tops和所有以external开头的参数-这些参数是saltstack与外部系统进行整合的相关配置参数</li></ul><h3 id="minion配置文件"><a href="#minion配置文件" class="headerlink" title="minion配置文件"></a>minion配置文件</h3><hr><h1 id="SaltStack组件"><a href="#SaltStack组件" class="headerlink" title="SaltStack组件"></a>SaltStack组件</h1>]]></content>
    
    <summary type="html">
    
      SaltStack技术入门与实践
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="运维自动化" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="SaltStack" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/SaltStack/"/>
    
    
      <category term="SaltStack" scheme="http://yoursite.com/tags/SaltStack/"/>
    
  </entry>
  
  <entry>
    <title>zabbix清理历史数据</title>
    <link href="http://yoursite.com/2018/05/17/zabbix%E6%B8%85%E7%90%86%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2018/05/17/zabbix清理历史数据/</id>
    <published>2018-05-17T11:00:59.000Z</published>
    <updated>2018-05-17T11:00:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考文献：</strong></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>zabbix一般都是这几个表太大， history， history_uint，history_log</p><p>zabbix里面的时间是用的时间戳方式记录，我们可以转换一下，然后根据时间戳来删除；</p><p>比如要删除2014年的1月1号以前的数据，先将标准时间转换为时间戳</p><pre><code># date +%s -d &quot;2018-05-15 00:00:01&quot;1526313601</code></pre><h1 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h1><h2 id="停止应用"><a href="#停止应用" class="headerlink" title="停止应用"></a>停止应用</h2><p><strong>停止zabbix_server</strong></p><p>[root@dwb-dev1 ~]$ /etc/init.d/zabbix_server stop</p><h2 id="清理数据"><a href="#清理数据" class="headerlink" title="清理数据"></a>清理数据</h2><p><strong>启动mysql</strong></p><pre><code>/bin/sh /usr/bin/mysqld_safe --datadir=/var/lib/mysql --socket=/var/lib/mysql/mysql.sock --pid-file=/var/run/mysqld/mysqld.pid --basedir=/usr --user=mysql/usr/libexec/mysqld --basedir=/usr --datadir=/var/lib/mysql --user=mysql --log-error=/var/log/mysqld.log --pid-file=/var/run/mysqld/mysqld.pid --socket=/var/lib/mysql/mysql.sockmysql&gt; DELETE FROM history_uint WHERE clock &lt; 1526313601;mysql&gt; delete from history  where clock &lt; 1526313601;mysql&gt; optimize table history;mysql&gt; optimize table history_uint;注：执行过优化命令之后可能会需要很长的一段时间，中间不要中断，否则容易丢失数据。</code></pre><h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><p>在数据库中给pt用户进行授权</p><p><strong>删除3个月之前的数据</strong></p><pre><code>pt-archiver --source h=192.168.1.202,P=3306,D=zabbix,t=history,u=pt,p=123456 --no-check-charset --where &apos;clock &lt; unix_timestamp(date_sub(curdate(),interval 3 month))&apos; --limit=500 --commit-each --sleep-coef=0.1 --nosafe-auto-increment --noversion-check --why-quit --purge --statistics --bulk-delete --progress=100000 &gt;&gt; ./tmp.log[root@master004-qa ~]# cat tmp.log TIME                ELAPSED   COUNT2018-05-21T10:02:53       0       02018-05-21T11:37:33    5679  1000002018-05-21T12:31:14    8900  2000002018-05-21T12:38:00    9307  3000002018-05-21T13:03:57   10863  313744Started at 2018-05-21T10:02:53, ended at 2018-05-21T13:40:20Source: D=zabbix,P=3306,h=192.168.1.202,p=...,t=history,u=ptSELECT 313744INSERT 0DELETE 313675Action             Count       Time        Pctselect               629 11701.8659      89.69bulk_deleting        628  1310.4642      10.04commit               629    30.3126       0.23other                  0     4.7184       0.04Exiting because there are no more rows.[root@master004-qa ~]# </code></pre><p><strong>释放空间</strong></p><pre><code>pt-online-schema-change --alter &quot;engine=innodb&quot; --print --charset utf8 --chunk-time 1.000000 --max-load Threads_running=50 --recurse=1 --check-interval 5.000000 --alter-foreign-keys-method=none --force --execute --statistics --max-lag 3.000000 --noversion-check --recursion-method=processlist --progress percentage,1 --user=pt --password=123456 --host=192.168.1.202 --port=3306 D=zabbix,t=history</code></pre><p><strong>创建主键</strong></p><pre><code>mysql -A zabbix -e &quot;alter table history add column id bigint auto_increment primary key first&quot; </code></pre>]]></content>
    
    <summary type="html">
    
      zabbix清理历史数据
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="运维监控体系" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB/"/>
    
      <category term="zabbix" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB/zabbix/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>RDS从入门到实践</title>
    <link href="http://yoursite.com/2018/05/14/RDS/"/>
    <id>http://yoursite.com/2018/05/14/RDS/</id>
    <published>2018-05-14T03:36:33.000Z</published>
    <updated>2018-05-14T03:36:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.alibabacloud.com/help/zh/product/26090.htm" target="_blank" rel="noopener">官方文档</a></p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>阿里云关系型数据库（Relational Database Service，简称 RDS）是一种稳定可靠、可弹性伸缩的在线数据库服务。基于阿里云分布式文件系统和SSD盘高性能存储，RDS 支持 MySQL、SQL Server、PostgreSQL 和 PPAS（Postgre Plus Advanced Server，一种高度兼容 Oracle 的数据库）引擎，并且提供了容灾、备份、恢复、监控、迁移等方面的全套解决方案，彻底解决数据库运维的烦恼。</p><h2 id="RDS的特点"><a href="#RDS的特点" class="headerlink" title="RDS的特点"></a>RDS的特点</h2><p>云数据库RDS作为一个公共的关系型数据库，高可用和高安全是其首要优势，其次才是高性能，因为没人会使用既不稳定又不安全的服务。RDS的优势主要体现在如下几点：</p><ul><li>RDS提供了主备双节点的实例，双节点可以在同一地域的不同可用区，MySQL实例的双节点还可以在不同地域，当主实例出现故障时可快速切换到备实例，保障了RDS的稳定性。</li></ul><ul><li>RDS在数据的存取上加入了中间层，所有请求都会经过中间层，而且有SQL注入的请求都会被中间层拦截掉。在底层数据写入上，RDS采用了最高安全级别的写入，保证在主机异常掉电的情况下数据不会出现丢失。以此来保障数据库的高安全性。</li></ul><p>RDS源码团队持续对MySQL进行源码优化，在标准的基准测试中性能和稳定性上都是高于社区版本的。</p><p>关于这部分内容可以查看：<a href="https://www.alibabacloud.com/help/zh/doc-detail/55823.htm?spm=a2c63.p38356.a3.4.563d5e74FcHTfi" target="_blank" rel="noopener">对比ECS自建数据库与RDS性能时的注意事项</a></p><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p><strong>数据库账号</strong></p><p>当用户创建实例后，RDS并不会为用户创建任何初始的数据库账号。</p><p>有如下两种方式来创建数据库帐号：</p><ul><li><p>用户可以通过控制台或者API来创建普通数据库账号，并设置数据库级别的读写权限。</p></li><li><p>如果用户需要更细粒度的权限控制，比如表、视图，字段级别的权限，也可以通过控制台或者API先创建高权限数据库账号，并使用数据库客户端和高权限数据库账号来创建普通数据库账号。高权限数据库账号可以为普通数据库账号设置表级别的读写权限。</p></li></ul><blockquote><p>说明：通过高权限数据库账号创建的普通数据库账号，无法通过控制台或者API进行管理。</p></blockquote><p><strong>IP白名单</strong></p><p>虽然RDS不支持ECS的安全组功能，但是RDS提供了IP白名单来实现网络安全访问控制。</p><p>默认情况下，RDS实例被设置为不允许任何IP访问，即127.0.0.1。</p><p>用户可以通过控制台的数据安全性模块或者API来添加IP白名单规则。IP白名单的更新无需重启RDS实例，因此不会影响用户的使用。</p><p>IP白名单可以设置多个分组，每个分组可配置1000个IP或IP段。</p><p>设置白名单后，只有以下服务器才能访问RDS实例：</p><ul><li>白名单中 IP 地址所属的服务器</li></ul><ul><li>白名单中 ECS 安全组内的 ECS 实例</li></ul><p>注意事项：</p><ul><li>系统会给每个实例创建一个默认的default白名单分组，该白名单分组只能被修改或清空，但不能被删除。</li></ul><ul><li>对于新建的RDS实例，系统默认会将回送地址127.0.0.1添加到default白名单分组中，IP地址127.0.0.1代表禁止所有IP地址或IP段访问该RDS实例。所以，在您设置白名单时，需要先将127.0.0.1删除，然后再添加您允许访问该RDS实例的IP地址或IP段。</li></ul><ul><li>若将白名单设置为%或者0.0.0.0/0，代表允许任何IP访问RDS实例。该设置将极大降低数据库的安全性，如非必要请勿使用。</li></ul><p><strong>安全组</strong></p><ul><li>目前仅杭州、青岛、香港地域支持 ECS 安全组。</li></ul><ul><li>目前仅支持添加一个安全组。</li></ul><ul><li>对白名单中的 ECS 安全组的更新将实时应用到白名单中。</li></ul><h2 id="系统安全"><a href="#系统安全" class="headerlink" title="系统安全"></a>系统安全</h2><ul><li><p>RDS 处于多层防火墙的保护之下，可以有力地抗击各种恶意攻击，保证数据的安全。</p></li><li><p>RDS 服务器不允许直接登录，只开放特定的数据库服务所需要的端口。</p></li><li><p>RDS 服务器不允许主动向外发起连接，只能接受被动访问。</p></li></ul><h2 id="数据链路服务"><a href="#数据链路服务" class="headerlink" title="数据链路服务"></a>数据链路服务</h2><p>阿里云数据库提供全数据链路服务，包括 DNS、负载均衡、Proxy 等。因为 RDS 使用原生的 DB Engine，对数据库的操作高度类似，基本没有学习成本。</p><p><strong>DNS</strong></p><p>DNS 模块提供域名到 IP 的动态解析功能，以便规避 RDS 实例 IP 地址改变带来的影响。在连接池中设置域名后，即使对应的IP地址发生了变化，仍然可以正常访问 RDS 实例。</p><p>例如，某 RDS 实例的域名为 test.rds.aliyun.com，对应的 IP 地址为 10.10.10.1。某程序连接池中设置为 test.rds.aliyun.com 或 10.10.10.1 都可以正常访问 RDS 实例。</p><p>一旦该 RDS 实例发生了可用区迁移或者版本升级后，IP 地址可能变为 10.10.10.2。如果程序连接池中设置的是域名 test.rds.aliyun.com，则仍然可以正常访问 RDS 实例。但是如果程序连接池中设置的是IP地址 10.10.10.1，就无法访问 RDS 实例了。</p><p><strong>负载均衡</strong></p><p>负载均衡 模块提供实例 IP 地址（包括内网 IP 和外网 IP），以便屏蔽物理服务器变化带来的影响。</p><p>例如，某 RDS 实例的内网 IP 地址为 10.1.1.1，对应的 Proxy 或者 DB Engine 运行在 192.168.0.1 上。在正常情况下，负载均衡 模块会将访问 10.1.1.1 的流量重定向到 192.168.0.1 上。当 192.168.0.1 发生了故障，处于热备状态的 192.168.0.2 接替了 192.168.0.1 的工作。此时 负载均衡 模块会将访问 10.1.1.1 的流量重定向到 192.168.0.2 上，RDS 实例仍旧正常提供服务。</p><p><strong>Proxy</strong></p><p>Proxy 模块提供数据路由、流量探测和会话保持等功能。</p><ul><li>数据路由功能：支持大数据场景下的分布式复杂查询聚合和相应的容量管理。</li><li>流量探测功能：降低 SQL 注入的风险，在必要情况下支持 SQL 日志的回溯。</li><li>会话保持功能：解决故障场景下的数据库连接中断问题。</li></ul><h2 id="高可用服务"><a href="#高可用服务" class="headerlink" title="高可用服务"></a>高可用服务</h2><p>高可用服务由 <strong><code>Detection、Repair、Notice</code></strong> 等模块组成，主要保障<strong><code>数据链路服务</code></strong>的可用性，除此之外还负责处理数据库内部的异常。</p><p>另外，RDS 还通过迁移到支持多可用区的地域和采用适当的高可用策略，提升 RDS 的高可用服务。</p><p><strong>Detection</strong></p><blockquote><p>Detection 模块负责检测 DB Engine 的主节点和备节点是否提供了正常的服务。通过间隔为 8~10 秒的心跳信息，HA 节点可以轻易获得主节点的健康情况，结合备节点的健康情况和其它 HA 节点的心跳信息，Detection 模块可以排除网络抖动等异常引入的误判风险，在 30 秒内完成异常切换操作。</p></blockquote><p><strong>Repair</strong></p><p>Repair 模块负责维护 DB Engine 的主节点和备节点之间的复制关系，还会修复主节点或者备节点在日常运行中出现的错误。</p><p>例如：</p><ul><li>主备复制异常断开的自动修复</li><li>主备节点表级别损坏的自动修复</li><li>主备节点 Crash 的现场保存和自动修复</li></ul><p><strong>Notice</strong></p><p>Notice 模块负责将主备节点的状态变动通知到 负载均衡 或者 Proxy，保证用户访问正确的节点。</p><p>例如：Detection 模块发现主节点异常，并通知 Repair 模块进行修复。Repair 模块进行了尝试后无法修复主节点，通知 Notice 进行流量切换。Notice 模块将切换请求转发至 负载均衡 或者Proxy，此时用户流量全部指向备节点。与此同时，Repair 在别的物理服务器上重建了新的备节点，并将变动同步给 Detection 模块。Detection 模块开始重新检测实例的健康状态。</p><p><strong>多可用区</strong></p><p>RDS在特定地域提供了多可用区部署的能力，也就是将RDS的主备实例分别部署于同一地域的不同可用区。相对于单可用区 RDS 实例，多可用区 RDS 实例可以承受更高级别的灾难。</p><p>目前多可用区 RDS 不额外收取任何费用，用户可以直接在已开通多可用区的地域购买多可用区 RDS 实例，也可以通过跨可用区迁移将单可用区 RDS 实例转化成多可用区 RDS 实例。</p><p>注意： 因为多可用区之间存在一定的网络延迟，因此多可用区 RDS 实例在采用半同步数据复制方案的时候，对于单个更新的响应时间会比单可用区实例长。这种情况最好通过提高并发量的方式来实现整体吞吐量的提高。</p><p><strong>高可用策略</strong></p><p>高可用策略是根据用户自身业务的特点，采用服务优先级和数据复制方式之间的不同组合，以组合出适合自身业务特点的高可用策略。</p><p>服务优先级有以下两个级别：</p><ul><li><p>RTO（Recovery Time Objective）优先：数据库应该尽快恢复服务，即可用时间最长。对于数据库在线时间要求比较高的用户应该使用 RTO 优先策略。</p></li><li><p>RPO（Recovery Point Objective）优先：数据库应该尽可能保障数据的可靠性，即数据丢失量最少。对于数据一致性要求比较高的用户应该使用 RPO 优先策略。</p></li></ul><p>数据复制方式有以下三种方式：</p><ul><li><p>异步复制（Async）：应用发起更新（含增加、删除、修改操作）请求，Master 完成相应操作后立即响应应用，Master 向 Slave 异步复制数据。因此异步复制方式下，Slave 不可用不影响主库上的操作，而 Master 不可用有较小概率会引起数据不一致。</p></li><li><p>强同步复制（Sync）：应用发起更新（含增加、删除、修改操作）请求，Master 完成操作后向 Slave 复制数据，Slave 接收到数据后向 Master 返回成功信息，Master 接到 Slave 的反馈后再响应应用。Master 向 Slave 复制数据是同步进行的，因此 Slave 不可用会影响 Master 上的操作，而 Master 不可用不会引起数据不一致。</p></li><li><p>半同步复制（Semi-Sync）：正常情况下数据复制方式采用强同步复制方式，当 Master 向 Slave 复制数据出现异常的时候（Slave 不可用或者双节点间的网络异常），Master 会暂停对应用的响应，直到复制方式超时退化成异步复制。如果允许应用在此时更新数据，则 Master 不可用会引起数据不一致。当双节点间的数据复制恢复正常（Slave 恢复或者网络恢复），异步复制会恢复成强同步复制。恢复成强同步复制的时间取决于半同步复制的实现方式，阿里云数据库 MySQL 5.5 版和 MySQL 5.6 版有所不同。</p></li></ul><h1 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h1><h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>阿里云上的MySQL提供基础版、高可用版和金融版三种版本</p><blockquote><p>基础版一般就是用于个人学习、或开发测试时使用。目前基础版只提供MySQL 5.7版本，并且只提供单节点部署，性价比非常高。基础版采用计算节点与存储分离的实现方式，也就是说假如计算节点宕机，MySQL就不可用啦，但数据都存在云盘里面不会丢，数据一致性还是可以得到保证，不用担心数据丢失。可用性不高这是基础版的最大问题，反正只是用于不重要的场景，生产环境大家是不会选用基础版的。</p><p>高可用版顾名思义，为应用提供了数据库的高可用保障，也就是说至少要用双节点。RDS MySQL高可用版采用一主一备的经典高可用架构，采用基于binlog的数据复制技术维护数据库的可用性和数据一致性。同时，高可用版从性能上也可以保障业务生产环境的需求，配置上采用物理服务器部署，本地SSD硬盘，提供最佳性能，各方面表现均衡。</p><p>最高级的是金融版，针对像金融、证券、保险等行业的核心数据库，他们对数据安全性、可用性要求非常高。金融版采用三节点，实现一主两备的部署架构，通过binlog日志多副本多级别复制，确保数据的强一致性，可提供金融级的数据可靠性和跨机房容灾能力。</p></blockquote><h3 id="规格"><a href="#规格" class="headerlink" title="规格"></a>规格</h3><p>阿里云上MySQL有三种规格类型：通用型、独享型和独占型。</p><blockquote><p>其中通用型和独享型都是在一台物理服务器上划分多个资源隔离的区域，为不同用户提供MySQL数据库实例。他们的不同点在于，通用型对于CPU和存储空间采用了复用的技术。当部署在同一台服务器上的所有MySQL 实例都很繁忙的情况下，有可能会出现实例间的CPU争抢，或存储的争抢；而独享型虽然也是多个数据库实例共享一台物理服务器，但资源隔离策略上确保每个用户都可以独享所分配到的CPU、内存、I/O、存储，不会出现多个实例发生资源争抢的情况。</p><p>最高级别的一种是独占型，是指一个MySQL实例独占一台服务器，会获得最好的性能，当然价格也最贵。最求极致性能但对价格不敏感的客户一般会在重要业务系统采用独占型实例。</p></blockquote><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p>通常，从新购实例到可以开始使用实例，需要完成如下操作：</p><p><img src="http://picture.watchmen.xin/RDS/RDS.png" alt="RDS"></p><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><h3 id="高权限账号"><a href="#高权限账号" class="headerlink" title="高权限账号"></a>高权限账号</h3><h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><p>注意：目前只支持同一个可用区的连接，不同可用区无法连接，如果需要跨越可用区，需要进行设置</p><p>目前RDS连接可以使用DMS连接或者第三方工具连接</p><h3 id="跨可用区访问"><a href="#跨可用区访问" class="headerlink" title="跨可用区访问"></a>跨可用区访问</h3><h3 id="管理工具-DMS"><a href="#管理工具-DMS" class="headerlink" title="管理工具-DMS"></a>管理工具-DMS</h3><p>DMS 是一款访问管理云端数据库的Web服务，支持Redis、 MySQL、SQL Server、PostgreSQL和MongoDB等数据源。DMS提供了数据管理、对象管理、数据流转和实例管理四部分功能。DMS使用也非常简单：</p><h3 id="数据迁移-DTS"><a href="#数据迁移-DTS" class="headerlink" title="数据迁移-DTS"></a>数据迁移-DTS</h3><p><strong>相关资料：</strong></p><ul><li><a href="https://www.alibabacloud.com/help/zh/doc-detail/26592.htm?spm=a2c63.l28256.b99.2.7f4a179d8ncgjh" target="_blank" rel="noopener">文档中心</a></li><li><a href="https://help.aliyun.com/product/26590.html" target="_blank" rel="noopener">帮助中心</a></li><li><a href="https://help.aliyun.com/document_detail/26627.html?spm=a2c4g.11186623.6.593.iT6gzz" target="_blank" rel="noopener">ECS自建数据库迁移到RDS</a></li></ul><h4 id="DTS概述"><a href="#DTS概述" class="headerlink" title="DTS概述"></a>DTS概述</h4><p>数据传输(Data Transmission)服务DTS是阿里云提供的一种支持RDBMS(关系型数据库)、NoSQL、OLAP等多种数据源之间数据交互的数据服务。它提供了数据迁移、实时数据订阅及数据实时同步等多种数据传输能力。通过数据传输可实现不停服数据迁移、数据异地灾备、跨境数据同步、缓存更新策略等多种业务应用场景，助您构建安全、可扩展、高可用的数据架构。</p><ul><li>数据传输服务DTS的目标是帮用户将复杂的数据交互工作承担下来，让用户可以专注于上层的业务开发，数据传输服务承诺99.95%的链路稳定性。</li></ul><ul><li>数据传输服务DTS支持多种数据源类型，例如：<ul><li>关系型数据库：Oracle、MySQL、SQLServer、PostgreSQL</li><li>NoSQL: Redis </li><li>OLAP: 分析型数据库AnalyticDB </li></ul></li></ul><p>迁移服务主要帮助用户把数据从本地数据库迁移到阿里云数据库，或者把阿里云数据库的一个实例迁移到另一实例中。阿里云数据库提供了数据传输服务DTS（Data Transfer Service）工具，方便用户快速的迁移数据库。</p><p>DTS是一个云上的数据传输服务，能快速的将本地数据库或者RDS中的实例迁移到另一个RDS实例中。关于DTS简介，请参见DTS产品概述。</p><p>DTS提供了三种迁移模式，分别为结构迁移、全量迁移和增量迁移：</p><ul><li>结构迁移：DTS会将迁移对象的结构定义迁移到目标实例，目前支持结构迁移的对象有表、视图、触发器、存储过程和存储函数。</li></ul><ul><li>全量迁移：DTS会将源数据库迁移对象已有数据全部迁移到目标实例中。</li></ul><blockquote><p>注意：在全量迁移过程中，为了保证数据一致性，无主键的非事务表会被锁定。锁定期间这些表无法写入，锁定时长依赖于这些表的数据量大小。在这些无主键非事务表迁移完成后，锁才会释放。</p></blockquote><ul><li>增量迁移：DTS会将迁移过程中数据变更同步到目标实例。</li></ul><p>,</p><blockquote><p>注意：如果迁移期间进行了DDL操作，这些结构变更不会同步到目标实例。</p></blockquote><h4 id="源及目标"><a href="#源及目标" class="headerlink" title="源及目标"></a>源及目标</h4><p><strong>数据迁移支持的源实例类型包括:</strong></p><p>(1) RDS实例</p><p>(2) 本地自建数据库</p><p>(3) ECS自建数据库</p><p><strong>数据迁移支持的目标实例包括：</strong></p><p>(1) RDS实例</p><p>(2) ECS自建数据库</p><p>(3) Redis实例</p><h4 id="Mysql迁移限制"><a href="#Mysql迁移限制" class="headerlink" title="Mysql迁移限制"></a>Mysql迁移限制</h4><p>对于本地 MySQL-&gt;RDS for MySQL 的数据迁移，DTS 支持结构迁移、全量数据迁移及增量数据迁移，各迁移类型的功能及限制如下：</p><ul><li>迁移过程中，不支持 DDL 操作。</li><li>结构迁移不支持 event 的迁移。</li><li>如果使用了对象名映射功能后，依赖这个对象的其他对象可能迁移失败。</li><li>当选择增量迁移时，源端的本地 MySQL 实例需要按照要求开启 binlog。</li><li>当选择增量迁移时，源库的 binlog_format 需要设置为 row。</li><li>当选择增量迁移且源 MySQL 实例如果为 5.6 或以上版本时，它的 binlog_row_image 必须为 full。</li></ul><h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p>数据实时同步功能旨在帮助用户实现两个数据源之间的数据实时同步。通过数据实时同步功能可实现数据异地灾备、本地数据灾备、跨境数据同步及在线离线数据打通(OLTP-&gt;OLAP数据同步)等多种业务场景。</p>]]></content>
    
    <summary type="html">
    
      RDS从入门到实践
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="公有云产品" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/"/>
    
      <category term="阿里云" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="RDS" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%85%AC%E6%9C%89%E4%BA%91%E4%BA%A7%E5%93%81/%E9%98%BF%E9%87%8C%E4%BA%91/RDS/"/>
    
    
      <category term="RDS" scheme="http://yoursite.com/tags/RDS/"/>
    
  </entry>
  
  <entry>
    <title>HTTP请求</title>
    <link href="http://yoursite.com/2018/05/13/HTTP%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2018/05/13/HTTP请求/</id>
    <published>2018-05-13T11:44:23.000Z</published>
    <updated>2018-05-13T11:44:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://www.cnblogs.com/yin-jingyu/archive/2011/08/01/2123548.html" target="_blank" rel="noopener">HTTP深入浅出 http请求</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTTP(HyperText Transfer Protocol)是一套计算机通过网络进行通信的<strong><code>规则</code></strong>。</p><p>计算机专家设计出HTTP，使HTTP客户（如Web浏览器）能够从HTTP服务器(Web服务器)请求信息和服务，HTTP目前协议的版本是1.1。</p><p>HTTP是一种<strong><code>无状态</code></strong>的协议，无状态是指Web浏览器和Web服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后Web服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP遵循请求(Request)/应答(Response)模型。Web浏览器向Web服务器发送请求，Web服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。</p><p>HTTP使用内容类型，是指Web服务器向Web浏览器返回的文件都有与之相关的类型。所有这些类型在MIME　Internet邮件协议上模型化，即Web服务器告诉Web浏览器该文件所具有的种类，是HTML文档、GIF格式图像、声音文件还是独立的应用程序。大多数Web浏览器都拥有一系列的可配置的辅助应用程序，它们告诉浏览器应该如何处理Web服务器发送过来的各种内容类型。</p><h1 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h1><p>在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p><p><strong>1. 建立TCP连接</strong></p><blockquote><p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80</p></blockquote><p><strong>2. Web浏览器向Web服务器发送请求命令</strong></p><blockquote><p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令</p><p>例如：GET/sample/hello.jsp HTTP/1.1</p></blockquote><p><strong>3. Web浏览器发送请求头信息</strong></p><blockquote><p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p></blockquote><p><strong>4. Web服务器应答</strong></p><blockquote><p>客户机向服务器发出请求后，服务器会客户机回送应答，</p><p>HTTP/1.1 200 OK</p><p>应答的第一部分是协议的版本号和应答状态码</p></blockquote><p><strong>5. Web服务器发送应答头信息</strong></p><blockquote><p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p></blockquote><p><strong>6. Web服务器向浏览器发送数据</strong></p><blockquote><p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</p></blockquote><p><strong>7. Web服务器关闭TCP连接</strong></p><blockquote><p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码<br><strong><code>Connection:keep-alive</code></strong></p><p>添加之后，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p></blockquote><h1 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h1><h2 id="HTTP请求格式"><a href="#HTTP请求格式" class="headerlink" title="HTTP请求格式"></a>HTTP请求格式</h2><p>当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求信息，HTTP请求信息由3部分组成：</p><ul><li>请求方法URI协议/版本</li></ul><ul><li>请求头(Request Header)</li></ul><ul><li>请求正文</li></ul><p>下面是一个HTTP请求的例子：</p><pre><code>GET/sample.jspHTTP/1.1Accept:image/gif.image/jpeg,*/*Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)Accept-Encoding:gzip,deflateusername=jinqiao&amp;password=1234</code></pre><p><strong>说明：</strong></p><p>（1）请求方法URI协议/版本</p><p>请求的第一行是“方法URL议/版本”：GET/sample.jsp HTTP/1.1</p><blockquote><p>以上代码中“GET”代表请求方法，“/sample.jsp”表示URI，“HTTP/1.1代表协议和协议的版本。</p><p>根据HTTP标准，HTTP请求可以使用多种请求方法。例如：HTTP1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。在Internet应用中，最常用的方法是GET和POST。</p><p>URL完整地指定了要访问的网络资源，通常只要给出相对于服务器的根目录的相对目录即可，因此总是以“/”开头，最后，协议版本声明了通信过程中使用HTTP的版本。</p></blockquote><p>（2）请求头(Request Header)</p><p>请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。</p><pre><code>Accept:image/gif.image/jpeg.*/*Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)Accept-Encoding:gzip,deflate.</code></pre><p>（3）请求正文</p><p>请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。</p><p>请求正文中可以包含客户提交的查询字符串信息：username=jinqiao&amp;password=1234</p><p>在以上的例子的HTTP请求中，请求的正文只有一行内容。当然，在实际应用中，HTTP请求正文可以包含更多的内容。</p><p>HTTP请求方法我这里只讨论GET方法与POST方法</p><ul><li>GET方法<blockquote><p>GET方法是默认的HTTP请求方法，我们日常用GET方法来提交表单数据，然而用GET方法提交的表单数据只经过了简单的编码，同时它将作为URL的一部分向Web服务器发送，因此，如果使用GET方法来提交表单数据就存在着安全隐患上。例如<br>Http://127.0.0.1/login.jsp?Name=zhangshi&amp;Age=30&amp;Submit=%cc%E+%BD%BB<br>从上面的URL请求中，很容易就可以辩认出表单提交的内容。（？之后的内容）另外由于GET方法提交的数据是作为URL请求的一部分所以提交的数据量不能太大</p></blockquote></li></ul><ul><li>POST方法</li></ul><blockquote><p>POST方法是GET方法的一个替代方法，它主要是向Web服务器提交表单数据，尤其是大批量的数据。POST方法克服了GET方法的一些缺点。通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给Web服务器，这就克服了GET方法中的信息无法保密和数据量太小的缺点。因此，出于安全的考虑以及对用户隐私的尊重，通常表单提交时采用POST方法。</p><p>从编程的角度来讲，如果用户通过GET方法提交数据，则数据存放在QUERY＿STRING环境变量中，而POST方法提交的数据则可以从标准输入流中获取。</p></blockquote><h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>HTTP应答与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p><ul><li>协议状态版本代码描述</li><li>响应头(Response Header)</li><li>响应正文</li></ul><p>下面是一个HTTP响应的例子：</p><pre><code>HTTP/1.1 200 OKServer:Apache Tomcat/5.0.12Date:Mon,6Oct2003 13:23:42 GMTContent-Length:112&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP响应示例&lt;title&gt;&lt;/head&gt;&lt;body&gt;Hello HTTP!&lt;/body&gt;&lt;/html&gt;</code></pre><p>（1）协议状态版本代码描述</p><blockquote><p>协议状态代码描述HTTP响应的第一行类似于HTTP请求的第一行，它表示通信所用的协议是HTTP1.1服务器已经成功的处理了客户端发出的请求（200表示成功）:</p></blockquote><pre><code>HTTP/1.1 200 OK</code></pre><p>（2）响应头</p><blockquote><p>响应头(Response Header)响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等：</p></blockquote><pre><code>　　 Server:Apache Tomcat/5.0.12Date:Mon,6Oct2003 13:13:33 GMTContent-Type:text/htmlLast-Moified:Mon,6 Oct 2003 13:23:42 GMTContent-Length:112</code></pre><p>（3）响应正文</p><blockquote><p>响应正文响应正文就是服务器返回的HTML页面：</p></blockquote><pre><code>　　&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP响应示例&lt;title&gt;&lt;/head&gt;&lt;body&gt;Hello HTTP!&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>响应头和正文之间也必须用空行分隔。　</strong>　</p><h2 id="HTTP应答码"><a href="#HTTP应答码" class="headerlink" title="HTTP应答码"></a>HTTP应答码</h2><p>　HTTP应答码也称为状态码，它反映了Web服务器处理HTTP请求状态。HTTP应答码由3位数字构成，其中首位数字定义了应答码的类型：</p><pre><code>　　　1XX－信息类(Information),表示收到Web浏览器请求，正在进一步的处理中　　　2XX－成功类（Successful）,表示用户请求被正确接收，理解和处理例如：200 OK3XX-重定向类(Redirection),表示请求没有成功，客户必须采取进一步的动作。4XX-客户端错误(Client Error)，表示客户端提交的请求有错误 例如：404 NOT Found，意味着请求中所引用的文档不存在。5XX-服务器错误(Server Error)表示服务器不能完成对请求的处理：如 500</code></pre><h2 id="常见请求方法"><a href="#常见请求方法" class="headerlink" title="常见请求方法"></a>常见请求方法</h2><ul><li>GET 通过请求URI得到资源</li></ul><ul><li>POST<br>用于添加新的内容</li></ul><ul><li>PUT<br>用于修改某个内容</li></ul><ul><li>DELETE<br>删除某个内容</li></ul><ul><li>CONNECT,<br>用于代理进行传输，如使用SSL</li></ul><ul><li>OPTIONS<br>询问可以执行哪些方法</li></ul><ul><li>PATCH,<br>部分文档更改</li></ul><ul><li>PROPFIND, (wedav)<br>查看属性</li></ul><ul><li>PROPPATCH, (wedav)<br>设置属性</li></ul><ul><li>MKCOL, (wedav)<br>创建集合（文件夹）</li></ul><ul><li>COPY, (wedav)<br>拷贝</li></ul><ul><li>MOVE, (wedav)<br>移动</li></ul><ul><li>LOCK, (wedav)<br>加锁</li></ul><ul><li>UNLOCK (wedav)<br>解锁</li></ul><ul><li>TRACE<br>用于远程诊断服务器</li></ul><ul><li>HEAD<br>类似于GET, 但是不返回body信息，用于检查对象是否存在，以及得到对象的元数据</li></ul>]]></content>
    
    <summary type="html">
    
      HTTP深入浅出之http请求
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="网络知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
      <category term="HTTP请求" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/HTTP%E8%AF%B7%E6%B1%82/"/>
    
    
      <category term="HTTP请求" scheme="http://yoursite.com/tags/HTTP%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
</feed>
