<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watchmen1992&#39;s Blog</title>
  
  <subtitle>锦瑟年华当与书香为度，是为不负天地人生。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-08T12:29:08.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>XiaoHua WANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day05-常用模块学习</title>
    <link href="http://yoursite.com/2018/08/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day05/day05/"/>
    <id>http://yoursite.com/2018/08/08/编程语言/Python/老男孩视频学习笔记/day05/day05/</id>
    <published>2018-08-08T12:29:08.000Z</published>
    <updated>2018-08-08T12:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h1><p>This module provides a portable way of using operating system dependent functionality</p><p>os模块主要用于和操作系统之间的交互，这个模块提供了一种方便的使用操作系统函数的方法。</p><h1 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h1><p>This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.</p><p>sys模块主要用于和python解释器之间的交互，这个模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。</p>]]></content>
    
    <summary type="html">
    
      day05-常用模块学习
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="day05" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day05/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>gitlab安装部署</title>
    <link href="http://yoursite.com/2018/08/01/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/git/gitlab%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/08/01/IT科学技术知识体系结构-Linux运维方向/git/gitlab安装部署/</id>
    <published>2018-08-01T09:57:42.000Z</published>
    <updated>2018-08-01T09:57:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1>]]></content>
    
    <summary type="html">
    
      gitlab安装部署
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/git/"/>
    
      <category term="gitlab" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/git/gitlab/"/>
    
    
      <category term="gitlab" scheme="http://yoursite.com/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>Alfresco</title>
    <link href="http://yoursite.com/2018/07/27/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/Alfresco/Alfresco/"/>
    <id>http://yoursite.com/2018/07/27/IT科学技术知识体系结构-Linux运维方向/内容管理系统/Alfresco/Alfresco/</id>
    <published>2018-07-27T09:42:20.000Z</published>
    <updated>2018-07-27T09:42:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><p>Alfresco下载地址:</p><p>　　<a href="https://sourceforge.net/projects/alfresco/files/?source=navbar" target="_blank" rel="noopener">https://sourceforge.net/projects/alfresco/files/?source=navbar</a>   (包含所有版本和文件)</p><p>下载文件:alfresco-community-installer-201701-linux-x64.bin</p><p>安装需要的依赖包:</p><p>[root@alfresco ~]# yum -y install fontconfig libSM libICE libXrender libXext  libGLU  cpus-libs cairo cairo-devel</p><p>[root@alfresco ~]# chmod +x alfresco-community-installer-201701-linux-x64.bin<br>[root@alfresco ~]# umask 0022</p><p>[root@alfresco ~]# ./alfresco-community-installer-201701-linux-x64.bin </p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1>]]></content>
    
    <summary type="html">
    
      Alfresco从入门到实践
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="内容管理系统" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Alfresco" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/Alfresco/"/>
    
    
      <category term="Alfresco" scheme="http://yoursite.com/tags/Alfresco/"/>
    
  </entry>
  
  <entry>
    <title>day04-函数装饰器迭代器生成器</title>
    <link href="http://yoursite.com/2018/07/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day04/day04-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2018/07/13/编程语言/Python/老男孩视频学习笔记/day04/day04-函数装饰器迭代器生成器/</id>
    <published>2018-07-13T12:43:08.000Z</published>
    <updated>2018-07-13T12:43:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>器：代表函数的意思。也就是说，装饰器本质是函数，基本语法都是使用def关键字去定义的</p><p>那么它的本质是函数，它的功能是什么？</p><p>定义：装饰器的本质是函数：装饰其他函数的函数【就是为其他函数添加附加功能】</p><p>在实际生产环境中，需要新增功能的时候，有以下原则</p><ol><li>不能修改现有函数的源代码</li><li>函数一旦写好了，原则上就不能再去修改它的源代码</li><li>函数的调用方式也不能被修改</li></ol><p>装饰器有自己独特的需要遵循的原则：</p><ol><li><strong>不能修改被装饰的函数的源代码</strong></li><li><strong>不能修改被装饰的函数的调用方式</strong></li></ol><p>也就是，被装饰的函数式完全透明的（调用函数的一方不知道这个函数被装饰过，函数本身也感知不到装饰器的存在）</p><p>实现装饰器的知识储备：</p><ol><li><p>函数即“变量”</p></li><li><p>高阶函数</p><ul><li><p>把一个函数名都当做实参传递给另外一个函数【在一般的函数使用中，给形参传递的都是<code>实参变量</code>，那么，函数即变量之后，就可以把==函数==当做一个<code>变量实参</code>传递给另外一个函数】</p><p>这一步可以做到，在不修改被装饰函数源代码的情况下，为其添加功能</p></li><li><p>返回值中包含函数名【一般函数的返回值中吗，可以是字符串，列表，数字等等，因为函数是变量，那么在返回值中是也可以包含函数的】</p><p>不修改函数的调用方式</p></li></ul></li><li><p>函数嵌套</p><ul><li>函数嵌套指的是，在一个函数的函数体之内用def去声明一个新的函数，而不是去调用它</li></ul></li></ol><p>高阶函数+嵌套函数==》装饰器</p><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test1&quot;)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test2&quot;)</span><br><span class="line"></span><br><span class="line">def timer(func):</span><br><span class="line">    def deco():</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print (&quot;func is cost &#123;cost&#125;&quot;.format(cost=stop_time-start_time))</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line"># 返回该函数（这里是deco函数）的内存地址</span><br><span class="line"></span><br><span class="line">test1 = timer(test1)</span><br><span class="line">test1()</span><br><span class="line">#test1执行，实际上是在执行deco这个函数</span><br></pre></td></tr></table></figure><p>执行后的输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in the test1</span><br><span class="line">func is cost 1.0031695365905762</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>函数的执行，主要是执行函数体中的内容，而我们在真正执行函数的时候，是通过函数名称进行调用的（也就是一个变量），因此，在函数真正执行之前，我们可以<strong>修改这个函数名称对应的函数体中的内容</strong></p><p>装饰器的编写步骤：</p><ol><li>首先编写一个函数，其中调用这个被装饰的函数，并在其中添加上新的功能</li><li>将这个函数的函数体，也就是<strong>内存地址</strong>拿出来，重新赋值给这个被装饰的函数</li><li>实现第2步，就需要使用函数的嵌套，以此来返回这个函数的内存地址（函数嵌套了函数之后，是直接将子函数的内存地址返回，而没有执行这个子函数）</li><li>而将这个被装饰的源函数传递给这个装饰函数执行，就需要使用高阶函数</li></ol><h3 id="改良"><a href="#改良" class="headerlink" title="改良"></a>改良</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def timer(func):</span><br><span class="line">    def deco():</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print (&quot;func is cost &#123;cost&#125;&quot;.format(cost=stop_time-start_time))</span><br><span class="line">    return deco</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def test1():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test1&quot;)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print (&quot;in the test2&quot;)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>在这里，@timer=test1 = timer(test1)</p><p>注意，使用这种方式的时候，timer函数的定义要在这些被装饰函数的前方</p><p>如果函数还涉及到参数，那么，我们就需要重新编写定义装饰器，将它写成通用的方式，不管被装饰的函数传递的是几个函数（0个或多个），都能够正确的读取。</p><p><strong>添加函数传递功能</strong></p><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = lambda x:x*3</span><br><span class="line">print (res(3))</span><br><span class="line"></span><br><span class="line">执行后输出结果为：9</span><br></pre></td></tr></table></figure><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>通过列表生成式【列表解析】，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种<strong><code>一边循环一边计算</code></strong>的<strong>机制</strong>，称为生成器：generator。</p><p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [i*2 for i in range(11)]</span><br><span class="line">b = (i*2 for i in range(11))</span><br><span class="line">print (a)</span><br><span class="line">print (b)</span><br><span class="line"></span><br><span class="line">执行后输出如下所示：</span><br><span class="line">[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x058D5360&gt;</span><br></pre></td></tr></table></figure><p>注意，在进行调用的时候，传统的方式能够直接通过列表下标的方式获取到相应的元素【因为元素已经生成并存在于内存当中】，但是生成器是只有你调用到我这一次的时候，我才会生成这一个，也就是必须循环到这个指定的下标的时候，我才会产生这个元素的值，因此，在前面的数据没有生成的情况下，直接调用中间的某个元素，因为不存在这个元素，因此就会产生报错,不支持这种数据获取方式</p><p>调用生成器的时候，只能使用for循环的方式一个个取用，当不想要获取全部的数据，只需要获取部分数据的时候，使用生成器提供的next方法进行操作【next方法获取当前】。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.__next()__()</span><br></pre></td></tr></table></figure><p>注意：没有previous方法用户获取上一个值，因为，生成器只会当前的位置，不知道前边和后边</p><p><strong>总结：</strong></p><ul><li>生成器只有在调用时，才会生成相应的数据</li><li>只会记录当前位置</li><li>只有一个<code>__next__()</code>方法（2.7中为next()）</li></ul><p>我们创建了一个generator后，基本上永远不会调用<code>next()</code>，而是通过<code>for</code>循环来迭代它，并且不需要关心<code>StopIteration</code>的错误。</p><p>generator非常强大。如果推算的算法比较复杂，用类似列表生成式的<code>for</code>循环无法实现的时候，还可以用函数来实现。</p><p>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p><p>1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p><p>yield的作用：保存函数的中断状态，yield返回当前状态的值，并且将函数保持停留在这里</p><p>对生成器使用send()方法，可以将参数传递给这个生成器，yield就会接受到这个参数</p><p>next()只是单纯的调用yield，它不会给yield传值；send()给yield传值，同时调用yield</p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：</p><p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p><p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p><p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p><p><strong>重点：</strong></p><ul><li><p>可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code></p></li><li><p>生成器不但可以作用于<code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值了。</p></li><li>可以被next()方法调用并不断返回下一个值的对象称为迭代器：<strong><code>Iterator</code></strong>。</li></ul><p>迭代器和next()方法相关联，有next()方法的才能称之为迭代器</p><p>查看一个对象能够调用的所有方法：dir(a)</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象【是否是<strong>迭代器</strong>对象】：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print (isinstance([1,2,3],Iterator))</span><br><span class="line">print (isinstance([],Iterator))</span><br><span class="line">print (isinstance((x for x in range(10)),Iterator))</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">a = [1,2,3]</span><br><span class="line">b = iter(a)</span><br><span class="line">print (isinstance(b,Iterator))</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p><p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p><p>你可能会问，为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？</p><p>这是因为Python的<code>Iterator</code>对象表示的是一个数据流，Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p><code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><h1 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h1><p>python中有以下内置函数</p><table><thead><tr><th></th><th>Built-in Functions</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#abs" target="_blank" rel="noopener"><code>abs()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#delattr" target="_blank" rel="noopener"><code>delattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#hash" target="_blank" rel="noopener"><code>hash()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-memoryview" target="_blank" rel="noopener"><code>memoryview()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-set" target="_blank" rel="noopener"><code>set()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#all" target="_blank" rel="noopener"><code>all()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-dict" target="_blank" rel="noopener"><code>dict()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#help" target="_blank" rel="noopener"><code>help()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#min" target="_blank" rel="noopener"><code>min()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#setattr" target="_blank" rel="noopener"><code>setattr()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#any" target="_blank" rel="noopener"><code>any()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#dir" target="_blank" rel="noopener"><code>dir()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#hex" target="_blank" rel="noopener"><code>hex()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#next" target="_blank" rel="noopener"><code>next()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#slice" target="_blank" rel="noopener"><code>slice()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#ascii" target="_blank" rel="noopener"><code>ascii()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#divmod" target="_blank" rel="noopener"><code>divmod()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#id" target="_blank" rel="noopener"><code>id()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#object" target="_blank" rel="noopener"><code>object()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#sorted" target="_blank" rel="noopener"><code>sorted()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#bin" target="_blank" rel="noopener"><code>bin()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#input" target="_blank" rel="noopener"><code>input()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#oct" target="_blank" rel="noopener"><code>oct()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#staticmethod" target="_blank" rel="noopener"><code>staticmethod()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#bool" target="_blank" rel="noopener"><code>bool()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#eval" target="_blank" rel="noopener"><code>eval()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#int" target="_blank" rel="noopener"><code>int()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#open" target="_blank" rel="noopener"><code>open()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-str" target="_blank" rel="noopener"><code>str()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#breakpoint" target="_blank" rel="noopener"><code>breakpoint()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#exec" target="_blank" rel="noopener"><code>exec()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#ord" target="_blank" rel="noopener"><code>ord()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#sum" target="_blank" rel="noopener"><code>sum()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-bytearray" target="_blank" rel="noopener"><code>bytearray()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#filter" target="_blank" rel="noopener"><code>filter()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#issubclass" target="_blank" rel="noopener"><code>issubclass()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#pow" target="_blank" rel="noopener"><code>pow()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#super" target="_blank" rel="noopener"><code>super()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-bytes" target="_blank" rel="noopener"><code>bytes()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#float" target="_blank" rel="noopener"><code>float()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#iter" target="_blank" rel="noopener"><code>iter()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#print" target="_blank" rel="noopener"><code>print()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-tuple" target="_blank" rel="noopener"><code>tuple()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#callable" target="_blank" rel="noopener"><code>callable()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#format" target="_blank" rel="noopener"><code>format()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#len" target="_blank" rel="noopener"><code>len()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#property" target="_blank" rel="noopener"><code>property()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#type" target="_blank" rel="noopener"><code>type()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#chr" target="_blank" rel="noopener"><code>chr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-frozenset" target="_blank" rel="noopener"><code>frozenset()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-list" target="_blank" rel="noopener"><code>list()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#func-range" target="_blank" rel="noopener"><code>range()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#vars" target="_blank" rel="noopener"><code>vars()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#classmethod" target="_blank" rel="noopener"><code>classmethod()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#getattr" target="_blank" rel="noopener"><code>getattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#locals" target="_blank" rel="noopener"><code>locals()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#repr" target="_blank" rel="noopener"><code>repr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#zip" target="_blank" rel="noopener"><code>zip()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#compile" target="_blank" rel="noopener"><code>compile()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#globals" target="_blank" rel="noopener"><code>globals()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#map" target="_blank" rel="noopener"><code>map()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#reversed" target="_blank" rel="noopener"><code>reversed()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#__import__" target="_blank" rel="noopener"><code>__import__()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#complex" target="_blank" rel="noopener"><code>complex()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#hasattr" target="_blank" rel="noopener"><code>hasattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#max" target="_blank" rel="noopener"><code>max()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html?highlight=built#round" target="_blank" rel="noopener"><code>round()</code></a></td></tr></tbody></table><ul><li><p>all()：判断输出的值是否都为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print (all([9,3]))</span><br><span class="line">print (all([0,9,3]))</span><br><span class="line"></span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li><p>any()：一个数据为真，就返回真，如果可迭代对象为空，返回也为False</p></li></ul><ul><li>eval()：将字符串变成字典</li></ul><h1 id="json序列化"><a href="#json序列化" class="headerlink" title="json序列化"></a>json序列化</h1><p>序列化：把内存中的数据对象变成字符串</p><p>反序列化： 把磁盘中的数据加载到内存当中</p><p>注意：json只能处理简单的数据类型，列表、字典、字符串等，因为json是所有语言都通用的，json主要的作用是用于不同语言之间进行数据交互，因为一些复杂的东西，例如python和java里面，类的定义和使用方式、一些特性等等，各语言之间很多东西都有很大的差异性，如果需要转换类、函数等对象就会变得相当复杂。所以，json默认只是支持这些比较简单的。</p><ul><li><p>xml知识补充：xml正在逐渐的被json所取代</p><blockquote><p>xml是一种标记语言，</p></blockquote></li></ul><h1 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h1><p>pickle的用法和json完全一样，但是它在序列化的时候，会把内存转换成为二进制的形式，所以在操作文件的时候，需要在序列化和反序列化的时候使用的方法为：wb和rb</p><p>pickle有自己的一套语法映射关系，将数据转换为二进制数据，因此系统的字符集识别之后将会显示为乱码</p><h1 id="dumps-和dump-以及loads-和load-区别"><a href="#dumps-和dump-以及loads-和load-区别" class="headerlink" title="dumps()和dump()以及loads()和load()区别"></a>dumps()和dump()以及loads()和load()区别</h1><p>注意，在序列化的时候，使用dumps和loads操作文件的时候，需要使用文件本身的f.write()或者f.read()方法；但是如果使用dump()和load()的时候，该方法中就可以嵌入了对文件的操作，也就是说不需要再额外的使用以上两个文件方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f.write(pickle.dumps(info))</span><br><span class="line">等价于</span><br><span class="line">pickle.dump(info,f)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">data = pickle.loads(f.read())</span><br><span class="line">等价于</span><br><span class="line">data = pickle.load(f)</span><br></pre></td></tr></table></figure><p>注意，我们可以dump很多次，但是dump很多次之后的这个文件，直接使用load是打不开的。</p><p>也就是说，在python3中，最多只能dump一次。</p><p><strong>在编写程序时的一个准则：</strong></p><ul><li>只dump一次，只load一次</li><li>如果还是想使用原来的文件，那么就把原来的内容覆盖掉 </li><li>例如虚拟机的快照，虚拟机的快照是每一个快照都会对应一个文件，而不是把所有的快照内容都存在一起</li><li>如果想保存好几个状态，那么就dump好几个文件。</li></ul><h1 id="软件目录结构规范"><a href="#软件目录结构规范" class="headerlink" title="软件目录结构规范"></a>软件目录结构规范</h1><h4 id="为什么要设计好目录结构"><a href="#为什么要设计好目录结构" class="headerlink" title="为什么要设计好目录结构?"></a>为什么要设计好目录结构?</h4><p>“设计项目目录结构”，就和”代码编码风格”一样，属于个人风格问题。对于这种风格上的规范，一直都存在两种态度:</p><ol><li>一类同学认为，这种个人风格问题”无关紧要”。理由是能让程序work就好，风格问题根本不是问题。</li><li>另一类同学认为，规范化能更好的控制程序结构，让程序具有更高的可读性。</li></ol><p>我是比较偏向于后者的，因为我是前一类同学思想行为下的直接受害者。我曾经维护过一个非常不好读的项目，其实现的逻辑并不复杂，但是却耗费了我非常长的时间去理解它想表达的意思。从此我个人对于提高项目可读性、可维护性的要求就很高了。”项目目录结构”其实也是属于”可读性和可维护性”的范畴，我们设计一个层次清晰的目录结构，就是为了达到以下两点:</p><ol><li>可读性高: 不熟悉这个项目的代码的人，一眼就能看懂目录结构，知道程序启动脚本是哪个，测试目录在哪儿，配置文件在哪儿等等。从而非常快速的了解这个项目。</li><li>可维护性高: 定义好组织规则后，维护者就能很明确地知道，新增的哪个文件和代码应该放在什么目录之下。这个好处是，随着时间的推移，代码/配置的规模增加，项目结构不会混乱，仍然能够组织良好。</li></ol><p>所以，我认为，保持一个层次清晰的目录结构是有必要的。更何况组织一个良好的工程目录，其实是一件很简单的事儿。</p><h4 id="目录组织方式"><a href="#目录组织方式" class="headerlink" title="目录组织方式"></a>目录组织方式</h4><p>关于如何组织一个较好的Python工程目录结构，已经有一些得到了共识的目录结构。在Stackoverflow的<a href="http://stackoverflow.com/questions/193161/what-is-the-best-project-structure-for-a-python-application" target="_blank" rel="noopener">这个问题</a>上，能看到大家对Python目录结构的讨论。</p><p>这里面说的已经很好了，我也不打算重新造轮子列举各种不同的方式，这里面我说一下我的理解和体会。</p><p>假设你的项目名为foo, 我比较建议的最方便快捷目录结构这样就足够了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Foo/</span><br><span class="line">|-- bin/</span><br><span class="line">|   |-- foo</span><br><span class="line">|</span><br><span class="line">|-- foo/</span><br><span class="line">|   |-- tests/</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- test_main.py</span><br><span class="line">|   |</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- main.py</span><br><span class="line">|</span><br><span class="line">|-- docs/</span><br><span class="line">|   |-- conf.py</span><br><span class="line">|   |-- abc.rst</span><br><span class="line">|</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- requirements.txt</span><br><span class="line">|-- README</span><br></pre></td></tr></table></figure><p>简要解释一下:</p><ol><li><code>bin/</code>: 存放项目的一些可执行文件，当然你可以起名<code>script/</code>之类的也行。</li><li><code>foo/</code>: 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录<code>tests/</code>存放单元测试代码； (3) 程序的入口最好命名为<code>main.py</code>。</li><li><code>docs/</code>: 存放一些文档。</li><li><code>setup.py</code>: 安装、部署、打包的脚本。</li><li><code>requirements.txt</code>: 存放软件依赖的外部Python包列表。</li><li><code>README</code>: 项目说明文件。</li></ol><p>除此之外，有一些方案给出了更加多的内容。比如<code>LICENSE.txt</code>,<code>ChangeLog.txt</code>文件等，我没有列在这里，因为这些东西主要是项目开源的时候需要用到。如果你想写一个开源软件，目录该如何组织，可以参考<a href="http://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/" target="_blank" rel="noopener">这篇文章</a>。</p><p>下面，再简单讲一下我对这些目录的理解和个人要求吧。</p><p><strong>注意：</strong>有<code>__init__.py</code>这个空文件的目录就叫做包，没有的就叫做目录</p><h4 id="关于README的内容"><a href="#关于README的内容" class="headerlink" title="关于README的内容"></a>关于README的内容</h4><p><strong>这个我觉得是每个项目都应该有的一个文件</strong>，目的是能简要描述该项目的信息，让读者快速了解这个项目。</p><p>它需要说明以下几个事项:</p><ol><li>软件定位，软件的基本功能。</li><li>运行代码的方法: 安装环境、启动命令等。</li><li>简要的使用说明。</li><li>代码目录结构说明，更详细点可以说明软件的基本原理。</li><li>常见问题说明。</li></ol><p>我觉得有以上几点是比较好的一个<code>README</code>。在软件开发初期，由于开发过程中以上内容可能不明确或者发生变化，并不是一定要在一开始就将所有信息都补全。但是在项目完结的时候，是需要撰写这样的一个文档的。</p><p>可以参考Redis源码中<a href="https://github.com/antirez/redis#what-is-redis" target="_blank" rel="noopener">Readme</a>的写法，这里面简洁但是清晰的描述了Redis功能和源码结构。</p><h4 id="关于requirements-txt和setup-py"><a href="#关于requirements-txt和setup-py" class="headerlink" title="关于requirements.txt和setup.py"></a>关于requirements.txt和setup.py</h4><h4 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a>setup.py</h4><p>一般来说，用<code>setup.py</code>来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具<a href="https://pythonhosted.org/setuptools/setuptools.html#developer-s-guide" target="_blank" rel="noopener">setuptools</a>来管理这些事情。这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，<strong>一个项目一定要有一个安装部署工具</strong>，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。</p><p>这个我是踩过坑的。</p><p>我刚开始接触Python写项目的时候，安装环境、部署代码、运行程序这个过程全是手动完成，遇到过以下问题:</p><ol><li>安装环境时经常忘了最近又添加了一个新的Python包，结果一到线上运行，程序就出错了。</li><li>Python包的版本依赖问题，有时候我们程序中使用的是一个版本的Python包，但是官方的已经是最新的包了，通过手动安装就可能装错了。</li><li>如果依赖的包很多的话，一个一个安装这些依赖是很费时的事情。</li><li>新同学开始写项目的时候，将程序跑起来非常麻烦，因为可能经常忘了要怎么安装各种依赖。</li></ol><p><code>setup.py</code>可以将这些事情自动化起来，提高效率、减少出错的概率。”复杂的东西自动化，能自动化的东西一定要自动化。”是一个非常好的习惯。</p><p>setuptools的<a href="https://pythonhosted.org/setuptools/setuptools.html#developer-s-guide" target="_blank" rel="noopener">文档</a>比较庞大，刚接触的话，可能不太好找到切入点。学习技术的方式就是看他人是怎么用的，可以参考一下Python的一个Web框架，flask是如何写的: <a href="https://github.com/mitsuhiko/flask/blob/master/setup.py" target="_blank" rel="noopener">setup.py</a></p><p>当然，简单点自己写个安装脚本（<code>deploy.sh</code>）替代<code>setup.py</code>也未尝不可。</p><h4 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a>requirements.txt</h4><p>这个文件存在的目的是:</p><ol><li>方便开发者维护软件的包依赖。将开发过程中新增的包添加进这个列表中，避免在<code>setup.py</code>安装依赖时漏掉软件包。</li><li>方便读者明确项目使用了哪些Python包。</li></ol><p>这个文件的格式是每一行包含一个包依赖的说明，通常是<code>flask&gt;=0.10</code>这种格式，要求是这个格式能被<code>pip</code>识别，这样就可以简单的通过 <code>pip install -r requirements.txt</code>来把所有Python包依赖都装好了。具体格式说明： <a href="https://pip.readthedocs.org/en/1.1/requirements.html" target="_blank" rel="noopener">点这里</a>。</p><h4 id="关于配置文件的使用方法"><a href="#关于配置文件的使用方法" class="headerlink" title="关于配置文件的使用方法"></a>关于配置文件的使用方法</h4><h4 id="注意，在上面的目录结构中，没有将conf-py放在源码目录下，而是放在docs-目录下。"><a href="#注意，在上面的目录结构中，没有将conf-py放在源码目录下，而是放在docs-目录下。" class="headerlink" title="注意，在上面的目录结构中，没有将conf.py放在源码目录下，而是放在docs/目录下。"></a>注意，在上面的目录结构中，没有将<code>conf.py</code>放在源码目录下，而是放在<code>docs/</code>目录下。</h4><p>很多项目对配置文件的使用做法是:</p><ol><li>配置文件写在一个或多个python文件中，比如此处的conf.py。</li><li>项目中哪个模块用到这个配置文件就直接通过<code>import conf</code>这种形式来在代码中使用配置。</li></ol><p>这种做法我不太赞同:</p><ol><li>这让单元测试变得困难（因为模块内部依赖了外部配置）</li><li>另一方面配置文件作为用户控制程序的接口，应当可以由用户自由指定该文件的路径。</li><li>程序组件可复用性太差，因为这种贯穿所有模块的代码硬编码方式，使得大部分模块都依赖<code>conf.py</code>这个文件。</li></ol><p>所以，我认为配置的使用，更好的方式是，</p><ol><li>模块的配置都是可以灵活配置的，不受外部配置文件的影响。</li><li>程序的配置也是可以灵活控制的。</li></ol><p>能够佐证这个思想的是，用过nginx和mysql的同学都知道，nginx、mysql这些程序都可以自由的指定用户配置。</p><p>所以，不应当在代码中直接<code>import conf</code>来使用配置文件。上面目录结构中的<code>conf.py</code>，是给出的一个配置样例，不是在写死在程序中直接引用的配置文件。可以通过给<code>main.py</code>启动参数指定配置路径的方式来让程序读取配置内容。当然，这里的<code>conf.py</code>你可以换个类似的名字，比如<code>settings.py</code>。或者你也可以使用其他格式的内容来编写配置文件，比如<code>settings.yaml</code>之类的。</p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1>]]></content>
    
    <summary type="html">
    
      day04-函数装饰器迭代器生成器
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="day04" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day04/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>内核模块操作命令-lsmod+rmmod+modinfo+modprobe</title>
    <link href="http://yoursite.com/2018/07/13/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-lsmod+rmmod+modinfo+modprobe/"/>
    <id>http://yoursite.com/2018/07/13/IT科学技术知识体系结构-Linux运维方向/Linux基础知识/Linux常用命令/内核模块操作命令-lsmod+rmmod+modinfo+modprobe/</id>
    <published>2018-07-13T07:23:11.000Z</published>
    <updated>2018-07-13T07:23:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要讲解和Linux内核模块相关的操作命令</p><hr><h1 id="lsmod-查看内核模块信息"><a href="#lsmod-查看内核模块信息" class="headerlink" title="lsmod-查看内核模块信息"></a>lsmod-查看内核模块信息</h1><p><strong>lsmod命令</strong>用于显示已经加载到内核中的模块的状态信息。执行lsmod命令后会列出所有已载入系统的模块。</p><p>Linux操作系统的核心具有模块化的特性，应此在编译核心时，可以不用把全部的功能都放入核心，而是将这些功能编译成一个个单独的模块，待需要时再分别载入使用。 </p><p>命令的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# lsmod </span><br><span class="line">Module                  Size  Used by</span><br><span class="line">iptable_nat             5923  0 </span><br><span class="line">nf_nat                 22676  1 iptable_nat</span><br><span class="line">nf_conntrack_ipv4       9186  3 iptable_nat,nf_nat</span><br><span class="line">nf_conntrack           79537  3 iptable_nat,nf_nat,nf_conntrack_ipv4</span><br><span class="line">nf_defrag_ipv4          1483  1 nf_conntrack_ipv4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# lsmod | grep ip_vs</span><br><span class="line">ip_vs_rr                1420  0 </span><br><span class="line">ip_vs                 126705  2 ip_vs_rr</span><br><span class="line">libcrc32c               1246  1 ip_vs</span><br><span class="line">ipv6                  336368  913 ip_vs,ib_ipoib,ib_addr</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>第1列：表示模块的名称。</li><li>第2列：表示模块的大小。</li><li>第3列：表示该模块调用其他模块的个数</li><li>第4列：显示该模块被其他什么模块调用</li></ul><p>通常在使用lsmod命令时，都会采用类似<code>lsmod | grep -i ipvs</code>这样的命令来查询当前系统是否加载了某些模块。</p><h1 id="modinfo-查看内核模块信息"><a href="#modinfo-查看内核模块信息" class="headerlink" title="modinfo-查看内核模块信息"></a>modinfo-查看内核模块信息</h1><p>modinfo会显示kernel模块的对象文件，以显示该模块的相关信息。 </p><p>modinfo列出Linux内核中命令行指定的模块的信息。若模块名不是一个文件名，则会在/lib/modules/version 目录中搜索，就像modprobe一样。</p><p>modinfo默认情况下，为了便于阅读，以下面的格式列出模块的每个属性：fieldname : value。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">参　　数：</span><br><span class="line">  -a或--author 　显示模块开发人员。 </span><br><span class="line">  -d或--description 　显示模块的说明。 </span><br><span class="line">  -h或--help 　显示modinfo的参数使用方法。 </span><br><span class="line">  -p或--parameters 　显示模块所支持的参数。 </span><br><span class="line">  -V或--version 　显示版本信息。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# modinfo ip_vs</span><br><span class="line">filename:       /lib/modules/2.6.32-696.el6.x86_64/kernel/net/netfilter/ipvs/ip_vs.ko</span><br><span class="line">license:        GPL</span><br><span class="line">srcversion:     0FB85919D62C4255E412E5C</span><br><span class="line">depends:        ipv6,libcrc32c</span><br><span class="line">vermagic:       2.6.32-696.el6.x86_64 SMP mod_unload modversions </span><br><span class="line">parm:           conn_tab_bits:Set connections&apos; hash size (int)</span><br></pre></td></tr></table></figure><p>注意，使用lsmod不能看到内核的相关参数配置，而使用modinfo命令则可以显示</p><h1 id="rmmod-卸载内核模块"><a href="#rmmod-卸载内核模块" class="headerlink" title="rmmod-卸载内核模块"></a>rmmod-卸载内核模块</h1><p><strong>rmmod命令</strong> 用于从当前运行的内核中移除指定的内核模块。</p><p>执行rmmod指令，可删除不需要的模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选项信息：</span><br><span class="line">-v：显示指令执行的详细信息；</span><br><span class="line">-f：强制移除模块，使用此选项比较危险；</span><br><span class="line">-w：等待着，直到模块能够被除时在移除模块；</span><br><span class="line">-s：向系统日志（syslog）发送错误信息。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# rmmod ip_vs</span><br><span class="line">ERROR: Module ip_vs is in use by ip_vs_rr</span><br></pre></td></tr></table></figure><p>使用rmmod卸载模块的时候，提示信息会比使用modprobe -r 的输出更详细，此时会显示该模块的被调用情况</p><h1 id="insmod-载入内核模块"><a href="#insmod-载入内核模块" class="headerlink" title="insmod-载入内核模块"></a>insmod-载入内核模块</h1><p>insmod(install module)命令用于载入模块。</p><p>Linux有许多功能是通过模块的方式，在需要时才载入kernel。如此可使kernel较为精简，进而提高效率，以及保有较大的弹性。这类可载入的模块，通常是设备驱动程序。</p><p><strong>语法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod [-fkmpsvxX][-o &lt;模块名称&gt;][模块文件][符号名称 = 符号值]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">-f 　不检查目前kernel版本与模块编译时的kernel版本是否一致，强制将模块载入。</span><br><span class="line">-k 　将模块设置为自动卸除。</span><br><span class="line">-m 　输出模块的载入信息。</span><br><span class="line">-o&lt;模块名称&gt; 　指定模块的名称，可使用模块文件的文件名。</span><br><span class="line">-p 　测试模块是否能正确地载入kernel。</span><br><span class="line">-s 　将所有信息记录在系统记录文件中。</span><br><span class="line">-v 　执行时显示详细的信息。</span><br><span class="line">-x 　不要汇出模块的外部符号。</span><br><span class="line">-X 　汇出模块所有的外部符号，此为预设置。</span><br></pre></td></tr></table></figure><p>在Linux中，modprobe和insmod都可以用来加载module，不过现在一般都推荐使用modprobe而不是insmod了。<br><strong>modprobe和insmod的区别是什么呢？</strong></p><ul><li>modprobe可以解决load module时的依赖关系，比如load moudleA就必须先load mouduleB之类的，它是通过/lib/modules//modules.dep文件来查找依赖关系的。而insmod不能解决依赖问题。</li><li>modprobe默认会去/lib/modules/目录下面查找module，而insmod只在给它的参数中去找module（默认在当前目录找）。</li></ul><p>但是insmod也有它的有用之处，举个例子吧。</p><p>有/root/my-mod.ko这个module，cd /root/，然后用insmod my-mod.ko(insmod /root/my-mod.ko)就可以insert这个module了，</p><p>但是用modprobe my-mod.ko(modprobe /root/my-mod.ko)却提示”FATAL: Module my-mod.ko not found”，这就是因为modprobe是到/lib/modules/<code>uname -r</code>/下去找module的，如果没找到就是这样了。</p><h1 id="depmod-分析模块依赖性"><a href="#depmod-分析模块依赖性" class="headerlink" title="depmod-分析模块依赖性"></a>depmod-分析模块依赖性</h1><h1 id="modprobe-内核模块操作"><a href="#modprobe-内核模块操作" class="headerlink" title="modprobe-内核模块操作"></a>modprobe-内核模块操作</h1><p><strong>modprobe命令</strong>用于智能地向内核中加载模块或者从内核中移除模块。</p><p>modprobe可载入指定的个别模块，或是载入一组相依的模块。</p><p>modprobe会根据<a href="http://man.linuxde.net/depmod" target="_blank" rel="noopener">depmod</a>所产生的相依关系，决定要载入哪些模块。若在载入过程中发生错误，在modprobe会卸载整组的模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数选项</span><br><span class="line"></span><br><span class="line">-a或--all：载入全部的模块/指定模块；</span><br><span class="line">-c或--show-conf：显示所有模块的设置信息；</span><br><span class="line">-d或--debug：使用排错模式；</span><br><span class="line">-l或--list：显示可用的模块；</span><br><span class="line">-r或--remove：卸载模块；</span><br><span class="line">-t或--type：指定模块类型；</span><br><span class="line">-v或--verbose：执行时显示详细的信息；</span><br><span class="line">-V或--version：显示版本信息；</span><br><span class="line">-help：显示帮助。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">卸载：modprobe -r ip_vs </span><br><span class="line">载入：modprobe -a ip_vs</span><br></pre></td></tr></table></figure><h1 id="get-module"><a href="#get-module" class="headerlink" title="get_module"></a>get_module</h1><p>需要安装sysfsutils包之后才能产生该命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install sysfsutils</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# get_module ip_vs</span><br><span class="line">initstate            : live</span><br><span class="line">refcnt               : 2</span><br><span class="line">srcversion           : 0FB85919D62C4255E412E5C</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">conn_tab_bits        : 12</span><br><span class="line">Sections:</span><br><span class="line">.altinstr_replacement : 0xffffffffa039c2b8</span><br><span class="line">.altinstructions     : 0xffffffffa039ef98</span><br><span class="line">.bss                 : 0xffffffffa03a1c60</span><br><span class="line">.data                : 0xffffffffa039ff00</span><br><span class="line">.data.cacheline_aligned : 0xffffffffa03a1580</span><br><span class="line">.data.read_mostly    : 0xffffffffa03a1040</span><br><span class="line">.exit.text           : 0xffffffffa039c40e</span><br><span class="line">.gnu.linkonce.this_module : 0xffffffffa03a1a20</span><br><span class="line">.init.text           : 0xffffffffa03aa000</span><br><span class="line">.note.gnu.build-id   : 0xffffffffa039c454</span><br><span class="line">.rheldata            : 0xffffffffa039fee0</span><br><span class="line">.rodata              : 0xffffffffa039c480</span><br><span class="line">.rodata.str1.1       : 0xffffffffa039d6e8</span><br><span class="line">.rodata.str1.8       : 0xffffffffa039dc90</span><br><span class="line">.smp_locks           : 0xffffffffa039eb68</span><br><span class="line">.strtab              : 0xffffffffa03ae2f8</span><br><span class="line">.symtab              : 0xffffffffa03aa4d0</span><br><span class="line">.text                : 0xffffffffa038a000</span><br><span class="line">__kcrctab_gpl        : 0xffffffffa039f540</span><br><span class="line">__kcrctab            : 0xffffffffa039fe80</span><br><span class="line">__ksymtab_gpl        : 0xffffffffa039f4f0</span><br><span class="line">__ksymtab_strings    : 0xffffffffa039f590</span><br><span class="line">__ksymtab            : 0xffffffffa039fdc0</span><br><span class="line">__mcount_loc         : 0xffffffffa039f6e8</span><br><span class="line">__param              : 0xffffffffa039f568</span><br><span class="line">__verbose            : 0xffffffffa03a1980</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      内核模块操作-lsmod+rmmod+modinfo+modprobe
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="Linux基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Linux常用命令" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="lsmod" scheme="http://yoursite.com/tags/lsmod/"/>
    
  </entry>
  
  <entry>
    <title>TCP连接状态</title>
    <link href="http://yoursite.com/2018/07/13/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/TCP%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/TCP%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2018/07/13/IT科学技术知识体系结构-Linux运维方向/网络知识/TCP连接状态/TCP连接状态/</id>
    <published>2018-07-13T05:48:30.000Z</published>
    <updated>2018-07-13T05:48:30.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="tag1" scheme="http://yoursite.com/tags/tag1/"/>
    
  </entry>
  
  <entry>
    <title>python常见模块+方法+函数记录</title>
    <link href="http://yoursite.com/2018/07/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/python%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/07/11/编程语言/Python/个人总结/python模块/</id>
    <published>2018-07-11T09:43:49.000Z</published>
    <updated>2018-07-11T09:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p>在平常的代码中，我们常常需要与时间打交道。在Python中，与时间处理有关的模块包括：time，datetime以及calendar。</p><p>在开始之前，首先要说明这几点：</p><ol><li><p>在Python中，通常有这几种方式来表示时间：</p><p>1）时间戳 </p><p>2）格式化的时间字符串 </p><p>3）元组（struct_time）共九个元素。由于Python的time模块实现主要调用C库，所以各个平台可能有所不同。</p></li></ol><ol><li>UTC（Coordinated Universal Time，世界协调时）亦即格林威治天文时间，世界标准时间。在中国为UTC+8。DST（Daylight Saving Time）即夏令时。</li></ol><ol><li>时间戳（timestamp）的方式：通常来说，时间戳表示的是从<strong>1970年1月1日00:00:00</strong>开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。返回时间戳方式的函数主要有time()，clock()等。</li></ol><ol><li>元组（struct_time）方式：struct_time元组共有9个元素，返回struct_time的函数主要有gmtime()，localtime()，strptime()。下面列出这种方式元组中的几个元素：</li></ol><table><thead><tr><th>索引（Index）</th><th>属性（Attribute）</th><th>值（Values）</th></tr></thead><tbody><tr><td>0</td><td>tm_year（年）</td><td>比如2011</td></tr><tr><td>1</td><td>tm_mon（月）</td><td>1 - 12</td></tr><tr><td>2</td><td>tm_mday（日）</td><td>1 - 31</td></tr><tr><td>3</td><td>tm_hour（时）</td><td>0 - 23</td></tr><tr><td>4</td><td>tm_min（分）</td><td>0 - 59</td></tr><tr><td>5</td><td>tm_sec（秒）</td><td>0 - 61</td></tr><tr><td>6</td><td>tm_wday（weekday）</td><td>0 - 6（0表示周日）</td></tr><tr><td>7</td><td>tm_yday（一年中的第几天）</td><td>1 - 366</td></tr><tr><td>8</td><td>tm_isdst（是否是夏令时）</td><td>默认为-1</td></tr></tbody></table><h3 id="获取当前时间戳"><a href="#获取当前时间戳" class="headerlink" title="获取当前时间戳"></a>获取当前时间戳</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.time())</span><br><span class="line">输出如下：</span><br><span class="line">1531317129.0039742</span><br></pre></td></tr></table></figure><h3 id="时间元祖"><a href="#时间元祖" class="headerlink" title="时间元祖"></a>时间元祖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.localtime())</span><br><span class="line">输出如下：</span><br><span class="line">time.struct_time(tm_year=2018, tm_mon=7, tm_mday=11, tm_hour=22, tm_min=4, tm_sec=18, tm_wday=2, tm_yday=192, tm_isdst=0)</span><br></pre></td></tr></table></figure><h3 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h3><p>最简单的获取可读模式的方法是asctime()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.asctime())</span><br><span class="line">输出如下：</span><br><span class="line">Wed Jul 11 21:52:09 2018</span><br></pre></td></tr></table></figure><p><strong>使用指定的格式输出</strong>，在这里，使用strftime方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print (time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.localtime()))</span><br><span class="line">输入如下：</span><br><span class="line">2018-07-11 22:02:27</span><br></pre></td></tr></table></figure><p><strong>补充-python中时间日期格式化符号</strong></p><p>python中时间日期格式化符号：</p><ul><li>%y 两位数的年份表示（00-99）</li><li>%Y 四位数的年份表示（000-9999）</li><li>%m 月份（01-12）</li><li>%d 月内中的一天（0-31）</li><li>%H 24小时制小时数（0-23）</li><li>%I 12小时制小时数（01-12）</li><li>%M 分钟数（00=59）</li><li>%S 秒（00-59）</li><li>%a 本地简化星期名称</li><li>%A 本地完整星期名称</li><li>%b 本地简化的月份名称</li><li>%B 本地完整的月份名称</li><li>%c 本地相应的日期表示和时间表示</li><li>%j 年内的一天（001-366）</li><li>%p 本地A.M.或P.M.的等价符</li><li>%U 一年中的星期数（00-53）星期天为星期的开始</li><li>%w 星期（0-6），星期天为星期的开始</li><li>%W 一年中的星期数（00-53）星期一为星期的开始</li><li>%x 本地相应的日期表示</li><li>%X 本地相应的时间表示</li><li>%Z 当前时区的名称</li><li>%% %号本身</li></ul><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Python time sleep() 方法推迟调用线程的运行，可通过参数secs指秒数，表示进程挂起的时间。 </p><p>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.sleep(t)</span><br></pre></td></tr></table></figure><h2 id="commands模块-3-x已废弃"><a href="#commands模块-3-x已废弃" class="headerlink" title="commands模块-3.x已废弃"></a>commands模块-3.x已废弃</h2><p>用Python写运维脚本时，经常需要执行linux shell的命令，Python中的commands模块专门用于调用Linux shell命令，并返回状态和结果。</p><p>下面是commands模块的几个主要方法： </p><h3 id="commands-getoutput-‘shell-command’"><a href="#commands-getoutput-‘shell-command’" class="headerlink" title="commands.getoutput(‘shell command’)"></a>commands.getoutput(‘shell command’)</h3><p>执行shell命令，返回结果（string类型）</p><p>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输出指定进程的pid</span><br><span class="line"></span><br><span class="line">wxh@wxh-virtual-machine:~/python_files$ cat tt.py</span><br><span class="line">#!/usr/bin/env python2</span><br><span class="line">import sys,commands</span><br><span class="line">cmdline = sys.argv[1]</span><br><span class="line">cmdline1 = sys.argv[2]</span><br><span class="line"></span><br><span class="line">cmd = &quot;ps -ef|grep &quot; + cmdline + &quot;|grep &quot; + cmdline1 + &quot;|grep -v grep|grep -v python|awk &apos;&#123;print $2&#125;&apos;&quot;</span><br><span class="line"></span><br><span class="line">c1 = commands.getoutput(cmd)</span><br><span class="line">print (c1)</span><br><span class="line">print (type(c1))</span><br></pre></td></tr></table></figure><p>执行后输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-virtual-machine:~/python_files$ python2 ./tt.py unity-panel-service lockscreen-mode</span><br><span class="line"></span><br><span class="line">126263</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="commands-getstatusoutput-‘shell-command’"><a href="#commands-getstatusoutput-‘shell-command’" class="headerlink" title="commands.getstatusoutput(‘shell command’)"></a>commands.getstatusoutput(‘shell command’)</h3><p>执行shell命令, 返回两个元素的元组tuple(status, result)，status为int类型，result为string类型。</p><p>因为cmd的执行方式是{ cmd ; } 2&gt;&amp;1, 故返回结果包含标准输出和标准错误.</p><ul><li>第一个值为命令执行的返回状态码，执行成功则返回的是0，不成功则返回的是非0</li></ul><p>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-virtual-machine:~/python_files$ cat tt.py </span><br><span class="line">#!/usr/bin/env python2</span><br><span class="line">import sys,commands</span><br><span class="line">cmdline = sys.argv[1]</span><br><span class="line">cmdline1 = sys.argv[2]</span><br><span class="line"></span><br><span class="line">cmd = &quot;ps -ef|grep &quot; + cmdline + &quot;|grep &quot; + cmdline1 + &quot;|grep -v grep|grep -v python|awk &apos;&#123;print $2&#125;&apos;&quot;</span><br><span class="line">res = commands.getstatusoutput(cmd)</span><br><span class="line">print (res)</span><br></pre></td></tr></table></figure><p>执行后输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-virtual-machine:~/python_files$ python2 ./tt.py unity-panel-service lockscreen-mode</span><br><span class="line">(0, &apos;126263&apos;)</span><br></pre></td></tr></table></figure><h1 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h1><p>用于检测linux进程的状态</p><p>实例如下：</p><pre><code>def redis_status(new_port):    p = subprocess.Popen([&quot;netstat&quot;, &quot;-unptl&quot;], stdout=subprocess.PIPE)    out, err = p.communicate()    if (new_port in str(out) ):        print (&quot;redis {PORT} instance is running...&quot;.format(PORT=new_port))    else:        print (&quot;start redis {PORT} faild.please check again...&quot;.format(PORT=new_port))</code></pre><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="truncate-方法"><a href="#truncate-方法" class="headerlink" title="truncate() 方法"></a>truncate() 方法</h3><p><strong>truncate()</strong> 方法用于截断文件，如果指定了可选参数 size，则表示截断文件的 size 个字符。 </p><p>如果没有指定 size，则从当前位置起截断（截断余下的所有字符）；截断之后 size 后面的所有字符被删除。 </p><h3 id="seek-方法"><a href="#seek-方法" class="headerlink" title="seek()方法"></a>seek()方法</h3>]]></content>
    
    <summary type="html">
    
      python模块
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="个人总结" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>网卡中断与CPU绑定</title>
    <link href="http://yoursite.com/2018/07/11/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E4%B8%8ECPU%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/07/11/IT科学技术知识体系结构-Linux运维方向/性能调优/网络调优/网卡中断与CPU绑定/</id>
    <published>2018-07-11T07:01:32.000Z</published>
    <updated>2018-07-11T07:01:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><p><a href="https://www.cnblogs.com/bamanzi/p/linux-irq-and-cpu-affinity.html" target="_blank" rel="noopener">Linux 性能调优] 网卡中断与CPU的绑定问题</a></p></li><li><p><a href="http://noican.blog.51cto.com/4081966/1355357" target="_blank" rel="noopener">简单介绍下linux下的中断（interrupt）- 一切皆有可能 - 51CTO技术博客</a></p></li><li><a href="https://segmentfault.com/a/1190000006178824" target="_blank" rel="noopener">把网卡中断绑定到CPU,最大化网卡的吞吐量 - SegmentFault</a></li><li><a href="http://www.vpsee.com/2010/07/load-balancing-with-irq-smp-affinity/" target="_blank" rel="noopener">Linux 多核下绑定硬件中断到不同 CPU（IRQ Affinity） | vpsee.com</a></li><li><p><a href="http://www.jianshu.com/p/6beacca6fdcd" target="_blank" rel="noopener">Linux系统CPU的性能监控及调优 - 简书</a></p></li><li><p><a href="https://www.chinanetcloud.com/en/info-center/blog/tech-items-linux-nic-interrupts-overloading-single-cpus/" target="_blank" rel="noopener">Tech Items - Linux NIC Interrupts Overloading Single CPUs - ChinaNetCloud</a> </p></li><li><p><a href="http://www.tuicool.com/articles/naUnia" target="_blank" rel="noopener">Linux网卡中断使单个CPU过载 - 推酷</a> </p></li><li><p><a href="http://wwdhks.blog.51cto.com/839773/1218785" target="_blank" rel="noopener">网卡软中断调优 - deven的博客 - 51CTO技术博客</a> </p></li></ul><p><strong>除了不让多个中断集中到单个CPU，还有更进一步的方法:</strong>  </p><p>调整网卡驱动参数使之采用多个队列，这样多个CPU可以各自处理一个队列。</p><p>当然，这依赖于网卡是否支持 </p><ul><li><a href="http://www.ywnds.com/?p=4380" target="_blank" rel="noopener">多队列网卡及网卡中断绑定阐述 – 运维那点事</a> (这篇文章讲得很全面，推荐阅读） </li><li><a href="http://blog.csdn.net/wyaibyn/article/details/14109325" target="_blank" rel="noopener">网卡多队列及中断绑定 - wyaibyn的专栏 - CSDN博客</a> </li><li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rss.html" target="_blank" rel="noopener">8.6. Receive-Side Scaling (RSS) - Performance Tuning Guide - Red Hat Enterprise Linux 6</a>  </li></ul><p>即使网卡只支持单个队列，我们可以在系统层面模拟层多个队列，这个涉及到被称为Receive Packet Steering (RFS)和Receive Flow Steering (RFS）的两个技术  </p><ul><li><p><a href="http://www.ywnds.com/?p=4380" target="_blank" rel="noopener">多队列网卡及网卡中断绑定阐述 – 运维那点事</a> </p></li><li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rps.html" target="_blank" rel="noopener">8.7. Receive Packet Steering (RPS) - Performance Tuning Guide - Red Hat Enterprise Linux 6</a></p></li><li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/network-rfs.html" target="_blank" rel="noopener">8.8. Receive Flow Steering (RFS) - Performance Tuning Guide - Red Hat Enterprise Linux 6</a> </li></ul><hr><p>在Linux的网络调优方面，如果你发现网络流量上不去，那么有一个方面需要去查一下：网卡处理网络请求的中断是否被绑定到单个CPU（或者说跟处理其它中断的是同一个CPU）。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>网卡与操作系统的交互一般有两种方式：</p><ul><li>一种是中断（IRQ，网卡在收到了网络信号之后，主动发送中断到CPU，而CPU将会立即停下手边的活以便对这个中断信号进行分析），</li><li>另一种叫DMA（Direct Memory Access, 也就是允许硬件在无CPU干预的情况下将数据缓存在指定的内存空间内，在CPU合适的时候才处理）</li></ul><p>在网卡方面，大部分还是在用IRQ方式（据说DMA技术仅仅被应用在少数高端网卡上; 另一个说法是：DMA方式会使外部设备的控制器独占PCI总线，从而CPU无法与外部设备进行交互，这对通用型操作系统Linux来说，是很难接收的，所以DMA方式在Linux内核里使用得很少）。</p><p>但是（再来一个但是），在现在的对称多核处理器（SMP）上，一块网卡的IRQ还是只有一个CPU来响应，其它CPU无法参与，如果这个CPU还要忙其它的中断（其它网卡或者其它使用中断的外设（比如磁盘）），那么就会形成瓶颈。</p><h1 id="问题判定"><a href="#问题判定" class="headerlink" title="问题判定"></a>问题判定</h1><p>网上不少讲这个问题的文章都是直接让查询IRQ跟CPU的绑定情况，甚至直接修改。但我们应该先判断我们的系统是不是受这个问题影响，然后再来看怎么解决。</p><p>首先，让你的网络跑满（比如对于MySQL/MongoDB服务，可以通过客户端发起密集的读操作; 或者执行一个i大文件传送任务）</p><p>第一个要查明的是：<strong>是不是某个CPU在一直忙着处理IRQ？</strong></p><p>这个问题我们可以从 <code>mpstat -P ALL 1</code> 的输出中查明：里面的 <code>%irq</code>一列即说明了CPU忙于处理中断的时间占比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">18:20:33     CPU   %user   %nice    %sys %iowait    %irq   %soft  %steal   %idle    intr/s</span><br><span class="line">18:20:33     all    0,23    0,00    0,08    0,11    6,41    0,02    0,00   93,16   2149,29</span><br><span class="line">18:20:33       0    0,25    0,00    0,12    0,07    0,01    0,05    0,00   99,49    127,08</span><br><span class="line">18:20:33       1    0,14    0,00    0,03    0,04    0,00    0,00    0,00   99,78      0,00</span><br><span class="line">18:20:33       2    0,23    0,00    0,02    0,03    0,00    0,00    0,00   99,72      0,02</span><br><span class="line">18:20:33       3    0,28    0,00    0,15    0,28   25,63    0,03    0,00   73,64   2022,19</span><br></pre></td></tr></table></figure><p>上面的例子中，第四个CPU有25.63%时间在忙于处理中断（这个数值还不算高，如果高达80%（而同时其它CPU这个数值很低）以上就说明有问题了），后面那个 intr/s 也说明了CPU每秒处理的中断数（从上面的数据也可以看出，其它几个CPU都不怎么处理中断）。</p><p>然后我们就要接着查另外一个问题：<strong>这个忙于处理中断的CPU都在处理哪个（些）中断？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupts </span><br><span class="line">           CPU0       CPU1       CPU2       CPU3       </span><br><span class="line">  0:        245          0          0    7134094    IO-APIC-edge  timer</span><br><span class="line">  8:          0          0         49          0    IO-APIC-edge  rtc</span><br><span class="line">  9:          0          0          0          0   IO-APIC-level  acpi</span><br><span class="line"> 66:         67          0          0          0   IO-APIC-level  ehci_hcd:usb2</span><br><span class="line"> 74:     902214          0          0          0         PCI-MSI  eth0</span><br><span class="line">169:          0          0         79          0   IO-APIC-level  ehci_hcd:usb1</span><br><span class="line">177:          0          0          0    7170885   IO-APIC-level  ata_piix, b4xxp</span><br><span class="line">185:          0          0          0      59375   IO-APIC-level  ata_piix</span><br><span class="line">NMI:          0          0          0          0 </span><br><span class="line">LOC:    7104234    7104239    7104243    7104218 </span><br><span class="line">ERR:          0</span><br><span class="line">MIS:          0</span><br></pre></td></tr></table></figure><p>这里记录的是自启动以来，每个CPU处理各类中断的数量（第一列是中断号，最后一列是对应的设备名）[详细说明: <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/s2-proc-interrupts.html" target="_blank" rel="noopener">E.2.10 /proc/interrupts - Deployment Guide - RedHat Enterprise Linux 6</a> )，从上面可以看到： <code>eth0</code>所出发的中断全部都是 <code>CPU0</code>在处理，而CPU0所处理的中断请求中，主要是eth0和LOC中断。</p><p>（有时我们会看到几个CPU对同一个中断类型所处理的的请求数相差无几（比如上面的LOC一行），这并不一定是说多个CPU会轮流处理同一个中断，而是因为这里记录的是“自启动以来”的统计，中间可能因为irq balancer重新分配过处理中断的CPU——当然，也可能是谁手工调节过）。</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>首先说明几点：</p><ol><li>首先应该根据上面的诊断方法查明当前系统是不是受这个原因影响，如果不是，那么就没有必要往下看了;</li><li>现在的多数Linux系统中已经有了IRQ Balance这个服务（服务程序一般是 <code>/usr/sbin/irqbalance</code>），它可以自动调节分配各个中断与CPU的绑定关系，以避免所有中断的处理都集中在少数几个CPU上;</li><li>在某些情况下，这个IRQ Balance反而会导致问题，会出现 irqbalance 这个进程反而自身占用了较高的CPU（当然也就影响了业务系统的性能）</li></ol><p>下面来说手工将中断限定到少数几个CPU的方法。</p><p>首先当然要查明，该网卡的中断当前是否已经限定到某些CPU了？具体是哪些CPU？</p><p>根据上面 <code>/proc/interrupts</code> 的内容我们可以看到 eth0 的中断号是74，然后我们来看看该中断号的CPU绑定情况（或者说叫亲和性 affinity）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /proc/irq/74/smp_affinity</span><br><span class="line">ffffff</span><br></pre></td></tr></table></figure><p>这个输出是一个16进制的数值，<code>0xffffff = ‘0b111111111111111111111111’</code>，这就意味着这里有24个CPU，所有位都为1表示所有CPU都可以被该中断干扰。</p><p>另一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /proc/irq/67/smp_affinity</span><br><span class="line">00000001</span><br></pre></td></tr></table></figure><p>这个例子说明，只有CPU0处理编号为67的中断。</p><p><strong>修改配置的方法</strong>：</p><p>我们可以用 <code>echo 2 &gt; /proc/irq/74/smp_affinity</code> 的方法来修改这个设置（设置为2表示将该中断绑定到CPU1上，0x2 = 0b10，而第一个CPU为CPU0）</p>]]></content>
    
    <summary type="html">
    
      网卡中断与CPU绑定
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="性能调优" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="网络调优" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>LVS性能指标及监控</title>
    <link href="http://yoursite.com/2018/07/10/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/LVS/LVS%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%8F%8A%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2018/07/10/IT科学技术知识体系结构-Linux运维方向/高并发/负载均衡/LVS/LVS性能指标及监控/</id>
    <published>2018-07-10T08:08:26.000Z</published>
    <updated>2018-07-10T08:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考文献：</strong></p><ul><li><a href="http://kb.linuxvirtualserver.org/wiki/Performance_and_Tuning" target="_blank" rel="noopener">Performance and Tuning - LVSKB</a></li></ul><h1 id="性能参数"><a href="#性能参数" class="headerlink" title="性能参数"></a>性能参数</h1><p>LVS 的性能主要通过以下几个方面来提高</p><h2 id="ipvs-connection-table-size-最大连接数"><a href="#ipvs-connection-table-size-最大连接数" class="headerlink" title="ipvs connection table size-最大连接数"></a>ipvs connection table size-最大连接数</h2><p>官方的解释如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">The IPVS connection hash table uses the chaining scheme to handle</span><br><span class="line">hash collisions. Using a big IPVS connection hash table will greatly</span><br><span class="line">reduce conflicts when there are hundreds of thousands of connections</span><br><span class="line">in the hash table.</span><br><span class="line"></span><br><span class="line">Note the table size must be power of 2. The table size will be the</span><br><span class="line">value of 2 to the your input number power. The number to choose is</span><br><span class="line">from 8 to 20, the default number is 12, which means the table size</span><br><span class="line">is 4096. Don&apos;t input the number too small, otherwise you will lose</span><br><span class="line">performance on it. You can adapt the table size yourself, according</span><br><span class="line">to your virtual server application. It is good to set the table size</span><br><span class="line">not far less than the number of connections per second multiplying</span><br><span class="line">average lasting time of connection in the table.  For example, your</span><br><span class="line">virtual server gets 200 connections per second, the connection lasts</span><br><span class="line">for 200 seconds in average in the connection table, the table size</span><br><span class="line">should be not far less than 200x200, it is good to set the table</span><br><span class="line">size 32768 (2**15).</span><br><span class="line"></span><br><span class="line">Another note that each connection occupies 128 bytes effectively and</span><br><span class="line">each hash entry uses 8 bytes, so you can estimate how much memory is</span><br><span class="line">needed for your box.</span><br><span class="line"></span><br><span class="line">You can overwrite this number setting conn_tab_bits module parameter</span><br><span class="line">or by appending ip_vs.conn_tab_bits=? to the kernel command line</span><br><span class="line">if IP VS was compiled built-in.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><p>LVS的连接信息使用<code>IPVS connection hash table</code>这个哈希表去保存，它记录每个进来的连接及路由去向的信息 </p><blockquote><p>任何一个报文到达都需要查找连接Hash表。Hash表的查找复杂度为O(n/m)，其中n为Hash表中对象的个数，m为Hash表的桶个数。当对象在Hash表中均匀分布和Hash表的桶个数与对象个数一样多时，Hash表的查找复杂度可以接近O(1)。 </p></blockquote></li><li><p><code>table size</code>使用2的幂次方进行配置指定，范围为8-20，也就是说连接数的取值范围为：2^8-2^20</p></li><li><p>默认配置为2^12，也就是4096个连接数上限</p></li><li><p>在生产环境中，我们一般设置为最大值，也就是2^20（1048576）</p></li><li><p>注意，这些连接是需要占用内存的，因此要考虑到内存大小的因素</p><blockquote><p>每一个TCP连接需要占用约128字节，哈希表的每个条目需要占用8字节</p><p>以设置为最大值为例，那么，这些连接以及条目共占用内存如下：</p><p>2^20*(128byte+8byte) = 142606336byte = 136MB</p></blockquote></li></ul><p><strong>配置：</strong></p><p>在/etc/modprobe.d/目录下添加文件ip_vs.conf，内容为：</p><p>options ip_vs conn_tab_bits=20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;options ip_vs conn_tab_bits=22&apos; &gt; /etc/modprobe.d/ipvs.conf</span><br><span class="line">modprobe -r ip_vs &amp;&amp; modprobe -a ip_vs</span><br><span class="line">ipvsadm -Ln</span><br></pre></td></tr></table></figure><p>注意，在卸载内核模块的时候，可能会有依赖关系，这时候使用lsmod先查看依赖调用关系，将调用的模块卸载之后再进行操作，例如，这里的操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 modprobe.d]# modprobe -r ip_vs_rr</span><br><span class="line">[root@lvs001 modprobe.d]# modprobe -r ip_vs</span><br><span class="line">[root@lvs001 modprobe.d]# modprobe -a ip_vs</span><br><span class="line">[root@lvs001 modprobe.d]# modprobe -a ip_vs_rr</span><br></pre></td></tr></table></figure><h2 id="CPU-Soft-Interrupt-CPU软中断"><a href="#CPU-Soft-Interrupt-CPU软中断" class="headerlink" title="CPU Soft Interrupt -CPU软中断"></a>CPU Soft Interrupt -CPU软中断</h2><p>在Linux的网络调优方面，如果你发现网络流量上不去，那么有一个方面需要去查一下：<strong>网卡处理网络请求的中断是否被绑定/发送到单个CPU，导致只有一个CPU处于网络请求</strong></p><p>但是，在当前的对称多核处理器服务器上，一块网卡的IRQ还是只有一个CPU来响应，其它CPU无法参与，如果这个CPU还要忙其它的中断（其它网卡或者其它使用中断的外设（比如磁盘）），那么就会形成瓶颈。 </p><p><strong>动态查看CPU的irq情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令：mpstat -P ALL 1 </span><br><span class="line">%irq一列即说明了CPU忙于处理中断的时间占比</span><br></pre></td></tr></table></figure><p><strong>查看CPU处理中断的情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupts </span><br><span class="line">这里记录的是自启动以来，每个CPU处理各类中断的数量（第一列是中断号，最后一列是对应的设备名）</span><br></pre></td></tr></table></figure><p>我们进行过滤，获取网卡的中断号，然后再分析CPU的中断情况</p><p>获取对应的中断号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 ~]# cat /proc/interrupts  | egrep &apos;em1|em2|p1p1|p1p2&apos; | awk &apos;&#123;print $1&#125;&apos;</span><br><span class="line">157:</span><br><span class="line">158:</span><br><span class="line">159:</span><br><span class="line">160:</span><br><span class="line">161:</span><br><span class="line">162:</span><br><span class="line">163:</span><br><span class="line">164:</span><br><span class="line">165:</span><br><span class="line">166:</span><br><span class="line">167:</span><br><span class="line">168:</span><br><span class="line">169:</span><br><span class="line">170:</span><br><span class="line">171:</span><br><span class="line">172:</span><br><span class="line">173:</span><br><span class="line">174:</span><br><span class="line">175:</span><br><span class="line">176:</span><br></pre></td></tr></table></figure><p>获取CPU的处理信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 ~]# for i in &#123;157..176&#125;;do cat /proc/interrupts  | egrep -w $i ;done</span><br><span class="line"> 157:   13529132          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-tx-0</span><br><span class="line"> 158:   32642550          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-1</span><br><span class="line"> 159:   30481981          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-2</span><br><span class="line"> 160:   15555217          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-3</span><br><span class="line"> 161:   25509530          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em1-rx-4</span><br><span class="line"> 162:   13538297          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-tx-0</span><br><span class="line"> 163:   25653580          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-1</span><br><span class="line"> 164:   25741710          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-2</span><br><span class="line"> 165:   35448970          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-3</span><br><span class="line"> 166:   25494937          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      em2-rx-4</span><br><span class="line"> 167:     256824          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-tx-0</span><br><span class="line"> 168:     281534          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-1</span><br><span class="line"> CAL:        133     863797        189        189        189        189        188        189        189        189        189        189        189        189        189        189        188        188        168        185        188        186        188        188        188        188        188        188        188        189        187        130   Function call interrupts</span><br><span class="line"> 169:      64639          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-2</span><br><span class="line"> 170:      65879          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-3</span><br><span class="line"> 171:     425700          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p1-rx-4</span><br><span class="line"> 172:     256754          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-tx-0</span><br><span class="line"> 173:      43230          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-1</span><br><span class="line"> 174:          4          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-2</span><br><span class="line"> 175:          5          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-3</span><br><span class="line"> 176:          3          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      p1p2-rx-4</span><br><span class="line">[root@lvs001 ~]#</span><br></pre></td></tr></table></figure><p>这里显示不友好，建议复制到编辑器中查看</p><p>可以看到，这些网卡的中断都是由CPU0来处理的</p><p><strong>查看</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs002 ~]# for i in &#123;157..176&#125;;do cat /proc/irq/$i/smp_affinity;done</span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;157..176&#125;;do echo ffffffff &gt; /proc/irq/$i/smp_affinity;done</span><br></pre></td></tr></table></figure><h2 id="Netfilter-Connection-Track-连接跟踪"><a href="#Netfilter-Connection-Track-连接跟踪" class="headerlink" title="Netfilter Connection Track-连接跟踪"></a>Netfilter Connection Track-连接跟踪</h2><p><strong>原文：</strong></p><p><a href="http://kb.linuxvirtualserver.org/wiki/IPVS" target="_blank" rel="noopener">IPVS</a> uses its own simple and fast connection tracking for performance reasons, instead of using netfilter connection tracking. So, if you don’t use firewalling feature at <a href="http://kb.linuxvirtualserver.org/wiki/Load_balancer" target="_blank" rel="noopener">load balancer</a> and you need an extremely fast load balancer, do not load netfilter conntrack modules into you system, because there is no need to do double tracking. Note that <a href="http://kb.linuxvirtualserver.org/wiki/LVS/NAT" target="_blank" rel="noopener">LVS/NAT</a> should work too without the conntrack modules.</p><p>Julian compared the performance of IPVS with ip_conntrack and without ip_conntrack. See <a href="http://archive.linuxvirtualserver.org/html/lvs-users/2001-12/msg00141.html" target="_blank" rel="noopener">http://archive.linuxvirtualserver.org/html/lvs-users/2001-12/msg00141.html</a></p><p>默认情况下LVS自身会记录连接信息，但是 iptables 也会记录 connection 的状态，但是很多情况下，我们并不需要 iptables 来做这件事，</p><p>我们可以告诉它 NOTRACK，不要记录这些信息。</p><p><strong>配置：</strong></p><p>增加raw表，在其他表处理之前，-j NOTRACK跳过其它表处理 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -t raw -A PREROUTING -d 103.13.244.16/29 -p tcp --dport 80 -j NOTRACK </span><br><span class="line">iptables -t raw -A OUTPUT -d 103.13.244.16/29 -p tcp --dport 80 -j NOTRACK </span><br><span class="line">iptables -t raw -A PREROUTING -d 103.13.244.16/29 -p tcp --dport 443 -j NOTRACK </span><br><span class="line">iptables -t raw -A OUTPUT -d 103.13.244.16/29 -p tcp --dport 443 -j NOTRACK </span><br><span class="line"></span><br><span class="line">[root@lvs002 ~]# /etc/init.d/iptables  save</span><br></pre></td></tr></table></figure><p>与之同时，因为涉及到内网之间的通信，因此这里也将连接跟踪表进行调大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">net.netfilter.nf_conntrack_max = 3065536 </span><br><span class="line">net.nf_conntrack_max = 3065536 </span><br><span class="line"></span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure><h2 id="Real-Server-syn-cookie参数"><a href="#Real-Server-syn-cookie参数" class="headerlink" title="Real Server - syn cookie参数"></a>Real Server - syn cookie参数</h2><p>参考链接：</p><ul><li><a href="https://link.zhihu.com/?target=http%3A//archive.linuxvirtualserver.org/html/lvs-users/2013-05/msg00020.html" target="_blank" rel="noopener">lvs-users IPVS SYN-cookies</a>  </li></ul><p>SYN Cookie是对TCP服务器端的<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">三次握手协议</a>作一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP ACK包时，TCP服务器在根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。 </p><p>SYN Flood攻击利用的是IPv4中TCP协议的<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" target="_blank" rel="noopener">三次握手</a>（Three-Way Handshake）过程进行的攻击。TCP协议规定，一端向另一端发起TCP连接时，它需要首先发送SYN 包到对方，对方收到后发送一个SYN+ACK包回来，发起方再发送 ACK包回去，这样<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" target="_blank" rel="noopener">三次握手</a>就结束了。我们把TCP连接的发起方叫作”TCP客户机（TCP Client）”，TCP连接的接收方叫作”TCP服务器（TCP Server）”。值得注意的是在TCP服务器收到TCP SYN request包时，在发送TCP SYN+ACK包回TCP客户机前，TCP服务器要先分配好一个数据区专门服务于这个即将形成的TCP连接。一般把收到SYN包而还未收到ACK包时的连接状态称为半开连接（Half-open Connection）。</p><p>在最常见的SYN Flood攻击中，攻击者在短时间内发送大量的TCP SYN包给受害者，这时攻击者是TCP客户机，受害者是TCP服务器。根据上面的描述，受害者会为每个TCP SYN包分配一个特定的数据区，只要这些SYN包具有不同的源地址（这一点对于攻击者来说是很容易伪造的）。这将给TCP<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">服务器系统</a>造成很大的系统负担，最终导致系统不能正常工作。</p><p><a href="https://github.com/torvalds/linux/blob/6b15d6650c5301ce023d8df0cc3a60b1a76d377e/Documentation/networking/ip-sysctl.txt#L66" target="_blank" rel="noopener">内核文档说明</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">tcp_syncookies - BOOLEAN</span><br><span class="line">Only valid when the kernel was compiled with CONFIG_SYN_COOKIES</span><br><span class="line">Send out syncookies when the syn backlog queue of a socket</span><br><span class="line">overflows. This is to prevent against the common &apos;SYN flood attack&apos;</span><br><span class="line">Default: 1</span><br><span class="line"></span><br><span class="line">Note, that syncookies is fallback facility.</span><br><span class="line">It MUST NOT be used to help highly loaded servers to stand</span><br><span class="line">against legal connection rate. If you see SYN flood warnings</span><br><span class="line">in your logs, but investigationshows that they occur</span><br><span class="line">because of overload with legal connections, you should tune</span><br><span class="line">another parameters until this warning disappear.</span><br><span class="line">See: tcp_max_syn_backlog, tcp_synack_retries, tcp_abort_on_overflow.</span><br><span class="line"></span><br><span class="line">syncookies seriously violate TCP protocol, do not allow</span><br><span class="line">to use TCP extensions, can result in serious degradation</span><br><span class="line">of some services (f.e. SMTP relaying), visible not by you,</span><br><span class="line">but your clients and relays, contacting you. While you see</span><br><span class="line">SYN flood warnings in logs not being really flooded, your server</span><br><span class="line">is seriously misconfigured.</span><br><span class="line"></span><br><span class="line">If you want to test which effects syncookies have to your</span><br><span class="line">network connections you can set this knob to 2 to enable</span><br><span class="line">unconditionally generation of syncookies.</span><br></pre></td></tr></table></figure><p>注意，即使开启该机制并不意味着所有的连接都是用SYN cookies机制来完成连接的建立，只有在半连接队列已满的情况下才会触发SYN cookies机制。由于SYN cookies机制严重违背TCP协议，不允许使用TCP扩展，可能对某些服务造成严重的性能影响（如SMTP转发），对于防御SYN flood攻击的确有效。对于没有收到攻击的高负载服务器，不要开启此选项，可以通过修改tcp_max_syn_backlog、tcp_synack_retries和tcp_abort_on_overflow系统参数来调节。</p><p>tcp_max_syn_backlog变量告诉你在内存中可以缓存多少个SYN请求。该变量需要打开tcp_syncookies才有效。如果服务器负载很高，可以尝试提高该变量的值。</p><p>tcp_synack_retries变量用于TCP三次握手机制中第二次握手，当收到客户端发来的SYN连接请求后，服务端将回复SYN+ACK包，这时服务端处于SYN_RCVD状态，并等 待客户端发来的回复ACK包。如果服务端没有收到客户端的ACK包，会重新发送SYN+ACK包，直到收到客户端的ACK包。该变量设置发送 SYN+ACK包的次数，超过这个次数，服务端将放弃连接。默认值是5。</p><p>tcp_abort_on_overflow变量的值是个布尔值，默认值为0（FALSE关闭）。如果开启，当服务端接收新连接的速度变慢时，服务端会发送RST包（reset包）给客户端，令客户端 重新连接。这意味着如果突然发生溢出，将重获连接。仅当你真的确定不能通过调整监听进程使接收连接的速度变快，可以启用该选项。该选项会影响到客户的连接。</p><p><strong>配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sysctl.conf </span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 2048</span><br><span class="line">保存退出后，执行：</span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><p>net.ipv4.tcp_syncookies = 1<br>#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN<em>*</em>，默认为0，表示关闭；</p><p>net.ipv4.tcp_tw_reuse = 1<br>#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；为1，开启；</p><p>这个酌情开启，这里暂时不开启</p><p>net.ipv4.tcp_tw_recycle = 1<br>#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；为1，开启；</p><p>net.ipv4.tcp_fin_timeout</p><p>#修改系統默认的 TIMEOUT 时间，<strong>这里根据服务器的实际情况设置</strong>。默认为60秒</p><p>  另外细心的朋友可能发现了，报错信息： Possible SYN flooding on port 13370. Sending cookies.后面跟了句”Check SNMP counters”。这句我当时差点被误导，因为我的服务器上正好跑了一个snmp抓流量的服务，开始以为是它导致的，后来一想那是udp的协议，和tcp没关系呀。查了<a href="https://github.com/torvalds/linux/blob/797cee982eef9195736afc5e7f3b8f613c41d19a/net/ipv4/tcp_input.c" target="_blank" rel="noopener">kernel</a>的代码发现，原来那是print打印的固定info输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static bool tcp_syn_flood_action(const struct sock *sk,</span><br><span class="line">                const struct sk_buff *skb,</span><br><span class="line">                const char *proto)</span><br><span class="line">&#123;</span><br><span class="line">    struct request_sock_queue *queue = &amp;inet_csk(sk)-&gt;icsk_accept_queue;</span><br><span class="line">    const char *msg = &quot;Dropping request&quot;;</span><br><span class="line">    bool want_cookie = false;</span><br><span class="line">    struct net *net = sock_net(sk);</span><br><span class="line">#ifdef CONFIG_SYN_COOKIES</span><br><span class="line">    if (net-&gt;ipv4.sysctl_tcp_syncookies) &#123;</span><br><span class="line">        msg = &quot;Sending cookies&quot;;</span><br><span class="line">        want_cookie = true;</span><br><span class="line">        __NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPREQQFULLDOCOOKIES);</span><br><span class="line">    &#125; else</span><br><span class="line">#endif</span><br><span class="line">        __NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPREQQFULLDROP);</span><br><span class="line">    if (!queue-&gt;synflood_warned &amp;&amp;</span><br><span class="line">    net-&gt;ipv4.sysctl_tcp_syncookies != 2 &amp;&amp;</span><br><span class="line">    xchg(&amp;queue-&gt;synflood_warned, 1) == 0)</span><br><span class="line">        pr_info(&quot;%s: Possible SYN flooding on port %d. %s.  Check SNMP counters.\n&quot;,</span><br><span class="line">            proto, ntohs(tcp_hdr(skb)-&gt;dest), msg);</span><br><span class="line">    return want_cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭网卡LRO和GRO"><a href="#关闭网卡LRO和GRO" class="headerlink" title="关闭网卡LRO和GRO"></a>关闭网卡LRO和GRO</h2><p>现在大多数网卡都具有LRO/GRO功能，即 网卡收包时将同一流的小包合并成大包 （tcpdump抓包可以看到&gt;MTU 1500bytes的数据包）交给 内核协议栈；LVS内核模块在处理&gt;MTU的数据包时，会丢弃；</p><p>因此，如果我们用LVS来传输大文件，很容易出现丢包，传输速度慢；</p><p>解决方法，关闭LRO/GRO功能，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ethtool -k eth0 查看LRO/GRO当前是否打开</span><br><span class="line">ethtool -K eth0 lro off 关闭GRO</span><br><span class="line">ethtool -K eth0 gro off 关闭GRO</span><br><span class="line"></span><br><span class="line">查看：</span><br><span class="line">[root@lvs001 ~]# ethtool -k p1p1 | grep offload</span><br><span class="line">[root@lvs001 ~]# ethtool -k p1p2 | grep offload</span><br><span class="line"></span><br><span class="line">配置：</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p1 lro off</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p1 gro off</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p2 lro off</span><br><span class="line">[root@lvs001 ~]# ethtool -K p1p2 gro off</span><br></pre></td></tr></table></figure><p>offload特性，主要是指将原本在协议栈中进行的IP分片、TCP分段、重组、checksum校验等操作，转移到网卡硬件中进行，降低系统CPU的消耗，提高处理性能。 </p><p>包括 LSO/LRO、GSO/GRO、TSO/UFO 等。</p><p><strong>LSO/LRO</strong></p><p>分别对应到发送和接收两个方向，是 Large Segment Offload 和 Large Receive Offload。</p><p>首先来看 LSO。我们知道计算机网络上传输的数据基本单位是离散的网包，既然是网包，就有大小限制，这个限制就是 MTU（Maximum Transmission Unit）的大小，一般是1518字节。比如我们想发送很多数据出去，经过os协议栈的时候，会自动帮你拆分成几个不超过MTU的网包。然而，这个拆分是比较费计算资源的（比如很多时候还要计算分别的checksum），由 CPU 来做的话，往往会造成使用率过高。那可不可以把这些简单重复的操作 offload 到网卡上呢？</p><p>于是就有了 LSO，在发送数据超过 MTU 限制的时候（太容易发生了），OS 只需要提交一次传输请求给网卡，网卡会自动的把数据拿过来，然后进行切，并封包发出，发出的网包不超过 MTU 限制。</p><p>接下来看 LSO，当网卡收到很多碎片包的时候，LRO 可以辅助自动组合成一段较大的数据，一次性提交给 OS处理。</p><p>一般的，LSO 和 LRO 主要面向 TCP 报文。</p><p><strong>GSO/GRO</strong></p><p>Generic Segmentation Offload 和 Generic Receive Offload，分别比 LSO 和 LRO 更通用，自动检测网卡支持特性，支持分包则直接发给网卡，否则先分包后发给网卡。新的驱动一般用 GSO/GRO。 </p><p><strong>TSO/UFO</strong></p><p>TCP Segmentation Offload 和 UDP fragmentation offload，分别对应 TCP 报文和 UDP 报文。</p><p>很典型的，TCP 协议中就考虑了分片存在的情况，往往是切分 TCP 的数据包，叫做 TSO。而一般的情况，则称为 LSO 或者 GSO。</p><p>对于其他不支持切片的协议例如 UDP，则只能进行 IP 层上的切片。</p><p><strong>检查与开关</strong></p><p>可以通过 <code>ethtool -k eth0</code> 命令来查看各个选项的当前状态，注意输出中各种 off-load 选项的状态。 </p><p><strong>总结</strong></p><p>也就是说，在将数据包转发出去的时候，包的大小必须小于1500字节，但是在处理收到的数据包的时候，包的大小没有1500字节的限制</p><ul><li>发送模式：<ul><li>TSO</li><li>GSO</li><li>UFO</li></ul></li><li>接收模式：<ul><li>LRO</li><li>GRO</li><li>RSS</li></ul></li></ul><p><strong>注意</strong></p><p>目前常用的抓包工具大部分都是从协议栈中（如数据链路层）捕获数据包，而网卡的offload特性会将数据包的分片、重组等工作转移到协议栈以下的硬件层面进行，因此在开启TSO、GRO等机制的情况下，我们使用tcpdump、wireshark等工具抓取到的数据包往往不能真实反应链路上实际的数据帧，给网络流量特征的分析造成不利影响。</p><p>在某些情况下，例如分片攻击等攻击方式，甚至可能会因为网卡设备的offload机制处理，而规避防火墙、IDS以及人工的检查。针对这些情况，可以选择关闭网卡offload的相关选项，或者在链路的其他节点进行抓包。</p><h2 id="proc下的IP-VS参数设置"><a href="#proc下的IP-VS参数设置" class="headerlink" title="/proc下的IP_VS参数设置"></a>/proc下的IP_VS参数设置</h2><p>根据前文的介绍，可以通过ipvsadm命令和LVS内核打交道；</p><p>除此之外，我们还可以通过proc参数，来 配置全局参数 和 获取统计信息；</p><ul><li>配置全局参数，位于目录/proc/sys/net/ipv4/vs/下；</li><li>获取统计信息，位于目录/proc/net/下；</li></ul><p>参考资料：<a href="https://github.com/torvalds/linux/blob/master/Documentation/networking/ipvs-sysctl.txt#L41" target="_blank" rel="noopener">官方内核文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs001 ~]# ll /proc/sys/net/ipv4/vs | awk &apos;&#123;print $9&#125;&apos;</span><br><span class="line">am_droprate</span><br><span class="line">amemthresh</span><br><span class="line">cache_bypass</span><br><span class="line">conn_reuse_mode</span><br><span class="line">drop_entry</span><br><span class="line">drop_packet</span><br><span class="line">expire_nodest_conn</span><br><span class="line">expire_quiescent_template</span><br><span class="line">nat_icmp_send</span><br><span class="line">secure_tcp</span><br><span class="line">sync_qlen_max</span><br><span class="line">sync_refresh_period</span><br><span class="line">sync_retries</span><br><span class="line">sync_sock_size</span><br><span class="line">sync_threshold</span><br><span class="line">sync_version</span><br></pre></td></tr></table></figure><p>有一些几个参数需要进行调整</p><ul><li><p>cache_bypass </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cache_bypass - BOOLEAN</span><br><span class="line">        0 - disabled (default)</span><br><span class="line">        not 0 - enabled</span><br><span class="line"></span><br><span class="line">        If it is enabled, forward packets to the original destination</span><br><span class="line">        directly when no cache server is available and destination</span><br><span class="line">        address is not local (iph-&gt;daddr is RTN_UNICAST). It is mostly</span><br><span class="line">        used in transparent web cache cluster.</span><br></pre></td></tr></table></figure><p>主要用于缓存体系，enable之后，当后端配置的是缓存系统的时候，当没有可用的sever时，直接将数据包转发给后端的数据产生节点</p></li></ul><ul><li><p>conn_reuse_mode </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">conn_reuse_mode - INTEGER</span><br><span class="line">1 - default</span><br><span class="line"></span><br><span class="line">Controls how ipvs will deal with connections that are detected</span><br><span class="line">port reuse. It is a bitmap, with the values being:</span><br><span class="line"></span><br><span class="line">0: disable any special handling on port reuse. The new</span><br><span class="line">connection will be delivered to the same real server that was</span><br><span class="line">servicing the previous connection. This will effectively</span><br><span class="line">disable expire_nodest_conn.</span><br><span class="line"></span><br><span class="line">bit 1: enable rescheduling of new connections when it is safe.</span><br><span class="line">That is, whenever expire_nodest_conn and for TCP sockets, when</span><br><span class="line">the connection is in TIME_WAIT state (which is only possible if</span><br><span class="line">you use NAT mode).</span><br><span class="line"></span><br><span class="line">bit 2: it is bit 1 plus, for TCP connections, when connections</span><br><span class="line">are in FIN_WAIT state, as this is the last state seen by load</span><br><span class="line">balancer in Direct Routing mode. This bit helps on adding new</span><br><span class="line">real servers to a very busy cluster.</span><br></pre></td></tr></table></figure><p>用户后端server开启端口reuse（端口复用，服务器上启动多个进程监听同一个端口，在tenginx中使用时能够极大的提高性能）的情况。</p><p>当设置enable的时候，接受到新连接之后，将进行重新调度，将连接请求分发到启动该端口的其他进程上</p></li></ul><ul><li><p>expire_nodest_conn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">expire_nodest_conn - BOOLEAN</span><br><span class="line">        0 - disabled (default)</span><br><span class="line">        not 0 - enabled</span><br><span class="line"></span><br><span class="line">        The default value is 0, the load balancer will silently drop</span><br><span class="line">        packets when its destination server is not available. It may</span><br><span class="line">        be useful, when user-space monitoring program deletes the</span><br><span class="line">        destination server (because of server overload or wrong</span><br><span class="line">        detection) and add back the server later, and the connections</span><br><span class="line">        to the server can continue.</span><br><span class="line"></span><br><span class="line">        If this feature is enabled, the load balancer will expire the</span><br><span class="line">        connection immediately when a packet arrives and its</span><br><span class="line">        destination server is not available, then the client program</span><br><span class="line">        will be notified that the connection is closed. This is</span><br><span class="line">        equivalent to the feature some people requires to flush</span><br><span class="line">        connections when its destination is not available.</span><br></pre></td></tr></table></figure><p>设置为0时，当后端的server被检测为不可用时，不会立即将连接断开，而是会保持一段时间，让其自然过期失效，如果在这个过程当中，server又恢复正常，那么将继续使用这个连接</p><p>当设置为为enable（非0）时，当检测到后端的server不可用时，将会立即将这个连接关闭。</p></li></ul><ul><li><p>expire_quiescent_template </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">expire_quiescent_template - BOOLEAN</span><br><span class="line">0 - disabled (default)</span><br><span class="line">not 0 - enabled</span><br><span class="line"></span><br><span class="line">When set to a non-zero value, the load balancer will expire</span><br><span class="line">persistent templates when the destination server is quiescent.</span><br><span class="line">This may be useful, when a user makes a destination server</span><br><span class="line">quiescent by setting its weight to 0 and it is desired that</span><br><span class="line">subsequent otherwise persistent connections are sent to a</span><br><span class="line">different destination server.  By default new persistent</span><br><span class="line">connections are allowed to quiescent destination servers.</span><br><span class="line"></span><br><span class="line">If this feature is enabled, the load balancer will expire the</span><br><span class="line">persistence template if it is to be used to schedule a new</span><br><span class="line">connection and the destination server is quiescent.</span><br></pre></td></tr></table></figure></li></ul><p>  默认值为0，当RS的weight为0时（例如健康监测失败时，LB会将RS的权重重置为0），会话保持的新建连接还会继续调度到该RS上</p><p>  如果设置为非0，那么当weight为0时，LB会将话保持的连接模板置为无效，重新调度新的RS； </p><ul><li><p>sync_threshold</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sync_threshold - vector of 2 INTEGERs: sync_threshold, sync_period</span><br><span class="line">default 3 50</span><br><span class="line"></span><br><span class="line">It sets synchronization threshold, which is the minimum number</span><br><span class="line">of incoming packets that a connection needs to receive before</span><br><span class="line">the connection will be synchronized. A connection will be</span><br><span class="line">synchronized, every time the number of its incoming packets</span><br><span class="line">modulus sync_period equals the threshold. The range of the</span><br><span class="line">threshold is from 0 to sync_period.</span><br><span class="line"></span><br><span class="line">When sync_period and sync_refresh_period are 0, send sync only</span><br><span class="line">for state changes or only once when pkts matches sync_threshold</span><br></pre></td></tr></table></figure><p> 同步阈值设置，该文件中的值为两个整数，默认为3 50 </p><p>数值表示含义如下（以3 50为例）：接受到3个数据包及以上，该连接就可以被同步</p></li></ul><h2 id="Linux系统调优-网络内核参数"><a href="#Linux系统调优-网络内核参数" class="headerlink" title="Linux系统调优-网络内核参数"></a>Linux系统调优-网络内核参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_recyle=1</span><br><span class="line">net.ipv4.tcp_tw_reuse=1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=8192</span><br><span class="line">net.ipv4.tcp_keepalive_time=1800</span><br><span class="line">net.ipv4.tcp_fin_timeout=30</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.ipv4.tcp_rmem=4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem=4096 65536 16777216</span><br><span class="line">net.core.netdev_max_backlog=3000</span><br></pre></td></tr></table></figure><h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><p><strong>SH调度算法</strong>-<strong>尽量不要采用</strong>  </p><p>一些业务为了支持会话保持，选择SH调度算法，以实现 同一源ip的请求调度到同一台RS上；但 SH算法本省没有实现一致性hash，一旦一台RS down，当前所有连接都会断掉；如果配置了inhibit_on_failure，那就更悲剧了，调度到该RS上的流量会一直损失；     实际线上使用时，如需<strong>会话保持</strong>，建议配置<strong>persistence_timeout参数，</strong>保证一段时间同一源ip的请求到同一RS上； </p><p><strong>WLC调度算法-注意RS donw-&gt;up的影响</strong>    </p><p>WLC算法下，RS一旦出现down后up的情况，瞬间所有的新建连接都会调度到该RS上，可能会超过该RS处理请求的上限；  </p><h2 id="快速配置"><a href="#快速配置" class="headerlink" title="快速配置"></a>快速配置</h2><p>[root@lvs002 ~]# vim /etc/sysctl.conf </p><p>[root@lvs002 ~]# sysctl  -p</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">kernel.sysrq = 0</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line">net.core.netdev_max_backlog = 2048</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 462144</span><br><span class="line">vm.swappiness = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 65535</span><br><span class="line">net.core.somaxconn = 32768</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.netfilter.nf_conntrack_max = 3065536</span><br><span class="line">net.nf_conntrack_max = 3065536</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1800</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 16777216</span><br><span class="line">net.core.netdev_max_backlog = 3000</span><br></pre></td></tr></table></figure><h1 id="LVS监控"><a href="#LVS监控" class="headerlink" title="LVS监控"></a>LVS监控</h1><p>一般情况下，我们可以通过watch ipvsadm -ln来监视lvs的当前状态，但如果我们想分析一段时间（一周，一月或者更长）的连接数情况，ipvsadm就无能为力了。我们可以借助一个叫lvs-rrd的小工具来达到这个目的。</p><p>lvs-rrd官网链接：<a href="http://tepedino.org/lvs-rrd/" target="_blank" rel="noopener">http://tepedino.org/lvs-rrd/</a></p><p>但是在这里，由于这个工具只能收集连接数的数据，因此我们还是采用zabbix进行集中监控</p><h2 id="使用lvs-rrd监控lvs状态"><a href="#使用lvs-rrd监控lvs状态" class="headerlink" title="使用lvs-rrd监控lvs状态"></a>使用lvs-rrd监控lvs状态</h2><p><a href="http://www.tepedino.org/lvs-rrd/" target="_blank" rel="noopener">lvs_rrd</a>工具实现了网页的形式来查看lvs状态功能。</p><p>其主要有两个脚本组成：信息收集脚本和图像绘制脚本。</p><p>信息收集脚本是将lvs的信息生成rrd格式的数据文件，然后利用图像绘制脚本生成图像，并生成一个php页面，这个页面中引用其所生成的图像，这样我们可以通过web页面的形式查看生成的php页面，就可以时时的查看lvs的状态信息。</p><p>lvs_rrd需要部署在LVS-Master和LVS-Backup上，更准确的说lvs_rrd中的信息收集脚本一定要在LVS director 上运行（不能安装在其他服务器上）。</p><p>但是通过配置图像生成脚本和图像的生成目录，我们也可以将源数据时时的复制到其他的服务器中，再在其他服务器上生成图像展示</p><p>下面简单的介绍部署的步骤</p><p><strong>下载安装rrdtool（画图）工具</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://oss.oetiker.ch/rrdtool/pub/rrdtool-1.4.7.tar.gz</span><br><span class="line"></span><br><span class="line">yum -y install cairo-devel libxml2-devel pango-devel pango libpng-devel freetype freetype-devel libart_lgpl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker dejavu-lgc-sans-fonts</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/rrdtool</span><br><span class="line">make &amp;&amp;  make install </span><br><span class="line"></span><br><span class="line">echo &quot;/usr/local/rrdtool/lib&quot; &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><p><strong>安装nginx</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre pcre-devel php php-fpm</span><br><span class="line"></span><br><span class="line">useradd -s /sbin/nologin nginx</span><br><span class="line"></span><br><span class="line">wget https://nginx.org/download/nginx-1.14.0.tar.gz</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module --with-pcre</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>注意修改nginx的监听端口为非80</p><p><strong>nginx+php配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/php-fpm start</span><br><span class="line">chkconfig php-fpm on</span><br></pre></td></tr></table></figure><p>在nginx配置文件中添加以下内容</p><pre><code>location ~ \.php$ {    root           html;    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;    include        fastcgi_params;}</code></pre><p><strong>下载安装lvs-rrd工具</strong></p><p>这里使用最新的0.7版本，该版本要求rrdtool版本最低为： 1.2.x </p><p>将lvs-rrd-v0.7.tar.gz解压后将文件夹复制到/data/www/目录下并更名为lvs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://tepedino.org/lvs-rrd/lvs-rrd-v0.7.tar.gz</span><br><span class="line">tar -zxvf lvs-rrd-v0.7.tar.gz</span><br><span class="line"></span><br><span class="line">mv lvs-rrd-v0.7 /usr/local/nginx/html/lvs-rrd</span><br></pre></td></tr></table></figure><p>修改相应的脚本文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim lvs.rrd.update 修改以下内容</span><br><span class="line"></span><br><span class="line">RRDTOOL=&quot;/usr/local/rrdtool/bin/rrdtool&quot;#rrdtool可执行程序路径</span><br><span class="line">IPVSADM=&quot;/sbin/ipvsadm&quot;   #ipvsadm命令路径</span><br><span class="line">WORKDIR=&quot;/data1/lvs-rrd&quot;   #rrdtool收集的数据的存放路径</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim graph-lvs.sh 修改以下内容</span><br><span class="line"></span><br><span class="line"># WORKDIR must match the directory used in the update script.</span><br><span class="line">WORKDIR=&quot;/data1/lvs-rrd&quot;#rrdtool收集的数据的存放路径,同上面一致</span><br><span class="line">RRDTOOL=&quot;/usr/local/rrdtool/bin/rrdtool&quot;  #rrdtool可执行程序路径</span><br><span class="line"># Where to put the graphs. </span><br><span class="line">GRAPHS=&quot;/data1/lvs-rrd/graphs&quot;#生成的图片保存路径</span><br><span class="line">WEBPATH=&quot;/lvs-rrd/graphs&quot;#web访问的路径</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim lvs-rrd.php</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">header(&quot;Cache-Control: max-age=300, must-revalidate&quot;);</span><br><span class="line">system(&quot;/usr/local/nginx/html/lvs-rrd/graph-lvs.sh -H&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注意：WEBPATH的配置是浏览器实际访问时图片的访问路径，也就是<a href="http://ip:port/webpath/xxx.gif" target="_blank" rel="noopener">http://ip:port/webpath/xxx.gif</a></p><p>在日志中的输出显示为：</p><p>/usr/local/nginx/html/lvs-rrd/graphs/lvs.All.All.All.All.All-year.gif</p><p>因此需要手动在站点目录下创建该目录并创建软链接，将<code>生成的图片保存路径</code>链接到该目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/nginx/html/lvs-rrd/graphs</span><br><span class="line">ln -s /data1/lvs-rrd/graphs /usr/local/nginx/html/lvs-rrd/graphs</span><br></pre></td></tr></table></figure><p><strong>配置nginx认证</strong></p><p>在nginx配置文件的server中配置如下两行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth_basic              &quot;dwd&quot;;</span><br><span class="line">auth_basic_user_file    htpasswd;</span><br></pre></td></tr></table></figure><p>然后执行以下命令创建加密文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -bc htpasswd  ops-lvs Dwd_Ops_123</span><br></pre></td></tr></table></figure><p><strong>配置计划任务</strong></p><p>这里，将更新数据的间隔时间设置为30s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /usr/local/nginx/html/lvs-rrd/lvs.rrd.update &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * /usr/local/nginx/html/lvs-rrd/graph-lvs.sh -H &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * sleep 30 ; /usr/local/nginx/html/lvs-rrd/lvs.rrd.update &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">* * * * * sleep 30 ; /usr/local/nginx/html/lvs-rrd/graph-lvs.sh -H &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="Zabbix监控LVS"><a href="#Zabbix监控LVS" class="headerlink" title="Zabbix监控LVS"></a>Zabbix监控LVS</h2><p><strong>监控指标：</strong></p><ul><li>vs的每秒会话连接数</li><li>lvs的每秒包转发数</li><li>lvs每秒转发带宽</li></ul><p>动态的数据：</p><ul><li>cps(connect per second) ，每秒的连接数情况</li><li>InPPS(input packge per second)，每秒的入向数据包数量情况</li><li>OutPPS(output packge per second)，每秒的出向数据包数量情况</li><li>InBPS（input byte per second）,每秒的流入字节数情况</li><li>OutBPS(output byte per second)，每秒的流出字节数情况</li><li>ActiveConn，处于ESAT的连接（使用系统的netstat无法看到）</li><li>InActConn，处于非ESAT的连接（使用系统的netstat无法看到）</li></ul><p>静态统计数据：</p><ul><li>Conns，自启动之后的总连接数</li><li>InPkts，自启动之后的总入向数据包数量统计</li><li>OutPkts，自启动之后的总出向数据包数量统计</li><li>InBytes，自启动之后的总入向字节数统计</li><li>OutBytes，自启动之后的总出向字节数统计</li></ul><p><strong>监控逻辑：</strong></p><p>使用ipvsadm命令从服务器中采集数据</p><p>key:</p><p>lvs_103.13.244.19_80_10.11.0.13_ActiveConn</p><p>lvs_103.13.244.19_80_10.11.0.14_ActiveConn</p><p>lvs_103.13.244.19_443_InActConn</p><p>脚本名称：lvs_ActiveConn</p><p>在sudo中配置zabbix用户对ipvsadm命令的权限</p>]]></content>
    
    <summary type="html">
    
      LVS性能指标及监控
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="高并发" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="LVS" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/LVS/"/>
    
    
      <category term="LVS" scheme="http://yoursite.com/tags/LVS/"/>
    
  </entry>
  
  <entry>
    <title>Keepalived从入门到实践</title>
    <link href="http://yoursite.com/2018/07/10/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%8F%AF%E7%94%A8/keepalived/Keepalived%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/07/10/IT科学技术知识体系结构-Linux运维方向/高可用/keepalived/Keepalived从入门到实践/</id>
    <published>2018-07-10T08:07:06.000Z</published>
    <updated>2018-07-10T08:07:06.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="tag1" scheme="http://yoursite.com/tags/tag1/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix从入门到实践</title>
    <link href="http://yoursite.com/2018/07/09/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB/zabbix/Zabbix%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/07/09/IT科学技术知识体系结构-Linux运维方向/运维监控体系/zabbix/Zabbix从入门到实践/</id>
    <published>2018-07-09T02:40:36.000Z</published>
    <updated>2018-07-09T02:40:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重点章节内容"><a href="#重点章节内容" class="headerlink" title="重点章节内容"></a>重点章节内容</h1><p>第一部分重点内容</p><p><strong>第1章</strong></p><ul><li>1.1 为何需要监控系统</li><li>1.2 实现</li><li>1.4 原理探究</li></ul><p><strong>第2章</strong></p><ul><li>2.5 zabbix的架构</li><li>2.6 运行流程</li></ul><p><strong>第3章</strong></p><ul><li>3.1 安装环境概述</li><li>3.7 zabbix-get的使用</li><li>3.8 zabbix相关术语</li><li>3.9  zabbix-server对数据的存储</li></ul><p><strong>第4章</strong></p><ul><li>4.1 配置流程</li><li>4.3 模板的添加<ul><li>主要关注宏的相关设置</li><li>设置了宏之后，在不同的主机对该宏设置不同的变量值，就可以达到模板化通用的目的</li></ul></li><li>4.5 graphs的配置<ul><li>了解各配置参数</li></ul></li><li>4.6 聚合图形-screen的配置</li><li>4.9 MAP的配置</li><li>4.10 web监控</li><li>4.11 IT服务</li><li>4.12 报表</li></ul><p><strong>第5章-深入配置使用</strong></p><ul><li>监控项的各配置参数</li><li>==第5章需要精通==</li></ul><p><strong>第6章-告警设置</strong></p><ul><li>==第6章需要精通==</li></ul><hr><h1 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h1><h2 id="图形配置参数对应"><a href="#图形配置参数对应" class="headerlink" title="图形配置参数对应"></a>图形配置参数对应</h2><h1 id="screen-聚合图形"><a href="#screen-聚合图形" class="headerlink" title="screen-聚合图形"></a>screen-聚合图形</h1><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>监控项、图形、触发器、web、discovery等都是存在于主机之上的，由于多个主机都会使用相同的监控配置，因此，可以对这部分同类的数据进行归纳抽象，将这些数据做成模板。</p><p>当我们需要对其他监控数据进行配置的时候，只需要对相应的主机添加对应的模板即可。</p><h2 id="模板创建"><a href="#模板创建" class="headerlink" title="模板创建"></a>模板创建</h2><h2 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h2><p>可以在模板中引用另外一个模板</p><p>注意，一般我们不会使用这个功能，因为如果引用的模板发生了改变，那么就会影响当前模板的状态。</p><h2 id="模板-宏"><a href="#模板-宏" class="headerlink" title="模板-宏"></a>模板-宏</h2><p>在模板中也可以设置宏</p><p>宏主要是对变量的定义，设置宏的作用是方面后面的Items、Trigger中引用，在模板中配置一个宏，在不同的主机对该宏设置不同的变量值，从而达到模板化通用的目的。</p><p><strong>划重点</strong></p><ul><li>作用范围：Items、Trigger。也就是说再模板中设置的宏只在监控项和触发器中生效</li></ul><p>宏的名称定义为：<code>{$名称}</code>，宏的字符范围为：A~Z、0-9、_</p><p>更多详细的配置，可以看zabbix-宏的配置</p><h1 id="zabbix-自定义监控项"><a href="#zabbix-自定义监控项" class="headerlink" title="zabbix-自定义监控项"></a>zabbix-自定义监控项</h1><h1 id="zabbix-宏的配置"><a href="#zabbix-宏的配置" class="headerlink" title="zabbix-宏的配置"></a>zabbix-宏的配置</h1><p>宏的作用是便于在模板、Items、Trigger中的引用。</p><p>宏的名称定义为：<code>{$名称}</code>，宏的字符范围为：A~Z、0-9、_</p><p>配置宏之后，在不同的主机对该宏设置不同的变量值，从而达到模板化通用的目的。</p><h2 id="全局宏"><a href="#全局宏" class="headerlink" title="全局宏"></a>全局宏</h2><p>单击Administrator–&gt;general–&gt;Macros</p><p>默认的全局宏只有一个，为：{$SNMP_COMMUNITY}=public</p><h2 id="模板宏"><a href="#模板宏" class="headerlink" title="模板宏"></a>模板宏</h2><h2 id="主机宏"><a href="#主机宏" class="headerlink" title="主机宏"></a>主机宏</h2><h1 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h1><h3 id="触发器配置监控时间范围"><a href="#触发器配置监控时间范围" class="headerlink" title="触发器配置监控时间范围"></a>触发器配置监控时间范围</h3><h4 id="方案1：定义2个触发器，触发器里面设置生效时间"><a href="#方案1：定义2个触发器，触发器里面设置生效时间" class="headerlink" title="方案1：定义2个触发器，触发器里面设置生效时间"></a>方案1：定义2个触发器，触发器里面设置生效时间</h4><h4 id="方案2-1个触发器，设置不同时间，使用不同阈值"><a href="#方案2-1个触发器，设置不同时间，使用不同阈值" class="headerlink" title="方案2:1个触发器，设置不同时间，使用不同阈值"></a>方案2:1个触发器，设置不同时间，使用不同阈值</h4><h1 id="常用问题"><a href="#常用问题" class="headerlink" title="常用问题"></a>常用问题</h1><h2 id="High-ICMP-ping-loss"><a href="#High-ICMP-ping-loss" class="headerlink" title="High ICMP ping loss"></a>High ICMP ping loss</h2>]]></content>
    
    <summary type="html">
    
      Zabbix从入门到实践
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="运维监控体系" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB/"/>
    
      <category term="zabbix" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB/zabbix/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>集合+文件操作+函数</title>
    <link href="http://yoursite.com/2018/07/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day03/%E9%9B%86%E5%90%88+%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C+%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/07/08/编程语言/Python/老男孩视频学习笔记/day03/集合+文件操作+函数/</id>
    <published>2018-07-08T12:26:10.000Z</published>
    <updated>2018-07-08T12:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合是一个无序的，不重复的数据组合，它的主要作用如下：</p><ul><li>去重，把一个列表变成集合，就自动去重了</li><li>关系测试，测试两组数据之前的交集、差集、并集等关系</li></ul><p><strong>集合创建：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4,5,7,6,6,1,7,8]</span><br><span class="line">list_set = set(list)</span><br><span class="line">print (list_set,type(list_set))</span><br><span class="line"></span><br><span class="line">set1 = set()</span><br><span class="line">print (set1,type(set1))</span><br><span class="line"></span><br><span class="line">执行后输出如下：</span><br><span class="line">&#123;1, 2, 3, 4, 5, 6, 7, 8&#125; &lt;class &apos;set&apos;&gt;</span><br><span class="line">set() &lt;class &apos;set&apos;&gt;</span><br></pre></td></tr></table></figure><p><strong>高级操作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = t | s          # t 和 s的并集  </span><br><span class="line">  </span><br><span class="line">b = t &amp; s          # t 和 s的交集  </span><br><span class="line">  </span><br><span class="line">c = t – s          # 求差集（项在t中，但不在s中）  </span><br><span class="line">  </span><br><span class="line">d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中），也就是在并集中去除掉了交集</span><br></pre></td></tr></table></figure><p><strong>其他操作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.add(&apos;x&apos;)            # 添加一项  </span><br><span class="line">  </span><br><span class="line">s.update([10,37,42])  # 在s中添加多项</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用remove()可以删除一项：  </span><br><span class="line">  </span><br><span class="line">t.remove(&apos;H&apos;)  </span><br><span class="line"></span><br><span class="line">还有discard()方法可以删除，但是当元素不存在的时候，它不会和remove一样报错</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">len(s)  </span><br><span class="line">set 的长度  </span><br><span class="line">  </span><br><span class="line">x in s  </span><br><span class="line">测试 x 是否是 s 的成员  </span><br><span class="line">  </span><br><span class="line">x not in s  </span><br><span class="line">测试 x 是否不是 s 的成员  </span><br><span class="line">  </span><br><span class="line">s.issubset(t)  </span><br><span class="line">s &lt;= t  </span><br><span class="line">测试是否 s 中的每一个元素都在 t 中  </span><br><span class="line">  </span><br><span class="line">s.issuperset(t)  </span><br><span class="line">s &gt;= t  </span><br><span class="line">测试是否 t 中的每一个元素都在 s 中  </span><br><span class="line">  </span><br><span class="line">s.union(t)  </span><br><span class="line">s | t  </span><br><span class="line">返回一个新的 set 包含 s 和 t 中的每一个元素  </span><br><span class="line">  </span><br><span class="line">s.intersection(t)  </span><br><span class="line">s &amp; t  </span><br><span class="line">返回一个新的 set 包含 s 和 t 中的公共元素  </span><br><span class="line">  </span><br><span class="line">s.difference(t)  </span><br><span class="line">s - t  </span><br><span class="line">返回一个新的 set 包含 s 中有但是 t 中没有的元素  </span><br><span class="line">  </span><br><span class="line">s.symmetric_difference(t)  </span><br><span class="line">s ^ t  </span><br><span class="line">返回一个新的 set 包含 s 和 t 中不重复的元素  </span><br><span class="line">  </span><br><span class="line">s.copy()  </span><br><span class="line">返回 set “s”的一个浅复制  </span><br><span class="line"></span><br><span class="line">判断两个集合是否有交集</span><br><span class="line">s1 = set([1,2,3,4,5,6])</span><br><span class="line">s2 = set([2,4,6,8,10])</span><br><span class="line">s3 = set([11,22,44,55])</span><br><span class="line">print (s1.isdisjoint(s2))</span><br><span class="line">print (s1.isdisjoint(s3))</span><br><span class="line">输出为：</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="文件操作相关知识"><a href="#文件操作相关知识" class="headerlink" title="文件操作相关知识"></a>文件操作相关知识</h2><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>read()方法，一次性读取文件的所有内容，当文件非常大的时候非常不建议</p><p>readline()方法，一次只读取文件的一行，从上往下的顺序</p><p>readlines()方法，将文件的内容按行一次性重新输出为一个==列表==，每行一个元素</p><p>read()和readlines()方法都是一次性读取文件的全部内容，只适合于小文件，不适合大文件</p><p>readline()是一行一行的读取，在大文件的时候也是十分占用内存的</p><p>注意，以上这三种方法只适合读取小文件，在读取大文件的时候，不能够再使用这种方法。</p><p>思路：文件的内容，打印完一行之后就不再需要这一行了，因此已经读取的内容就没有必要再存储在内存当中，在内存中永远只保存一行</p><p>写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f =  open(r&apos;C:\Users\Administrator\PycharmProjects\files\login.txt&apos;, &apos;r&apos;)</span><br><span class="line">for line in f:</span><br><span class="line">    print(line)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="tell-和seek-文件位置"><a href="#tell-和seek-文件位置" class="headerlink" title="tell()和seek()-文件位置"></a>tell()和seek()-文件位置</h2><p>tell打印当前文件内容的输出位置，seek将当前光标重新定向到指定的位置</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(f.readline())</span><br><span class="line">print(f.readline())</span><br><span class="line">print (f.tell())</span><br><span class="line">f.seek(0)</span><br><span class="line">print (f.readline())</span><br><span class="line"></span><br><span class="line">执行后输出为：</span><br><span class="line">wxh:wxh123</span><br><span class="line">wsy:wsy123</span><br><span class="line">24</span><br><span class="line">wxh:wxh123</span><br></pre></td></tr></table></figure><h2 id="缓存区-flush"><a href="#缓存区-flush" class="headerlink" title="缓存区-flush()"></a>缓存区-flush()</h2><p>在进行循环等操作的时候，程序需要等循环完毕才输出，也就是缓存区满了之后再进行显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys,time</span><br><span class="line">for i in range(50):</span><br><span class="line">    sys.stdout.write(&quot;#&quot;)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    </span><br><span class="line">执行后的程序输出将会是持续的输出#</span><br></pre></td></tr></table></figure><p>使用flush()方法，可以在操作时立即输出</p><h1 id="程序练习"><a href="#程序练习" class="headerlink" title="程序练习"></a>程序练习</h1><h2 id="实现shell-sed替换功能"><a href="#实现shell-sed替换功能" class="headerlink" title="实现shell sed替换功能"></a>实现shell sed替换功能</h2><p>用户输入旧的需要替换的字符和新的字符，通过给脚本传入参数来实现</p><p>可以使用sys模块的argv进行参数获取，然后进行替换操作</p><h2 id="修改haproxy配置文件"><a href="#修改haproxy配置文件" class="headerlink" title="修改haproxy配置文件"></a>修改haproxy配置文件</h2><p>需求</p><ul><li>进入程序之后，可以选择：增、删、改、查等操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1、查</span><br><span class="line">    输入：www.oldboy.org</span><br><span class="line">    获取当前backend下的所有记录</span><br><span class="line"></span><br><span class="line">2、新建</span><br><span class="line">    输入：</span><br><span class="line">        arg = &#123;</span><br><span class="line">            &apos;bakend&apos;: &apos;www.oldboy.org&apos;,</span><br><span class="line">            &apos;record&apos;:&#123;</span><br><span class="line">                &apos;server&apos;: &apos;100.1.7.9&apos;,</span><br><span class="line">                &apos;weight&apos;: 20,</span><br><span class="line">                &apos;maxconn&apos;: 30</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">3、删除</span><br><span class="line">    输入：</span><br><span class="line">        arg = &#123;</span><br><span class="line">            &apos;bakend&apos;: &apos;www.oldboy.org&apos;,</span><br><span class="line">            &apos;record&apos;:&#123;</span><br><span class="line">                &apos;server&apos;: &apos;100.1.7.9&apos;,</span><br><span class="line">                &apos;weight&apos;: 20,</span><br><span class="line">                &apos;maxconn&apos;: 30</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>源文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">global       </span><br><span class="line">        log 127.0.0.1 local2</span><br><span class="line">        daemon</span><br><span class="line">        maxconn 256</span><br><span class="line">        log 127.0.0.1 local2 info</span><br><span class="line">defaults</span><br><span class="line">        log global</span><br><span class="line">        mode http</span><br><span class="line">        timeout connect 5000ms</span><br><span class="line">        timeout client 50000ms</span><br><span class="line">        timeout server 50000ms</span><br><span class="line">        option  dontlognull</span><br><span class="line"></span><br><span class="line">listen stats :8888</span><br><span class="line">        stats enable</span><br><span class="line">        stats uri       /admin</span><br><span class="line">        stats auth      admin:1234</span><br><span class="line"></span><br><span class="line">frontend oldboy.org</span><br><span class="line">        bind 0.0.0.0:80</span><br><span class="line">        option httplog</span><br><span class="line">        option httpclose</span><br><span class="line">        option  forwardfor</span><br><span class="line">        log global</span><br><span class="line">        acl www hdr_reg(host) -i www.oldboy.org</span><br><span class="line">        use_backend www.oldboy.org if www</span><br><span class="line"></span><br><span class="line">backend www.oldboy.org</span><br><span class="line">        server 100.1.7.9 100.1.7.9 weight 20 maxconn 3000</span><br></pre></td></tr></table></figure><p>使用eval实现</p><h1 id="函数基础知识"><a href="#函数基础知识" class="headerlink" title="函数基础知识"></a>函数基础知识</h1><h2 id="函数结构"><a href="#函数结构" class="headerlink" title="函数结构"></a>函数结构</h2><p>面向对象：类 class</p><p>面向过程：过程 def  【过程实际上可以理解为没有返回值的函数】</p><p>函数式编程：函数 def 【函数式逻辑结构化和过程化的一种编程方法】</p><p>注意，过程和函数的定义都是使用def进行标识的</p><p>在python中<strong>定义一个函数</strong>的结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def test(x):</span><br><span class="line">    &quot;&quot;&quot;define the function for test&quot;&quot;&quot;</span><br><span class="line">    x += 1</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line">a = test(1)</span><br><span class="line">print (a)</span><br></pre></td></tr></table></figure><ul><li>def：定义函数的关键字</li><li>test：函数名称</li><li>()：参数列表空间，内可定义形参</li><li>中间是代码块，用于实现程序处理逻辑</li><li>return：定义返回值</li></ul><p>在python当中，过程也是被当做函数来处理，python其实也给过程隐式的定义了返回值None，因此在调用过程的时候，我们也能看到返回值，但是返回值是None</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>将实参传递给形参的时候，有两种方法，</p><ul><li>一种是在括号中直接写实参，例如：test(1,2)，这个时候将会按照这个顺序进行参数的传递，与形参一一对应</li><li>一种是人为的指定赋值对象，例如：test1(x=2,y=1)，这个时候将会按照指定的值进行赋值导入，与形参的顺序无关</li></ul><h3 id="函数为什么要有返回值"><a href="#函数为什么要有返回值" class="headerlink" title="函数为什么要有返回值"></a>函数为什么要有返回值</h3><p>函数有返回值的一个最主要的原因是，我想要这个函数整个的执行结果</p><p>后面的处理逻辑需要根据这个返回值的结果进行相应的操作</p><h2 id="定义不限制数量的函数形参个数"><a href="#定义不限制数量的函数形参个数" class="headerlink" title="定义不限制数量的函数形参个数"></a>定义不限制数量的函数形参个数</h2><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">输出为元祖类型：</span><br><span class="line"></span><br><span class="line">def test(x,*wxh):</span><br><span class="line">    print (x)</span><br><span class="line">    print (wxh)</span><br><span class="line"></span><br><span class="line">test(1,2,2,34,45)</span><br><span class="line">执行后输出如下所示：</span><br><span class="line">1</span><br><span class="line">(2, 2, 34, 45)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出为字典类型：</span><br><span class="line">def test(x,**wxh):</span><br><span class="line">    print (x)</span><br><span class="line">    print (wxh)</span><br><span class="line"></span><br><span class="line">test(1,name=&quot;wxh&quot;,age=6)</span><br><span class="line">执行后输出如下所示：</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">&#123;&apos;name&apos;: &apos;wxh&apos;, &apos;age&apos;: 6&#125;</span><br></pre></td></tr></table></figure><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>测试代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def change_name(name):</span><br><span class="line">    print (&quot;befor change&quot;,name)</span><br><span class="line">    name = &quot;wang xiao hua&quot;</span><br><span class="line">    print (&quot;after change&quot;,name)</span><br><span class="line">name = &quot;wxh&quot;</span><br><span class="line">a1= change_name(name)</span><br><span class="line">print (name)</span><br><span class="line">print (a1)</span><br><span class="line"></span><br><span class="line">执行后的输出如下所示:</span><br><span class="line"></span><br><span class="line">befor change wxh</span><br><span class="line">after change wang xiao hua</span><br><span class="line">wxh</span><br><span class="line">None</span><br></pre></td></tr></table></figure><p>这个测试的效果就是局部变量，局部变量只会在函数里面生效，可以理解为，这个函数就是这个变量的作用域，在这个函数之外</p><h2 id="函数内操作全局变量"><a href="#函数内操作全局变量" class="headerlink" title="函数内操作全局变量"></a>函数内操作全局变量</h2><p>默认情况下，在函数体中操作的都是局部变量，但是有些情况需要在函数体中操作全局变量，这个时候就需要在变量的前面加上标志信息：global</p><p>注意，在外部定义的全局变量，只有字符串和单独的整数这种是不能再函数中去修改的，而像列表字典元祖集合等比较复杂的数据类型，这些都是可以直接在局部里面直接修改全局的 </p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自己本身，那么这个函数就是递归函数。</p><h2 id="递归的特性"><a href="#递归的特性" class="headerlink" title="递归的特性"></a>递归的特性</h2><p>递归函数应该拥有以下特性：</p><ul><li>必须有一个明确的结束条件</li><li>每次进入更深一层的递归时，问题规模相比上次递归都应有所减少</li><li>递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用时通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。）</li></ul><p>演示代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def cal(n):</span><br><span class="line">    print (n)</span><br><span class="line">    if int(n/2)&gt;0:</span><br><span class="line">        return (cal(int(n/2)))</span><br><span class="line">cal(10)</span><br><span class="line">输出为：</span><br><span class="line">10</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">这就是一个有明确结束条件的递归函数</span><br></pre></td></tr></table></figure><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>演示代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def add(a,b,f):</span><br><span class="line">    return f(a),f(b)</span><br><span class="line"></span><br><span class="line">res = add(-5,-4,abs)</span><br><span class="line">print (res)</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">(5, 4)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      集合及文件操作知识补充+函数
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="day03" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day03/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>模块初始及列表字典等深入</title>
    <link href="http://yoursite.com/2018/06/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day02/%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B/"/>
    <id>http://yoursite.com/2018/06/27/编程语言/Python/老男孩视频学习笔记/day02/模块初始/</id>
    <published>2018-06-27T13:54:39.000Z</published>
    <updated>2018-06-27T13:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h1><p>模块的简单介绍：用户写好了一堆功能，将其封装在一个文件当中，从网上下载下来之后，导入之后就可以使用，不用再去重新编写相对应的功能代码。这个文件就叫做模块，又可以叫做库</p><p>模块（库）主要分为两种：</p><ul><li>一个是标准库（不需要额外安装下载，就可以直接导入的库，比如说getpass,os,sys模块等）</li><li>一个是第三方库（必须要额外的下载安装之后，才可以使用，例如django）</li></ul><p>几个要点：</p><ul><li>模块在系统中是以.py结尾的文件方式存在的</li><li>这些模块文件在python有一个寻找路径/环境变量（存储路径可以通过sys模块的path方法进行查看，默认情况下，会最优先从当前目录下进行寻找）【这个是python的全局变量，和系统的path环境变量不一样】，这个python全局变量，存储的是路径信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;python</span><br><span class="line">Python 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 16:07:46) [MSC v.1900 32 bit (Intel)] on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; print (sys.path)</span><br><span class="line">[&apos;&apos;, &apos;D:\\software\\python\\python36.zip&apos;, &apos;D:\\software\\python\\DLLs&apos;, &apos;D:\\software\\python\\lib&apos;, &apos;D:\\software\\python&apos;, &apos;D:\\software\\python\\lib\\site-packages&apos;]</span><br></pre></td></tr></table></figure><p>一般情况下，python安装的第三方库都是存放在lib\site-packages路径下</p><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">print (sys.path)</span><br><span class="line">print(sys.argv)</span><br></pre></td></tr></table></figure><p>输出信息如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;C:\Users\Administrator\PycharmProjects\python14\day02&apos;, &apos;C:\Users\Administrator\PycharmProjects\python14&apos;, &apos;D:\software\python\python36.zip&apos;, &apos;D:\software\python\DLLs&apos;, &apos;D:\software\python\lib&apos;, &apos;D:\software\python&apos;, &apos;D:\software\python\lib\site-packages&apos;]</span><br><span class="line"></span><br><span class="line">[&apos;C:/Users/Administrator/PycharmProjects/python14/day02/moudles.py&apos;]</span><br></pre></td></tr></table></figure><ul><li>path方法输出python定义的环境变量信息</li><li>argv方法输出当前文件所在相对路径信息（注意是相对路径，这里输出是因为在IDE中调用的时候写的脚本名字的路径就是绝对路径，pycharm在调用的时候写的是绝对路径）</li></ul><h2 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h2><p>OS模块是跟操作系统进行交互</p><p>从python中调用shell的命令，或者在系统上创建一个文件、目录等</p><p>比如</p><p>执行命令，使用方法：os.system()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import os</span><br><span class="line">cmd_res = os.system(&quot;df -h&quot;)</span><br><span class="line">print (cmd_res)</span><br></pre></td></tr></table></figure><p>执行后的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@redis001 ~]# python test.py</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda2       197G  1.4G  186G   1% /</span><br><span class="line">tmpfs            63G   24K   63G   1% /dev/shm</span><br><span class="line">/dev/sda1       283M   37M  232M  14% /boot</span><br><span class="line">/dev/sda6       1.3T  203M  1.3T   1% /data1</span><br><span class="line">/dev/sda3        99G   60M   94G   1% /home</span><br><span class="line">/dev/sda5        50G   52M   47G   1% /tmp</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意：在使用os.system执行命令的时候，这个结果的输出是直接输出到屏幕上的，而不是存到这个变量中，所以输出之后就没有了</p><p>0 是命令执行成功与否的返回状态码</p><p>上面的system是执行命令，但是不保存结果</p><p>那么，我们就想保存结果的时候，该做什么操作？ 这个时候我们使用popen方法</p><p>popen()方法输出的是一个内存的对象地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@redis001 ~]# cat test.py </span><br><span class="line">#!/usr/bin/python</span><br><span class="line">import os</span><br><span class="line">cmd_res = os.popen(&quot;ls&quot;)</span><br><span class="line">print (cmd_res)</span><br><span class="line">[root@redis001 ~]# python test.py</span><br><span class="line">&lt;open file &apos;ls&apos;, mode &apos;r&apos; at 0x7ff2cce43c00&gt;</span><br><span class="line">ls: write error: Broken pipe</span><br></pre></td></tr></table></figure><p>那么，想要真正的结果，则需要再调用一下read()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@redis001 ~]# cat test.py </span><br><span class="line">#!/usr/bin/python</span><br><span class="line">import os</span><br><span class="line">cmd_res = os.popen(&quot;ls&quot;).read()</span><br><span class="line">print (cmd_res)</span><br><span class="line">[root@redis001 ~]# python test.py</span><br><span class="line">anaconda-ks.cfg</span><br><span class="line">install.log</span><br><span class="line">install.log.syslog</span><br><span class="line">test.py</span><br></pre></td></tr></table></figure><p>解析：在执行完popen()之后，这个结果是保存在内存的一个临时的地方，这个地方，必须通过read()方法，再去取出来</p><h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表切片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">print (list[1:3])</span><br><span class="line">输出为：</span><br><span class="line">[&apos;wsy&apos;, &apos;dabadou&apos;]</span><br></pre></td></tr></table></figure><p>打印列表中item的数量-使用count方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">print(list.count(&quot;wxh&quot;))</span><br></pre></td></tr></table></figure><p>清除列表-clear方法-注意这里只是清空了但是不会被删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.clear()</span><br></pre></td></tr></table></figure><p>列表反转-reverse()方法</p><p>列表合并-extend()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">list2 = [1,2,3,4]</span><br><span class="line">list.extend(list2)</span><br><span class="line">print (list)</span><br><span class="line">输出为：</span><br><span class="line">[&apos;wxh&apos;, &apos;wsy&apos;, &apos;dabadou&apos;, &apos;badou&apos;, &apos;wxh&apos;, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>列表删除-del命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list2 = [1,2,3,4]</span><br><span class="line">del list2</span><br><span class="line">print (list2)</span><br></pre></td></tr></table></figure><p>列表嵌套列表及子列表赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,[&quot;wxh&quot;,&quot;heheh&quot;,&quot;haha&quot;],&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">list[3][1] = &quot;WXH&quot;</span><br><span class="line">print(list)</span><br><span class="line">执行后输出为：</span><br><span class="line">[&apos;wxh&apos;, &apos;wsy&apos;, &apos;dabadou&apos;, [&apos;wxh&apos;, &apos;WXH&apos;, &apos;haha&apos;], &apos;badou&apos;, &apos;wxh&apos;]</span><br></pre></td></tr></table></figure><p>列表复制-使用copy模块的copy方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,[&quot;wxh&quot;,&quot;heheh&quot;,&quot;haha&quot;],&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">list2 = copy.copy(list)</span><br><span class="line">print (list2)</span><br><span class="line">输出为：</span><br><span class="line">[&apos;wxh&apos;, &apos;wsy&apos;, &apos;dabadou&apos;, [&apos;wxh&apos;, &apos;heheh&apos;, &apos;haha&apos;], &apos;badou&apos;, &apos;wxh&apos;]</span><br><span class="line"></span><br><span class="line">也可以使用下面这种方式：</span><br><span class="line">list = [&quot;wxh&quot;,&quot;wsy&quot;,&quot;dabadou&quot;,[&quot;wxh&quot;,&quot;heheh&quot;,&quot;haha&quot;],&quot;badou&quot;,&quot;wxh&quot;]</span><br><span class="line">list2 = list[:]</span><br><span class="line">print (list2)</span><br></pre></td></tr></table></figure><p>使用这种列表再赋值的方式，可以拿来作为联合账号类功能，也就是说前者最开始的列表将会连带的影响所有的列表。</p><p>列表循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in list:</span><br><span class="line">print (i)</span><br></pre></td></tr></table></figure><p>在循环的时候-按照步长进行输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(list[0:-1:2])</span><br></pre></td></tr></table></figure><h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h2><p>元祖和列表差不多，只不过一旦创建之后就不能再次修改，因此又叫做只读列表</p><p>元祖使用()进行定义，而不是列表的[]</p><p>元祖只有两个方法，count和index方法</p><h2 id="购物车程序"><a href="#购物车程序" class="headerlink" title="购物车程序"></a>购物车程序</h2><p>需求如下：</p><ol><li>启动程序之后，让用户输入工资，然后打印商品列表</li><li>允许用户根据商品编号购买商品</li><li>用户选择商品后，检测余额是否足够，够久直接扣款，不够就提醒（不够的话可以选择便宜的，也就是说进入下一次循环）</li><li>可以随时退出，退出时，打印已经购买的商品和余额</li></ol><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Author:XiaoHua Wang</span><br><span class="line">goods = [(&quot;iphone&quot;,7000),(&quot;Ipad pro&quot;,5000),(&quot;Mac pro&quot;,22000),(&quot;tea&quot;,40),(&quot;bag&quot;,2000),(&quot;Nike&quot;,860),(&quot;book&quot;,105)]</span><br><span class="line">salary = int(input(&quot;Please input your salary: &quot;))</span><br><span class="line">message2 = &quot;Please choice which number to buy,enter q to quit in any time:&quot;</span><br><span class="line">buy_goods = []</span><br><span class="line">while True:</span><br><span class="line">    print(&quot;These are all goods you can buy:&quot;)</span><br><span class="line">#    for i in range(len(goods)):</span><br><span class="line">#        print(str(i) + &quot; &quot; + str(goods[i]))</span><br><span class="line">    for item in goods:</span><br><span class="line">        print (goods.index(item),item)</span><br><span class="line">    Tag = input(message2)</span><br><span class="line">    jude = Tag.isdigit()</span><br><span class="line">    if Tag == &quot;q&quot;:</span><br><span class="line">        break</span><br><span class="line">    if jude != True:</span><br><span class="line">        print (&quot;sorry,input error,please enter number or q&quot;)</span><br><span class="line">        break</span><br><span class="line">    consume_moneny = int(goods[int(Tag)][1])</span><br><span class="line">    salary1 = salary</span><br><span class="line">    salary = salary - consume_moneny</span><br><span class="line">    if  salary &lt; 0:</span><br><span class="line">        print (&quot;sorry,you The amount is not enough,please select again&quot;)</span><br><span class="line">        print( &quot;rest salary is &#123;Salary&#125;&quot;.format(Salary=salary1) )</span><br><span class="line">        salary = salary1</span><br><span class="line">        continue</span><br><span class="line">#    if salary == 0:</span><br><span class="line">    if salary == 0:</span><br><span class="line">        print(&quot;Add &quot; + str(goods[int(Tag)]) )</span><br><span class="line">        print(&quot;consume all money just right,&quot;+ &quot;rest salary is 0 . you can&apos;t buy again.&quot;)</span><br><span class="line">        buy_goods = buy_goods.append(goods[int(Tag)][0])</span><br><span class="line">        break</span><br><span class="line">    print(&quot;Add &quot; + str(goods[int(Tag)]))</span><br><span class="line">#    print(&quot;rest salary is &quot; + str(salary))</span><br><span class="line">    print(&quot;rest salary is &#123;Salary&#125;&quot;.format(Salary=salary))</span><br><span class="line">    buy_goods.append(goods[int(Tag)][0])</span><br><span class="line">    continue</span><br><span class="line">print (&quot;you have buy blow goods: &quot;)</span><br><span class="line">print (buy_goods)</span><br></pre></td></tr></table></figure><p>注意：匹配列表的索引和对应的值还可以使用下面的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">goods = [(&quot;iphone&quot;,7000),(&quot;Ipad pro&quot;,5000),(&quot;Mac pro&quot;,22000),(&quot;tea&quot;,40),(&quot;bag&quot;,2000),(&quot;Nike&quot;,860),(&quot;book&quot;,105)]</span><br><span class="line">for item in goods:</span><br><span class="line">    print(goods.index(item), item)</span><br><span class="line">#或者</span><br><span class="line">for index,item in enumerate(goods):</span><br><span class="line">    print (index,item)</span><br><span class="line"></span><br><span class="line">执行后输出如下：</span><br><span class="line">0 (&apos;iphone&apos;, 7000)</span><br><span class="line">1 (&apos;Ipad pro&apos;, 5000)</span><br><span class="line">2 (&apos;Mac pro&apos;, 22000)</span><br><span class="line">3 (&apos;tea&apos;, 40)</span><br><span class="line">4 (&apos;bag&apos;, 2000)</span><br><span class="line">5 (&apos;Nike&apos;, 860)</span><br><span class="line">6 (&apos;book&apos;, 105)</span><br><span class="line">0 (&apos;iphone&apos;, 7000)</span><br><span class="line">1 (&apos;Ipad pro&apos;, 5000)</span><br><span class="line">2 (&apos;Mac pro&apos;, 22000)</span><br><span class="line">3 (&apos;tea&apos;, 40)</span><br><span class="line">4 (&apos;bag&apos;, 2000)</span><br><span class="line">5 (&apos;Nike&apos;, 860)</span><br><span class="line">6 (&apos;book&apos;, 105)</span><br></pre></td></tr></table></figure><h2 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h2><p><strong>字符串对应位置替换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;wangxiaohua&quot;</span><br><span class="line">p = str.maketrans(&quot;abcdefg&quot;,&quot;1234567&quot;)</span><br><span class="line">print (name.translate(p))</span><br><span class="line"></span><br><span class="line">执行之后的输出如下所示：</span><br><span class="line">w1n7xi1ohu1</span><br></pre></td></tr></table></figure><p><strong>临时替换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print (&quot;wangxiaohua&quot;.replace(&apos;a&apos;,&apos;A&apos;,2))</span><br><span class="line">执行后输出如下：</span><br><span class="line">wAngxiAohua</span><br><span class="line"></span><br><span class="line">格式为：旧字符，新字符，替换的格式个数</span><br></pre></td></tr></table></figure><p><strong>split分割-按照字符</strong></p><p>将字符串的值，按照指定的分隔符号，重新定义为列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = &quot;1+2+3+4&quot;</span><br><span class="line">print (num.split(&quot;+&quot;))</span><br><span class="line">执行后输出如下：</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]</span><br></pre></td></tr></table></figure><p><strong>split分割-按照行</strong></p><p>split分割按照行来进行区分的时候，我们就需要使用splitlines()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num = &quot;1+2+3\n+4+\n5+6&quot;</span><br><span class="line">print (num)</span><br><span class="line">print (num.split(&quot;+&quot;))</span><br><span class="line">print (num.splitlines())</span><br><span class="line"></span><br><span class="line">执行后输出如下所示：</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3\n&apos;, &apos;4&apos;, &apos;\n5&apos;, &apos;6&apos;]</span><br><span class="line">[&apos;1+2+3&apos;, &apos;+4+&apos;, &apos;5+6&apos;]</span><br></pre></td></tr></table></figure><p>注意：在linux和windows平台上使用splitlines()方法的时候，它会自动的识别换行符（Linux和windows的换行符号是不一样的）</p><p><strong>Title格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;wang xiao hua&quot;</span><br><span class="line">name1 = &quot;wangxiaohua&quot;</span><br><span class="line">print (name.title())</span><br><span class="line">print (name1.title())</span><br><span class="line"></span><br><span class="line">执行后的输出如下所示：</span><br><span class="line">Wang Xiao Hua</span><br><span class="line">Wangxiaohua</span><br></pre></td></tr></table></figure><p>将输入的字符串输出为标题的格式，也就是首字母大写的格式</p><h2 id="字典操作"><a href="#字典操作" class="headerlink" title="字典操作"></a>字典操作</h2><p>字典的数据类型是一种key-value类型</p><p>字典的特性：</p><ul><li>dict是无序的</li><li>key必须是唯一的，因此字典天生就具备去重的功能</li><li>在输出的时候，默认是没有顺序的，因此可能写在最后的在最前面输出，因为字典没有下标信息，因为列表是通过索引下标进行查找，但是字典是通过key进行查找的</li><li>在取值的时候，用法和列表的相似，不过是在[]中将索引下标数字修改成为key值</li></ul><p>删除字典有几种方法，使用pop的时候，可以再进行赋值，使用del的时候就是真的删除了</p><p>字典的查找，可以使用get方法，也可以使用in的用法</p><p>字典中有该值则返回，没有的话则返回None</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangxiaohua&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;26&quot;,</span><br><span class="line">    &quot;sex&quot;:&quot;man&quot;</span><br><span class="line">&#125;</span><br><span class="line">print (info.get(&quot;name&quot;))</span><br><span class="line">print (info.get(&quot;named&quot;))</span><br><span class="line">if &quot;name&quot; in info:</span><br><span class="line">    print (&quot;Yes&quot;)</span><br><span class="line"></span><br><span class="line">执行后的输出如下所示：</span><br><span class="line">wangxiaohua</span><br><span class="line">None</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p>字典的特殊赋值-如果能取到值则返回取到的值，如果值不存在则创建一个新的-setdefault()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangxiaohua&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;26&quot;,</span><br><span class="line">    &quot;sex&quot;:&quot;man&quot;</span><br><span class="line">&#125;</span><br><span class="line">info.setdefault(&quot;name&quot;,&quot;hehe&quot;)</span><br><span class="line">print (info)</span><br><span class="line"></span><br><span class="line">执行后输出如下所示：</span><br><span class="line">&#123;&apos;name&apos;: &apos;wangxiaohua&apos;, &apos;age&apos;: &apos;26&apos;, &apos;sex&apos;: &apos;man&apos;&#125;</span><br></pre></td></tr></table></figure><p>字典的合并更新-存在交叉的key值进行覆盖，不存在的则进行插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangxiaohua&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;26&quot;,</span><br><span class="line">    &quot;sex&quot;:&quot;man&quot;</span><br><span class="line">&#125;</span><br><span class="line">info2 = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;dabadou&quot;,</span><br><span class="line">    &quot;city&quot;:&quot;hangzhou&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info.update(info2)</span><br><span class="line">print (info)</span><br><span class="line"></span><br><span class="line">执行后的输出如下所示：</span><br><span class="line">&#123;&apos;name&apos;: &apos;dabadou&apos;, &apos;age&apos;: &apos;26&apos;, &apos;sex&apos;: &apos;man&apos;, &apos;city&apos;: &apos;hangzhou&apos;&#125;</span><br></pre></td></tr></table></figure><p><strong>字典的循环</strong></p><p>字典的循环，一般使用的是items()方法，但是使用下面这种方法，会比items()方法高效很多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;wangxiaohua&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;26&quot;,</span><br><span class="line">    &quot;sex&quot;:&quot;man&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i in info:</span><br><span class="line">  print (i,info[i])</span><br><span class="line"></span><br><span class="line">for k,v in info.items():</span><br><span class="line">    print (k,v)</span><br><span class="line">    </span><br><span class="line">执行后的输出如下所示：</span><br><span class="line"></span><br><span class="line">name wangxiaohua</span><br><span class="line">age 26</span><br><span class="line">sex man</span><br><span class="line">name wangxiaohua</span><br><span class="line">age 26</span><br><span class="line">sex man</span><br></pre></td></tr></table></figure><p>上面的方式，是通过索引的形式（这里是key）就直接把value取出来了，但是下面这个items()相当于是把字典变成一个列表，因此就多了一个字典转换成列表的过程，在数据量大的时候，效率非常的差</p><p>因此字典的循环，最好使用上面的这种方式，尽量避免使用items()方法来实现</p><h2 id="三级菜单程序"><a href="#三级菜单程序" class="headerlink" title="三级菜单程序"></a>三级菜单程序</h2><ul><li>三级菜单【省市县】【例如，浙江省–&gt;杭州市–&gt;xx县/区】</li><li>可依次选择进入各个子菜单</li><li>所需新知识点：列表，字典</li></ul><p>打开程序，列出中国所有的省，选择一个省，列出下面所有的城市，选中一个城市，再列出下面所有的县</p><p>在任何一个级别，可以返回上一级</p><p>在任何一个级别的时候，可以整个退出程序，输入例如quit等退出程序</p>]]></content>
    
    <summary type="html">
    
      模块初始
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="day02" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day02/"/>
    
      <category term="模块初识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day02/%E6%A8%A1%E5%9D%97%E5%88%9D%E8%AF%86/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器双网卡bond配置</title>
    <link href="http://yoursite.com/2018/06/26/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/2%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8C%E7%BD%91%E5%8D%A1bond%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/06/26/IT科学技术知识体系结构-Linux运维方向/高并发/负载均衡/2层负载均衡/Linux服务器双网卡bond配置/</id>
    <published>2018-06-26T02:04:42.000Z</published>
    <updated>2018-06-26T02:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考文献：</strong></p><ul><li><a href="https://www.jianshu.com/p/e7df65f996f4" target="_blank" rel="noopener">linux 网卡绑定 bonding</a></li><li><a href="https://www.cnblogs.com/wuxulei/p/3270256.html" target="_blank" rel="noopener">Linux网卡绑定探析</a></li><li><a href="https://www.linuxidc.com/Linux/2017-06/144865.htm" target="_blank" rel="noopener">Linux下网卡bonding配置</a></li><li><a href="https://blog.csdn.net/werm520/article/details/43953421" target="_blank" rel="noopener">LINUX-网卡Bond</a></li><li><a href="http://blog.51cto.com/lixin15/1769338" target="_blank" rel="noopener">Linux双网卡绑定bond详解</a></li><li><a href="http://blog.51cto.com/linuxnote/1680315" target="_blank" rel="noopener">Linux网卡bond的七种模式详解</a></li></ul><h1 id="基础知识概述"><a href="#基础知识概述" class="headerlink" title="基础知识概述"></a>基础知识概述</h1><h2 id="什么是bond"><a href="#什么是bond" class="headerlink" title="什么是bond"></a>什么是bond</h2><p>网卡bond是通过多张网卡绑定为一个逻辑网卡，实现本地网卡的<strong><code>冗余，带宽扩容和负载均衡</code></strong>，在生产场景中是一种常用的技术。</p><p>通俗点讲就是两块网卡具有相同的IP地址而并行链接聚合成一个逻辑链路工作。</p><p>其实这项技术在Sun和Cisco中早已存在，被称为Trunking和Etherchannel 技术，在Linux的2.4.x的内核中开始采用这这种技术，被称为bonding。 </p><h2 id="内核支持"><a href="#内核支持" class="headerlink" title="内核支持"></a>内核支持</h2><p>在Linux Kernels 2.4.12及以后的版本均供bonding模块，以前的版本可以通过patch实现。可以通过以下命令确定内核是否支持 bonding： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 ~]# cat /boot/config-2.6.32-696.el6.x86_64 | grep -i bond</span><br><span class="line"># CONFIG_PATA_WINBOND is not set</span><br><span class="line">CONFIG_BONDING=m</span><br><span class="line">CONFIG_WINBOND_840=m</span><br><span class="line">CONFIG_INPUT_WINBOND_CIR=m</span><br><span class="line">CONFIG_IR_WINBOND_CIR=m</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">[root@nginx001 ~]# cat /boot/config-2.6.32-696.el6.x86_64 | grep -i bonding</span><br><span class="line">CONFIG_BONDING=m</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">[root@ network-scripts]# modinfo bonding</span><br><span class="line">filename:       /lib/modules/2.6.32-696.el6.x86_64/kernel/drivers/net/bonding/bonding.ko</span><br><span class="line">author:         Thomas Davis, tadavis@lbl.gov and many others</span><br><span class="line">description:    Ethernet Channel Bonding Driver, v3.7.1</span><br><span class="line">version:        3.7.1</span><br><span class="line">license:        GPL</span><br><span class="line">alias:          rtnl-link-bond</span><br><span class="line">srcversion:     454FF5806F146AD7FB41356</span><br><span class="line">depends:        </span><br><span class="line">vermagic:       2.6.32-696.el6.x86_64 SMP mod_unload modversions </span><br><span class="line">parm:           max_bonds:Max number of bonded devices (int)</span><br><span class="line">parm:           tx_queues:Max number of transmit queues (default = 16) (int)</span><br><span class="line">parm:           num_grat_arp:Number of peer notifications to send on failover event (alias of num_unsol_na) (int)</span><br><span class="line">parm:           num_unsol_na:Number of peer notifications to send on failover event (alias of num_grat_arp) (int)</span><br><span class="line">parm:           miimon:Link check interval in milliseconds (int)</span><br><span class="line">parm:           updelay:Delay before considering link up, in milliseconds (int)</span><br><span class="line">parm:           downdelay:Delay before considering link down, in milliseconds (int)</span><br><span class="line">parm:           use_carrier:Use netif_carrier_ok (vs MII ioctls) in miimon; 0 for off, 1 for on (default) (int)</span><br><span class="line">parm:           mode:Mode of operation; 0 for balance-rr, 1 for active-backup, 2 for balance-xor, 3 for broadcast, 4 for 802.3ad, 5 for balance-tlb, 6 for balance-alb (charp)</span><br><span class="line">parm:           primary:Primary network device to use (charp)</span><br><span class="line">parm:           primary_reselect:Reselect primary slave once it comes up; 0 for always (default), 1 for only if speed of primary is better, 2 for only on active slave failure (charp)</span><br><span class="line">parm:           lacp_rate:LACPDU tx rate to request from 802.3ad partner; 0 for slow, 1 for fast (charp)</span><br><span class="line">parm:           ad_select:803.ad aggregation selection logic; 0 for stable (default), 1 for bandwidth, 2 for count (charp)</span><br><span class="line">parm:           min_links:Minimum number of available links before turning on carrier (int)</span><br><span class="line">parm:           xmit_hash_policy:balance-xor and 802.3ad hashing method; 0 for layer 2 (default), 1 for layer 3+4, 2 for layer 2+3 (charp)</span><br><span class="line">parm:           arp_interval:arp interval in milliseconds (int)</span><br><span class="line">parm:           arp_ip_target:arp targets in n.n.n.n form (array of charp)</span><br><span class="line">parm:           arp_validate:validate src/dst of ARP probes; 0 for none (default), 1 for active, 2 for backup, 3 for all (charp)</span><br><span class="line">parm:           arp_all_targets:fail on any/all arp targets timeout; 0 for any (default), 1 for all (charp)</span><br><span class="line">parm:           fail_over_mac:For active-backup, do not set all slaves to the same MAC; 0 for none (default), 1 for active, 2 for follow (charp)</span><br><span class="line">parm:           all_slaves_active:Keep all frames received on an interface by setting active flag for all slaves; 0 for never (default), 1 for always. (int)</span><br><span class="line">parm:           resend_igmp:Number of IGMP membership reports to send on link failure (int)</span><br><span class="line">parm:           packets_per_slave:Packets to send per slave in balance-rr mode; 0 for a random slave, 1 packet per slave (default), &gt;1 packets per slave. (int)</span><br><span class="line">parm:           lp_interval:The number of seconds between instances where the bonding driver sends learning packets to each slaves peer switch. The default is 1. (uint)</span><br></pre></td></tr></table></figure><p>当看到有相关配置输出的时候则说明当前操作系统的内核版本是支持bond的</p><h2 id="bond模式"><a href="#bond模式" class="headerlink" title="bond模式"></a>bond模式</h2><p><strong>bonding的七种工作模式:</strong> </p><p>bonding技术提供了七种工作模式，在使用的时候需要指定一种，每种有各自的优缺点.</p><ol><li>balance-rr (mode=0)       默认, 有高可用 (容错) 和负载均衡的功能,  需要交换机的配置，每块网卡轮询发包 (流量分发比较均衡).</li><li>active-backup (mode=1)  只有高可用 (容错) 功能, 不需要交换机配置, 这种模式只有一块网卡工作, 对外只有一个mac地址。缺点是端口利用率比较低</li><li>balance-xor (mode=2)     不常用</li><li>broadcast (mode=3)        不常用</li><li>802.3ad (mode=4)          IEEE 802.3ad 动态链路聚合，需要交换机配置，没用过</li><li>balance-tlb (mode=5)      不常用</li><li>balance-alb (mode=6)     有高可用 ( 容错 )和负载均衡的功能，不需要交换机配置  (流量分发到每个接口不是特别均衡)</li></ol><p>具体的网上有很多资料，了解每种模式的特点根据自己的选择就行, 一般会用到0、1、4、6这几种模式。</p><p>一般常用的常用的有两种：</p><p>  <strong>mode=0（balance-rr）</strong></p><p>​    表示负载分担round-robin，并且是轮询的方式比如第一个包走eth0，第二个包走eth1，直到数据包发送完毕。</p><p>​    优点：流量提高一倍</p><p>​    缺点：需要接入交换机做端口聚合，否则可能无法使用</p><p>  <strong>mode=1（active-backup）</strong></p><p>​    表示主备模式，即同时只有1块网卡在工作。</p><p>​    优点：冗余性高</p><p>​    缺点：链路利用率低，两块网卡只有1块在工作</p><h1 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h1><h2 id="配置子网卡"><a href="#配置子网卡" class="headerlink" title="配置子网卡"></a>配置子网卡</h2><p><strong>源文件内容：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 network-scripts]# cat ifcfg-p1p1</span><br><span class="line">DEVICE=&quot;p1p1&quot;</span><br><span class="line">BOOTPROTO=&quot;dhcp&quot;</span><br><span class="line">DHCP_HOSTNAME=&quot;bigdata&quot;</span><br><span class="line">HWADDR=&quot;D0:94:66:5B:76:89&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;no&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">UUID=&quot;9126f785-f642-4ce4-84d8-558284f17623&quot;</span><br></pre></td></tr></table></figure><p><strong>修改后的文件内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 network-scripts]# cat ifcfg-p1p1</span><br><span class="line">DEVICE=&quot;p1p1&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">DHCP_HOSTNAME=&quot;bigdata&quot;</span><br><span class="line">HWADDR=&quot;D0:94:66:5B:76:89&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">UUID=&quot;9126f785-f642-4ce4-84d8-558284f17623&quot;</span><br><span class="line">MASTER=bond1</span><br><span class="line">SLAVE=yes</span><br></pre></td></tr></table></figure><p>同样的，在第二块网卡上进行配置，配置之后的文件内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 network-scripts]# cat  ifcfg-p1p2</span><br><span class="line">DEVICE=&quot;p1p2&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">DHCP_HOSTNAME=&quot;bigdata&quot;</span><br><span class="line">HWADDR=&quot;D0:94:66:5B:76:8A&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">UUID=&quot;a89099a9-0852-4c43-bef3-07e3999ec597&quot;</span><br><span class="line">MASTER=bond1</span><br><span class="line">SLAVE=yes</span><br></pre></td></tr></table></figure><h2 id="配置bond网卡"><a href="#配置bond网卡" class="headerlink" title="配置bond网卡"></a>配置bond网卡</h2><p>子网卡配置完毕之后，我们开始配置bond网卡，vim创建文件，填入以下内容之后，保存退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx001 network-scripts]# vim ifcfg-bond1</span><br><span class="line">DEVICE=&quot;bond1&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">MTU=&quot;1500&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">IPADDR=103.13.244.21</span><br><span class="line">NETMASK=255.255.255.248</span><br><span class="line">GATEWAY=103.13.244.17</span><br><span class="line">DNS1=223.5.5.5</span><br><span class="line">DNS2=223.6.6.6</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Linux服务器双网卡bond配置
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="高并发" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="二层负载均衡" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/%E4%BA%8C%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="负载均衡" scheme="http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python流程控制</title>
    <link href="http://yoursite.com/2018/06/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/Python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/Python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2018/06/25/编程语言/Python/个人总结/Python流程控制/Python流程控制/</id>
    <published>2018-06-25T11:32:40.000Z</published>
    <updated>2018-06-25T11:32:40.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="tag1" scheme="http://yoursite.com/tags/tag1/"/>
    
  </entry>
  
  <entry>
    <title>Python数据运算</title>
    <link href="http://yoursite.com/2018/06/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/Python%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97/Python%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2018/06/25/编程语言/Python/个人总结/Python数据运算/Python数据运算/</id>
    <published>2018-06-25T11:32:11.000Z</published>
    <updated>2018-06-25T11:32:11.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="tag1" scheme="http://yoursite.com/tags/tag1/"/>
    
  </entry>
  
  <entry>
    <title>Python数据类型</title>
    <link href="http://yoursite.com/2018/06/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/06/25/编程语言/Python/个人总结/Python数据类型/Python数据类型/</id>
    <published>2018-06-25T11:29:33.000Z</published>
    <updated>2018-06-25T11:29:33.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="tag1" scheme="http://yoursite.com/tags/tag1/"/>
    
  </entry>
  
  <entry>
    <title>LVS+Keepalived配置文件模板</title>
    <link href="http://yoursite.com/2018/06/25/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/LVS/LVS-Keepalived%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2018/06/25/IT科学技术知识体系结构-Linux运维方向/高并发/负载均衡/LVS/LVS-Keepalived配置文件模板/</id>
    <published>2018-06-25T09:57:30.000Z</published>
    <updated>2018-06-25T09:57:30.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="tag1" scheme="http://yoursite.com/tags/tag1/"/>
    
  </entry>
  
  <entry>
    <title>LVS的三种工作模式</title>
    <link href="http://yoursite.com/2018/06/25/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/LVS/LVS%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/06/25/IT科学技术知识体系结构-Linux运维方向/高并发/负载均衡/LVS/LVS的三种工作模式/</id>
    <published>2018-06-25T09:51:40.000Z</published>
    <updated>2018-06-25T09:51:40.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="tag1" scheme="http://yoursite.com/tags/tag1/"/>
    
  </entry>
  
  <entry>
    <title>Chrome常用操作</title>
    <link href="http://yoursite.com/2018/06/25/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Chrome/Chrome%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/06/25/常用软件工具/Chrome/Chrome常用操作/</id>
    <published>2018-06-25T07:39:26.000Z</published>
    <updated>2018-06-25T07:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考文献：</strong></p><ul><li><a href="https://support.google.com/chrome/answer/157179?hl=zh-Hans" target="_blank" rel="noopener">chrome键盘快捷键</a></li></ul><hr><h1 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h1><h2 id="书签管理"><a href="#书签管理" class="headerlink" title="书签管理"></a>书签管理</h2><h3 id="书签管理器"><a href="#书签管理器" class="headerlink" title="书签管理器"></a>书签管理器</h3><p>ctrl+shift+o</p><h3 id="为此网页添加书签"><a href="#为此网页添加书签" class="headerlink" title="为此网页添加书签"></a>为此网页添加书签</h3><p>ctrl+d</p><h2 id="浏览器管理"><a href="#浏览器管理" class="headerlink" title="浏览器管理"></a>浏览器管理</h2><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>在搜索框中输入相对应的名称，然后tab</p><p>例如在搜索框中，输入：baidu.com 然后tab，然后再输入内容，此时就是使用百度搜索引擎来进行搜索。</p><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><h4 id="切换页面"><a href="#切换页面" class="headerlink" title="切换页面"></a>切换页面</h4><p>显示前一个标签页：ctrl+tab</p><p>显示后一个标签页：ctrl+shift+tab</p><h4 id="新增页面"><a href="#新增页面" class="headerlink" title="新增页面"></a>新增页面</h4><p>ctrl+t</p>]]></content>
    
    <summary type="html">
    
      Chrome常用操作
    
    </summary>
    
      <category term="常用软件工具" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Chrome" scheme="http://yoursite.com/categories/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Chrome/"/>
    
    
      <category term="Chrome" scheme="http://yoursite.com/tags/Chrome/"/>
    
  </entry>
  
</feed>
