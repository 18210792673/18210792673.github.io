<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watchmen1992&#39;s Blog</title>
  
  <subtitle>锦瑟年华当与书香为度，是为不负天地人生。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-31T08:49:42.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>XiaoHua WANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何自学计算机科学</title>
    <link href="http://yoursite.com/2018/12/31/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    <id>http://yoursite.com/2018/12/31/IT科学技术知识体系结构-Linux运维方向/IT基础知识/自学计算机科学/如何自学计算机科学/</id>
    <published>2018-12-31T08:49:42.000Z</published>
    <updated>2018-12-31T08:49:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1>]]></content>
    
    <summary type="html">
    
      “自学计算机科学“这个系列的文章将会是我工作经验的输出和对IT领域知识领悟后的抽象和提炼，可以说将会包含我个人最核心的思想（就计算机科学这一学科来说）。《如何自学计算机科学》这篇文章，后续如果记录的内容较多时可能会进行拆分；同样的，《IT技术学习网站及学习资料汇总》这篇文章可能也会进行拆分。但是不管怎么样，都是统一归类到“自学计算机科学“这一个系列当中
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="IT基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="自学计算机科学" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="计算机科学" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>IT技术学习网站及学习资料汇总</title>
    <link href="http://yoursite.com/2018/12/31/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/IT%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/12/31/IT科学技术知识体系结构-Linux运维方向/IT基础知识/自学计算机科学/IT技术学习网站及学习资料汇总/</id>
    <published>2018-12-31T08:46:00.000Z</published>
    <updated>2018-12-31T08:46:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文有2个目的：</p><ul><li>记录同级目录下的另一篇文章：《如何自学计算机科学》中所提及的资料，便于检索查找。</li><li>记录在学习及工作中所涉及到的相关网站或者书籍资料等。同样的，也是为了便于检索查找。</li></ul><h1 id="学习网站汇总"><a href="#学习网站汇总" class="headerlink" title="学习网站汇总"></a>学习网站汇总</h1><h1 id="学习资料汇总"><a href="#学习资料汇总" class="headerlink" title="学习资料汇总"></a>学习资料汇总</h1>]]></content>
    
    <summary type="html">
    
      “自学计算机科学“这个系列的文章将会是我工作经验的输出和对IT领域知识领悟后的抽象和提炼，可以说将会包含我个人最核心的思想（就计算机科学这一学科来说）。《如何自学计算机科学》这篇文章，后续如果记录的内容较多时可能会进行拆分；同样的，《IT技术学习网站及学习资料汇总》这篇文章可能也会进行拆分。但是不管怎么样，都是统一归类到“自学计算机科学“这一个系列当中
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="IT基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="自学计算机科学" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/IT%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="计算机科学" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>python可变参数args</title>
    <link href="http://yoursite.com/2018/12/20/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/python%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0args/"/>
    <id>http://yoursite.com/2018/12/20/IT科学技术知识体系结构-Linux运维方向/程序编程/Python/基础知识/python可变参数args/</id>
    <published>2018-12-20T11:18:57.000Z</published>
    <updated>2018-12-20T11:18:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>如果我们在函数被调用前并不知道也不限制将来函数可以接收的参数数量。在这种情况下我们可以使用<code>*args</code>和<code>**kwargs</code>来进行定义函数</p><p><code>*args</code>和<code>**kwargs</code>这两个是python中的可变参数。</p><ul><li><p>args表示任何多个无名参数，它是一个tuple</p></li><li><p>kwargs表示关键字参数，它是一个dict</p></li></ul><p><strong>特别注意：</strong></p><ul><li><p>同时使用<code>*args</code>和<code>**kwargs</code>时，<code>*args</code>参数要列在<code>**kwargs</code><strong>前</strong>。</p></li><li><p>因此像foo(a=1, b=’2’, c=3, a’, 1, None, )这样调用的话，会提示语法错误“SyntaxError: non-keyword arg after keyword arg”。</p></li><li><p>当两者同时存在时，正确的调用方式应该像是：foo(‘a’,1,a=1,b=2)</p></li><li><p>实际上真正的Python参数传递语法是<code>*</code>和<code>**</code>。<code>*args</code>和<code>**kwargs</code>只是一种约定俗成的编程实践。我们也可以写成<code>*vars</code>和<code>**kvars</code>。</p></li></ul><h1 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h1><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def test(*args,**kwargs):</span><br><span class="line">    print (&quot;args = &quot;,args)</span><br><span class="line">    print (&quot;kwargs = &quot;,kwargs)</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">test(1,2,3,4)</span><br><span class="line">test(&quot;11&quot;,&quot;2&quot;,a=1,b=2)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">args =  (1, 2, 3, 4)</span><br><span class="line">kwargs =  &#123;&#125;</span><br><span class="line">args =  (&apos;11&apos;, &apos;2&apos;)</span><br><span class="line">kwargs =  &#123;&apos;a&apos;: 1, &apos;b&apos;: 2&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      python可变参数args
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="python可变参数args" scheme="http://yoursite.com/tags/python%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0args/"/>
    
  </entry>
  
  <entry>
    <title>harbor镜像仓库实战</title>
    <link href="http://yoursite.com/2018/12/18/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker+k8s/harbor/"/>
    <id>http://yoursite.com/2018/12/18/IT科学技术知识体系结构-Linux运维方向/虚拟化/Docker+k8s/harbor/</id>
    <published>2018-12-18T02:52:05.000Z</published>
    <updated>2018-12-18T02:52:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">github主页</a></li></ul><h1 id="Harbor基础知识"><a href="#Harbor基础知识" class="headerlink" title="Harbor基础知识"></a>Harbor基础知识</h1><h2 id="Features-功能特性"><a href="#Features-功能特性" class="headerlink" title="Features-功能特性"></a>Features-功能特性</h2><ul><li><p><strong>Role based access control</strong>: Users and repositories are organized via ‘projects’ and a user can have different permission for images under a project.</p><blockquote><p>用户和镜像仓库是通过项目关联起来的，不同用户在该项目下拥有不同的权限</p></blockquote></li><li><p><strong>Policy based image replication</strong>: Images can be replicated (synchronized) between multiple registry instances, with auto-retry on errors. Great for load balancing, high availability, multi-datacenter, hybrid and multi-cloud scenarios.</p><blockquote><p>镜像将在多个注册实例中复制，实现高可用、负载均衡、多路选择等功能</p></blockquote></li><li><p><strong>Vulnerability Scanning</strong>: Harbor scans images regularly and warns users of vulnerabilities.</p><blockquote><p>高危扫描：harbor将会在规律的扫描镜像并且提醒用户相关的危险</p></blockquote></li><li><p><strong>LDAP/AD support</strong>: Harbor integrates with existing enterprise LDAP/AD for user authentication and management.</p><blockquote><p>harbor可以聚合企业现在的LDAP/AD等实现用户认证和管理</p></blockquote></li><li><p><strong>Image deletion &amp; garbage collection</strong>: Images can be deleted and their space can be recycled.</p><blockquote><p>镜像删除和垃圾收集</p></blockquote></li><li><p><strong>Notary</strong>: Image authenticity can be ensured.</p><blockquote><p>可以保证镜像的可靠性</p></blockquote></li><li><p><strong>Graphical user portal</strong>: User can easily browse, search repositories and manage projects.</p><blockquote><p>图形化的用户入口：可以浏览，检索，管理项目</p></blockquote></li><li><p><strong>Auditing</strong>: All the operations to the repositories are tracked.</p><blockquote><p>审计：所有的操作都可以被追踪</p></blockquote></li><li><p><strong>RESTful API</strong>: RESTful APIs for most administrative operations, easy to integrate with external systems.</p><blockquote><p>提供api</p></blockquote></li><li><p><strong>Easy deployment</strong>: Provide both an online and offline installer.</p><blockquote><p>部署简单，提供在线和离线两种安装方式</p></blockquote></li></ul><h2 id="Architecture-体系结构"><a href="#Architecture-体系结构" class="headerlink" title="Architecture-体系结构"></a>Architecture-体系结构</h2><p><img src="https://camo.githubusercontent.com/e0de62fb4f08efedd2c5abd44786410d3af06c7b/687474703a2f2f7777772e7468696e6b2d666f756e6472792e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30392f61727469636c65315f696d616765322e706e67" alt="img"></p><p>As depicted in the above diagram, Harbor comprises 6 components:</p><p><strong>Proxy:</strong> Components of Harbor, such as registry, UI and token services, are all behind a reversed proxy. The proxy forwards requests from browsers and Docker clients to various backend services.</p><blockquote><p>harbor使用代理结构，外部的客户端（浏览器或者docker client）访问调用是通过代理层去实现的</p></blockquote><p><strong>Registry:</strong> Responsible for storing Docker images and processing Docker push/pull commands. As Harbor needs to enforce access control to images, the Registry will direct clients to a token service to obtain a valid token for each pull or push request.</p><blockquote><p>注册部分：响应操作docker镜像的请求</p><p>harbor为了确保安全性，客户端在调用的时候，需要取得valid token才可以进行操作</p></blockquote><p><strong>Core services:</strong> Harbor’s core functions, which mainly provides the following services:</p><p><strong>UI:</strong> a graphical user interface to help users manage images on the Registry Webhook: Webhook is a mechanism configured in the Registry so that image status changes in the Registry can be populated to the Webhook endpoint of Harbor. Harbor uses webhook to update logs, initiate replications, and some other functions. Token service: Responsible for issuing a token for every docker push/pull command according to a user’s role of a project. If there is no token in a request sent from a Docker client, the Registry will redirect the request to the token service. Database: Database stores the meta data of projects, users, roles, replication policies and images.</p><blockquote><p>提供一个图形的用户入口，方便用户在注册钩子系统（registry webhook）中管理镜像。</p></blockquote><p><strong>Job services:</strong> used for image replication, local images can be replicated(synchronized) to other Harbor instances.</p><p><strong>Log collector:</strong> Responsible for collecting logs of other modules in a single place.</p><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><h2 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md" target="_blank" rel="noopener">官方安装手册</a></li></ul><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>Harbor is deployed as several Docker containers, and, therefore, can be deployed on any Linux distribution that supports Docker. The target host requires Python, Docker, and Docker Compose to be installed.</p><p>harbor是使用docker的方式部署的，整个harbor包含几个容器，因此能够部署在任何只要支持docker的Linux发行版本上。</p><p>目标主机只需要包含：python、docker、docker compose这3个东西即可</p><p><strong>Hardware</strong></p><table><thead><tr><th>Resource</th><th>Capacity</th><th>Description</th></tr></thead><tbody><tr><td>CPU</td><td>minimal 2 CPU</td><td>4 CPU is prefered</td></tr><tr><td>Mem</td><td>minimal 4GB</td><td>8GB is prefered</td></tr><tr><td>Disk</td><td>minimal 40GB</td><td>160GB is prefered</td></tr></tbody></table><p><strong>Software</strong></p><table><thead><tr><th>Software</th><th>Version</th><th>Description</th></tr></thead><tbody><tr><td>Python</td><td>version 2.7 or higher</td><td>Note that you may have to install Python on Linux distributions (Gentoo, Arch) that do not come with a Python interpreter installed by default</td></tr><tr><td>Docker engine</td><td>version 1.10 or higher</td><td>For installation instructions, please refer to: <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a></td></tr><tr><td>Docker Compose</td><td>version 1.6.0 or higher</td><td>For installation instructions, please refer to: <a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">https://docs.docker.com/compose/install/</a></td></tr><tr><td>Openssl</td><td>latest is prefered</td><td>Generate certificate and keys for Harbor</td></tr></tbody></table><p><strong>Network ports</strong></p><table><thead><tr><th>Port</th><th>Protocol</th><th>Description</th></tr></thead><tbody><tr><td>443</td><td>HTTPS</td><td>Harbor UI and API will accept requests on this port for https protocol</td></tr><tr><td>4443</td><td>HTTPS</td><td>Connections to the Docker Content Trust service for Harbor, only needed when Notary is enabled</td></tr><tr><td>80</td><td>HTTP</td><td>Harbor UI and API will accept requests on this port for http protocol</td></tr></tbody></table><p>官方的安装步骤（The installation steps boil down to the following）：</p><ol><li>Download the installer;</li><li>Configure <strong>harbor.cfg</strong>;</li><li>Run <strong>install.sh</strong> to install and start Harbor;</li></ol><p>下面我们开始实际操作</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><h3 id="下载并解压"><a href="#下载并解压" class="headerlink" title="下载并解压"></a>下载并解压</h3><p><a href="https://github.com/goharbor/harbor/releases" target="_blank" rel="noopener">所有软件包的下载地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xvf harbor-online-installer-&lt;version&gt;.tgz</span><br></pre></td></tr></table></figure><p>当前节点我使用的是harbor.v1.4.0.tar.gz</p><h3 id="安装docker-ce"><a href="#安装docker-ce" class="headerlink" title="安装docker-ce"></a>安装docker-ce</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># sudo yum install -y yum-utils   device-mapper-persistent-data   lvm2</span><br><span class="line"></span><br><span class="line"># sudo yum-config-manager     --add-repo     https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># sudo yum install docker-ce</span><br></pre></td></tr></table></figure><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start  docker</span><br><span class="line"># systemctl enable  docker</span><br></pre></td></tr></table></figure><h3 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># docker-compose --version</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置概述"><a href="#配置概述" class="headerlink" title="配置概述"></a>配置概述</h3><p>Configuration parameters are located in the file <strong>harbor.cfg</strong></p><p>There are two categories of parameters in harbor.cfg, <strong>required parameters</strong> and <strong>optional parameters</strong>.</p><ul><li><p><strong>required parameters</strong>: These parameters are required to be set in the configuration file. They will take effect if a user updates them in <code>harbor.cfg</code> and run the <code>install.sh</code> script to reinstall Harbor.</p></li><li><p><strong>optional parameters</strong>: These parameters are optional for updating, i.e. user can leave them as default and update them on Web UI after Harbor is started. If they are set in <code>harbor.cfg</code>, they only take effect in the first launch of Harbor. Subsequent update to these parameters in <code>harbor.cfg</code> will be ignored.</p><p><strong>Note:</strong> If you choose to set these parameters via the UI, be sure to do so right after Harbor is started. In particular, you must set the desired <strong>auth_mode</strong> before registering or creating any new users in Harbor. When there are users in the system (besides the default admin user), <strong>auth_mode</strong> cannot be changed.</p></li></ul><p>配置文件中有2种配置内容，一种是必须配置的参数，一种是可选参数</p><ul><li>必须参数：这是是在配置文件当中必须要存在的参数，当用户修改之后并且重新安装harbor之后生效</li><li>可选参数：这些参数是可以动态更新的，你能够在harbor启动之后，在web界面中进行更新。但是如果你把这些参数直接配置在harbor.cfg配置文件中（默认的配置不算人为配置了），它们只能在你第一次启动harbor的时候加载生效，之后再更新参数将不会生效。这一点需要尤为注意<ul><li>注意1：你使用动态的可选参数方式的时候，首先要确认harbor已经启动</li><li>注意2：有一个特别需要注意的参数，当有用户（除了默认的管理员用户）已经存在于harbor中的时候，<strong>auth_mode</strong>这个参数是不能被修改的。所以你需要在有新的用户注册进harbor之前，设置好认证模式（auth_mode）</li></ul></li></ul><h3 id="配置文件参数详解"><a href="#配置文件参数详解" class="headerlink" title="配置文件参数详解"></a>配置文件参数详解</h3><h4 id="Required-parameters-必需参数"><a href="#Required-parameters-必需参数" class="headerlink" title="Required parameters-必需参数"></a>Required parameters-必需参数</h4><ul><li><p><strong>hostname</strong>: The target host’s hostname, which is used to access the UI and the registry service. It should be the IP address or the fully qualified domain name (FQDN) of your target machine, e.g., <code>192.168.1.10</code> or <code>reg.yourdomain.com</code>. <em>Do NOT use localhost or 127.0.0.1 for the hostname - the registry service needs to be accessible by external clients!</em></p><blockquote><p><strong>hostname一般配置为域名</strong>,也就是整个harbor的入口</p></blockquote></li><li><p><strong>ui_url_protocol</strong>: (<strong>http</strong> or <strong>https</strong>. Default is <strong>http</strong>) The protocol used to access the UI and the token/notification service. If Notary is enabled, this parameter has to be <em>https</em>. By default, this is <em>http</em>. To set up the https protocol, refer to <strong>Configuring Harbor with HTTPS Access</strong>.</p><blockquote><p><strong>走HTT还是HTTPS</strong></p></blockquote></li><li><p><strong>db_password</strong>: The root password for the MySQL database used for <strong>db_auth</strong>. <em>Change this password for any production use!</em></p></li><li><p><strong>max_job_workers</strong>: (default value is <strong>3</strong>) The maximum number of replication workers in job service. For each image replication job, a worker synchronizes all tags of a repository to the remote destination. Increasing this number allows more concurrent replication jobs in the system. However, since each worker consumes a certain amount of network/CPU/IO resources, please carefully pick the value of this attribute based on the hardware resource of the host.</p><blockquote><p><strong>做复制工作的进程数量，默认3个，这些进程，将这些镜像同步到远端的存储中</strong></p><p>每个进程都需要消耗系统的资源，因此合理设置数量</p></blockquote></li><li><p><strong>customize_crt</strong>: (<strong>on</strong> or <strong>off</strong>. Default is <strong>on</strong>) When this attribute is <strong>on</strong>, the prepare script creates private key and root certificate for the generation/verification of the registry’s token. Set this attribute to <strong>off</strong> when the key and root certificate are supplied by external sources. Refer to <a href="https://github.com/goharbor/harbor/blob/master/docs/customize_token_service.md" target="_blank" rel="noopener">Customize Key and Certificate of Harbor Token Service</a> for more info.</p></li><li><p><strong>ssl_cert</strong>: The path of SSL certificate, it’s applied only when the protocol is set to https</p></li><li><p><strong>ssl_cert_key</strong>: The path of SSL key, it’s applied only when the protocol is set to https</p></li><li><p><strong>secretkey_path</strong>: The path of key for encrypt or decrypt the password of a remote registry in a replication policy.</p></li><li><p><strong>log_rotate_count</strong>: Log files are rotated <strong>log_rotate_count</strong> times before being removed. If count is 0, old versions are removed rather than rotated.</p></li><li><p><strong>log_rotate_size</strong>: Log files are rotated only if they grow bigger than <strong>log_rotate_size</strong> bytes. If size is followed by k, the size is assumed to be in kilobytes. If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G are all valid.</p></li></ul><h4 id="optional-parameters-动态可选参数"><a href="#optional-parameters-动态可选参数" class="headerlink" title="optional parameters-动态可选参数"></a>optional parameters-动态可选参数</h4><h2 id="harbor启动"><a href="#harbor启动" class="headerlink" title="harbor启动"></a>harbor启动</h2><p>修改完毕之后的配置如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@app028-dev harbor]# less harbor.cfg  | egrep -v &apos;^$|^#&apos;</span><br><span class="line">hostname = dhub-dev.dwbops.com</span><br><span class="line">ui_url_protocol = https</span><br><span class="line">max_job_workers = 3</span><br><span class="line">customize_crt = on</span><br><span class="line">ssl_cert = /data/cert/server.cer</span><br><span class="line">ssl_cert_key = /data/cert/server.key</span><br><span class="line">secretkey_path = /data</span><br><span class="line">admiral_url = NA</span><br><span class="line">log_rotate_count = 50</span><br><span class="line">log_rotate_size = 200M</span><br><span class="line">email_identity =</span><br><span class="line">email_server = smtp.mydomain.com</span><br><span class="line">email_server_port = 25</span><br><span class="line">email_username = sample_admin@mydomain.com</span><br><span class="line">email_password = abc</span><br><span class="line">email_from = admin &lt;sample_admin@mydomain.com&gt;</span><br><span class="line">email_ssl = false</span><br><span class="line">email_insecure = false</span><br><span class="line">harbor_admin_password = dHarbor12345</span><br><span class="line">auth_mode = db_auth</span><br><span class="line">ldap_url = ldaps://ldap.mydomain.com</span><br><span class="line">ldap_basedn = ou=people,dc=mydomain,dc=com</span><br><span class="line">ldap_uid = uid</span><br><span class="line">ldap_scope = 2</span><br><span class="line">ldap_timeout = 5</span><br><span class="line">ldap_verify_cert = true</span><br><span class="line">self_registration = on</span><br><span class="line">token_expiration = 30</span><br><span class="line">project_creation_restriction = everyone</span><br><span class="line">db_host = mysql</span><br><span class="line">db_password = root123</span><br><span class="line">db_port = 3306</span><br><span class="line">db_user = root</span><br><span class="line">redis_url =</span><br><span class="line">clair_db_host = postgres</span><br><span class="line">clair_db_password = password</span><br><span class="line">clair_db_port = 5432</span><br><span class="line">clair_db_username = postgres</span><br><span class="line">clair_db = postgres</span><br><span class="line">uaa_endpoint = uaa.mydomain.org</span><br><span class="line">uaa_clientid = id</span><br><span class="line">uaa_clientsecret = secret</span><br><span class="line">uaa_verify_cert = true</span><br><span class="line">uaa_ca_cert = /path/to/ca.pem</span><br><span class="line">registry_storage_provider_name = filesystem</span><br><span class="line">registry_storage_provider_config =</span><br></pre></td></tr></table></figure><p>自己做测试时，将url类型设置成为http，并且将域名设置成为了：harbor.wxh.com</p><p>修改完配置之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./install.sh</span><br></pre></td></tr></table></figure><p>整个的安装过程如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost harbor]# ./install.sh</span><br><span class="line"></span><br><span class="line">[Step 0]: checking installation environment ...</span><br><span class="line"></span><br><span class="line">Note: docker version: 18.06.1</span><br><span class="line"></span><br><span class="line">Note: docker-compose version: 1.22.0</span><br><span class="line"></span><br><span class="line">[Step 1]: loading Harbor images ...</span><br><span class="line">651f69aef02c: Loading layer [==================================================&gt;]  135.8MB/135.8MB</span><br><span class="line">40a1aad64343: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">3fe2713e4072: Loading layer [==================================================&gt;]  12.16MB/12.16MB</span><br><span class="line">ba3a1eb0e375: Loading layer [==================================================&gt;]   17.3MB/17.3MB</span><br><span class="line">447427ec5e1a: Loading layer [==================================================&gt;]  15.87kB/15.87kB</span><br><span class="line">4ccb4026663c: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">16faa95946a1: Loading layer [==================================================&gt;]  29.46MB/29.46MB</span><br><span class="line">Loaded image: vmware/notary-server-photon:v0.5.1-v1.4.0</span><br><span class="line">fa7ba9fd42c9: Loading layer [==================================================&gt;]  10.95MB/10.95MB</span><br><span class="line">4e400f9ae23e: Loading layer [==================================================&gt;]   17.3MB/17.3MB</span><br><span class="line">2802fb27c88b: Loading layer [==================================================&gt;]  15.87kB/15.87kB</span><br><span class="line">e6367a4e1e1e: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">8ece8dfcdd98: Loading layer [==================================================&gt;]  28.24MB/28.24MB</span><br><span class="line">Loaded image: vmware/notary-signer-photon:v0.5.1-v1.4.0</span><br><span class="line">a7dd1a8afcaf: Loading layer [==================================================&gt;]  396.7MB/396.7MB</span><br><span class="line">05adebbe496f: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">86eb534949fa: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">d7f127c69380: Loading layer [==================================================&gt;]   7.68kB/7.68kB</span><br><span class="line">5ac1c4dc5ee9: Loading layer [==================================================&gt;]  1.536kB/1.536kB</span><br><span class="line">d0bec56b5b1a: Loading layer [==================================================&gt;]  9.728kB/9.728kB</span><br><span class="line">4bbe83860556: Loading layer [==================================================&gt;]   2.56kB/2.56kB</span><br><span class="line">e526f9e6769f: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">Loaded image: vmware/harbor-db:v1.4.0</span><br><span class="line">1cff102bbda2: Loading layer [==================================================&gt;]  154.1MB/154.1MB</span><br><span class="line">04c9f3e07de1: Loading layer [==================================================&gt;]  10.75MB/10.75MB</span><br><span class="line">7b6c7bf54f5c: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">42f8acdb7fe3: Loading layer [==================================================&gt;]  48.13kB/48.13kB</span><br><span class="line">5b6299d0a1df: Loading layer [==================================================&gt;]   10.8MB/10.8MB</span><br><span class="line">Loaded image: vmware/clair-photon:v2.0.1-v1.4.0</span><br><span class="line">6534131f457c: Loading layer [==================================================&gt;]  94.76MB/94.76MB</span><br><span class="line">73f582101e4b: Loading layer [==================================================&gt;]  6.656kB/6.656kB</span><br><span class="line">86d847823c48: Loading layer [==================================================&gt;]  6.656kB/6.656kB</span><br><span class="line">Loaded image: vmware/postgresql-photon:v1.4.0</span><br><span class="line">5cd250d5a352: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">ad3fd52b54f3: Loading layer [==================================================&gt;]  14.99MB/14.99MB</span><br><span class="line">13b1e24cc368: Loading layer [==================================================&gt;]  14.99MB/14.99MB</span><br><span class="line">Loaded image: vmware/harbor-adminserver:v1.4.0</span><br><span class="line">c26c69706710: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">223f6fe02cc8: Loading layer [==================================================&gt;]  23.45MB/23.45MB</span><br><span class="line">1fc843c8698a: Loading layer [==================================================&gt;]  7.168kB/7.168kB</span><br><span class="line">e09293610ee7: Loading layer [==================================================&gt;]  10.39MB/10.39MB</span><br><span class="line">d59f9780b1d8: Loading layer [==================================================&gt;]  23.44MB/23.44MB</span><br><span class="line">Loaded image: vmware/harbor-ui:v1.4.0</span><br><span class="line">dd4753242e59: Loading layer [==================================================&gt;]  73.07MB/73.07MB</span><br><span class="line">95aed61ca251: Loading layer [==================================================&gt;]  3.584kB/3.584kB</span><br><span class="line">1864f9818562: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">da2a19f80b81: Loading layer [==================================================&gt;]  4.096kB/4.096kB</span><br><span class="line">058531639e75: Loading layer [==================================================&gt;]  3.584kB/3.584kB</span><br><span class="line">a84e69fb619b: Loading layer [==================================================&gt;]  10.24kB/10.24kB</span><br><span class="line">Loaded image: vmware/harbor-log:v1.4.0</span><br><span class="line">b1056051f246: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">07678065e08b: Loading layer [==================================================&gt;]  19.19MB/19.19MB</span><br><span class="line">a2d9bdb8f5fb: Loading layer [==================================================&gt;]  19.19MB/19.19MB</span><br><span class="line">Loaded image: vmware/harbor-jobservice:v1.4.0</span><br><span class="line">7f58ce57cd5e: Loading layer [==================================================&gt;]  4.805MB/4.805MB</span><br><span class="line">Loaded image: vmware/nginx-photon:v1.4.0</span><br><span class="line">4c8965978b77: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">1466c942edde: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">ac5c17331735: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">86824c7c466a: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">fd3bd0e70d67: Loading layer [==================================================&gt;]   22.8MB/22.8MB</span><br><span class="line">b02195d77636: Loading layer [==================================================&gt;]   22.8MB/22.8MB</span><br><span class="line">Loaded image: vmware/registry-photon:v2.6.2-v1.4.0</span><br><span class="line">Loaded image: vmware/photon:1.0</span><br><span class="line">Loaded image: vmware/mariadb-photon:v1.4.0</span><br><span class="line">454c81edbd3b: Loading layer [==================================================&gt;]  135.2MB/135.2MB</span><br><span class="line">e99db1275091: Loading layer [==================================================&gt;]  395.4MB/395.4MB</span><br><span class="line">051e4ee23882: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">6cca4437b6f6: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">1d48fc08c8bc: Loading layer [==================================================&gt;]   7.68kB/7.68kB</span><br><span class="line">0419724fd942: Loading layer [==================================================&gt;]  1.536kB/1.536kB</span><br><span class="line">526b2156bd7a: Loading layer [==================================================&gt;]  637.8MB/637.8MB</span><br><span class="line">9ebf6900ecbd: Loading layer [==================================================&gt;]  78.34kB/78.34kB</span><br><span class="line">Loaded image: vmware/harbor-db-migrator:1.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Step 2]: preparing environment ...</span><br><span class="line">Generated and saved secret to file: /data/secretkey</span><br><span class="line">Generated configuration file: ./common/config/nginx/nginx.conf</span><br><span class="line">Generated configuration file: ./common/config/adminserver/env</span><br><span class="line">Generated configuration file: ./common/config/ui/env</span><br><span class="line">Generated configuration file: ./common/config/registry/config.yml</span><br><span class="line">Generated configuration file: ./common/config/db/env</span><br><span class="line">Generated configuration file: ./common/config/jobservice/env</span><br><span class="line">Generated configuration file: ./common/config/log/logrotate.conf</span><br><span class="line">Generated configuration file: ./common/config/jobservice/app.conf</span><br><span class="line">Generated configuration file: ./common/config/ui/app.conf</span><br><span class="line">Generated certificate, key file: ./common/config/ui/private_key.pem, cert file: ./common/config/registry/root.crt</span><br><span class="line">The configuration files are ready, please use docker-compose to start the service.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Step 3]: checking existing instance of Harbor ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Step 4]: starting Harbor ...</span><br><span class="line">Creating network &quot;harbor_harbor&quot; with the default driver</span><br><span class="line">Creating harbor-log ... done</span><br><span class="line">Creating harbor-db          ... done</span><br><span class="line">Creating registry           ... done</span><br><span class="line">Creating harbor-adminserver ... done</span><br><span class="line">Creating harbor-ui          ... done</span><br><span class="line">Creating nginx              ... done</span><br><span class="line">Creating harbor-jobservice  ... done</span><br><span class="line"></span><br><span class="line">✔ ----Harbor has been installed and started successfully.----</span><br><span class="line"></span><br><span class="line">Now you should be able to visit the admin portal at http://harbor.wxh.com.</span><br><span class="line">For more details, please visit https://github.com/vmware/harbor .</span><br><span class="line"></span><br><span class="line">[root@localhost harbor]#</span><br></pre></td></tr></table></figure><h1 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h1><h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><p>push的格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker push reg.yourdomain.com/myproject/myrepo:mytag</span><br></pre></td></tr></table></figure><p>注意首先需要登录： docker login domain_name</p><p><strong>步骤1：登录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login domain_name</span><br></pre></td></tr></table></figure><p><strong>步骤2：将要上传的镜像打上标志</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker tag hello-world harbor.wxh.com/apps/hello-world</span><br><span class="line"></span><br><span class="line"># docker push harbor.wxh.com/apps/hello-world</span><br></pre></td></tr></table></figure><p>这种上传的话，默认是打上latest的标志</p><p>打上指定的标签使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag hello-world harbor.wxh.com/apps/hello-world:v1</span><br><span class="line">docker push harbor.wxh.com/apps/hello-world:v1</span><br></pre></td></tr></table></figure><h2 id="harbor镜像删除"><a href="#harbor镜像删除" class="headerlink" title="harbor镜像删除"></a>harbor镜像删除</h2><p>在web页面上删除镜像实际上只是执行的软删除，因为镜像存在很强的文件系统依赖关系</p><p>Harbor的UI界面上先删除镜像，但这个操作并没有删除磁盘上存放的镜像文件，只是镜像文件manifest的映射关系，还需要通过GC来删除。</p><p><strong>CAUTION: If both tag A and tag B refer to the same image, after deleting tag A, B will also get deleted. if you enabled content trust, you need to use notary command line tool to delete the tag’s signature before you delete an image.</strong></p><p>注意，如果标签A和B都指向都一个镜像（比如hello-world的2个镜像），那么删除一个之后，另外一个也会消失</p><p><strong>步骤1：删除镜像tag</strong></p><p>在web页面删除镜像或者使用api接口进行删除</p><p><strong>步骤2：停止Harbor</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><p><strong>步骤3：执行gc回收空间</strong></p><ul><li>通过带有–dry-run选项，可以<strong>查看</strong>到将要删除的镜像文件：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name gc --rm --volumes-from registry vmware/registry:2.6.2-photon garbage-collect --dry-run /etc/registry/config.yml1</span><br></pre></td></tr></table></figure><ul><li>不带–dry-run选项，直接<strong>执行删除</strong>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name gc --rm --volumes-from registry vmware/registry:2.6.2-photon garbage-collect /etc/registry/config.yml1</span><br></pre></td></tr></table></figure><p><strong>步骤4：启动Harbor</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose start</span><br></pre></td></tr></table></figure><h2 id="镜像清理策略"><a href="#镜像清理策略" class="headerlink" title="镜像清理策略"></a>镜像清理策略</h2><p>需求：</p><ul><li>暂时不做删除 repo 的处理【这部分手动处理】</li><li>保留 60 天内创建的所有 tag ，在 60 天之前创建的 tag ，额外保留 10 个；</li><li>标签数只有 1的镜像，不清理</li><li>保留最后一次更新的tag，有些image比较稳定，有可能超过60天都没有修改，但是却一直在用</li><li>针对一些特殊的（比如每天5个tag的镜像，那么60天就有300个），这个单独特殊处理</li></ul><p>最终：</p><ul><li>针对 tag ：保留 60 天内创建的所有 tag ，在 60 天之前创建的 tag ，额外保留 10 个；</li><li>针对 repo ：暂时不做删除 repo 的处理（不太好确定 repo 是否还在使用，理论上讲每个 repo 下至少应该有一个 tag 是被需要的；若打算删除，则建议 repo 负责人自行进行删除操作）；</li><li>私有仓库暂时不做处理；</li></ul><p><strong>具体实现：</strong></p><ul><li>harbor 主要概念的关系：1 个 project -&gt; 每个 project 下具有 N 种不同的 repos &gt; 每个 repo 下具有 M 个 tags</li><li>project 有创建时间，但这个对我们的处理策略来说没有用处；</li><li>repo 有创建时间和 pull 时间，该 pull 时间对应 repo 下任意一个 tag ，最新一次，被拉取的那个时间</li><li>tag 有创建时间，但没有针对 tag 的 pull 时间（harbor 中定义的数据结构中不支持）；</li></ul><p>因此</p><ul><li>保留 60 天内的 tag”，这个根据 tag 的创建时间</li><li>“60 天之外的看 pull 的数量，关注 60 天之外是不是被 pull 过”，由于 pull 数量是针对 repo 整体的，无法对应到具体的 tag ，即在 API 层面无法方便的知道哪些 tag 最近被 pull 过（当然如果一定要做，就只能沟通分析 log 来搞，性价比不高），所以，只能根据 tag 创建时间的先后，“武断”的认为，后创建的 tag 应该是用户最想保留的；</li><li>“如果没有被 pull 过，则只保留最新 5 个 tag”，根据上一条的说明，某个 tag 是否被 pull 过是无法知道的，但目前可以做到根据 tag 的创建时间进行保留（满足保留最新 N 个需求）；</li></ul><h1 id="Harborclient-harbor客户端命令"><a href="#Harborclient-harbor客户端命令" class="headerlink" title="Harborclient-harbor客户端命令"></a>Harborclient-harbor客户端命令</h1><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ul><li><a href="https://github.com/int32bit/python-harborclient/blob/master/README.zh.md" target="_blank" rel="noopener">主页说明</a></li></ul><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><h1 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h1><h2 id="harbor镜像复制"><a href="#harbor镜像复制" class="headerlink" title="harbor镜像复制"></a>harbor镜像复制</h2><h3 id="参考文献-2"><a href="#参考文献-2" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://github.com/goharbor/harbor/blob/master/docs/user_guide.md" target="_blank" rel="noopener">官网文档</a></li></ul><h3 id="镜像复制概述"><a href="#镜像复制概述" class="headerlink" title="镜像复制概述"></a>镜像复制概述</h3><p>镜像复制有一些基本的概念需要知晓：</p><ul><li><p>该功能是<strong>面向项目</strong>的，系统管理员设置之后，匹配了过滤规则的项目，在触发了事先定义好的触发条件之后，这些项目就会被复制到远程的另一个仓库中。</p></li><li><p>如果在远程镜像仓库中，该项目不存在，那么就会自动创建这个项目</p></li><li><p>如果在远程仓库中，这个项目已经存在，并且配置的用户对这个项目没有写的权限，那么这个操作将会失败</p></li><li>因为网络的原因，在复制传输的过程中，可能会出现一些延迟。如果复制job是因为网络原因而导致失败的，那么这个任务将会在几分钟之后再次尝试，一直尝试，知道网络恢复正常。</li></ul><p><strong>注意：</strong></p><ul><li><p>因为api等原因，不同版本的镜像复制可能会失败，所以尽量使用同一个版本。</p></li><li><p>用户信息不会被复制</p></li></ul><h3 id="创建复制规则"><a href="#创建复制规则" class="headerlink" title="创建复制规则"></a>创建复制规则</h3><p>注意，在创建endpoint的时候，直接test connection是会报错：“harbor Failed to ping endpoint”</p><p>这是因为网络问题导致，在内网访问的时候，还需要额外的添加hosts文件，详见注意事项</p><p>注意：在创建完毕之后，默认不会执行同步，需要手动点击一下replication</p><h3 id="删除replication规则"><a href="#删除replication规则" class="headerlink" title="删除replication规则"></a>删除replication规则</h3><p>删除规则的时候有几个注意事项：</p><ul><li><p>Only rules which have no pending/running/retrying jobs can be deleted.</p><p>也就是说，只有当改规则下面没有正在运行或者等待运行或者正在重传的jobs时，才可以删除</p></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在创建endpoint的时候，如果事先没有在容器内存配置对端的地址，那么会报连接错误</p><p>官方的issues：<a href="https://github.com/goharbor/harbor/issues/2221" target="_blank" rel="noopener">https://github.com/goharbor/harbor/issues/2221</a></p><h2 id="harbor迁移"><a href="#harbor迁移" class="headerlink" title="harbor迁移"></a>harbor迁移</h2><h3 id="节点完全迁移"><a href="#节点完全迁移" class="headerlink" title="节点完全迁移"></a>节点完全迁移</h3><h3 id="存储迁移"><a href="#存储迁移" class="headerlink" title="存储迁移"></a>存储迁移</h3><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="证书问题"><a href="#证书问题" class="headerlink" title="证书问题"></a>证书问题</h2><p>证书生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -sha256 -x509 -days 365 -nodes -newkey rsa:4096 -keyout  harbor.wxh.com.key -out harbor.wxh.com.crt</span><br></pre></td></tr></table></figure><p>注意，一些name的字段要配置成为配置文件中配置的域名，例如：harbor.wxh.com</p><p>生成之后，将证书存放到指定位置，然后修改配置文件指向这些证书文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">less harbor.cfg  | egrep -v &quot;^$|^#&quot;</span><br><span class="line">ssl_cert = /data/cert/harbor.wxh.com.crt</span><br><span class="line">ssl_cert_key = /data/cert/harbor.wxh.com.key</span><br></pre></td></tr></table></figure><p>然后需要对docker进行一些配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker/certs.d/harbor.wxh.com</span><br></pre></td></tr></table></figure><p>然后将上面的2个证书文件复制到这个目录之下，并将/data/cert/harbor.wxh.com.crt重命名为/data/cert/harbor.wxh.com.cert</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># pwd;ls</span><br><span class="line">/etc/docker/certs.d/harbor.wxh.com</span><br><span class="line">harbor.wxh.com.crt harbor.wxh.com.key</span><br><span class="line"></span><br><span class="line"># mv harbor.wxh.com.crt harbor.wxh.com.cert</span><br></pre></td></tr></table></figure><h2 id="文件创建为目录问题"><a href="#文件创建为目录问题" class="headerlink" title="文件创建为目录问题"></a>文件创建为目录问题</h2><p>/data1/harbor/data/secretkey  </p><p>在harbor安装之后以及运行过程中，secretkey为文件，而不是目录。</p><p>在一些异常情况可能会出现这个文件变成目录这种问题，当出现这种问题的时候，将该目录清空，然后重新安装即可</p>]]></content>
    
    <summary type="html">
    
      harbor镜像仓库实战
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="虚拟化" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Docker+k8s" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker-k8s/"/>
    
    
      <category term="harbor" scheme="http://yoursite.com/tags/harbor/"/>
    
  </entry>
  
  <entry>
    <title>python操作MySQL</title>
    <link href="http://yoursite.com/2018/12/13/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/python%E6%93%8D%E4%BD%9CMySQL/"/>
    <id>http://yoursite.com/2018/12/13/IT科学技术知识体系结构-Linux运维方向/程序编程/Python/基础知识/python操作MySQL/</id>
    <published>2018-12-13T14:01:29.000Z</published>
    <updated>2018-12-13T14:01:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="http://www.runoob.com/python/python-mysql.html" target="_blank" rel="noopener">菜鸟教程</a></li></ul><h1 id="实例案例"><a href="#实例案例" class="headerlink" title="实例案例"></a>实例案例</h1><p>在py3中，我们一般使用pymysql这个客户端去连接mysql数据库</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><h2 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h2>]]></content>
    
    <summary type="html">
    
      python操作MySQL
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="python操作MySQL" scheme="http://yoursite.com/tags/python%E6%93%8D%E4%BD%9CMySQL/"/>
    
  </entry>
  
  <entry>
    <title>异地多活-多机房bind部署</title>
    <link href="http://yoursite.com/2018/12/12/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/DNS%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0-bind/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB-%E5%A4%9A%E6%9C%BA%E6%88%BFbind%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/12/12/IT科学技术知识体系结构-Linux运维方向/网络知识及网络服务/网络服务/DNS服务实现-bind/异地多活-多机房bind部署/</id>
    <published>2018-12-12T06:20:18.000Z</published>
    <updated>2018-12-12T06:20:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>有关bind的一些部署，请查看我在该目录下的其他文章</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在实现多机房异地多活时，将服务分散到多个机房之后，一个核心的问题就是自建DNS，实现根据不同来源的ip段，返回相对应zone中的nginx服务端ip地址，只有这样才能</p><h1 id="需求概述"><a href="#需求概述" class="headerlink" title="需求概述"></a>需求概述</h1><p><strong>需要实现的功能如下：</strong></p><ul><li>DNS服务端采取主从结构，阿里云端为master，IDC机房端为slave，数据保持一致</li><li>阿里云VPC内网IP地址作为dns客户端访问时，返回VPC内机房的nginx服务器IP地址</li><li>IDC机房内网IP地址作为dns客户端访问时，返回IDC机房的nginx服务器IP地址</li><li>杭州的公网IP地址访问SLB的公网地址，上海的公网IP地址访问IDC机房的IP地址</li><li>总结：dns客户端请求到的永远是最距离最近服务器</li></ul><h1 id="bind部署需要明确的几个问题"><a href="#bind部署需要明确的几个问题" class="headerlink" title="bind部署需要明确的几个问题"></a>bind部署需要明确的几个问题</h1><ol><li><p>主从关系</p><p>暂定：阿里云为主，其他为从</p></li><li><p>服务器配置</p><ul><li>阿里云端需要重新购置机器吗？是的话可用区及配置？</li><li>IDC机房端的机器规划，挑一台common机器</li></ul></li><li><p>匹配ip转发规则</p><ul><li>根据阿里云网段、机房网段等不同网段进行匹配转发</li><li>dns客户端请求域名之后，分别返回阿里云nginx服务的地址，机房的nginx服务器对应的vip</li><li>因此，阿里云端的请求的域名就有2条记录，机房端就一条记录</li></ul></li><li><p>服务器端dns服务器配置</p><p>服务端预计配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/resolv.conf</span><br><span class="line">nameserver 机房1dns服务器ip </span><br><span class="line">nameserver 机房2dns服务器ip</span><br></pre></td></tr></table></figure><p>所有的dns客户端，在请求dns服务的时候 ，可能会连接到距离较远的服务器，但是获取记录之后将不会有影响。这里的第一次开销就保持这样吗？还是说这个也需要做优化，暂时没想到太好的方法</p></li><li><p>域名记录同步实现方式【这个目前是主要矛盾】</p><ul><li>数据源为dnspod</li><li>如何同步dnspod上的记录到自建dns（我的想法：每隔3/5分钟去调用dnspod的api获取结果，根据对应的公网ip，去判断是阿里云还是机房的记录，然后追加进对应的zone数据文件，并且增大复制偏移量的值）</li><li>那么这个时候就存在一个问题：当一个域名只存在一个地方的时候，其他地域的主机将无法访问，因为没有记录到对应的zone数据文件中。所以需要每个地域都配置并且注册到dnspod上</li></ul></li><li><p>主服务器有数据更新之后，触发通知的实现方式</p><p>我这边看下是否有更好的方式，没有的话暂时使用reload的方式</p></li><li><p>移动端配置？</p><p>移动端需要考虑吗？</p></li></ol><p>总结：</p><ul><li>阿里云走内网的slb</li></ul><p>并不是所有的域名都需要配置成为多机房，只有一些特定的域名需要配置成为多记录的方式</p><p>当只有一条记录的时候，我们所有的配置文件中都配置成为这一个记录</p><p>当有3条记录的时候，我们将数据分发到3个配置文件当中</p><p>当只有一条记录的时候，每个数据文件都记录这个内容，保证解析成功</p><h1 id="架构规划这里是拓扑图"><a href="#架构规划这里是拓扑图" class="headerlink" title="架构规划这里是拓扑图"></a>架构规划这里是拓扑图</h1><p>讲解</p><ol><li>主从结构</li><li>Bind 视图和zone功能，实现根据来源ip进行判断</li><li>现在的所有域名导入</li></ol><h1 id="部署实施"><a href="#部署实施" class="headerlink" title="部署实施"></a>部署实施</h1><h2 id="目录分层"><a href="#目录分层" class="headerlink" title="目录分层"></a>目录分层</h2><p>并不是所有的域名都需要根据地域不同返回不同的ip</p><p>我们根据不不同的地域创建了不同的zone目录，目录下有相同名称的zone数据文件</p><p>所以这个时候我们就可以进行匹配，当匹配到一个域名只有一个解析ip的时候，我们就把这条记录写入到3个不同的目录下的相同域名zone文件中</p><p>当匹配到有3个解析ip的时候，我们就对这个信息做处理，把对应的ip写入到对应的目录下的zone文件当中。</p><h2 id="zone配置"><a href="#zone配置" class="headerlink" title="zone配置"></a>zone配置</h2><h3 id="common"><a href="#common" class="headerlink" title="common"></a>common</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 common]$ pwd;ls</span><br><span class="line">/home/named/bind/chroot/var/named/zone/common</span><br><span class="line">dwb.dgt.zone  dwd.gds-sh.zone  ecs.east1-b.zone  ecs.east1-e.zone  ecs.east1-g.zone</span><br></pre></td></tr></table></figure><p>zone文件配置模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 common]$ cat dwd.gds-sh.zone</span><br><span class="line"></span><br><span class="line">$TTL      86400</span><br><span class="line">@            IN SOA  dwd.gds-sh.  admin.dwd.gds-sh. (</span><br><span class="line">                      1                ; serial</span><br><span class="line">                      3H                ; refresh</span><br><span class="line">                      15M                ; retry</span><br><span class="line">                      1W                ; expiry</span><br><span class="line">                      1D )              ; minimum</span><br><span class="line">        IN         NS     dns.dwd.gds-sh.</span><br><span class="line">dns     IN      A      10.11.4.11</span><br><span class="line">dns     IN      A      10.11.4.12</span><br><span class="line">dns     IN      A      10.10.10.72</span><br><span class="line">dns     IN      A      10.10.10.73</span><br><span class="line">dns     IN      A      172.24.139.193</span><br><span class="line">dns     IN      A      172.24.139.194</span><br><span class="line">lvs001     IN      A      10.11.0.11</span><br><span class="line">lvs002     IN      A      11.11.0.12</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>为了便于后期分析及拍错等操作，我们在每个zone配置文件中都添加上6条ns记录</li></ul><h1 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h1><p>因为dnspod上的数据都是公网地址</p><p>所以要进行匹配，匹配公网之后，替换为对应的内网负载均衡的ip地址</p><h1 id="优化进阶"><a href="#优化进阶" class="headerlink" title="优化进阶"></a>优化进阶</h1><p>最终实现目标是编写一个平台去管理，在当前时间节点下，先只能做到通过web框架去编写api实现下面这些操作</p><h2 id="主节点zone数据信息变更"><a href="#主节点zone数据信息变更" class="headerlink" title="主节点zone数据信息变更"></a>主节点zone数据信息变更</h2><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>在master节点上启动django服务，提供api，当数据源有变化时，对端发送POST请求，参数为：</p><ul><li></li></ul><p>收到请求之后进行处理</p><p>注意：因为这个很重要，所以事先定义用户名和密码，生成token，然后才运行更新数据</p><p>写完之后，序列号更新为当天的时间，例如：2007041501</p><p>如果发现当天已经存在，那么在当前的序列号上+1</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>和写入一样，在master节点上启动django服务，提供api，当数据源有变化时，对端发送POST请求</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>和写入一样，在master节点上启动django服务，提供api，当数据源有变化时，对端发送delete请求</p><p>针对主机名的配置，我们不使用提供接口的方式，对主机名的配置，我们编写程序作为客户端，定时的去扫描数据源（阿里云或者jumpserver端）</p><h2 id="主从数据同步"><a href="#主从数据同步" class="headerlink" title="主从数据同步"></a>主从数据同步</h2><p>主从数据同步主要分为2种</p><ul><li>一种是主节点数据变化之后，主动的触发通知机制，发送通知消息给所以slave节点。</li><li>另一种是从节点定期去连接主节点，获取序列号信息，与当前的值进行比较，如果获取的更大则发起数据同步</li></ul><p>结合实际情况，我们选择第一种方式</p><p>那么，当数据变更之后，如何不适用rndc reload的方式</p><h2 id="序列号增长问题"><a href="#序列号增长问题" class="headerlink" title="序列号增长问题"></a>序列号增长问题</h2><p>因为序列号最多为10位数，所以使用传统的日期表示法</p><h2 id="dns服务稳定性问题"><a href="#dns服务稳定性问题" class="headerlink" title="dns服务稳定性问题"></a>dns服务稳定性问题</h2><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>主从节点两边的acl列表需要保持一致，这部分数据是不会同步的</p><p>会同步的只是zone数据</p><p>因此在启动之前，一定要确保主配置文件、acl列表、view配置等都保持一致</p><p>因为主的多个view会共用一些zone（主机名），所以这些zone，view配置中的路径可以一致</p><p>但是从上，每一个view之间不能存在这种通用文件。</p><p>slave的ip地址不止应该在named.conf主配置文件当中定义</p><p>在acl列表中也应该写明，不然会被refused</p><p>在master上：所有的acl列表需要包含slave节点ip</p><p>在salve节点上，所有的acl列表需要包含master节点的ip</p><p>不然：</p><ul><li>主从同步开始时，slave向master发送soa时会被拒绝</li><li>主修改之后发送notify，slave将会拒绝这个消息，因此来源ip不在acl中</li></ul><p>同时存在3个view，在主上修改了view3或view2，但是slave上收到的信息始终是view1的notify</p><p>在这里，只有shidc这个view能收到信息</p><h1 id="主节点-acl配置"><a href="#主节点-acl配置" class="headerlink" title="主节点 acl配置"></a>主节点 acl配置</h1><p>阿里云acl：</p><ul><li>vpc的网段 【必须有】</li><li>阿里云2台dns的ip</li></ul><p>杭州acl：</p><ul><li>杭州机房网段 【必须有】</li><li>杭州机房2台dns服务器的ip  允许这2台主机发送soa请求并给予响应</li></ul><p>上海机房acl</p><ul><li>上海机房网段 【必须有】</li><li>上海机房2台dns服务器</li></ul><h1 id="从节点acl配置"><a href="#从节点acl配置" class="headerlink" title="从节点acl配置"></a>从节点acl配置</h1><ul><li>vpc的网段 【必须有】</li><li>上海主节点的ip地址。为了主节点发送notify发送消息时不拒绝</li></ul><p>杭州acl：</p><ul><li>杭州机房网段 【必须有】</li><li>上海主节点的ip地址。为了主节点发送notify发送消息时不拒绝</li></ul><p>上海机房acl</p><ul><li>上海机房网段 【必须有】</li><li>上海主节点的ip地址。为了主节点发送notify发送消息时不拒绝</li></ul><p>因为从节点需要做备份，所以从节点上需要维护3个view，而不只是所在地域的这一个网段</p><h1 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h1><p>有变化的只是杭州idc和阿里云</p><p>测试客户端</p><p>hzidc: common008-dev 192.168.11.88</p><p>Aliyun:  common010-dev 192.168.11.76</p><p>shIDC：common007-dev  192.168.11.84 </p><h1 id="notify配置"><a href="#notify配置" class="headerlink" title="notify配置"></a>notify配置</h1><p>注意，notify的配置需要写在每一个zone里面，不能写在主配置文件当中</p><p>master发送的notify信息中不能携带view信息，slave接收的时候，根据本身的view的配置进行匹配</p><p>如果一个网段存在于多个view当中，那么只有第一个生效，也就是说，如果主节点更新的是view3的数据，如果view1收到之后，那么将会更新view1中的zone信息</p><p>又因为master的ip必须存在于acl中（需要允许master发送的notify，不设置的话主节点发送的消息会被拒绝），</p><p>但是因为acl是从上到下匹配的</p><p>因此slave只能有一个view，也就是说除了主上维护的是全量的数据，其他从节点维护的只是一个view的数据</p><p>也就是说，如果存在同一个ip，那么不管配置几个view，同时生效的只会有一个view</p><h1 id="从节点直接显示文本"><a href="#从节点直接显示文本" class="headerlink" title="从节点直接显示文本"></a>从节点直接显示文本</h1><h1 id="多view主从同步问题"><a href="#多view主从同步问题" class="headerlink" title="多view主从同步问题"></a>多view主从同步问题</h1><p>多个view的主备同步主要是是主备之间每个view都使用共享key进行消息的签名。master的配置和之前的稍微有点小的改动</p><p>大家经常使用bind的时候是划分不同的view的，因为每个view的zone需要单独修改，所以人肉修改是比较麻烦的。这个时候可以使用nsupdate进行批量的操作。只要注意每个view使用正确的记录就行。</p><p>每个view指定一个对应key进行能更新</p><p>最终的实现目的：主从上的数据完全一致，也就是</p><p>参考文献：</p><ul><li><a href="https://blog.gnuers.org/?p=896" target="_blank" rel="noopener">bind多个view的主备同步</a></li></ul><p>#!/bin/bash<br>cd /home/appdeploy/deploy/apps/fortune-unit-service<br>/usr/bin/nohup /usr/local/jdk/bin/java -Dproject.name=fortune-unit-service -verbose:gc -Xloggc:/home/appdeploy/deploy/logs/fortune-unit-service/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/appdeploy/deploy/logs/fortune-unit-service/java.hprof -XX:ErrorFile=/home/appdeploy/deploy/logs/fortune-unit-service/java_error.log -Dlogging.file.path=”/home/appdeploy/deploy/logs/fortune-unit-service” -Dspring.cloud.config.label=aliyun.hz.unit1 -Dspring.cloud.config.index=aliyun.hz.unit1 -Dlogging.console.level=off -Dzone=unit1 -Dregion=aliyun.hz -server -Xms3000m -Xmx3000m -XX:MaxNewSize=512m -XX:PermSize=512M -XX:MaxPermSize=512m -XX:ThreadStackSize=512 -XX:-OmitStackTraceInFastThrow -jar fortune-unit-service.jar –spring.profiles.active=production &gt;&gt; /dev/null 2&gt;&amp;1 &amp;</p><p>select h.name as hostname,SUM(tre.value_min) as mem_avail<br>from hosts h,items i,trends_uint tre<br>where<br>h.name like ‘redis%’<br>and  h.status = ‘0’<br>and h.hostid= i.hostid<br>and i.itemid= tre.itemid<br>and i.name = “Available memory”<br>and tre.clock BETWEEN 1545809182 and 1545812782<br>group by hostname,total</p>]]></content>
    
    <summary type="html">
    
      异地多活-多机房bind部署
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="网络知识及网络服务" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="网络服务" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="DNS服务实现-bind" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/DNS%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0-bind/"/>
    
    
      <category term="bind" scheme="http://yoursite.com/tags/bind/"/>
    
  </entry>
  
  <entry>
    <title>python异常处理</title>
    <link href="http://yoursite.com/2018/12/09/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/09/IT科学技术知识体系结构-Linux运维方向/程序编程/Python/基础知识/python异常处理/</id>
    <published>2018-12-09T15:08:04.000Z</published>
    <updated>2018-12-09T15:08:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="http://www.runoob.com/python/python-exceptions.html" target="_blank" rel="noopener">菜鸟教程-Python异常处理</a></li></ul><h1 id="异常处理基础知识"><a href="#异常处理基础知识" class="headerlink" title="异常处理基础知识"></a>异常处理基础知识</h1><p>异常处理在任何一门编程语言里都是值得关注的一个话题，良好的异常处理可以让你的程序更加健壮，清晰的错误信息更能帮助你快速修复问题。</p><p>默认情况下，出现异常之后，整个程序就会直接终止，因此我们需要定义异常处理，保证程序按照我们的意愿输出便于我们分析问题的信息或者继续运行</p><h2 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h2><p>python提供了两个非常重要的功能来<strong><code>处理python程序在运行中出现的异常和错误</code></strong>。你可以使用它们来调试python程序。</p><ul><li>异常处理</li><li>断言(Assertions)</li></ul><p>本文会将这两种方式都进行介绍及梳理</p><h1 id="方式-功能1-异常处理"><a href="#方式-功能1-异常处理" class="headerlink" title="方式/功能1-异常处理"></a>方式/功能1-异常处理</h1><h2 id="使用python自带异常进行处理"><a href="#使用python自带异常进行处理" class="headerlink" title="使用python自带异常进行处理"></a>使用python自带异常进行处理</h2><h3 id="python标准异常"><a href="#python标准异常" class="headerlink" title="python标准异常"></a>python标准异常</h3><p>我们先了解下python定义了哪些标准异常</p><table><thead><tr><th>异常名称</th><th>描述</th></tr></thead><tbody><tr><td>BaseException</td><td>所有异常的基类</td></tr><tr><td>SystemExit</td><td>解释器请求退出</td></tr><tr><td>KeyboardInterrupt</td><td>用户中断执行(通常是输入^C)</td></tr><tr><td>Exception</td><td><strong>常规错误的基类</strong></td></tr><tr><td>StopIteration</td><td>迭代器没有更多的值</td></tr><tr><td>GeneratorExit</td><td>生成器(generator)发生异常来通知退出</td></tr><tr><td>StandardError</td><td>所有的内建标准异常的基类</td></tr><tr><td>ArithmeticError</td><td>所有数值计算错误的基类</td></tr><tr><td>FloatingPointError</td><td>浮点计算错误</td></tr><tr><td>OverflowError</td><td>数值运算超出最大限制</td></tr><tr><td>ZeroDivisionError</td><td>除(或取模)零 (所有数据类型)</td></tr><tr><td>AssertionError</td><td>断言语句失败</td></tr><tr><td>AttributeError</td><td>对象没有这个属性</td></tr><tr><td>EOFError</td><td>没有内建输入,到达EOF 标记</td></tr><tr><td>EnvironmentError</td><td>操作系统错误的基类</td></tr><tr><td>IOError</td><td>输入/输出操作失败</td></tr><tr><td>OSError</td><td>操作系统错误</td></tr><tr><td>WindowsError</td><td>系统调用失败</td></tr><tr><td>ImportError</td><td>导入模块/对象失败</td></tr><tr><td>LookupError</td><td>无效数据查询的基类</td></tr><tr><td>IndexError</td><td>序列中没有此索引(index)</td></tr><tr><td>KeyError</td><td>映射中没有这个键</td></tr><tr><td>MemoryError</td><td>内存溢出错误(对于Python 解释器不是致命的)</td></tr><tr><td>NameError</td><td>未声明/初始化对象 (没有属性)</td></tr><tr><td>UnboundLocalError</td><td>访问未初始化的本地变量</td></tr><tr><td>ReferenceError</td><td>弱引用(Weak reference)试图访问已经垃圾回收了的对象</td></tr><tr><td>RuntimeError</td><td>一般的运行时错误</td></tr><tr><td>NotImplementedError</td><td>尚未实现的方法</td></tr><tr><td>SyntaxError</td><td>Python 语法错误</td></tr><tr><td>IndentationError</td><td>缩进错误</td></tr><tr><td>TabError</td><td>Tab 和空格混用</td></tr><tr><td>SystemError</td><td>一般的解释器系统错误</td></tr><tr><td>TypeError</td><td>对类型无效的操作</td></tr><tr><td>ValueError</td><td>传入无效的参数</td></tr><tr><td>UnicodeError</td><td>Unicode 相关的错误</td></tr><tr><td>UnicodeDecodeError</td><td>Unicode 解码时的错误</td></tr><tr><td>UnicodeEncodeError</td><td>Unicode 编码时错误</td></tr><tr><td>UnicodeTranslateError</td><td>Unicode 转换时错误</td></tr><tr><td>Warning</td><td>警告的基类</td></tr><tr><td>DeprecationWarning</td><td>关于被弃用的特征的警告</td></tr><tr><td>FutureWarning</td><td>关于构造将来语义会有改变的警告</td></tr><tr><td>OverflowWarning</td><td>旧的关于自动提升为长整型(long)的警告</td></tr><tr><td>PendingDeprecationWarning</td><td>关于特性将会被废弃的警告</td></tr><tr><td>RuntimeWarning</td><td>可疑的运行时行为(runtime behavior)的警告</td></tr><tr><td>SyntaxWarning</td><td>可疑的语法的警告</td></tr><tr><td>UserWarning</td><td>用户代码生成的警告</td></tr></tbody></table><h3 id="try-except-else-finally语法"><a href="#try-except-else-finally语法" class="headerlink" title="try/except/else/finally语法"></a>try/except/else/finally语法</h3><p>首先说明下语法</p><ul><li><p>try: 需要检测异常的代码块放在try中</p></li><li><p>except &lt;异常名称&gt;：匹配之后，指定该段中的代码。可以定义多个抓取异常的语句</p></li><li><p>except Exception：用户捕获我们没有发现的异常，这段需要放在except语句块的最后</p></li><li>else: 语句执行正常时执行的代码</li><li>finally：语句无论是否发生异常都将执行最后的代码</li></ul><p>实际组合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">&lt;语句&gt;        #运行代码</span><br><span class="line">except &lt;名字1&gt;：</span><br><span class="line">&lt;语句&gt;        #如果在try部份引发了&apos;name1&apos;异常，则执行这段代码</span><br><span class="line">except &lt;名字2&gt;:</span><br><span class="line">&lt;语句&gt;        #如果在try部份引发了&apos;name2&apos;异常，则执行这段代码</span><br><span class="line">except Exception：</span><br><span class="line">&lt;语句&gt;# 匹配到未知异常时执行，也就是没有被&quot;except &lt;名字&gt;&quot;定义的异常</span><br><span class="line">else:</span><br><span class="line">&lt;语句&gt;        #如果没有异常发生执行这段代码</span><br><span class="line">finally:</span><br><span class="line">&lt;语句&gt;# 无论异常与否都执行</span><br></pre></td></tr></table></figure><p>光说没案例是理解不了的，下面我们看一个案例</p><h3 id="实例案例"><a href="#实例案例" class="headerlink" title="实例案例"></a>实例案例</h3><p>我们先看一段会导致异常的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test(par1,par2):</span><br><span class="line">    print (par1,par2)</span><br><span class="line"></span><br><span class="line">test(1)</span><br></pre></td></tr></table></figure><p>运行之后的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/python3 /Users/wangxiaohua/PycharmProjects/private_project/test/test.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/wangxiaohua/PycharmProjects/private_project/test/test.py&quot;, line 6, in &lt;module&gt;</span><br><span class="line">    test(1)</span><br><span class="line">TypeError: test() missing 1 required positional argument: &apos;par2&apos;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p>可以很明显的看到，因为我们少输入的一个参数，这里产生了TypeError这个异常，并且还给出了异常的相关信息</p><p><strong>—— 分割线 ——</strong></p><p>接下来我们对这段代码进行一下改造，添加上异常处理功能</p><p>修改之后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def test(par1,par2):</span><br><span class="line">    print (par1,par2)</span><br><span class="line">try:</span><br><span class="line">    test(1)</span><br><span class="line">except TypeError as e:</span><br><span class="line">    print (&quot;位置参数错误，详细信息为：&quot;,e)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print (&quot;未知错误：&quot;,e)</span><br><span class="line">else:</span><br><span class="line">    print (&quot;执行正常时输出这段话&quot;)</span><br><span class="line">finally:</span><br><span class="line">    print (&quot;不管成功与否，都会执行的代码段，可以不定义&quot;)</span><br></pre></td></tr></table></figure><p>我们开始运行程序</p><ul><li><p>第一次（错误案例，调用方式为：test(1)），结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/python3 /Users/wangxiaohua/PycharmProjects/private_project/test/test.py</span><br><span class="line">位置参数错误，详细信息为： test() missing 1 required positional argument: &apos;par2&apos;</span><br><span class="line">不管成功与否，都会执行的代码段，可以不定义</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li><li><p>第二次（成功案例，调用方式为：test(1,2)），结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/python3 /Users/wangxiaohua/PycharmProjects/private_project/test/test.py</span><br><span class="line">1 2</span><br><span class="line">执行正常时输出这段话</span><br><span class="line">不管成功与否，都会执行的代码段，可以不定义</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong></p><ul><li>如果代码本身有错误，都没办法执行的话，是抓不到错误异常的，因为上面抓取错误异常指的是在代码执行时出现的异常</li></ul><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a><strong>工作流</strong></h3><p>try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。</p><ul><li>如果当try后的语句执行时发生异常，python就<strong><code>跳回到try</code></strong>并执行<strong>第一个</strong>匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。</li><li>如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印缺省的出错信息）。</li><li>如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。</li></ul><h2 id="自定义触发异常"><a href="#自定义触发异常" class="headerlink" title="自定义触发异常"></a>自定义触发异常</h2><p>在我们定义一些代码逻辑的时候，可能程序并不是产生异常，但是已经不符合我们定义的逻辑，这个时候，我们需要使用raise语句来强制引发抛出异常</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><strong>raise语法格式</strong>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise Exception(&quot;message&quot;, args)</span><br></pre></td></tr></table></figure><p>语句中 Exception 是异常的类型（例如，NameError、IOError）参数，标准异常中任一种，args 是自已提供的参数。两个参数都可以省略</p><h3 id="实例案例-1"><a href="#实例案例-1" class="headerlink" title="实例案例"></a>实例案例</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def test (num):</span><br><span class="line">    if num &lt; 10:</span><br><span class="line">        raise ValueError(&quot;Invaild num:&quot;,num)</span><br><span class="line">try:</span><br><span class="line">    test(8)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print (e)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print (&quot;异常错误&quot;,e)</span><br><span class="line">else:</span><br><span class="line">    print (&quot;ok&quot;)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&apos;Invaild num:&apos;, 8)</span><br></pre></td></tr></table></figure><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><p>有些时候，我们需要使用我们自己定义的异常类去做一些处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class wxherror(Exception):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def test (num):</span><br><span class="line">    if num &lt; 10:</span><br><span class="line">        raise wxherror(num)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    test(8)</span><br><span class="line">except wxherror as e:</span><br><span class="line">    print (&quot;错误,参数为：&#123;e&#125;&quot;.format(e=e))</span><br><span class="line">except Exception as e:</span><br><span class="line">    print (&quot;异常错误&quot;,e)</span><br><span class="line">else:</span><br><span class="line">    print (&quot;ok&quot;)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误,参数为：8</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的案例，我们可以总结一下使用方式</p><ul><li>和python自带的异常处理不同，在使用自定义异常的时候，我们在具体的实现代码块中就要事先定义好，当出现某种情况时，需要抛出指定的异常（需要人为定义异常的内容）</li><li>其实自带异常处理，也是在实现代码中定义了这些异常，只不过已经内部集成，不为外部所见</li><li>自己写的异常，系统不知道它的存在，也就是说系统不知道走到哪一步应该触发它，因为所有的逻辑都是我们认为的去判断的，因此自己写的异常需要我们自己去触发，否则它不会自动触发，会自动触发的异常只有标准异常</li></ul><h1 id="方式-功能2-断言-Assertions"><a href="#方式-功能2-断言-Assertions" class="headerlink" title="方式/功能2-断言(Assertions)"></a>方式/功能2-断言(Assertions)</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p><strong>assert断言语句用来声明某个条件是真的，其作用是判断一个条件(condition)是否成立，如果不成立，则抛出异常。</strong></p><p>assert一般用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert condition</span><br></pre></td></tr></table></figure><p>如果condition为false，就raise一个AssertionError出来。逻辑上等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if not condition:</span><br><span class="line">    raise AssertionError()</span><br></pre></td></tr></table></figure><p>另一种使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert condition，expression</span><br></pre></td></tr></table></figure><p>如果condition为false，就raise一个描述为 expression 的AssertionError出来。逻辑上等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if not condition:</span><br><span class="line">        raise AssertionError(expression)</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>assert使用示例：</p><ul><li>案例1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert isinstance(11,str)</span><br></pre></td></tr></table></figure><p>执行后输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/wangxiaohua/PycharmProjects/private_project/test/test.py&quot;, line 26, in &lt;module&gt;</span><br><span class="line">    assert isinstance(11,str)</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure><p>知道会抛出AssertionError之后，我们就可以做一些判断处理</p><ul><li>案例2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def test (num):</span><br><span class="line">    if not (num &lt; 10):</span><br><span class="line">        raise AssertionError(&quot;&#123;num&#125; &gt;= 10&quot;.format(num=num))</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    test(11)</span><br><span class="line">except AssertionError as e:</span><br><span class="line">    print (&quot;输入数字错误&quot;,e)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print (&quot;异常错误&quot;,e)</span><br></pre></td></tr></table></figure><p>执行后输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数字错误 11 &gt;= 10</span><br></pre></td></tr></table></figure><ul><li>案例3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert (1&gt;2),&quot;异常信息：1&gt;2&quot;</span><br></pre></td></tr></table></figure><p>执行后输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/wangxiaohua/PycharmProjects/private_project/test/test.py&quot;, line 18, in &lt;module&gt;</span><br><span class="line">    assert (1&gt;2),&quot;异常信息：1&gt;2&quot;</span><br><span class="line">AssertionError: 异常信息：1&gt;2</span><br></pre></td></tr></table></figure><h2 id="断言跟异常的区别"><a href="#断言跟异常的区别" class="headerlink" title="断言跟异常的区别"></a>断言跟异常的区别</h2><p>断言是用来检查非法情况而不是错误情况的，用来帮开发者快速定位问题的位置。<br>异常处理用于对程序发生异常情况的处理，增强程序的健壮性和容错性。</p><p>对一个函数而言，一般情况下，断言用于检查函数输入的合法性，要求输入满足一定的条件才能继续执行;</p><p>在函数执行过程中出现的异常情况使用异常来捕获。</p>]]></content>
    
    <summary type="html">
    
      python异常处理
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="python异常处理" scheme="http://yoursite.com/tags/python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>python日志处理</title>
    <link href="http://yoursite.com/2018/12/05/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/python%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/05/IT科学技术知识体系结构-Linux运维方向/程序编程/Python/基础知识/python日志处理/</id>
    <published>2018-12-05T03:12:59.000Z</published>
    <updated>2018-12-05T03:12:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.cnblogs.com/yyds/p/6901864.html" target="_blank" rel="noopener">Python之日志处理（logging模块）</a></li><li><a href="https://docs.python.org/3/library/logging.html?highlight=logging#module-logging" target="_blank" rel="noopener">官方文档</a></li></ul><h1 id="日志相关概念"><a href="#日志相关概念" class="headerlink" title="日志相关概念"></a>日志相关概念</h1><p>日志是一种可以追踪某些软件运行时所发生事件的方法。软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情。一个事件可以用一个可包含可选变量数据的消息来描述。此外，事件也有重要性的概念，这个重要性也可以被称为严重性级别（level）。</p><p><strong>总结重点：</strong></p><ul><li>追踪记录程序运行时发生的事件</li><li>实现：在代码中调用日志处理方法</li><li>事件有严重性级别</li></ul><h2 id="日志作用"><a href="#日志作用" class="headerlink" title="日志作用"></a>日志作用</h2><p>通过对log进行分析，可以</p><ol><li>方便用户了解系统或软件、应用的运行情况；</li><li>如果你的应用log足够丰富，也可以分析以往用户的操作行为、类型喜好、地域分布或其他更多信息；</li><li>如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。</li></ol><p>简单来讲就是：我们通过记录和分析日志可以了解一个系统或软件程序运行情况是否正常，也可以在应用程序出现故障时快速定位问题。</p><p>比如，做运维的同学，在接收到报警或各种问题反馈后，进行问题排查时通常都会先去看各种日志，大部分问题都可以在日志中找到答案。</p><p>再比如，做开发的同学，可以通过IDE控制台上输出的各种日志进行程序调试。</p><p>对于运维老司机或者有经验的开发人员，可以快速的通过日志定位到问题的根源。可见，日志的重要性不可小觑。</p><p>如果应用的日志信息足够详细和丰富，还可以用来做用户行为分析，如：分析用户的操作行为、类型洗好、地域分布以及其它更多的信息，由此可以实现改进业务、提高商业利益。</p><p><strong>日志作用简单总结：</strong></p><ul><li>程序调试</li><li>了解软件程序<strong><code>运行状况</code></strong>是否正常</li><li>软件程序运行故障时<strong><code>定位问题及分析问题</code></strong></li><li>用户行为分析，并以此改进业务等</li></ul><h2 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h2><p>在软件开发阶段或部署开发环境时，为了尽可能详细的查看应用程序的运行状态来保证上线后的稳定性，我们需要把该应用程序所有的运行日志全部记录下来进行分析，这是非常耗费机器性能的。当应用程序在生产环境正式部署时，我们通常只记录应用程序的异常信息、错误信息等，这样既可以减小服务器的I/O压力，也可以避免我们在排查故障时被淹没在日志的海洋里。</p><p>那么，怎样才能在不改动应用程序代码的情况下实现在不同的环境记录不同详细程度的日志呢？这就是日志等级的作用了，我们通过配置文件指定我们需要的日志等级就可以了。</p><p>不同的应用程序所定义的日志等级可能会有所差别，分的详细点的会包含以下几个等级：</p><ul><li>DEBUG</li><li>INFO</li><li>NOTICE</li><li>WARNING</li><li>ERROR</li><li>CRITICAL</li><li>ALERT</li><li>EMERGENCY</li></ul><h2 id="日志字段信息与日志格式"><a href="#日志字段信息与日志格式" class="headerlink" title="日志字段信息与日志格式"></a>日志字段信息与日志格式</h2><p>一条日志信息对应的是一个<strong><code>需要关注的事件</code></strong>的发生，因此通常需要包括以下几个内容：</p><ul><li>事件的严重程度（日志级别）</li><li>事件发生时间</li><li>事件发生位置</li><li>事件内容</li></ul><p>上面这些都是一条日志记录中可能包含的字段信息，当然还可以包括一些其他信息，如进程ID、进程名称、线程ID、线程名称等。</p><p><strong>日志格式</strong>就是用来<strong>定义</strong>一条日志记录中<strong>包含哪些字段</strong>及其组合顺序及方式，且日志格式通常都是可以自定义的。</p><p><strong>注意：</strong>输出一条日志时，日志内容和日志级别是需要开发人员明确指定的。对于而其它字段信息，只需要是否显示在日志中就可以了。</p><h2 id="日志功能实现"><a href="#日志功能实现" class="headerlink" title="日志功能实现"></a>日志功能实现</h2><p>几乎所有开发语言都会内置日志相关功能，或者会有比较优秀的第三方库来提供日志操作功能，比如：log4j，log4php等。它们功能强大、使用简单。Python自身也提供了一个用于记录日志的标准库模块-logging。</p><h1 id="python日志处理"><a href="#python日志处理" class="headerlink" title="python日志处理"></a>python日志处理</h1><p>我们在Python中一般使用logging模块实现日志功能，因此我们在这里说的python日志处理实际上是logging模块相关内容。</p><p>logging模块是Python的一个标准库模块，由标准库模块提供日志记录API的关键好处是所有Python模块都可以使用这个日志记录功能。所以，你的应用日志可以将你自己的日志信息与来自第三方模块的信息整合起来。</p><h2 id="logging模块支持日志级别"><a href="#logging模块支持日志级别" class="headerlink" title="logging模块支持日志级别"></a>logging模块支持日志级别</h2><p>logging模块并不支持我们上面说的所有级别，它默认定义了以下几个日志等级</p><table><thead><tr><th>日志等级（level）</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>最详细的日志信息，典型应用场景是 问题诊断</td></tr><tr><td>INFO</td><td>信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作</td></tr><tr><td>WARNING</td><td>当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的</td></tr><tr><td>ERROR</td><td>由于一个更严重的问题导致某些功能不能正常运行时记录的信息</td></tr><tr><td>CRITICAL</td><td>当发生严重错误，导致应用程序不能继续运行时记录的信息</td></tr></tbody></table><p>开发应用程序或部署开发环境时，可以使用DEBUG或INFO级别的日志获取尽可能详细的日志信息来进行开发或部署调试；</p><p>应用上线或部署生产环境时，应该使用WARNING或ERROR或CRITICAL级别的日志来降低机器的I/O压力和提高获取错误日志信息的效率。日志级别的指定通常都是在应用程序的配置文件中进行指定的。</p><p><strong>说明：</strong></p><ul><li>上面列表中的日志等级是从上到下依次升高的，即：DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL，而日志的信息量是依次减少的；</li><li>当为某个应用程序指定一个日志级别后，应用程序会记录所有日志级别<strong><code>大于或等于</code></strong>指定日志级别的日志信息，而不是仅仅记录指定级别的日志信息，nginx、php等应用程序以及这里python的logging模块都是这样的。同样，logging模块也可以指定日志记录器的日志级别，只有级别大于或等于该指定日志级别的日志记录才会被输出，小于该等级的日志记录将会被丢弃。</li></ul><h2 id="logging模块的两种实现方式"><a href="#logging模块的两种实现方式" class="headerlink" title="logging模块的两种实现方式"></a>logging模块的两种实现方式</h2><p>logging模块提供了两种记录日志的方式：</p><ul><li>第一种方式是使用logging提供的<strong><code>模块级别的函数</code></strong></li><li>第二种方式是使用Logging日志系统的<strong><code>四大组件</code></strong></li></ul><p><strong>logging模块定义的模块级别常用函数</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>logging.debug(msg, <em>args, *</em>kwargs)</td><td>创建一条严重级别为DEBUG的日志记录</td></tr><tr><td>logging.info(msg, <em>args, *</em>kwargs)</td><td>创建一条严重级别为INFO的日志记录</td></tr><tr><td>logging.warning(msg, <em>args, *</em>kwargs)</td><td>创建一条严重级别为WARNING的日志记录</td></tr><tr><td>logging.error(msg, <em>args, *</em>kwargs)</td><td>创建一条严重级别为ERROR的日志记录</td></tr><tr><td>logging.critical(msg, <em>args, *</em>kwargs)</td><td>创建一条严重级别为CRITICAL的日志记录</td></tr><tr><td>logging.log(level, <em>args, *</em>kwargs)</td><td>创建一条严重级别为level的日志记录</td></tr><tr><td>logging.basicConfig(**kwargs)</td><td>对root logger进行一次性配置</td></tr></tbody></table><p>其中<code>logging.basicConfig(**kwargs)</code>函数用于指定“要记录的日志级别”、“日志格式”、“日志输出位置”、“日志文件的打开模式”等信息，其他几个都是用于记录各个级别日志的函数。</p><p><strong>logging模块日志系统的四大组件</strong></p><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td>loggers</td><td>提供应用程序代码直接使用的接口</td></tr><tr><td>handlers</td><td>用于将日志记录发送到指定的目的位置进行输出</td></tr><tr><td>filters</td><td>提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略）</td></tr><tr><td>formatters</td><td>用于控制日志信息的最终输出格式</td></tr></tbody></table><p><strong>说明：</strong> logging模块提供的模块级别的那些函数实际上也是通过这几个组件的相关实现类来记录日志的，只是在创建这些类的实例时设置了一些默认值。</p><h2 id="实现方式1-使用logging提供的模块级别函数记录日志"><a href="#实现方式1-使用logging提供的模块级别函数记录日志" class="headerlink" title="实现方式1-使用logging提供的模块级别函数记录日志"></a>实现方式1-使用logging提供的模块级别函数记录日志</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging.debug(&quot;debug log&quot;)</span><br><span class="line">logging.info(&quot;info log&quot;)</span><br><span class="line">logging.warning(&quot;warning log&quot;)</span><br><span class="line">logging.error(&quot;error log&quot;)</span><br><span class="line">logging.critical(&quot;critical log&quot;)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING:root:warning log</span><br><span class="line">ERROR:root:error log</span><br><span class="line">CRITICAL:root:critical log</span><br></pre></td></tr></table></figure><p>这里需要注意的是：logging模块提供的<strong><code>日志记录函数</code></strong>所使用的日志器设置的日志级别是<code>WARNING</code>，因此只有<code>WARNING</code>级别的日志记录以及大于它的<code>ERROR</code>和<code>CRITICAL</code>级别的日志记录被输出了，而小于它的<code>DEBUG</code>和<code>INFO</code>级别的日志记录被丢弃了。</p><p>几个注意事项：</p><ul><li><p>默认的输出格式为：<strong><code>日志级别:日志器名称:日志内容</code></strong></p><p>之所以会这样输出，是因为logging模块提供的日志记录函数所使用的日志器设置的日志格式默认是BASIC_FORMAT，其值为：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;%(levelname)s:%(name)s:%(message)s&quot;</span><br></pre></td></tr></table></figure></li><li><p>日志记录函数所使用的<strong>日志器</strong>设置的<strong>处理器</strong>所指定的日志输出位置默认为:<code>sys.stderr</code></p></li><li><p>日志器（Logger）是有层级关系的，上面调用的logging模块级别的函数所使用的日志器是<code>RootLogger</code>类的实例，其名称为’root’，它是处于日志器层级关系最顶层的日志器，且该实例是以单例模式存在的。</p></li><li><p>源码实现：</p><p>查看这些日志记录函数的实现代码，可以发现：当我们没有提供任何配置信息的时候，这些函数都会去调用<code>logging.basicConfig(**kwargs)</code>方法，且不会向该方法传递任何参数。继续查看<code>basicConfig()</code>方法的代码就可以找到上面这些问题的答案了。</p></li><li><p>如何修改默认配置</p><p>在我们调用上面这些日志记录函数之前，手动调用一下basicConfig()方法，把我们想设置的内容以参数的形式传递进去就可以了</p><p>在我们需要将日志内容从控制台输出重定向到文件时需要修改配置</p></li></ul><h3 id="logging-basicConfig-函数"><a href="#logging-basicConfig-函数" class="headerlink" title="logging.basicConfig()函数"></a>logging.basicConfig()函数</h3><p>该方法用于为logging日志系统做一些基本配置，方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(**kwargs)</span><br></pre></td></tr></table></figure><p>该函数可接收的关键字参数如下：</p><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td>filename</td><td>指定日志输出目标文件的文件名，指定该设置项后日志就不会被输出到控制台了</td></tr><tr><td>filemode</td><td>指定日志文件的打开模式，默认为’a’。需要注意的是，该选项要在filename指定时才有效</td></tr><tr><td>format</td><td>指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段下面会列出。</td></tr><tr><td>datefmt</td><td>指定日期/时间格式。需要注意的是，该选项要在format中包含时间字段%(asctime)s时才有效</td></tr><tr><td>level</td><td>指定日志器的日志级别</td></tr><tr><td>stream</td><td>指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 <code>ValueError</code>异常</td></tr><tr><td>style</td><td>Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为’%’、’{‘和’$’，默认为’%’</td></tr><tr><td>handlers</td><td>Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。</td></tr></tbody></table><p>logging模块中定义好的可以用于format格式字符串中的字段：</p><table><thead><tr><th>字段/属性名称</th><th>使用格式</th><th>描述</th></tr></thead><tbody><tr><td>asctime</td><td>%(asctime)s</td><td>日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896</td></tr><tr><td>created</td><td>%(created)f</td><td>日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值</td></tr><tr><td>relativeCreated</td><td>%(relativeCreated)d</td><td>日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的）</td></tr><tr><td>msecs</td><td>%(msecs)d</td><td>日志事件发生事件的毫秒部分</td></tr><tr><td>levelname</td><td>%(levelname)s</td><td>该日志记录的文字形式的日志级别（’DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’）</td></tr><tr><td>levelno</td><td>%(levelno)s</td><td>该日志记录的数字形式的日志级别（10, 20, 30, 40, 50）</td></tr><tr><td>name</td><td>%(name)s</td><td>所使用的<strong>日志器名称</strong>，默认是’root’，因为默认使用的是 rootLogger</td></tr><tr><td>message</td><td>%(message)s</td><td>日志记录的文本内容，通过 <code>msg % args</code>计算得到的</td></tr><tr><td>pathname</td><td>%(pathname)s</td><td>调用日志记录函数的源码文件的全路径</td></tr><tr><td>filename</td><td>%(filename)s</td><td>pathname的文件名部分，包含文件后缀</td></tr><tr><td>module</td><td>%(module)s</td><td>filename的名称部分，不包含后缀</td></tr><tr><td>lineno</td><td>%(lineno)d</td><td>调用日志记录函数的源代码所在的行号</td></tr><tr><td>funcName</td><td>%(funcName)s</td><td>调用日志记录函数的函数名</td></tr><tr><td>process</td><td>%(process)d</td><td>进程ID</td></tr><tr><td>processName</td><td>%(processName)s</td><td>进程名称，Python 3.1新增</td></tr><tr><td>thread</td><td>%(thread)d</td><td>线程ID</td></tr><tr><td>threadName</td><td>%(thread)s</td><td>线程名称</td></tr></tbody></table><h3 id="实际配置案例"><a href="#实际配置案例" class="headerlink" title="实际配置案例"></a>实际配置案例</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">import time</span><br><span class="line">from os import path</span><br><span class="line"></span><br><span class="line"># 定义日志文件名称格式</span><br><span class="line">base_log_name = path.abspath(path.dirname(path.dirname(__file__))) + &apos;/logs/&apos; + &quot;dcache.log&quot; + &quot;-&quot;</span><br><span class="line">info_log_filename = base_log_name + time.strftime(&apos;%Y-%m-%d-%H&apos;) + &quot;-&quot; + time.strftime(&apos;%H&apos;)</span><br><span class="line">error_log_filename = base_log_name + &quot;error.log&quot;</span><br><span class="line">warn_log_filename = base_log_name + &quot;warn.log&quot;</span><br><span class="line"></span><br><span class="line"># 定义日志的输出格式</span><br><span class="line">log_format = &quot;%(asctime)s - %(levelname)s - %(pathname)s[line:%(lineno)d] - %(message)s&quot;</span><br><span class="line">logging.basicConfig(filename=info_log_filename,level=logging.DEBUG,format=log_format)</span><br><span class="line"></span><br><span class="line"># 日志记录，第一种方式来源方式2，下面会将</span><br><span class="line">log = logging.getLogger(&apos;root&apos;)</span><br><span class="line">log.info(&quot;info log&quot;)</span><br><span class="line">或者</span><br><span class="line">logging.info(&quot;info log&quot;)</span><br></pre></td></tr></table></figure><p>在这里使用了以下字段：</p><ul><li>asctime    事件发生的时间</li><li>levelname 事件的等级</li><li>pathname 产生事件的文件的绝对路径</li><li>lineno 调用日志记录函数的源代码所在的行号</li><li>message 日志记录的文本内容</li></ul><p>日志的输出格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-12-07 11:10:33,546 - INFO - /Users/wangxiaohua/PycharmProjects/dcache/lib/logger.py[line:35] - info log</span><br></pre></td></tr></table></figure><h2 id="实现方式2-使用四大组件记录日志"><a href="#实现方式2-使用四大组件记录日志" class="headerlink" title="实现方式2-使用四大组件记录日志"></a>实现方式2-使用四大组件记录日志</h2><h3 id="logging模块的四大组件"><a href="#logging模块的四大组件" class="headerlink" title="logging模块的四大组件"></a>logging模块的四大组件</h3><table><thead><tr><th>组件名称</th><th>对应类名</th><th>功能描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供了应用程序可一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将logger创建的日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filter</td><td>提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table><p>logging模块就是通过这些组件来完成日志处理的，上面所使用的logging模块级别的函数也是通过这些组件对应的类来实现的。 </p><p><strong>这些组件之间的关系描述：</strong></p><ul><li>日志器/记录器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等；</li><li>不同的处理器（handler）可以将日志输出到不同的位置；</li><li>日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置；</li><li>每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志；</li><li>每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。</li></ul><p>简单点说就是：<strong>日志器（logger）是入口</strong>，真正干活儿的是处理器（handler），处理器（handler）还可以通过过滤器（filter）和格式器（formatter）对要输出的日志内容做过滤和格式化等处理操作。</p><h3 id="四大组件相关类及其常用方法"><a href="#四大组件相关类及其常用方法" class="headerlink" title="四大组件相关类及其常用方法"></a>四大组件相关类及其常用方法</h3><p>下面介绍下与logging四大组件相关的类：Logger, Handler, Filter, Formatter。</p><h4 id="logger类"><a href="#logger类" class="headerlink" title="logger类"></a>logger类</h4><p>Logger对象，也就是日志器有3个任务要做：</p><ul><li><p>向应用程序代码暴露几个方法，使应用程序可以在运行时记录日志消息；</p></li><li><p>基于日志严重等级（默认的过滤设施）或filter对象来决定要对哪些日志进行后续处理；</p><p>也就是说logger日志器这一层就会对日志做初步的过滤</p></li><li><p>将日志消息传送给所有感兴趣的日志handlers。</p></li></ul><p>Logger对象最常用的方法分为两类：<strong><code>配置方法 和 消息发送方法</code></strong></p><p><strong>常用配置方法：</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Logger.setLevel()</td><td>设置日志器将会处理的日志消息的最低严重级别</td></tr><tr><td>Logger.addHandler() 和 Logger.removeHandler()</td><td>为该logger对象添加 和 移除一个handler对象</td></tr><tr><td>Logger.addFilter() 和 Logger.removeFilter()</td><td>为该logger对象添加 和 移除一个filter对象</td></tr></tbody></table><p>关于Logger.setLevel()方法的说明：</p><blockquote><p>内建等级中，级别最低的是DEBUG，级别最高的是CRITICAL。例如setLevel(logging.INFO)，此时函数参数为INFO，那么该logger将只会处理INFO、WARNING、ERROR和CRITICAL级别的日志，而DEBUG级别的消息将会被忽略/丢弃。</p></blockquote><p>logger对象配置完成后，可以使用下面的方法来创建日志记录：</p><p><strong>常用消息发送方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Logger.debug(), Logger.info(), Logger.warning(), Logger.error(), Logger.critical()</td><td>创建一个与它们的方法名对应等级的日志记录</td></tr><tr><td>Logger.exception()</td><td>创建一个类似于Logger.error()的日志消息</td></tr><tr><td>Logger.log()</td><td>需要获取一个明确的日志level参数来创建一个日志记录</td></tr></tbody></table><p>说明：</p><blockquote><ul><li>Logger.exception()与Logger.error()的区别在于：Logger.exception()将会输出堆栈追踪信息，另外通常只是在一个exception handler中调用该方法。</li><li>Logger.log()的用法为：logging.log(logging.ERROR,”log message”)</li><li>Logger.log()与Logger.debug()、Logger.info()等方法相比，虽然需要多传一个level参数，显得不是那么方便，但是当需要记录自定义level的日志时还是需要该方法来完成。</li></ul></blockquote><p>如何得到一个Logger对象呢？一种方式是通过Logger类的实例化方法创建一个Logger类的实例，但是我们通常都是用第二种方式–logging.getLogger()方法。</p><p>logging.getLogger()方法有一个可选参数name，该参数表示将要返回的日志器的名称标识，如果不提供该参数，则其值为’root’。若以相同的name参数值多次调用getLogger()方法，将会返回指向同一个logger对象的引用。</p><h5 id="关于logger的层级结构与有效等级的说明"><a href="#关于logger的层级结构与有效等级的说明" class="headerlink" title="关于logger的层级结构与有效等级的说明"></a>关于logger的层级结构与有效等级的说明</h5><ul><li>logger的名称是一个以’.’分割的层级结构，每个’.’后面的logger都是’.’前面的logger的children，例如，有一个名称为 foo 的logger，其它名称分别为 foo.bar, foo.bar.baz 和 foo.bam都是 foo 的后代。</li><li>logger有一个”有效等级（effective level）”的概念。如果一个logger上没有被明确设置一个level，那么该logger就是使用它parent的level;如果它的parent也没有明确设置level则继续向上查找parent的parent的有效level，依次类推，直到找到个一个明确设置了level的祖先为止。需要说明的是，root logger总是会有一个明确的level设置（默认为 WARNING）。当决定是否去处理一个已发生的事件时，logger的有效等级将会被用来决定是否将该事件传递给该logger的handlers进行处理。</li><li>child loggers在完成对日志消息的处理后，默认会将日志消息传递给与它们的祖先loggers相关的handlers。因此，我们不必为一个应用程序中所使用的所有loggers定义和配置handlers，只需要为一个顶层的logger配置handlers，然后按照需要创建child loggers就可足够了。我们也可以通过将一个logger的propagate属性设置为False来关闭这种传递机制。</li></ul><p>也就是说：四大组件是一种分层的架构，不管是父logger还是子logger，只要是logger，都是在handler层级之上的，所以child logger处理之后，会把消息传递给父logger的handler</p><h4 id="Handler类"><a href="#Handler类" class="headerlink" title="Handler类"></a>Handler类</h4><p>Handler对象的作用是（基于日志消息的level）将消息分发到handler指定的位置（文件、网络、邮件等）。Logger对象可以通过addHandler()方法为自己添加0个或者更多个handler对象。比如，一个应用程序可能想要实现以下几个日志需求：</p><ul><li>1）把所有日志都发送到一个日志文件中；</li><li>2）把所有严重级别大于等于error的日志发送到stdout（标准输出）；</li><li>3）把所有严重级别为critical的日志发送到一个email邮件地址。<br>这种场景就需要3个不同的handlers，每个handler负责发送一个特定严重级别的日志到一个特定的位置。</li></ul><p>一个handler中只有非常少数的方法是需要应用开发人员去关心的。对于使用内建handler对象的应用开发人员来说，似乎唯一相关的handler方法就是下面这几个配置方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Handler.setLevel()</td><td>设置handler将会处理的日志消息的最低严重级别</td></tr><tr><td>Handler.setFormatter()</td><td>为handler设置一个格式器对象</td></tr><tr><td>Handler.addFilter() 和 Handler.removeFilter()</td><td>为handler添加 和 删除一个过滤器对象</td></tr></tbody></table><p>需要说明的是，应用程序代码不应该直接实例化和使用Handler实例。因为Handler是一个基类，它只定义了所有handlers都应该有的接口，同时提供了一些子类可以直接使用或覆盖的默认行为。下面是一些常用的Handler：</p><table><thead><tr><th>Handler</th><th>描述</th></tr></thead><tbody><tr><td>logging.StreamHandler</td><td>将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。</td></tr><tr><td>logging.FileHandler</td><td>将日志消息发送到磁盘文件，默认情况下文件大小会无限增长</td></tr><tr><td>logging.handlers.RotatingFileHandler</td><td>将日志消息发送到磁盘文件，并支持日志文件按大小切割</td></tr><tr><td>logging.hanlders.TimedRotatingFileHandler</td><td>将日志消息发送到磁盘文件，并支持日志文件按时间切割</td></tr><tr><td>logging.handlers.HTTPHandler</td><td>将日志消息以GET或POST的方式发送给一个HTTP服务器</td></tr><tr><td>logging.handlers.SMTPHandler</td><td>将日志消息发送给一个指定的email地址</td></tr><tr><td>logging.NullHandler</td><td>该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免’No handlers could be found for logger XXX’信息的出现。</td></tr></tbody></table><h4 id="Formater类"><a href="#Formater类" class="headerlink" title="Formater类"></a>Formater类</h4><p>Formater对象用于配置日志信息的顺序、结构和内容。</p><p>与logging.Handler基类不同的是，应用代码可以直接实例化Formatter类。另外，如果你的应用程序需要一些特殊的处理行为，也可以实现一个Formatter的子类来完成。</p><p>Formatter类的构造方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.Formatter.__init__(fmt=None, datefmt=None, style=&apos;%&apos;)</span><br></pre></td></tr></table></figure><p>可见，该构造方法接收3个可选参数：</p><ul><li>fmt：指定消息格式化字符串，如果不指定该参数则默认使用message的原始值</li><li>datefmt：指定日期格式字符串，如果不指定该参数则默认使用”%Y-%m-%d %H:%M:%S”</li><li>style：Python 3.2新增的参数，可取值为 ‘%’, ‘{‘和 ‘$’，如果不指定该参数则默认使用’%’</li></ul><h4 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h4><p>Filter可以被Handler和Logger用来做比level更细粒度的、更复杂的过滤功能。Filter是一个过滤器基类，它只允许某个logger层级下的日志事件通过过滤。该类定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class logging.Filter(name=&apos;&apos;)</span><br><span class="line">    filter(record)</span><br></pre></td></tr></table></figure><p>比如，一个filter实例化时传递的name参数值为’A.B’，那么该filter实例将只允许名称为类似如下规则的loggers产生的日志记录通过过滤：’A.B’，’A.B,C’，’A.B.C.D’，’A.B.D’，而名称为’A.BB’, ‘B.A.B’的loggers产生的日志则会被过滤掉。如果name的值为空字符串，则允许所有的日志事件通过过滤。</p><p>filter方法用于具体控制传递的record记录是否能通过过滤，如果该方法返回值为0表示不能通过过滤，返回值为非0表示可以通过过滤。</p><p><strong>说明：</strong></p><blockquote><ul><li>如果有需要，也可以在filter(record)方法内部改变该record，比如添加、删除或修改一些属性。</li><li>我们还可以通过filter做一些统计工作，比如可以计算下被一个特殊的logger或handler所处理的record数量等。</li></ul></blockquote><h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><p><strong>需求：</strong></p><p>生成2个日志文件</p><ol><li><p>普通日志文件：</p><ul><li>日志级别：INFO及以上级别</li><li>格式：dcache.log | 之前文件：dcache.log.2018-12-09</li><li>日志轮询：所有级别的日志相对来说会比较大，因此按天分割，每天输出一个日志文件，保留30天</li></ul></li><li><p>error日志：</p><ul><li>日志级别：Error及CRITICAL级别</li><li>格式：dcache-error.log | 之前文件：dcache-error.log.2018-12-09</li><li>日志轮询：error日志不会太大，因此每7天生成一个新的文件，保留4个文件</li></ul></li></ol><p><strong>分析：</strong></p><ul><li>要记录INFO级别机器以上的日志，因此日志器的有效level需要设置为最低级别–INFO;</li><li>日志需要被发送到2个不同的目的地，因此需要为日志器设置2个handler，并且这3个目的地都是磁盘文件，因此这3个handler都是与FileHandler相关的</li><li>这里使用统一的内容格式，因此handler分别格式器设置一致，不需要额外区分</li><li>日志按照时间进行分割，因此需要用logging.handlers.TimedRotatingFileHandler; 而不是使用FileHandler;</li></ul><p><strong>代码实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">import logging.handlers</span><br><span class="line">from os import path</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">生成2个日志文件</span><br><span class="line">1. 普通日志文件：</span><br><span class="line">    - 日志级别：INFO及以上级别</span><br><span class="line">    - 格式：dcache.log | 之前文件：dcache.log.2018-12-09</span><br><span class="line">    - 日志轮询：按天分割，每天输出一个日志文件，保留30天</span><br><span class="line"></span><br><span class="line">2. error日志：</span><br><span class="line">    - 日志级别：Error及CRITICAL级别</span><br><span class="line">    - 格式：dcache-error.log | 之前文件：dcache-error.log.2018-12-09</span><br><span class="line">    - 日志轮询：为防止文件过大，每7天生成一个新的文件，保留7个文件</span><br><span class="line">    </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">## 定义日志文件名称格式</span><br><span class="line">base_log_name = path.abspath(path.dirname(path.dirname(__file__))) + &apos;/logs/&apos; + &quot;dcache&quot;</span><br><span class="line">info_log_filename = base_log_name + &quot;.log&quot;</span><br><span class="line">error_log_filename = base_log_name + &quot;-error.log&quot;</span><br><span class="line"></span><br><span class="line"># 定义日志内容的输出格式</span><br><span class="line">log_format = &quot;%(asctime)s - %(levelname)s - %(pathname)s[line:%(lineno)d] - %(message)s&quot;</span><br><span class="line"></span><br><span class="line"># 定义日志处理器(实例化一个日志处理器对象)</span><br><span class="line">logger = logging.getLogger(&apos;root&apos;)</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"># 定义handlers</span><br><span class="line">info_handler = logging.handlers.TimedRotatingFileHandler(info_log_filename, when=&apos;midnight&apos;, interval=1,backupCount=30, atTime=datetime.time(0, 0, 0, 0))</span><br><span class="line">info_handler.suffix = &quot;%Y-%m-%d&quot;</span><br><span class="line">info_handler.setLevel(logging.INFO)</span><br><span class="line">info_handler.setFormatter(logging.Formatter(log_format))</span><br><span class="line"></span><br><span class="line">error_handler = logging.handlers.TimedRotatingFileHandler(error_log_filename, when=&apos;midnight&apos;, interval=7,backupCount=4, atTime=datetime.time(0, 0, 0, 0))</span><br><span class="line">error_handler.suffix = &quot;%Y-%m-%d&quot;</span><br><span class="line">error_handler.setLevel(logging.ERROR)</span><br><span class="line">error_handler.setFormatter(logging.Formatter(log_format))</span><br><span class="line"></span><br><span class="line"># 日志器添加handlers</span><br><span class="line">logger.addHandler(info_handler)</span><br><span class="line">logger.addHandler(error_handler)</span><br><span class="line"></span><br><span class="line"># test</span><br><span class="line">logger.debug(&apos;debug message&apos;)</span><br><span class="line">logger.info(&apos;info message&apos;)</span><br><span class="line">logger.warning(&apos;warning message&apos;)</span><br><span class="line">logger.error(&apos;error message&apos;)</span><br><span class="line">logger.critical(&apos;critical message&apos;)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>interval表示的是：多少个指定时间内，当前的日志文件没有新的内容被写入进来，再去创建新文件，而不是时间一到就去创建新文件。每次每隔一小时输出一个文件的功能使用TimedRotatingFileHandler的方式实现不了。</li><li>因此要每小时一个文件的这种功能，需要我们想其他办法去实现</li></ul>]]></content>
    
    <summary type="html">
    
      python日志处理
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="python日志处理" scheme="http://yoursite.com/tags/python%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>运维思想</title>
    <link href="http://yoursite.com/2018/12/04/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E6%80%9D%E6%83%B3/%E8%BF%90%E7%BB%B4%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2018/12/04/IT科学技术知识体系结构-Linux运维方向/运维思想/运维思想/</id>
    <published>2018-12-04T01:47:52.000Z</published>
    <updated>2018-12-04T01:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="产品思维指导工作"><a href="#产品思维指导工作" class="headerlink" title="产品思维指导工作"></a>产品思维指导工作</h1><h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><ul><li>站在远处、高处分析这件事对不对</li><li>所负责的工作产出是一个产品，自己本身也是一个产品</li><li>如何确定目标：主谓宾方法论，未来十年，什么是不变的</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>不关注合理性，只讨论必要性</li><li>目标–&gt;路径–&gt;资源（目标管理本质其实是资源管理）</li></ul><h2 id="运营"><a href="#运营" class="headerlink" title="运营"></a>运营</h2><ul><li>把目标分解成没人每天每件事</li></ul><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><h2 id="效率（每天的工作）"><a href="#效率（每天的工作）" class="headerlink" title="效率（每天的工作）"></a>效率（每天的工作）</h2><ul><li>流程</li><li>规范</li><li>框架</li></ul><h2 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h2>]]></content>
    
    <summary type="html">
    
      运维思想
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="运维思想" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%BF%90%E7%BB%B4%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="运维思想" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>day14-前端技术</title>
    <link href="http://yoursite.com/2018/11/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day14-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/11/28/编程语言/Python/老男孩视频学习笔记/day14-前端技术/</id>
    <published>2018-11-28T15:31:09.000Z</published>
    <updated>2018-11-28T15:31:09.000Z</updated>
    
    <summary type="html">
    
      day14-前端技术
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>day09-进程线程协程</title>
    <link href="http://yoursite.com/2018/11/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day09-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/11/28/编程语言/Python/老男孩视频学习笔记/day09-进程线程协程/</id>
    <published>2018-11-28T15:24:56.000Z</published>
    <updated>2018-11-28T15:24:56.000Z</updated>
    
    <summary type="html">
    
      day09-进程线程协程
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>day08-socket编程</title>
    <link href="http://yoursite.com/2018/11/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day08-socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/11/28/编程语言/Python/老男孩视频学习笔记/day08-socket编程/</id>
    <published>2018-11-28T14:52:56.000Z</published>
    <updated>2018-11-28T14:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day08目录"><a href="#day08目录" class="headerlink" title="day08目录"></a>day08目录</h1><ul><li>08-03 通过socket实现减半的ssh</li><li><p>08-04 通过socket结束大数据</p></li><li><p>08-06 通过socket接收大数据</p></li><li><p>08-06 通过socket实现文件发送</p></li><li>08-07 socket粘包问题解决</li><li><p>08-09 socketservr使用</p></li><li><p>08-10 socketservr使用2</p></li></ul>]]></content>
    
    <summary type="html">
    
      day08-socket编程
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>bind部署</title>
    <link href="http://yoursite.com/2018/11/20/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/DNS%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0-bind/bind%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/11/20/IT科学技术知识体系结构-Linux运维方向/网络知识及网络服务/网络服务/DNS服务实现-bind/bind部署/</id>
    <published>2018-11-20T06:54:05.000Z</published>
    <updated>2018-11-20T06:54:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.isc.org/downloads/bind/" target="_blank" rel="noopener">bind官方网站</a></li><li><a href="https://ftp.isc.org/isc/bind9/9.12.2-P2/doc/arm/Bv9ARM.pdf" target="_blank" rel="noopener">bind9官方PDF文档</a></li><li><a href="http://cn.linux.vbird.org/linux_server/0350dns.php" target="_blank" rel="noopener">鸟哥的bind文章</a></li><li><a href="http://blog.51cto.com/yuanbin/108572" target="_blank" rel="noopener">BIND配置文件详解（一）</a></li><li>《TCP/IP详解》DNS部分</li><li>google了无数网页</li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>记录在bind中的一些基本概念</p><ul><li>DNS服务器：向客户端提供域名解析服务的服务器·</li><li><p>DNS服务器的类型；</p><ul><li>主DNS服务器：维护所负责解析的域内解析库服务器；解析库由管理维护；读写操作均可进行；</li><li>从DNS服务器：从主DNS服务器或从其他的从DNS服务器那里区域传递(类似“复制”)一份解析库，只能进行读操作</li><li>缓存DNS服务器：负责代理客户机的递归查询工作，并且采用迭代查询的服务器</li><li>转发器：如果目标域名在本DNS服务器辖区内，直接转发</li></ul></li><li><p>BIND (Berkeley Internet Name Domain)</p><blockquote><p>是Domain Name System (DNS) 协议的一个实现，提供了DNS主要功能的开放实现</p></blockquote></li><li><p>资源记录</p><blockquote><p>resource records (RRs) | 表示</p></blockquote></li><li><p>domain </p><blockquote><p>域，树状结构上的每一个节点叫做domain</p><p>Each node of the tree, called a domain, is given a label. </p></blockquote></li><li><p>Domain name</p><blockquote><p>存储在dns分布式数据库中的每一个具体的数据被称之为域名</p><p>The data stored in the DNS is identified by <strong><code>domain names</code></strong> that are organized as a tree according to organizational or administrative boundaries</p></blockquote></li><li><p>zone </p><blockquote><p>zone是dns树状结构中某个节点的代表</p><p>a zone is a point of delegation in the DNS tree</p><p>zone被用于管理界限的划分，一个域名空间被划分为各个区域，也就是zone</p><p>zone本身就是一个节点（domain），一个zone包含了那些相邻并且是往下的节点</p><p>It contains all domain names from a certain point downward in the<br>domain tree except those which are delegated to other zones</p><p>这个zone(节点)被它的上级zone标记为NS记录，而它的上级zone将会被根标记为NS记录</p><p>A delegation point is marked by one or more NS records in the parent zone, which should be matched by equivalent NS records at the root of the delegated zone</p><p>例如，有一个 domain 叫 example.com ，它可以包含test1.aaa.example.com 和<br>test2.bbb.example.com 这些名字，但是它的 zone 文件中却只有 2 个 zone 的记录<br>aaa.example.com 和 bbb.example.com。</p></blockquote></li><li><p>权威DNS服务器（Authoritative name server）</p><blockquote><p>权威服务器用于响应dns客户端的请求，上面有完整的zone数据，下面要说的主和从服务器都是属于权威服务器</p><p>在响应数据库报中，我们可以看到authoritative answer标志位的出现</p><p>设置权威服务器可以帮助我们排查问题，例如使用dig的时候可以输出重要信息</p><p>Responses from authoritative servers have the “authoritative answer” (AA) bit set in the response<br>packets. This makes them easy to identify when debugging DNS configurations using<br>tools like dig </p></blockquote></li><li><p>The Primary Master 主域名服务器</p><blockquote><p>在权威服务器中，起主要重要的我们称之为主域名服务器</p><p>数据文件一般是zone file或者master file</p><p>This file is called the zone file or master file.</p></blockquote></li><li><p>Slave Servers 从域名服务器</p><blockquote><p>权威服务器的一种</p><p>slave提供必要的冗余服务，所有的slave服务器都应该记录在这个域名的ns记录中</p><p>一般来说，slave上的数据一般是通过zone transfer进程从master上同步的，但是它也能从其他slave节点上同步数据</p><p>slave节点会周期性的发送请求到master节点，检测和同步数据（sending a query for the zone’s SOA record and checking whether the SERIAL field has been updated）</p></blockquote></li><li><p>bind-chroot</p><blockquote><p>bind-chroot是bind的一个功能，使bind可以在一个chroot的模式下运行。也就是说，bind运行时的/(根)目录，并不是系统真正的/(根)目录，只是系统中的一个子目录而已。这样做的目的是为了提高安全性。因为在chroot的模式下，bind可以访问的范围仅限于这个子目录的范围里，无法进一步提升，进入到系统的其他目录中。</p></blockquote></li><li><p>dns服务器工作流程</p><blockquote><ol><li><p>设置forward转发。如果设置了转发，则将请求转发到forward服务器</p></li><li><p>没有设置forward转发</p><p>1). 本地cache</p><p>2). 本地zone配置</p><p>2). 若本地cache和zone都没有数据，则前往root(.)进行查询</p></li></ol></blockquote></li></ul><h1 id="具体部署"><a href="#具体部署" class="headerlink" title="具体部署"></a>具体部署</h1><h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><p>在做测试或者只是提供基本功能的时候，我们可以使用软件源，只需用yum(redhat、centos系列)等方式安装即可。</p><p>如果需要更深层次的使用配置，我们建议使用源码包的安装方式</p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd named</span><br><span class="line">useradd -g named named</span><br></pre></td></tr></table></figure><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>依赖关系需要使用管理员用户安装</p><p>具体安装哪些需要根据实际的服务器情况决定，例如gcc、openssl等都是需要的，这里不再赘述。</p><h2 id="下载bind"><a href="#下载bind" class="headerlink" title="下载bind"></a>下载bind</h2><p>为了便于后续的维护及配置，这里采用源码包的安装方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 ~]$ pwd</span><br><span class="line">/home/named</span><br><span class="line">[named@host1 ~]$ wget https://www.isc.org/downloads/file/bind-9-12-3/?version=tar-gz -O bind-9.12.3.tar.gz</span><br></pre></td></tr></table></figure><p>这里我们选择9.12.3版本（当前时间节点为：2018年11月20日）</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在编译的时候可以添加以下功能参数</p><ul><li><code>--enable-threads</code>  | 在多cpu环境下，开启多线程支持，提高性能</li><li><code>--with-tuning=large</code> | 在内存充裕（12G以上）的情况下，开启以提高性能，否则不建议开启</li><li><code>--prefix=&lt;PREFIX&gt;</code> | 自定义安装路径，源码安装时必须指定。 </li><li><code>--with-openssl=&lt;PREFIX&gt;</code> | 如果使用自定义的openssl，需要进行指定。使用系统自带的就不需要额外指定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf bind-9.12.3.tar.gz</span><br><span class="line">./configure --prefix=/home/named/bind</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>安装完成之后在目录下会提供一些调试工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 bin]$ pwd;ls</span><br><span class="line">/home/named/bind/bin </span><br><span class="line">arpaname  bind9-config  delv  dig  host  isc-config.sh  mdig  named-rrchecker  nslookup  nsupdate</span><br></pre></td></tr></table></figure><p>然后我们把必要的系统管理命令的目录路径添加到系统路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 ~]$ vim .bash_profile  # 在文件末尾添加一下2行内容</span><br><span class="line">PATH=/home/named/bind/sbin/:$PATH</span><br><span class="line">export PATH</span><br><span class="line">alias rndc=&apos;rndc -c /home/named/bind/chroot/etc/rndc.conf&apos;</span><br><span class="line">[named@host1 ~]$ source .bash_profile</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h3><h4 id="1-创建chroot目录"><a href="#1-创建chroot目录" class="headerlink" title="1. 创建chroot目录"></a>1. 创建chroot目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 bind]$ mkdir -p /home/named/bind/chroot/&#123;etc,var,log&#125;</span><br><span class="line">[named@host1 bind]$ mkdir -p /home/named/bind/chroot/var/&#123;run,named&#125;</span><br><span class="line">[named@host1 bind]$ mkdir -p /home/named/bind/chroot/var/named/&#123;zone,data&#125;</span><br></pre></td></tr></table></figure><h4 id="2-生成配置文件"><a href="#2-生成配置文件" class="headerlink" title="2. 生成配置文件"></a>2. 生成配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$ pwd</span><br><span class="line">/home/named/bind/chroot/etc</span><br><span class="line">[named@host1 etc]$ /home/named/bind/sbin/rndc-confgen &gt; rndc.conf</span><br><span class="line">[named@host1 etc]$ sed -n &apos;15,23s/#\ //p&apos;  rndc.conf  &gt; named.conf</span><br></pre></td></tr></table></figure><p>两个配置文件简要说明：</p><ul><li><p>named.conf </p><p>这个是我们的主配置文件，关于域名的配置都记录在这里</p></li><li><p>rndc.conf</p><p>这个是rndc的安全配置文件。</p><p>rndc 是 BIND 9 之后提供一个管理工具，包括重加载zone数据而不需要重新启动整个 DNS 、检查 DNS 的状态与统计数据等等</p><p>因为 rndc 可以很深入的管理DNS 服务器，所以要进行一些管控。控管的方式是通过rndc 的设置创建一个密钥 (rndc key)，并将这个密钥相关信息写入 named.conf 配置文件当中。启动 DNS 后，你的 DNS 就能够藉由 rndc 这个命令管理！ </p></li></ul><h4 id="3-下载name-root文件（13个根服务器的配置）"><a href="#3-下载name-root文件（13个根服务器的配置）" class="headerlink" title="3. 下载name.root文件（13个根服务器的配置）"></a>3. 下载name.root文件（13个根服务器的配置）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$ wget  ftp://ftp.rs.internic.net/domain/named.root -P /home/named/bind/chroot/var/named/</span><br></pre></td></tr></table></figure><h4 id="4-创建localhost-zone文件"><a href="#4-创建localhost-zone文件" class="headerlink" title="4. 创建localhost.zone文件"></a>4. 创建localhost.zone文件</h4><p>该文件一般情况下不使用，因为服务器上的本地hosts文件中都会添加这个信息</p><p>在实际部署时，不会使用。这里也进行说明，如有特殊需求可以使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 named]$ pwd</span><br><span class="line">/home/named/bind/chroot/var/named</span><br><span class="line">[named@host1 named]$ cat localhost.zone</span><br><span class="line">$TTL      86400</span><br><span class="line">@     IN SOA      @ root (</span><br><span class="line">                                  1                ; serial (d. adams)</span><br><span class="line">                                  3H                ; refresh</span><br><span class="line">                                  15M               ; retry</span><br><span class="line">                                  1W                ; expiry</span><br><span class="line">                                  1D )              ; minimum</span><br><span class="line">                IN NS           @</span><br><span class="line">                IN A            127.0.0.1</span><br><span class="line">                IN AAAA         ::1</span><br></pre></td></tr></table></figure><h4 id="5-创建文件localhost-rev"><a href="#5-创建文件localhost-rev" class="headerlink" title="5. 创建文件localhost.rev"></a>5. 创建文件localhost.rev</h4><p>该文件一般情况下不使用，因为服务器上的本地hosts文件中都会添加这个信息</p><p>在实际部署时，不会使用。这里也进行说明，如有特殊需求可以使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 named]$ pwd</span><br><span class="line">/home/named/bind/chroot/var/named</span><br><span class="line">[named@host1 named]$ cat localhost.rev</span><br><span class="line">$TTL    86400</span><br><span class="line">@    IN      SOA        localhost. root.localhost.  (</span><br><span class="line">                                        1  ; Serial</span><br><span class="line">                                        3H       ; Refresh</span><br><span class="line">                                        15M        ; Retry</span><br><span class="line">                                        1W      ; Expire</span><br><span class="line">                                        1D )      ; Minimum</span><br><span class="line">        IN        NS        localhost.</span><br><span class="line">1       IN        PTR       localhost.</span><br></pre></td></tr></table></figure><h4 id="6-修改named-conf配置文件"><a href="#6-修改named-conf配置文件" class="headerlink" title="6. 修改named.conf配置文件"></a>6. 修改named.conf配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$ pwd</span><br><span class="line">/home/named/bind/chroot/etc</span><br><span class="line">[named@host1 etc]$ cat named.conf</span><br><span class="line">key &quot;rndc-key&quot; &#123;</span><br><span class="line">algorithm hmac-sha256;</span><br><span class="line">secret &quot;vqOF9VUn75lvtpCYvYffOVNT8LkLK0z78UCPVkX1ofk=&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">controls &#123;</span><br><span class="line">inet 127.0.0.1 port 953</span><br><span class="line">allow &#123; 127.0.0.1; &#125; keys &#123; &quot;rndc-key&quot;; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">options&#123;</span><br><span class="line">        listen-on port 53&#123;</span><br><span class="line">                192.168.103.99;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        listen-on-v6 port 53&#123;</span><br><span class="line">                fe80::20c:29ff:fefe:d1f4;</span><br><span class="line">        &#125;;</span><br><span class="line">        version &quot;bind 9.12.3&quot;;</span><br><span class="line">        directory &quot;/home/named/bind/chroot/var/named&quot;;</span><br><span class="line">        pid-file &quot;/home/named/bind/chroot/var/run/named.pid&quot;;</span><br><span class="line">        session-keyfile &quot;/home/named/bind/chroot/var/run/session.key&quot;;</span><br><span class="line">        dump-file &quot;/home/named/bind/chroot/var/named/data/cache_dump.db&quot;;</span><br><span class="line">        statistics-file &quot;/home/named/bind/chroot/var/named/data/named_stats.txt&quot;;</span><br><span class="line">        memstatistics-file &quot;/home/named/bind/chroot/var/named/data/named_mem_stats.txt&quot;;</span><br><span class="line">        recursion yes;</span><br><span class="line">        allow-query&#123;</span><br><span class="line">                any;</span><br><span class="line">        &#125;;</span><br><span class="line">        allow-query-cache&#123;</span><br><span class="line">                any;</span><br><span class="line">        &#125;;</span><br><span class="line">        allow-transfer&#123;</span><br><span class="line">                192.168.101.172;</span><br><span class="line">       &#125;;</span><br><span class="line">        notify yes;</span><br><span class="line">        also-notify&#123;</span><br><span class="line">                192.168.101.172;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">logging &#123;</span><br><span class="line">        channel default_debug &#123;</span><br><span class="line">                file &quot;/home/named/bind/chroot/log/named.run&quot; versions 10 size 128m;</span><br><span class="line">                severity dynamic;</span><br><span class="line">                print-category yes;</span><br><span class="line">                print-severity yes;</span><br><span class="line">                print-time yes;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel queries_info &#123;</span><br><span class="line">                file &quot;/home/named/bind/chroot/log/query.log&quot; versions 10 size 128m;</span><br><span class="line">                severity info;</span><br><span class="line">                print-category yes;</span><br><span class="line">                print-severity yes;</span><br><span class="line">                print-time yes;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        category queries &#123;</span><br><span class="line">                queries_info;</span><br><span class="line">                default_debug;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel notify_info &#123;</span><br><span class="line">                file &quot;/home/named/bind/chroot/log/notify.log&quot; versions 10 size 128m;</span><br><span class="line">                severity info;</span><br><span class="line">                print-category yes;</span><br><span class="line">                print-severity yes;</span><br><span class="line">                print-time yes;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        category notify &#123;</span><br><span class="line">                notify_info;</span><br><span class="line">                default_debug;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel xfer_in_log &#123;</span><br><span class="line">                file &quot;/home/named/bind/chroot/log/xfer_in.log&quot; versions 10 size 128m;</span><br><span class="line">                severity info;</span><br><span class="line">                print-category yes;</span><br><span class="line">                print-severity yes;</span><br><span class="line">                print-time yes;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel xfer_out_log &#123;</span><br><span class="line">                file &quot;/home/named/bind/chroot/log/xfer_out.log&quot; versions 10 size 128m;</span><br><span class="line">                severity info;</span><br><span class="line">                print-category yes;</span><br><span class="line">                print-severity yes;</span><br><span class="line">                print-time yes;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        category xfer-in &#123; xfer_in_log; &#125;;</span><br><span class="line">        category xfer-out &#123; xfer_out_log; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone &quot;.&quot; in&#123;</span><br><span class="line">        type hint;</span><br><span class="line">        file &quot;named.root&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">zone &quot;localhost&quot; in&#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;localhost.zone&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">zone &quot;0.0.127.in-addr.arpa&quot; in&#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;localhost.rev&quot;;</span><br><span class="line">        allow-update &#123; none; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">zone &quot;test.com&quot; IN &#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;zone/test.com.zone&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：localhost和0.0.127.in-addr.arpa这2个zone，我们在实际部署的时候不会添加，当有特殊需求时使用</p><p>上面是为了测试把zone信息写了出来，在实际部署中，主配置文件中zone相关部分替换成下面这种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include &quot;/home/named/bind/chroot/etc/acls/shidc&quot;;</span><br><span class="line">include &quot;/home/named/bind/chroot/etc/acls/hzidc&quot;;</span><br><span class="line">include &quot;/home/named/bind/chroot/etc/acls/aliyun-east1&quot;;</span><br><span class="line"></span><br><span class="line">include &quot;/home/named/bind/chroot/etc/views/shidc&quot;;</span><br><span class="line">include &quot;/home/named/bind/chroot/etc/views/hzidc&quot;;</span><br><span class="line">include &quot;/home/named/bind/chroot/etc/views/aliyun-east1&quot;;</span><br></pre></td></tr></table></figure><p>有关acl以及view的部分，请查看本文的<strong>bind总结</strong>部分的named.conf配置文件详解</p><h4 id="7-创建zone相关文件"><a href="#7-创建zone相关文件" class="headerlink" title="7. 创建zone相关文件"></a>7. 创建zone相关文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 zone]$ pwd</span><br><span class="line">/home/named/bind/chroot/var/named/zone</span><br><span class="line">[named@host1 zone]$ cat test.com.zone</span><br><span class="line">$TTL      86400</span><br><span class="line">@            IN SOA  test.com.  admin.test.com. (</span><br><span class="line">                      57                ; serial (d. adams)</span><br><span class="line">                      3H                ; refresh</span><br><span class="line">                      15M                ; retry</span><br><span class="line">                      1W                ; expiry</span><br><span class="line">                      1D )              ; minimum</span><br><span class="line">        IN         NS     dns.test.com.</span><br><span class="line">        IN         MX  5  mail</span><br><span class="line">dns     IN      A      192.168.11.91</span><br><span class="line">mail    IN      A      192.168.11.102</span><br><span class="line">www     IN      A      192.168.11.8</span><br></pre></td></tr></table></figure><h4 id="8-检查配置文件"><a href="#8-检查配置文件" class="headerlink" title="8. 检查配置文件"></a>8. 检查配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$ /home/named/bind/sbin/named-checkconf /home/named/bind/chroot/etc/named.conf</span><br></pre></td></tr></table></figure><h4 id="9-检查正向和反向zone配置文件"><a href="#9-检查正向和反向zone配置文件" class="headerlink" title="9. 检查正向和反向zone配置文件"></a>9. 检查正向和反向zone配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$ /home/named/bind/sbin/named-checkzone localhost /home/named/bind/chroot/var/named/localhost.zone</span><br><span class="line">zone localhost/IN: loaded serial 42</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">[named@host1 etc]$ /home/named/bind/sbin/named-checkzone 127.0.0.1 /home/named/bind/chroot/var/named/localhost.rev</span><br><span class="line">zone 127.0.0.1/IN: loaded serial 1997022700</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h4 id="10-检查自定义zone配置文件"><a href="#10-检查自定义zone配置文件" class="headerlink" title="10. 检查自定义zone配置文件"></a>10. 检查自定义zone配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$ /home/named/bind/sbin/named-checkzone 127.0.0.1 /home/named/bind/chroot/var/named/zone/test.com.zone</span><br><span class="line">zone 127.0.0.1/IN: loaded serial 57</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="主从-主辅同步配置"><a href="#主从-主辅同步配置" class="headerlink" title="主从/主辅同步配置"></a>主从/主辅同步配置</h3><p>bind的主从，也称之为主辅，其实都是一样的。</p><h4 id="master-主配置"><a href="#master-主配置" class="headerlink" title="master/主配置"></a>master/主配置</h4><h5 id="修改named-conf配置文件"><a href="#修改named-conf配置文件" class="headerlink" title="修改named.conf配置文件"></a>修改named.conf配置文件</h5><p>在<strong>option配置段</strong>中增加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allow-transfer&#123;</span><br><span class="line">        192.168.11.89;</span><br><span class="line">&#125;; </span><br><span class="line">notify yes;</span><br><span class="line">also-notify&#123;</span><br><span class="line">        192.168.11.89;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是全局配置，如果是配置到具体的zone，只需要将以上3个参数配置zone里面即可（从服务器无需变化），如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">zone &quot;test.com&quot; IN &#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;zone/test.com.zone&quot;;</span><br><span class="line">        allow-transfer&#123;</span><br><span class="line">                192.168.11.89;</span><br><span class="line">        &#125;;</span><br><span class="line">        notify yes;</span><br><span class="line">        also-notify&#123;</span><br><span class="line">                192.168.11.89;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>增加参数为：</p><ul><li><p>allow-transfer</p></li><li><p>notify</p></li><li><p>also-notify</p></li></ul><p>有关这些参数的含义，请查看本文的<strong>bind总结</strong>部分的named.conf配置文件详解</p><p><strong>注意</strong>：bind的主辅同步可以针对具体的每一个zone，也就是说每个zone都可以配置自己的从服务器。当域名的数据量很庞大时，为提高解析效率，实现读写分离，使用一台主服务器写，并将域名均分到多台从服务器上，以提高读的效率。</p><h4 id="slave-辅配置"><a href="#slave-辅配置" class="headerlink" title="slave/辅配置"></a>slave/辅配置</h4><h5 id="修改named-conf配置文件-1"><a href="#修改named-conf配置文件-1" class="headerlink" title="修改named.conf配置文件"></a>修改named.conf配置文件</h5><p>在<strong>zone配置段</strong>中增加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$ pwd</span><br><span class="line">/home/named/bind/chroot/etc</span><br><span class="line">[named@host1 etc]$ vim named.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zone &quot;test.com&quot; IN &#123;</span><br><span class="line">        type slave;</span><br><span class="line">        file &quot;zone/test.com.zone&quot;;</span><br><span class="line">        masters&#123;</span><br><span class="line">                192.168.11.91;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要增加参数：</p><ul><li><p>masters 配置主服务器</p></li><li><p>type slave指定为从服务器</p></li></ul><p>注意：slave端的zone配置文件可以事先不存在，但是对应的存储目录一定要存在</p><h3 id="子域授权配置"><a href="#子域授权配置" class="headerlink" title="子域授权配置"></a>子域授权配置</h3><p>除了 Master/Slave 这种需要多个DNS 服务器共同提供服务之外，DNS 之间如果有上层、下属的关系时，该如何设置？ </p><p>也就是说，假设我的管理范围很大，我只想要负责上层的 DNS ，下层希望直接交给各单位的负责人来负责，要怎么设置呢？ </p><p>所以，bind可以将各个 subdomain (子域) 的管理权交给指定的的主机管理员去管理，如此一来， 域名设置会比较灵活，而且上层 DNS 服务器管理员也不用太麻烦！</p><p>子域授权在我们当前的这种架构中不会部署，但是也提及一下</p><p>子域授权的配置相当简单，分为两个步骤</p><h4 id="步骤1-master端配置"><a href="#步骤1-master端配置" class="headerlink" title="步骤1. master端配置"></a>步骤1. master端配置</h4><p>我们只需要在master端的zone配置文件（注意是zone配置文件而不是named.conf）添加对应的NS记录和A记录即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub.test.com.com.      IN NS    dns.sub.test.com.com.</span><br><span class="line">dns.sub.test.com.com.  IN A     192.168.100.200</span><br></pre></td></tr></table></figure><p>在这里，我们把sub.test.com.com.这个子域的解析交给dns.sub.test.com.com.这个域名对应的主机</p><p>因此，在这之后，例如www.sub.test.com.com.、aaa.sub.test.com.com.等域名都将由200这个主机提供解析服务</p><h4 id="步骤2-下层dns服务器"><a href="#步骤2-下层dns服务器" class="headerlink" title="步骤2. 下层dns服务器"></a>步骤2. 下层dns服务器</h4><p>上层 DNS 的设置非常简单！只要修改 zone file 即可</p><p>下层的dns服务器配置没有什么特殊的，按照正常的配置，只不过named.conf和zone配置文件中域名要设置成“sub.test.com.com”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zone &quot;sub.test.com.com&quot; IN &#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;zone/sub.test.com.com.zone&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="view-视图解析配置"><a href="#view-视图解析配置" class="headerlink" title="view-视图解析配置"></a>view-视图解析配置</h3><p>根据客户端的ip地址，返回不同的zone解析记录，因此，我们就需要对同一个zone准备几个不同的配置</p><p>我们根据这个原则，进行如下的测试</p><ul><li>当来源是192.168.11.0/24网段时，返回www.test.com的解析记录是192.168.11.80</li><li><p>当来源是非上述之外的所有网段时，返回www.test.com的解析记录是8.8.8.8</p></li><li><p>对不同的来源创建不同的zone文件</p></li></ul><p>下面我们开始正式的配置</p><p>在named.conf配置文件中添加一下内容</p><p>view的配置分为2个步骤，一个是设置客户端的来源，这部分通过acl列表设置；另一个是编辑view块</p><h4 id="acl列表"><a href="#acl列表" class="headerlink" title="acl列表"></a>acl列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acl internal &#123;192.168.11.0/24;&#125;;       </span><br><span class="line">acl external &#123;!192.168.11.0/24;any;&#125;;</span><br></pre></td></tr></table></figure><p>!表示反向选择的意思，也就是取反</p><p>第二行其实也可以写成如下的形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl external &#123;!&quot;internal&quot;;any;&#125;;</span><br></pre></td></tr></table></figure><p>当ip地址和网段过多时，可以采取导入外部文件的形式</p><p>文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># cat CHINANET.acl</span><br><span class="line">acl &quot;CHINANET&quot; &#123;</span><br><span class="line">1.0.1.0/24;</span><br><span class="line">1.0.2.0/23;</span><br><span class="line">1.0.8.0/21;</span><br><span class="line">1.0.32.0/19;</span><br><span class="line">1.1.0.0/24;</span><br><span class="line">1.1.2.0/23;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>named.conf配置方式如下</p><p>导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &quot;/home/named/bind/etc/CHINANET.acl&quot;;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view &quot;view_CHINANET&quot; &#123;</span><br><span class="line">match-clients &#123;CHINANET; &#125;;</span><br></pre></td></tr></table></figure><h4 id="view区块配置"><a href="#view区块配置" class="headerlink" title="view区块配置"></a>view区块配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">view &quot;internal&quot; &#123;</span><br><span class="line">    match-clients &#123;&quot;internal&quot;;&#125;;</span><br><span class="line">        zone &quot;.&quot; in&#123;</span><br><span class="line">                type hint;</span><br><span class="line">                file &quot;named.root&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">        zone &quot;localhost&quot; in&#123;</span><br><span class="line">                type master;</span><br><span class="line">                file &quot;localhost.zone&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">        zone &quot;0.0.127.in-addr.arpa&quot; in&#123;</span><br><span class="line">                type master;</span><br><span class="line">                file &quot;localhost.rev&quot;;</span><br><span class="line">                allow-update &#123; none; &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        zone &quot;test.com&quot; IN &#123;</span><br><span class="line">                type master;</span><br><span class="line">                file &quot;zone/test.com.zone.int&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">view &quot;external&quot; &#123;</span><br><span class="line">    match-clients &#123;&quot;external&quot;;&#125;;</span><br><span class="line">        zone &quot;.&quot; in&#123;</span><br><span class="line">                type hint;</span><br><span class="line">                file &quot;named.root&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">        zone &quot;localhost&quot; in&#123;</span><br><span class="line">                type master;</span><br><span class="line">                file &quot;localhost.zone&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">        zone &quot;0.0.127.in-addr.arpa&quot; in&#123;</span><br><span class="line">                type master;</span><br><span class="line">                file &quot;localhost.rev&quot;;</span><br><span class="line">                allow-update &#123; none; &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        zone &quot;test.com&quot; IN &#123;</span><br><span class="line">                type master;</span><br><span class="line">                file &quot;zone/test.com.zone.ext&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><strong>192.168.11.0/24网段主机</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@wxh-func-test-3 ~]# dig @192.168.11.91 -p 53 www.test.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.68.rc1.el6_10.1 &lt;&lt;&gt;&gt; @192.168.11.91 -p 53 www.test.com</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 43365</span><br><span class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.test.com.INA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.test.com.86400INA192.168.11.80</span><br><span class="line"></span><br><span class="line">;; Query time: 1 msec</span><br><span class="line">;; SERVER: 192.168.11.91#53(192.168.11.91)</span><br><span class="line">;; WHEN: Tue Nov 27 14:14:26 2018</span><br><span class="line">;; MSG SIZE  rcvd: 46</span><br><span class="line"></span><br><span class="line">[root@wxh-func-test-3 ~]#</span><br></pre></td></tr></table></figure><p><strong>其他网段主机</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ dig @192.168.11.91 -p 53 www.test.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; @192.168.11.91 -p 53 www.test.com</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 25915</span><br><span class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.test.com.INA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.test.com.86400INA8.8.8.8</span><br><span class="line"></span><br><span class="line">;; Query time: 10 msec</span><br><span class="line">;; SERVER: 192.168.11.91#53(192.168.11.91)</span><br><span class="line">;; WHEN: Tue Nov 27 14:13:07 CST 2018</span><br><span class="line">;; MSG SIZE  rcvd: 57</span><br></pre></td></tr></table></figure><p><strong>dns服务器端的访问日志</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@Zabbix server log]# tailf query.log</span><br><span class="line">27-Nov-2018 14:13:12.955 queries: info: client @0x7fcf840be8e0 192.168.11.64#47324 (www.test.com): view internal: query: www.test.com IN A + (192.168.11.91)</span><br><span class="line">27-Nov-2018 14:13:18.323 queries: info: client @0x7fcf840be8e0 192.168.101.35#50891 (www.test.com): view extenal: query: www.test.com IN A +E(0) (192.168.11.91)</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h3><p>通过查看源码包中提供的named.8，我们在启动的时候添加以下参数：</p><ul><li><p>-L logfile</p><p>Log to the file logfile by default instead of the system log.</p></li><li><p>-u user</p><p>Setuid to user after completing privileged operations, such as creating sockets that listen on privileged ports.</p></li></ul><p>启动命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Zabbix server chroot]# /home/named/bind/sbin/named -gc /home/named/bind/chroot/etc/named.conf</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>此处是在前台启动并且启动了调试模式，有问题会打印出出错信息。当调试正常后启动需要去掉g这个参数。</li></ul><p>启动脚本内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/named/bind/sbin/named -c /home/named/bind/chroot/etc/named.conf</span><br></pre></td></tr></table></figure><h3 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h3><p>因为我们监听的是小于1024的知名端口，named用户默认没有权限，因此我们的启动脚本为系统用户执行，在启动命令中使用-u参数指定named用户</p><p>在后续使用过程中，有关bind服务都是管理员用户去执行（改操作很少会涉及，因为后续配置重载等操作使用rndc即完成）</p><p>启动脚本内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$ cat /etc/init.d/named</span><br><span class="line"></span><br><span class="line">#!/bin/sh</span><br><span class="line"># chkconfig:   - 86 14</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"></span><br><span class="line">user=&quot;named&quot;</span><br><span class="line">exec=&quot;/home/named/bind/sbin/named&quot;</span><br><span class="line">prog=&quot;named&quot;</span><br><span class="line">config=&quot;/home/named/bind/chroot/etc/named.conf&quot;</span><br><span class="line"></span><br><span class="line">#[ -e /usr/local/named/etc/sysconfig/$prog ] &amp;&amp; . /usr/local/named/etc/sysconfig/$prog</span><br><span class="line"></span><br><span class="line">lockfile=/var/lock/subsys/named</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">    #[ -x $exec ] || exit 5</span><br><span class="line">    [ -e $config ] || exit 6</span><br><span class="line">    echo -n $&quot;Starting $prog: &quot;</span><br><span class="line">    daemon $exec -c $config -u $user</span><br><span class="line">    retval=$?</span><br><span class="line">    echo</span><br><span class="line">    [ $retval -eq 0 ] &amp;&amp; touch $lockfile</span><br><span class="line">    return $retval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    echo -n $&quot;Stopping $prog: &quot;</span><br><span class="line">    killproc $prog</span><br><span class="line">    retval=$?</span><br><span class="line">    echo</span><br><span class="line">    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile</span><br><span class="line">    return $retval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart() &#123;</span><br><span class="line">    stop</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reload() &#123;</span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot;</span><br><span class="line">    killproc $prog -1</span><br><span class="line">    retval=$?</span><br><span class="line">    echo</span><br><span class="line">    return $retval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">force_reload() &#123;</span><br><span class="line">    restart</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rh_status() &#123;</span><br><span class="line">    status $prog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rh_status_q() &#123;</span><br><span class="line">    rh_status &amp;&gt;/dev/null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        rh_status_q &amp;&amp; exit 0</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        rh_status_q || exit 0</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    reload)</span><br><span class="line">        rh_status_q || exit 7</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    force-reload)</span><br><span class="line">        force_reload</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        rh_status</span><br><span class="line">        ;;</span><br><span class="line">    condrestart|try-restart)</span><br><span class="line">        rh_status_q || exit 0</span><br><span class="line">        restart</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload&#125;&quot;</span><br><span class="line">        exit 2</span><br><span class="line">esac</span><br><span class="line">exit $?</span><br></pre></td></tr></table></figure><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><p>我们使用dig命令进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># dig @192.168.11.91 -p 53 www.test.com</span><br></pre></td></tr></table></figure><h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>bind的监控从几个方面</p><ul><li>端口号（53和953）</li><li>解析功能是否正常</li><li>主从同步是否正常</li></ul><p>在这里使用zabbix去实现监控，那么这个监控模板的内容就如下所示：</p><h1 id="bind总结"><a href="#bind总结" class="headerlink" title="bind总结"></a>bind总结</h1><h2 id="rndc命令"><a href="#rndc命令" class="headerlink" title="rndc命令"></a>rndc命令</h2><p>rndc命令作为我们管理bind的一大利器，我们有必要对它进行掌握，这一部分就记录下常用的操作</p><p>我们首先看一下它的help输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 ~]$ rndc -h</span><br><span class="line">Usage: rndc [-b address] [-c config] [-s server] [-p port]</span><br><span class="line">[-k key-file ] [-y key] [-r] [-V] [-4 | -6] command</span><br><span class="line"></span><br><span class="line">command is one of the following:</span><br><span class="line"></span><br><span class="line">  addzone zone [class [view]] &#123; zone-options &#125;</span><br><span class="line">Add zone to given view. Requires allow-new-zones option.</span><br><span class="line">  delzone [-clean] zone [class [view]]</span><br><span class="line">Removes zone from given view.</span><br><span class="line">  dnstap -reopen</span><br><span class="line">Close, truncate and re-open the DNSTAP output file.</span><br><span class="line">  dnstap -roll count</span><br><span class="line">Close, rename and re-open the DNSTAP output file(s).</span><br><span class="line">  dumpdb [-all|-cache|-zones|-adb|-bad|-fail] [view ...]</span><br><span class="line">Dump cache(s) to the dump file (named_dump.db).</span><br><span class="line">  flush Flushes all of the server&apos;s caches.</span><br><span class="line">  flush [view]Flushes the server&apos;s cache for a view.</span><br><span class="line">  flushname name [view]</span><br><span class="line">Flush the given name from the server&apos;s cache(s)</span><br><span class="line">  flushtree name [view]</span><br><span class="line">Flush all names under the given name from the server&apos;s cache(s)</span><br><span class="line">  freezeSuspend updates to all dynamic zones.</span><br><span class="line">  freeze zone [class [view]]</span><br><span class="line">Suspend updates to a dynamic zone.</span><br><span class="line">  haltStop the server without saving pending updates.</span><br><span class="line">  halt -pStop the server without saving pending updates reporting</span><br><span class="line">process id.</span><br><span class="line">  loadkeys zone [class [view]]</span><br><span class="line">Update keys without signing immediately.</span><br><span class="line">  managed-keys refresh [class [view]]</span><br><span class="line">Check trust anchor for RFC 5011 key changes</span><br><span class="line">  managed-keys status [class [view]]</span><br><span class="line">Display RFC 5011 managed keys information</span><br><span class="line">  managed-keys sync [class [view]]</span><br><span class="line">Write RFC 5011 managed keys to disk</span><br><span class="line">  modzone zone [class [view]] &#123; zone-options &#125;</span><br><span class="line">Modify a zone&apos;s configuration.</span><br><span class="line">Requires allow-new-zones option.</span><br><span class="line">  notify zone [class [view]]</span><br><span class="line">Resend NOTIFY messages for the zone.</span><br><span class="line">  notraceSet debugging level to 0.</span><br><span class="line">  nta -dump</span><br><span class="line">List all negative trust anchors.</span><br><span class="line">  nta [-lifetime duration] [-force] domain [view]</span><br><span class="line">Set a negative trust anchor, disabling DNSSEC validation</span><br><span class="line">for the given domain.</span><br><span class="line">Using -lifetime specifies the duration of the NTA, up</span><br><span class="line">to one week.</span><br><span class="line">Using -force prevents the NTA from expiring before its</span><br><span class="line">full lifetime, even if the domain can validate sooner.</span><br><span class="line">  nta -remove domain [view]</span><br><span class="line">Remove a negative trust anchor, re-enabling validation</span><br><span class="line">for the given domain.</span><br><span class="line">  querylog [ on | off ]</span><br><span class="line">Enable / disable query logging.</span><br><span class="line">  reconfigReload configuration file and new zones only.</span><br><span class="line">  recursingDump the queries that are currently recursing (named.recursing)</span><br><span class="line">  refresh zone [class [view]]</span><br><span class="line">Schedule immediate maintenance for a zone.</span><br><span class="line">  reloadReload configuration file and zones.</span><br><span class="line">  reload zone [class [view]]</span><br><span class="line">Reload a single zone.</span><br><span class="line">  retransfer zone [class [view]]</span><br><span class="line">Retransfer a single zone without checking serial number.</span><br><span class="line">  scanScan available network interfaces for changes.</span><br><span class="line">  secroots [view ...]</span><br><span class="line">Write security roots to the secroots file.</span><br><span class="line">  serve-stale [ yes | no | reset | status ] [class [view]]</span><br><span class="line">Control whether stale answers are returned</span><br><span class="line">  showzone zone [class [view]]</span><br><span class="line">Print a zone&apos;s configuration.</span><br><span class="line">  sign zone [class [view]]</span><br><span class="line">Update zone keys, and sign as needed.</span><br><span class="line">  signing -clear all zone [class [view]]</span><br><span class="line">Remove the private records for all keys that have</span><br><span class="line">finished signing the given zone.</span><br><span class="line">  signing -clear &lt;keyid&gt;/&lt;algorithm&gt; zone [class [view]]</span><br><span class="line">Remove the private record that indicating the given key</span><br><span class="line">has finished signing the given zone.</span><br><span class="line">  signing -list zone [class [view]]</span><br><span class="line">List the private records showing the state of DNSSEC</span><br><span class="line">signing in the given zone.</span><br><span class="line">  signing -nsec3param hash flags iterations salt zone [class [view]]</span><br><span class="line">Add NSEC3 chain to zone if already signed.</span><br><span class="line">Prime zone with NSEC3 chain if not yet signed.</span><br><span class="line">  signing -nsec3param none zone [class [view]]</span><br><span class="line">Remove NSEC3 chains from zone.</span><br><span class="line">  signing -serial &lt;value&gt; zone [class [view]]</span><br><span class="line">Set the zones&apos;s serial to &lt;value&gt;.</span><br><span class="line">  statsWrite server statistics to the statistics file.</span><br><span class="line">  statusDisplay status of the server.</span><br><span class="line">  stopSave pending updates to master files and stop the server.</span><br><span class="line">  stop -pSave pending updates to master files and stop the server</span><br><span class="line">reporting process id.</span><br><span class="line">  sync [-clean]Dump changes to all dynamic zones to disk, and optionally</span><br><span class="line">remove their journal files.</span><br><span class="line">  sync [-clean] zone [class [view]]</span><br><span class="line">Dump a single zone&apos;s changes to disk, and optionally</span><br><span class="line">remove its journal file.</span><br><span class="line">  tcp-timeoutsDisplay the tcp-*-timeout option values</span><br><span class="line">  tcp-timeouts initial idle keepalive advertised</span><br><span class="line">Update the tcp-*-timeout option values</span><br><span class="line">  thawEnable updates to all dynamic zones and reload them.</span><br><span class="line">  thaw zone [class [view]]</span><br><span class="line">Enable updates to a frozen dynamic zone and reload it.</span><br><span class="line">  traceIncrement debugging level by one.</span><br><span class="line">  trace levelChange the debugging level.</span><br><span class="line">  tsig-delete keyname [view]</span><br><span class="line">Delete a TKEY-negotiated TSIG key.</span><br><span class="line">  tsig-listList all currently active TSIG keys, including both statically</span><br><span class="line">configured and TKEY-negotiated keys.</span><br><span class="line">  validation [ yes | no | status ] [view]</span><br><span class="line">Enable / disable DNSSEC validation.</span><br><span class="line">  zonestatus zone [class [view]]</span><br><span class="line">Display the current status of a zone.</span><br><span class="line"></span><br><span class="line">Version: 9.12.3</span><br></pre></td></tr></table></figure><p>现在开始讲解</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>rndc（Remote Name Domain Controllerr）是一个远程管理bind的工具，通过这个工具可以在本地或者远程了解当前服务器的运行状况，也可以对服务器进行关闭、重载、刷新缓存、增加删除zone等操作。  </p><p>使用rndc可以在不停止DNS服务器工作的情况进行数据的更新，使修改后的配置文件生效。</p><p>在实际情况下，DNS服务器是非常繁忙的，任何短时间的停顿都会给用户的使用带来影响。因此，使用rndc工具可以使DNS服务器更好地为用户提供服务。在使用rndc管理bind前需要使用rndc生成一对密钥文件，一半保存于rndc的配置文件中，另一半保存于bind主配置文件中。rndc的配置文件默认路径为/etc/rndc.conf，在CentOS或者RHEL中，rndc的密钥保存在/etc/rndc.key文件中。rndc默认监听在953号端口（TCP），其实在bind9中rndc默认就是可以使用，不需要配置密钥文件。</p><p>rndc与DNS服务器实行连接时，需要通过数字证书进行认证，而不是传统的用户名/密码方式。在当前版本的rndc 和 named中，唯一支持的认证算法是HMAC-MD5，在连接的两端使用共享密钥。它为命令请求和名字服务器的响应提供 TSIG类型的认证。所有经由通道发送的命令都必须被一个服务器所知道的 key_id 签名。为了生成双方都认可的密钥，可以使用rndc-confgen命令产生密钥和相应的配置，再把这些配置分别放入named.conf和rndc的配置文件rndc.conf中。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>rndc常用命令：</strong></p><ul><li><strong>status</strong>        # Display status of the server 显示bind的相关信息</li><li>reload        # Reload configuration file and zones. 重新加载所有配置文件和zone数据文件</li><li><strong>reload zone [class [view]]</strong>    #Reload a single zone</li><li>reconfig        #    Reload configuration file and new zones only。重新加载配置文件以及zone文件(只涉及新的zone文件)</li><li><strong>flush [view]</strong>        # 刷新服务器的所有高速缓存</li><li><strong>stats</strong>        # 将服务器统计信息写入统计文件中（统计文件的路径定义在namd.conf配置文件当中）</li><li>dumpdb        # 将cache高速缓存转储到转储文件 (文件的路径定义在named.conf配置文件当中)</li><li>zonestatus zone [class [view]]            # Display the current status of a zone 显示指定的zone的状态信息</li><li>notify zone [class [view]]        # Resend NOTIFY messages for the zone 针对指定的zone发送通知消息</li></ul><h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><ul><li><p>status 显示bind运行状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$ rndc status</span><br><span class="line">version: BIND 9.12.3 &lt;id:6c8e92c&gt; (bind 9.12.3)</span><br><span class="line">running on host1: Linux x86_64 2.6.32-642.el6.x86_64 #1 SMP Tue May 10 17:27:01 UTC 2016</span><br><span class="line">boot time: Fri, 14 Dec 2018 07:40:25 GMT</span><br><span class="line">last configured: Mon, 17 Dec 2018 05:52:49 GMT</span><br><span class="line">configuration file: /home/named/bind/chroot/etc/named.conf</span><br><span class="line">CPUs found: 4</span><br><span class="line">worker threads: 4</span><br><span class="line">UDP listeners per interface: 3</span><br><span class="line">number of zones: 336 (297 automatic)</span><br><span class="line">debug level: 0</span><br><span class="line">xfers running: 0</span><br><span class="line">xfers deferred: 0</span><br><span class="line">soa queries in progress: 0</span><br><span class="line">query logging is ON</span><br><span class="line">recursive clients: 0/900/1000</span><br><span class="line">tcp clients: 0/150</span><br><span class="line">server is up and running</span><br></pre></td></tr></table></figure></li><li><p>reload单个zone的数据内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$  rndc  reload  dwd.gds-sh IN shidc</span><br><span class="line">zone reload up-to-date</span><br><span class="line"></span><br><span class="line">注意：reload zone [class [view]]对应的实际执行格式是zone IN view</span><br><span class="line">这个执行之后就有通知从域复制的作用</span><br></pre></td></tr></table></figure></li><li><p>单纯通知某个zone的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 common]$ rndc notify dwd.gds-sh  IN shidc</span><br><span class="line">zone notify queued</span><br><span class="line"></span><br><span class="line">注意：经过实际的测试，使用该命名不能实现通知从节点复制域的功能</span><br></pre></td></tr></table></figure></li><li><p>刷新某个view的缓存数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 common]$ rndc flush shidc</span><br></pre></td></tr></table></figure></li></ul><h2 id="named-conf配置文件详解"><a href="#named-conf配置文件详解" class="headerlink" title="named.conf配置文件详解"></a>named.conf配置文件详解</h2><p><strong>配置文件框架</strong></p><ul><li>常规配置配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">include &quot;/path/file&quot;;# 加载外部文件</span><br><span class="line"></span><br><span class="line">key &quot;rndc-key&quot; &#123;</span><br><span class="line"># rndc相关配置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">controls &#123;</span><br><span class="line"># rndc相关配置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">options&#123;</span><br><span class="line"># 全局配置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logging&#123;</span><br><span class="line"># 日志配置</span><br><span class="line">&#125;</span><br><span class="line">zone &quot;zone name&quot; IN &#123;</span><br><span class="line"># 区域（域名）配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>view（视图）模式配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">acl acl_name1 &#123;192.168.11.0/24;&#125;;# acl列表，用于后面调用，这部分通常置于最上方</span><br><span class="line">acl acl_name2 &#123;!192.168.11.0/24;any;&#125;;</span><br><span class="line">include &quot;/path/file&quot;;# 加载外部文件</span><br><span class="line"></span><br><span class="line">key &quot;rndc-key&quot; &#123;</span><br><span class="line"># rndc相关配置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">controls &#123;</span><br><span class="line"># rndc相关配置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">options&#123;</span><br><span class="line"># 全局配置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logging&#123;</span><br><span class="line"># 日志配置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">view &quot;view_name1&quot; &#123;</span><br><span class="line">    match-clients &#123;&quot;acl_name1&quot;;&#125;;# 定义该view匹配的网段</span><br><span class="line">    zone &quot;zone name&quot; IN &#123;</span><br><span class="line">                # 区域（域名）配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">view &quot;view_name2&quot; &#123;</span><br><span class="line">    match-clients &#123;&quot;acl_name2&quot;;&#125;;# 定义该view匹配的网络</span><br><span class="line">    zone &quot;zone name&quot; IN &#123;</span><br><span class="line">                # 区域（域名）配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 注意：使用view之后，所有的zone都需要包含在view块中</span><br></pre></td></tr></table></figure><p>我们拿下面这个配置文件进行案例说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$ cat named.conf</span><br><span class="line"></span><br><span class="line">key &quot;rndc-key&quot; &#123;</span><br><span class="line">algorithm hmac-sha256;</span><br><span class="line">secret &quot;vqOF9VUn75lvtpCYvYffOVNT8LkLK0z78UCPVkX1ofk=&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">controls &#123;</span><br><span class="line">inet 127.0.0.1 port 953</span><br><span class="line">allow &#123; 127.0.0.1; &#125; keys &#123; &quot;rndc-key&quot;; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">options&#123;</span><br><span class="line">        listen-on port 53&#123;</span><br><span class="line">                192.168.103.99;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        listen-on-v6 port 53&#123;</span><br><span class="line">                fe80::20c:29ff:fefe:d1f4;</span><br><span class="line">        &#125;;</span><br><span class="line">        version &quot;bind 9.12.3&quot;;</span><br><span class="line">        directory &quot;/home/named/bind/chroot/var/named&quot;;</span><br><span class="line">        pid-file &quot;/home/named/bind/chroot/var/run/named.pid&quot;;</span><br><span class="line">    session-keyfile &quot;/home/named/bind/chroot/var/run/session.key&quot;;</span><br><span class="line">        dump-file &quot;/home/named/bind/chroot/var/named/data/cache_dump.db&quot;;</span><br><span class="line">        statistics-file &quot;/home/named/bind/chroot/var/named/data/named_stats.txt&quot;;</span><br><span class="line">        memstatistics-file &quot;/home/named/bind/chroot/var/named/data/named_mem_stats.txt&quot;;</span><br><span class="line">        recursion yes;</span><br><span class="line">        allow-query&#123;</span><br><span class="line">                any;</span><br><span class="line">        &#125;;</span><br><span class="line">        allow-query-cache&#123;</span><br><span class="line">                any;</span><br><span class="line">        &#125;;</span><br><span class="line">        allow-transfer&#123;</span><br><span class="line">                192.168.11.89;</span><br><span class="line">       &#125;;</span><br><span class="line">        notify yes;</span><br><span class="line">        also-notify&#123;</span><br><span class="line">                192.168.11.89;</span><br><span class="line">        &#125;;</span><br><span class="line">/* Path to ISC DLV key */</span><br><span class="line">bindkeys-file &quot;/home/named/bind/chroot/etc/named.iscdlv.key&quot;;</span><br><span class="line">managed-keys-directory &quot;/home/named/bind/chroot/var/named/dynamic&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">logging &#123;</span><br><span class="line">channel default_debug &#123;</span><br><span class="line">file &quot;/home/named/bind/chroot/log/named.run&quot; versions 10 size 128m;</span><br><span class="line">severity dynamic;</span><br><span class="line">                print-category yes;</span><br><span class="line">                print-severity yes;</span><br><span class="line">                print-time yes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">        channel queries_info &#123;</span><br><span class="line">                file &quot;/home/named/bind/chroot/log/query.log&quot; versions 10 size 128m;</span><br><span class="line">                severity info;</span><br><span class="line">                print-category yes;</span><br><span class="line">                print-severity yes;</span><br><span class="line">                print-time yes;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        category queries &#123;</span><br><span class="line">                queries_info;</span><br><span class="line">                default_debug;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel notify_info &#123;</span><br><span class="line">                file &quot;/home/named/bind/chroot/log/notify.log&quot; versions 10 size 128m;</span><br><span class="line">                severity info;</span><br><span class="line">                print-category yes;</span><br><span class="line">                print-severity yes;</span><br><span class="line">                print-time yes;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        category notify &#123;</span><br><span class="line">                notify_info;</span><br><span class="line">                default_debug;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel xfer_in_log &#123;</span><br><span class="line">                file &quot;/home/named/bind/chroot/log/xfer_in.log&quot; versions 10 size 128m;</span><br><span class="line">                severity info;</span><br><span class="line">                print-category yes;</span><br><span class="line">                print-severity yes;</span><br><span class="line">                print-time yes;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel xfer_out_log &#123;</span><br><span class="line">                file &quot;/home/named/bind/chroot/log/xfer_out.log&quot; versions 10 size 128m;</span><br><span class="line">                severity info;</span><br><span class="line">                print-category yes;</span><br><span class="line">                print-severity yes;</span><br><span class="line">                print-time yes;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        category xfer-in &#123; xfer_in_log; &#125;;</span><br><span class="line">        category xfer-out &#123; xfer_out_log; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include &quot;/home/named/bind/chroot/etc/acls/shidc&quot;;</span><br><span class="line">include &quot;/home/named/bind/chroot/etc/acls/hzidc&quot;;</span><br><span class="line">include &quot;/home/named/bind/chroot/etc/acls/aliyun-east1&quot;;</span><br><span class="line"></span><br><span class="line">include &quot;/home/named/bind/chroot/etc/views/shidc&quot;;</span><br><span class="line">include &quot;/home/named/bind/chroot/etc/views/hzidc&quot;;</span><br><span class="line">include &quot;/home/named/bind/chroot/etc/views/aliyun-east1&quot;;</span><br></pre></td></tr></table></figure><p>某一段acl的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$ cat /home/named/bind/chroot/etc/acls/shidc</span><br><span class="line">acl shidc &#123;</span><br><span class="line">10.11.0.0/16;</span><br><span class="line"># 省略剩余网段，格式一致</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>某一段view的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[named@host1 etc]$ cat /home/named/bind/chroot/etc/views/shidc</span><br><span class="line">view &quot;shidc&quot; &#123;</span><br><span class="line">        match-clients &#123;&quot;shidc&quot;;&#125;;</span><br><span class="line">        zone &quot;.&quot; in&#123;</span><br><span class="line">                type hint;</span><br><span class="line">                file &quot;named.root&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">        zone &quot;dianwoda.com&quot; IN &#123;</span><br><span class="line">                type master;</span><br><span class="line">                file &quot;zone/shidc/dianwoda.com.zone&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">        # 这里省略很多zone配置段</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>配置文件中每一行必须以;结尾，{} 里面两侧必须有空格</p><h3 id="acl"><a href="#acl" class="headerlink" title="acl"></a>acl</h3><p>访问控制列表只有定义后才能使用，通常acl要定义在named.conf的最上方</p><p>除了我们自己定义的acl，在bind中有4个内置的acl</p><ul><li>any：任何主机</li><li>none：无一主机</li><li>local：本机</li><li>localnet：本机所在的网络   </li></ul><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><ul><li><p>include “/path/file”;</p><p>导入相关文件，为了保持主配置文件的简介，我们通常会把大段的配置文件使用include的方式进行加载，acl、view、zone等都可以使用include方式进行加载</p></li></ul><h3 id="key-controls"><a href="#key-controls" class="headerlink" title="key+controls"></a>key+controls</h3><p>定义rndc管理命令的相关配置</p><p>我们在文章的最开始配置章节就看到，使用了rndc-confgen命令来生成rndc文件。生成之后，需要把其中的密码信息等完整的复制进主配置文件当中</p><ul><li><p>algorithm hmac-sha256;</p><p>密钥算法</p></li><li><p>secret “vqOF9VUn75lvtpCYvYffOVNT8LkLK0z78UCPVkX1ofk=”;</p><p>密钥内容</p></li><li><p>inet 127.0.0.1 port 953</p><p>rndc服务监听在本机的953端口</p></li><li><p>allow { 127.0.0.1; } keys { “rndc-key”; };</p><p>只允许本机访问，使用的认证密码信息为前面定义的：rndc-key</p></li></ul><p>有关rndc，请看下面的有关rndc章节</p><h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><p>这一部分主要定义全局的核心信息</p><ul><li><p>listen-on port 53 {};</p><p>IPv4网络：指定提供dns服务的端口以及ip地址（很多服务器上可能会有多块网卡）</p></li><li><p>listen-on-v6 port 53 {};</p><p>IPv6网络：指定提供dns服务的端口以及ip地址（很多服务器上可能会有多块网卡）</p></li><li><p>version “version”;</p><p>bind版本信息</p></li><li><p>directory “file_path”;</p><p>zone区域文件存储目录</p></li><li><p>pid-file “file_path”;</p><p>pid文件所在路径</p></li><li><p>session-keyfile “file_path”;</p><p>dns安全方面的配置</p></li><li><p>dump-file “file_path”;</p><p>当执行rndc dumpdb命令时，服务器存放数据库文件的路径名。</p></li><li><p>statistics-file</p><p>当使用rndc stats命令的时候，服务器会将统计信息追加到的文件路径名。如果没有指定，默认为named.stats在服务器程序的当前目录中。</p></li><li><p>memstatistics-file “file_path”;</p><p>当服务退出的时候，会把内存使用情况统计写入到这个文件中</p></li><li><p>forwarders {};</p><p>当设置为转发服务器时需要设置，在{}内设置上游服务器ip</p></li><li><p>recursion yes;</p><p>开启递归功能，当接收到请求的域名不是自身所负责解析的域名（也就是没有对应的zone配置），这个时候，将自己变成dns客户端，向根服务器发送请求，获取解析记录之后再返回客户端</p></li><li><p>allow-recursion {};</p><p>允许递归的白名单，配合上面的recursion yes使用</p></li><li><p>allow-query {};</p><p>允许谁可以查询，也就是定义接收请求的来源，当设置为any之后表示可以接收所有人的域名请求</p></li><li><p>allow-query-cache {};</p><p>允许谁可以查询域名记录的缓存数据，和上面一样，当设置为any之后表示可以接收所有人的域名请求</p></li><li><p>allow-transfer {};</p><p>设定哪台主机允许和本地服务器进行域传输。allow-transfer也可以设置在zone语句中，这样全局options中的allow-transfer选项在这里就不起作用了。如果没有设定，默认值是允许和所有主机进行域传输</p><p>一般我们定义成从节点的网段</p></li><li><p>allow-update {};</p><p>允许动态更新数据文件的主机白名单，一般设置为none</p></li><li><p>notify yes;</p><ul><li><p>如果是yes（默认），当一个授权的服务器修改了一个域后，DNS NOTIFY信息被发送出去。此信息将会发给列在域NS记录上的服务器（除了由SOA MNAME标示的主域名服务器）和任何列在also-notify选项中的服务器。</p></li><li><p>如果是explicit，则notify将只发给列在also-notify中的服务器。</p></li><li><p>如果是no，就不会发出任何报文。</p></li><li><p><strong>注意：</strong>notify选项也可能设定在zone语句中，这样它就替代了options中的notify 语句。</p></li></ul></li><li><p>also-notify {};</p><p>定义一个用于全局的域名服务器IP地址列表。无论何时，当一个新的域文件被调入系统，域名服务器都会向这些地址，还有这些域中的NS记录发送NOTIFY信息。这有助于更新的域文件尽快在相关的域名服务器上收敛同步。</p><p>also-notify列表也可以配置在一个zone语句中，那么全局options中的also-notify语句就会在这里失效。</p><p>当一个zone-notify语句被设定为no，系统就不会向在全局中also-notify列表中的IP地址发送NOTIFY消息。缺省状态为空表(没有全局通知列表)。</p></li></ul><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>logging语句为域名服务器设定了一个多样性的logging选项。它的channel短语对应于输出方式、格式选项和分类级别，它的名称可以与category短语一起定义多样的日志信息。</p><p>只用一个logging语句就可以用来定义多个channel和category。</p><p>在BIND9中，logging的配置只有在整个配置文件被读取后才被执行。而在BIND8中，logging部分被读取后就开始执行了。当服务器启动时，所有在配置文件中关于语法错误的logging信息都转到缺省通道（channel）中，或者使用”-g”选项，指定转成标准错误。</p><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p>所有日志会输出到一个或多个channel中；你可以定义所有你想要的通道。每个通道的定义必须包括一个目的字句，用来确定所选的相关通道的信息，将会被输出到一个文件，或者到一个特殊的syslog工具，或者到一个标准错误流，或者被忽略。它也可以随意的限制通道能接受的信息级别（默认值info），定义是否包含一个由named产生的时间标记，或者是否包含分类的名称、级别等（默认是不包含任何内容）。</p><ul><li><p>目的子句为null时，会使所有发送给通道的信息被丢弃；那样的话，其他通道选项就没有意义了。</p></li><li><p>目的子句为file 时，会使通道的内容输出到一个磁盘文件。它可以包含这个文件的大小和该文件可以保存多少个版本。</p></li><li><p>如果使用versions日志文件选项，named就会自动保留多个版本的日志文件。例如，如果选择保存文件lamers.log的三个老版本，那么在它被打开的时候lamers.log.1被更名为lamers.log.2，lamers.log.0 被更名为lamers.log.1 ，lamers.log 被更名为lamers.log.0。也可以设置version unlimited，这样就没有备份版本的限制了。</p></li><li><p>如果对日志文件设置了size选项，那么仅当此文件超过了设定的大小时，系统就会进行更名。默认情况下不储存备份文件；所有存在的日志文件被简单进行追加。文件的size 选项用来限制日志的增长。如果文件超过了限制，又没有versions选项，则named 就会停止写入文件。如果保留了备份版本，则备份文件如上所述进行滚动命名，然后开始创建一个新的文件。如果没有versions选项，也没有其它的机制来删除或减小日志文件，则系统就不会有数据继续写入日志中。默认状态是不限制文件的大小的。</p></li><li><p>syslog 目的子句是把通道指向系统日志。它的参数是一个syslog的前缀，如syslog帮助中所述。syslog是怎样处理带有这些前缀的信息，可以参考syslog.conf 的帮助信息。</p></li><li><p>severity子句象syslog中的”priorites”一样工作，唯一区别的是用户可以直接写入一个文件，而不是使用syslog写入一个文件。不到严重级的信息将不会被通道选择；高严重级的信息将会被接受。</p><p>如果用户正在使用syslog，那么syslog.conf 的优先级也会决定什么会最终通过。例如，将channel facility和severity定义成daemon和debug，就不会只记录通过syslog.conf的daemon.warning信息，后者会使severity是info和notice的信息被丢弃。如果情况相反，named就会只记录warning或更高级别的信息，而syslogd则会记录来自于通道的所有信息。</p></li><li><p>stderr目的子句将通道输出到服务器的标准错误流。它用于服务器在前台运行的情况下，例如，当处于debug模式的时候，服务器能提供丰富的调试信息。如果服务器的全局debug级别（globe debug level）大于0，debug 模式将被激活。全局debug级别可以通过在启动named时设置“-d”参数加一个正数，或运行rndc trace来设置。如果要关闭debug模式，则将全局debug 级别设置成0，或运行rndc notrace。服务器中所有的debug信息有一个debug级别，高调试级给出更详细的输出。</p></li><li><p>如果使用了print-time参数，则日期和时间也将会记录下来。print-time也可以针对syslog的通道进行设置，但因为syslog也打印日期和时间，所以一般来讲，这没有什么意义。如果设置了print-category 参数，则信息的分类也会记录下来。如果设置了print-severity参数，则信息的严重级别也会记录下来。print-xxx 选项可以进行多重组合，单输出格式都是这个顺序：时间、分类、严重级别。</p></li><li><p><strong>default_debug 通道</strong>有特殊的性质：只有当服务器的debug级别非0的时候，它才产生输出。一般来说，它会在服务器的工作目录中写入named.run文件。因为安全原因，当在命令行选项中使用了“-u”参数后，只有当named使用了新的UID后，named.run文件才会产生，以root身份启动和运行的named所产生的debug信息将会被丢弃。如果用户需要得到这些输出，则必须使用“-g”参数运行服务器，并重新将标准错误定向到一个文件中去。</p></li><li><p>一旦定义好一个通道，它就不能被重新定义。这样就不能修改内置的通道，但是可以通过把分类指向你已经定义的通道，来修改默认的日志记录。</p></li></ul><h4 id="category"><a href="#category" class="headerlink" title="category"></a>category</h4><p>这里存在许多分类，用户可根据需要定义想看到或不想看到的日志。如果你不将某个分类指定到某些通道的话，那么在这个分类的日志信息就会被发送到default分类通道中。如果用户没有设定缺省的分类，下列”default”则会被系统使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">category &quot;default&quot; &#123; &quot;default_syslog&quot;; &quot;default_debug&quot;; &#125;;</span><br></pre></td></tr></table></figure><p>作为一个例子，假定你要在文件中记录安全事件，但您也要保留缺省的日志文件。最好按照下面配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">channel &quot;my_security_channel&quot; &#123;</span><br><span class="line">file &quot;my_security_file&quot;;</span><br><span class="line">severity info;</span><br><span class="line">&#125;;</span><br><span class="line">category &quot;security&quot; &#123;</span><br><span class="line">&quot;my_security_channel&quot;;</span><br><span class="line">&quot;default_debug&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 为了丢弃一个分类中的所有信息，可以设定null 通道：</span><br><span class="line">category &quot;xfer-out&quot; &#123; &quot;null&quot;; &#125;;</span><br><span class="line">category &quot;notify&quot; &#123; &quot;null&quot;; &#125;;</span><br></pre></td></tr></table></figure><p>下面是简单写这里用到的分类和相关的简明描述，更多内容可以查看官网提供的bind9管理员手册</p><table><thead><tr><th>default</th><th>没有配置的分类会使用default的分类日志配置</th></tr></thead><tbody><tr><td>notify</td><td>notify协议相关日志</td></tr><tr><td>queries</td><td>dns解析请求日志</td></tr><tr><td>xfer-in</td><td>主从域传输相关日志（入方向）</td></tr><tr><td>xfer-out</td><td>主从域传输相关日志（出方向）</td></tr></tbody></table><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>view试图段的配置相对来说比较简单，主要分为2个部分，通过上面的案例我们就可以很直观看出来：</p><ul><li>使用match-clients匹配来源ip</li><li>将要解析的zone都放置在view区块内，匹配来源之后，将使用对应的zone文件数据去响应请求</li></ul><h3 id="zone"><a href="#zone" class="headerlink" title="zone"></a>zone</h3><p>zone可以单独存在或者包含在view当中，不管哪种方式配置格式都是一样的。</p><ul><li><p>type master;</p><p>type字段说明了当前服务器所承担的任务职责，type可为：</p><ul><li>hint。根角色</li><li>master    主角色。可以响应该域名的解析请求。数据源为本地的zone文件</li><li>slave    从角色。可以响应该域名的解析请求。不使用自身的数据，数据源为从master端同步的zone数据</li><li>forward    转发角色。不直接响应域名解析请求，接受到请求之后，将请求直接转发给配置的上游服务器</li></ul></li></ul><h2 id="zone配置文件详解"><a href="#zone配置文件详解" class="headerlink" title="zone配置文件详解"></a>zone配置文件详解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$TTL      86400</span><br><span class="line">@            IN SOA  test.com.  admin.test.com. (</span><br><span class="line">                      2018121401                ; serial (d. adams)</span><br><span class="line">                      3H                ; refresh</span><br><span class="line">                      15M                ; retry</span><br><span class="line">                      1W                ; expiry</span><br><span class="line">                      1D )              ; minimum</span><br><span class="line">        IN         NS     dns.test.com.</span><br><span class="line">        IN         MX  5  mail</span><br><span class="line">dns     IN      A      192.168.11.49</span><br><span class="line">mail    IN      A      192.168.11.100</span><br><span class="line">www     IN      A      192.168.11.80</span><br></pre></td></tr></table></figure><h3 id="TTL-86400"><a href="#TTL-86400" class="headerlink" title="$TTL      86400"></a>$TTL      86400</h3><p>资源记录的缓存超时时间，为了简化 RR 记录的设置，因此我们可以将 TTL 挪到最前面统一设定，在这里相当于是一个默认值，针对所有记录生效</p><p>单位是s，例如这里是86400秒，也就是一天</p><h3 id=""><a href="#" class="headerlink" title="@"></a>@</h3><p>第一列的这个符号代表 zone 对应域名，例如写在 test.com.zone 中，@ 代表 test.com.（注意不是根据名称决定的，而是根据named.conf中的配置）</p><p>在下面的配置中，第一列可以不写，那么将会继承这个配置</p><h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a><strong>SOA</strong></h3><p>如果你有多个 DNS 服务器管理同一个领域名时，那么最好使用 master/slave 的方式来进行管理。</p><p>既然要这样管理， 那就得要宣告被管理的 zone file 是如何进行传输的，此时就得要 SOA (Start Of Authority) 的标志了。</p><p>SOA 主要是与zone有关，SOA 后面共会接七个参数，这七个参数的意义依序是：</p><ol><li><p>负责解析的域名</p></li><li><p>管理员的 email：发生问题可以联络这个管理员。要注意的是， 由于 @ 有特殊意义的，因此这里就将 admin@test.com 改写成 admin.test.com</p></li><li><p>序号 (Serial)：这个序号代表的是这个数据库档案的新旧，序号越大代表越新。 当 slave 要判断是否主动下载新的数据库时，就以序号是否比 slave 上的还要新来判断，若是则下载，若不是则不下载。 所以当你修订了数据库内容时，记得要将这个数值放大才行！ 为了方便用户记忆，通常序号都会使用日期格式『YYYYMMDDNU』来记忆，例如 2010080369 序号代表 2010/08/03 当天的第 69 次更新的感觉。不过，序号不可大于 2 的 32 次方，亦即必须小于 4294967296 一共10位数才行。</p><p>也就是说一天最多能更新99次，当到达99次之后，就不得不使用明天的日期，所以当场景的变更次数很频繁的时候，需要思考使用其他方式来定义序列号</p></li><li><p>更新频率 (Refresh)：那么什么时候 slave 会去向 master 要求数据更新的判断？ 就是这个数值定义的。 这里设置为每 10800 秒（3小时）进行一次 slave 向 master 要求数据更新。每次 slave 去更新时， 如果发现序号没有比较自身的大，那就不会下载数据库档案。</p></li><li><p>失败重新尝试时间 (Retry)：如果因为某些因素，导致 slave 无法正常访问 master， 那么在多久的时间内，slave 会尝试重新联机到 master。在这里设置为900 秒（15分钟）会重新尝试一次。意思是说，每 3小时slave 会主动向 master 联机，但如果该次联机没有成功，那接下来尝试联机的时间会变成 15分钟。若后来有成功，则又会恢复到3小时再一次联机。</p></li><li><p>失效时间 (Expire)：如果一直尝试失败，持续到到达这个时间， 那么 slave 将不再继续尝试联机，并且尝试删除这份下载的 zone file 信息。这里设置为 604800 秒（1周）。意思是说，当联机失败，每 15分钟进行一次尝试，直到到达1周后，slave 将不再更新，只能等待系统管理员的处理。</p></li><li><p>Minimum部分，这个部分定义了DNS对否定回答(NXDOMAIN即访问的记录在权威DNS上不存在)的缓存时间。</p></li></ol><p>除了 Serial 不可以超过 2^32 次方之外，还有一些其他的限制：</p><ul><li>Refresh &gt;= Retry *2</li><li>Refresh + Retry &lt; Expire</li><li>Expire &gt;= Rrtry * 10</li><li>Expire &gt;= 7Days</li></ul><p>一般来说，如果 DNS RR 记录变更情况频繁，那么上述的相关数值可以设置的小一些，如果 DNS RR 是很稳定的， 为了节省带宽，则可以将 Refresh 设置的较大一些。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>再次强调，一个正向解析的RR数据库中，至少应该要有 $TTL, SOA, NS </p></li><li><p>如果是写完全的域名，RR记录中在最后一定要带上”.”。不写完整的，则系统会进行自动补全</p></li><li>在zone配置文件中，master和slave都需要添加NS记录，并对对应主机还需要添加A记录</li></ul><h2 id="有关rndc"><a href="#有关rndc" class="headerlink" title="有关rndc"></a>有关rndc</h2><p>在服务启动之后，我们可以看到服务器的监听端口情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Zabbix server etc]# netstat -unptl  | grep named</span><br><span class="line">tcp        0      0 192.168.11.91:53            0.0.0.0:*                   LISTEN      14861/named</span><br><span class="line">tcp        0      0 127.0.0.1:953               0.0.0.0:*                   LISTEN      14861/named</span><br><span class="line">tcp        0      0 :::53                       :::*                        LISTEN      14861/named</span><br><span class="line">udp        0      0 192.168.11.91:53            0.0.0.0:*                               14861/named</span><br><span class="line">udp        0      0 :::53                       :::*                                    14861/named</span><br></pre></td></tr></table></figure><p>那么为什么会开启953端口呢？</p><p>其实这就是所谓的 rndc 了。rndc 是 BIND version 9 以后所提供的功能，他可以让你很轻松的管理你自己的 DNS 服务器。包括检查已经存在 DNS 当中的资料、更新某个 zone 而不需要重新启动整个 DNS ， 以及检查 DNS 的状态与统计数据。</p><p>不过，因为 rndc 可以很深入的管理你的 DNS 服务器，所以当然要进行一些管控。控管的方式是通过rndc 的设置创建一个密钥 (rndc key)，并将这个密钥相关信息写入 named.conf 配置文件当中。重新启动 DNS 后，你的 DNS 就能够藉由 rndc 这个命令管理！ </p><p>事实上，新版的 distributions 通常已经帮你主动的建立好 rndc key了。</p><p>关于rndc的更多内容可以看鸟哥的文章：<a href="http://cn.linux.vbird.org/linux_server/0350dns.php" target="_blank" rel="noopener">http://cn.linux.vbird.org/linux_server/0350dns.php</a></p><h2 id="启动用户"><a href="#启动用户" class="headerlink" title="启动用户"></a>启动用户</h2><p>在测试的时候，我们可以使用root用户启动，实际在生产环境中运行的时候，我们需要使用named这个普通用户去启动服务，这里一定要注意</p><h2 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h2><p>一般客户机和服务器之间属递归查询，当客户机向DNS服务器发出请求后,若DNS服务器本身不能解析,DNS服务器则会向另外的DNS服务器发出查询请求，得到结果后转交给客户机。</p><p>当客户端的请求域名不在本地named.conf中配置的zone区块中，并且缓存中也没有的话，那么就会开启递归查询，为这个客户端去请求这个域名对应的ip。</p><p>如果请求的域名在zone配置中，但是zone的数据文件中没有这条记录，那么解析失败，server将不会再为这条记录去进行递归查询</p><p>因此：</p><ul><li><p>如果是完全作为一个真正的权威服务器，那么不建议开启递归查询功能（默认为开启）</p></li><li><p>如果是既要作为权威服务器又要作为第一级的dns服务器，提供递归功能，那么可以开启</p></li></ul><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="主从数据同步"><a href="#主从数据同步" class="headerlink" title="主从数据同步"></a>主从数据同步</h3><p> Master和Slave 的数据库，都会有一个代表该数据库新旧的序列号，这个序号数值的大小，会影响是否要更新的动作， 至于更新的方式主要有两种：</p><ul><li>Master 主动告知：例如在 Master 在修改了数据库内容，并且加大数据库序号后， 重新启动 DNS 服务或者reload文件之后， master 会主动告知在配置文件中定义好的notify列表来更新数据库，此时就能够达成数据同步；</li><li>由 Slave 主动提出要求：Slave 会<code>定时</code>的向 Master发起请求，查看数据库的序号， 当发现Master的序号比 Slave 自己的序号还要大 (代表比较新)，那么 Slave 就会开始更新。如果序号不变， 那么就判断数据库没有更动，因此不会进行同步更新。</li></ul><p>由上面的说明来看，其实设计数据库的序列号最重要的目的就是让 master/slave 数据的同步化。那我们也知道slave 会向 master 提出数据库更新的需求，问题是，多久提出一次更新，如果该次更新时由于网络问题，所以没有查询到 master 的序号 (亦即更新失败)，那隔多久会重新更新一次？这个可以查看上面的 SOA 的标志。</p><h3 id="Name-Servers-in-Multiple-Roles导致不能实现域名穿透"><a href="#Name-Servers-in-Multiple-Roles导致不能实现域名穿透" class="headerlink" title="Name Servers in Multiple Roles导致不能实现域名穿透"></a>Name Servers in Multiple Roles导致不能实现域名穿透</h3><p>DNS服务器的类型；</p><ol><li><p>主DNS服务器：维护所负责解析的域内解析库服务器；解析库由管理维护；读写操作均可进行；</p></li><li><p>从DNS服务器：从主DNS服务器或从其他的从DNS服务器那里区域传递(类似“复制”)一份解析库，只能进行读操作</p></li><li><p>缓存DNS服务器：负责代理客户机的递归查询工作，并且采用迭代查询的服务器</p></li><li><p>转发器：如果目标域名在本DNS服务器辖区内，直接转发</p></li></ol><p><strong>希望实现：</strong></p><blockquote><p>当自主dns的配置中没有请求的域名时，本地dns服务器进行迭代查询，查找dnspod或者其他上的相关记录，然后将对应信息返回给dns客户端</p><p>例如：本机可以解析test.com这个域，但是不包含www这条A记录，当有请求来的时候，希望实现dns服务器可以作为客户端，从internet上找寻对应记录信息。</p></blockquote><p><strong>存在问题：</strong></p><blockquote><p>The BIND name server 能同时拥有多种角色，可以是作为权威服务器（主或者从服务器）专门负责解析，缓存服务器（递归服务器，也就是本地dns服务器）负责处理dns客户端的请求</p><p>但是，权威服务器和本地服务器的功能是冲突的，因为建议将这2个分开部署</p><p>原因是处于安全性和可靠性，权威服务器不能实现递归功能，也就是说本地没有记录的话，不会再作为客户端帮助末端去请求</p><p>只要当本地dns配置中存在某个域名的时候，就算配置数据库中不包含dns客户端请求的记录，也不会进行迭代查询，因此，最终会导致解析失败</p></blockquote><p><strong>问题解决：</strong></p><blockquote><p>因为本身的协议限制，无法实现，所以在实例应用到公司时，需要维护全量的域名资源记录。</p></blockquote><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>修改zone数据文件在每次存盘时要注意增加Serial值，主要用来让辅助服务器同步主服务器的区域数据文件。</li><li>使用绝对域名时千万别忘了后面要带”.”。</li><li>主配置文件named.conf的”;”不能少。</li><li>通常 DNS 查询的时候，是以 udp 协议来查询的， 但是万一没有办法查询到完整的信息时，就会再次的以 tcp 来重新查询的！所以启动 DNS 的 daemon (就是 named ) 时，会同时启动 tcp 及 udp 的 port 53 ,所以如果涉及到一些防火墙配置的时候，记得需要同时放行 tcp, udp port 53 </li></ul>]]></content>
    
    <summary type="html">
    
      bind部署
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="网络知识及网络服务" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="网络服务" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="DNS服务实现-bind" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/DNS%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0-bind/"/>
    
    
      <category term="bind" scheme="http://yoursite.com/tags/bind/"/>
    
  </entry>
  
  <entry>
    <title>day07-面向对象编程进阶及异常处理</title>
    <link href="http://yoursite.com/2018/08/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/08/31/编程语言/Python/老男孩视频学习笔记/day07-面向对象编程进阶及异常处理/</id>
    <published>2018-08-31T13:30:09.000Z</published>
    <updated>2018-08-31T13:30:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节讲解内容：</p><p>面向对象高级语法部分</p><ul><li>静态方法、类方法、属性方法</li><li>类的特殊方法</li><li>反射</li></ul><p>异常处理</p><p>socket开发基础</p><hr><h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><p>通过@staticmethod装饰器即可把其装饰的方法变为一个静态方法。</p><p>什么是静态方法呢？其实不难理解，普通的方法，可以在实例化后直接调用，并且在方法里可以通过self.调用实例变量或类变量，但静态方法是不可以访问实例变量或类变量的，一个不能访问实例变量和类变量的方法，其实相当于跟类本身已经没什么关系了，它与类唯一的关联就是需要通过类名来调用这个方法</p><p>总结：</p><ul><li>使用了静态方法之后，这个方法不能访问变量，只能被直接调用</li><li>把这个方法和类关联取消，因此self参数不再有效（默认会自动传self）</li><li>被静态化之后的方法的作用就只是相当于是一个单纯的函数，调用不了类的变量，调用不了实例的变量</li><li>因为，在这种情况下，如果还是需要使用参数，进行调用相关的方法，那么需要把实例或者属性传递进去</li><li>一般情况下，我们传递进去都会是一个实例，而不是一个属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">传递单个属性：</span><br><span class="line">class Dog(object):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">    @staticmethod</span><br><span class="line">    def eat(self):</span><br><span class="line">        # print (&quot;&#123;name&#125; is eating &#123;food&#125;...&quot;.format(name=self.name,food=food))</span><br><span class="line">        print (&quot;&#123;name&#125; is eating ...&quot;.format(name=self))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d1 = Dog(&quot;wxh&quot;)</span><br><span class="line"></span><br><span class="line">d1.eat(&quot;wxh&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">传递实例对象：</span><br><span class="line">class Dog(object):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">    @staticmethod</span><br><span class="line">    def eat(self):</span><br><span class="line">        # print (&quot;&#123;name&#125; is eating &#123;food&#125;...&quot;.format(name=self.name,food=food))</span><br><span class="line">        print (&quot;&#123;name&#125; is eating ...&quot;.format(name=self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d1 = Dog(&quot;wxh&quot;)</span><br><span class="line"></span><br><span class="line">d1.eat(d1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行后输出如下所示：</span><br><span class="line">sdd is eating ...</span><br></pre></td></tr></table></figure><h1 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h1><p>类方法中，只能访问类变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    name = &quot;gegege&quot;</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    # @staticmethod</span><br><span class="line">    @classmethod</span><br><span class="line">    def eat(self):</span><br><span class="line">        # print (&quot;&#123;name&#125; is eating &#123;food&#125;...&quot;.format(name=self.name,food=food))</span><br><span class="line">        print (&quot;&#123;name&#125; is eating ...&quot;.format(name=self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d1 = Dog(&quot;wxh&quot;)</span><br><span class="line"></span><br><span class="line">d1.eat()</span><br><span class="line"></span><br><span class="line">执行后输出如下：</span><br><span class="line">gegege is eating ...</span><br></pre></td></tr></table></figure><h1 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h1><h2 id="属性方法详解"><a href="#属性方法详解" class="headerlink" title="属性方法详解"></a>属性方法详解</h2><p>把一个方法变成静态的属性 ，因此，在调用的时候，不能再通过()调用 </p><p>这个时候就涉及到2个操作</p><ul><li>将方法变成属性</li><li>对这个属性赋值</li></ul><p>对属性赋值，不能直接像传参数一样操作了，需要使用eat.setter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    name = &quot;gegege&quot;</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def eat(self):</span><br><span class="line">        # print (&quot;&#123;name&#125; is eating &#123;food&#125;...&quot;.format(name=self.name,food=food))</span><br><span class="line">        print (&quot;&#123;name&#125; is eating ...&quot;.format(name=self.name))</span><br><span class="line">    @eat.setter</span><br><span class="line">    def eat(self,food):</span><br><span class="line">        print (&quot;set to food: &#123;food&#125;&quot;.format(food=food))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d1 = Dog(&quot;wxh&quot;)</span><br><span class="line"> </span><br><span class="line">d1.eat</span><br><span class="line">d1.eat = &quot;arg&quot;</span><br><span class="line">d1.eat</span><br><span class="line"></span><br><span class="line">执行后输出如下：</span><br><span class="line">wxh is eating ...</span><br><span class="line">set to food: arg</span><br><span class="line">wxh is eating ...</span><br></pre></td></tr></table></figure><p>通过上面我们可以看到，这个值并没有真正赋值进去，因此在再次调用的时候，输出的还是原来的值（赋值之前的值）。</p><p>因此@eat.setter下面这个方法只是执行了一系列的动作，根本没有存到某个地方</p><p>修改之后的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    name = &quot;gegege&quot;</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__food = None</span><br><span class="line"></span><br><span class="line">    # @staticmethod</span><br><span class="line">    # @classmethod</span><br><span class="line">    @property</span><br><span class="line">    def eat(self):</span><br><span class="line">        # print (&quot;&#123;name&#125; is eating &#123;food&#125;...&quot;.format(name=self.name,food=food))</span><br><span class="line">        print (&quot;&#123;name&#125; is eating &#123;food&#125;...&quot;.format(name=self.name,food=self.__food))</span><br><span class="line">    @eat.setter</span><br><span class="line">    def eat(self,food):</span><br><span class="line">        print (&quot;set to food: &#123;food&#125;&quot;.format(food=food))</span><br><span class="line">        self.__food = food</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d1 = Dog(&quot;wxh&quot;)</span><br><span class="line"></span><br><span class="line">d1.eat</span><br><span class="line">d1.eat = &quot;arg&quot;</span><br><span class="line">d1.eat</span><br><span class="line"></span><br><span class="line">执行后输出如下：</span><br><span class="line">wxh is eating None...</span><br><span class="line">set to food: arg</span><br><span class="line">wxh is eating arg...</span><br></pre></td></tr></table></figure><p>要删除的话，添加删除方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@eat.deleter</span><br><span class="line">def eat(self):</span><br><span class="line">    del self.__food</span><br><span class="line">    print (&quot;删除完毕&quot;)</span><br></pre></td></tr></table></figure><p>删除这个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del d1.eat</span><br></pre></td></tr></table></figure><h2 id="属性方法的使用场景"><a href="#属性方法的使用场景" class="headerlink" title="属性方法的使用场景"></a>属性方法的使用场景</h2><p>了解了属性方法的编写规则之后，需要知道它的应用场景。</p><p>我们在定义这个属性方法的时候，不需要传入参数等就能获取一个明确的输出，因此适用于比如我们想知道一个事物的当前状态，但是这个状态可能会牵涉到很多其他的操作，但是对于我们用户而言，我只需要知道一个结果就可以了，因此在这种情况下就可以使用属性方法。</p><p>比如 ，你想知道一个航班当前的状态，是到达了、延迟了、取消了、还是已经飞走了， 想知道这种状态你必须经历以下几步:</p><p>\1. 连接航空公司API查询</p><p>\2. 对查询结果进行解析 （可能是json、xml等等）</p><p>\3. 返回结果给你的用户</p><p>因此这个status属性的值是一系列动作后才得到的结果，所以你每次调用时，其实它都要经过一系列的动作才返回你结果，但这些动作过程不需要用户关心， 用户只需要调用这个属性就可以。背后的连接api，对结果解析等操作全部被隐藏了。</p><h1 id="类的特殊成员方法"><a href="#类的特殊成员方法" class="headerlink" title="类的特殊成员方法"></a>类的特殊成员方法</h1><h2 id="doc-类的描述信息"><a href="#doc-类的描述信息" class="headerlink" title="__doc__-类的描述信息"></a><code>__doc__</code>-类的描述信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    &quot;&quot;&quot; 描述类信息，这是用于看片的神奇 &quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">    def func(self):</span><br><span class="line">        pass</span><br><span class="line"> </span><br><span class="line">print Foo.__doc__</span><br><span class="line">#输出：类的描述信息</span><br></pre></td></tr></table></figure><h2 id="module-和-class"><a href="#module-和-class" class="headerlink" title="__module__ 和  __class__"></a><code>__module__</code> 和  <code>__class__</code></h2><p><code>__module__</code> 表示当前操作的对象在那个模块</p><p><code>__class__</code>     表示当前操作的对象的类是什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;wupeiqi&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from lib.aa import C</span><br><span class="line"></span><br><span class="line">obj = C()</span><br><span class="line">print obj.__module__  # 输出 lib.aa，即：输出模块</span><br><span class="line">print obj.__class__      # 输出 lib.aa.C，即：输出类</span><br></pre></td></tr></table></figure><h2 id="init-构造方法"><a href="#init-构造方法" class="headerlink" title="__init__ -构造方法"></a><code>__init__</code> -构造方法</h2><p>构造方法，通过类创建对象时，自动触发执行。</p><h2 id="del-析构方法"><a href="#del-析构方法" class="headerlink" title="__del__-析构方法"></a><code>__del__</code>-析构方法</h2><p>析构方法，当对象在内存中被释放时，自动触发执行。</p><blockquote><p>注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的</p></blockquote><h2 id="call-对象后面加括号，触发执行。"><a href="#call-对象后面加括号，触发执行。" class="headerlink" title="__call__ -对象后面加括号，触发执行。"></a><code>__call__</code> -对象后面加括号，触发执行。</h2><blockquote><p>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 <strong>call</strong> 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line"> </span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">     </span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line"> </span><br><span class="line">        print &apos;__call__&apos;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">obj = Foo() # 执行 __init__</span><br><span class="line">obj()       # 执行 __call__</span><br></pre></td></tr></table></figure><h2 id="dict-查看类或对象中的所有成员"><a href="#dict-查看类或对象中的所有成员" class="headerlink" title="__dict__ -查看类或对象中的所有成员 　　"></a><code>__dict__</code> -查看类或对象中的所有成员 　　</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Province:</span><br><span class="line"> </span><br><span class="line">    country = &apos;China&apos;</span><br><span class="line"> </span><br><span class="line">    def __init__(self, name, count):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.count = count</span><br><span class="line"> </span><br><span class="line">    def func(self, *args, **kwargs):</span><br><span class="line">        print &apos;func&apos;</span><br><span class="line"> </span><br><span class="line"># 获取类的成员，即：静态字段、方法、</span><br><span class="line">print Province.__dict__</span><br><span class="line"># 输出：&#123;&apos;country&apos;: &apos;China&apos;, &apos;__module__&apos;: &apos;__main__&apos;, &apos;func&apos;: &lt;function func at 0x10be30f50&gt;, &apos;__init__&apos;: &lt;function __init__ at 0x10be30ed8&gt;, &apos;__doc__&apos;: None&#125;</span><br><span class="line"> </span><br><span class="line">obj1 = Province(&apos;HeBei&apos;,10000)</span><br><span class="line">print obj1.__dict__</span><br><span class="line"># 获取 对象obj1 的成员</span><br><span class="line"># 输出：&#123;&apos;count&apos;: 10000, &apos;name&apos;: &apos;HeBei&apos;&#125;</span><br><span class="line"> </span><br><span class="line">obj2 = Province(&apos;HeNan&apos;, 3888)</span><br><span class="line">print obj2.__dict__</span><br><span class="line"># 获取 对象obj1 的成员</span><br><span class="line"># 输出：&#123;&apos;count&apos;: 3888, &apos;name&apos;: &apos;HeNan&apos;&#125;</span><br></pre></td></tr></table></figure><h2 id="str-输出方法返回值"><a href="#str-输出方法返回值" class="headerlink" title="__str__-输出方法返回值"></a><code>__str__</code>-输出方法返回值</h2><p>如果一个类中定义了<strong>str</strong>方法，那么在打印 对象 时，默认输出该方法的返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line"> </span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &apos;alex li&apos;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">obj = Foo()</span><br><span class="line">print obj</span><br><span class="line"># 输出：alex li</span><br></pre></td></tr></table></figure><h2 id="new-metaclass"><a href="#new-metaclass" class="headerlink" title="__new__ \ __metaclass__"></a><code>__new__ \ __metaclass</code>__</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">f = Foo(&quot;alex&quot;)</span><br></pre></td></tr></table></figure><p>上述代码中，obj 是通过 Foo 类实例化的对象，其实，不仅 obj 是一个对象，Foo类本身也是一个对象，因为在<strong>Python中一切事物都是对象</strong>。</p><p>如果按照一切事物都是对象的理论：obj对象是通过执行Foo类的构造方法创建，那么Foo类对象应该也是通过执行某个类的 构造方法 创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print type(f) # 输出：&lt;class &apos;__main__.Foo&apos;&gt;     表示，obj 对象由Foo类创建</span><br><span class="line">print type(Foo) # 输出：&lt;type &apos;type&apos;&gt;              表示，Foo类对象由 type 类创建</span><br></pre></td></tr></table></figure><p>所以，<strong>f对象是Foo类的一个实例</strong>，<strong>Foo类对象是 type 类的一个实例</strong>，即：Foo类对象 是通过type类的构造方法创建。</p><p>那么，创建类就可以有两种方式：</p><ul><li><p>普通方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">  </span><br><span class="line">    def func(self):</span><br><span class="line">        print &apos;hello alex&apos;</span><br></pre></td></tr></table></figure></li><li><p>特殊方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func(self):</span><br><span class="line">    print &apos;hello wupeiqi&apos;</span><br><span class="line">  </span><br><span class="line">Foo = type(&apos;Foo&apos;,(object,), &#123;&apos;func&apos;: func&#125;)</span><br><span class="line">#type第一个参数：类名</span><br><span class="line">#type第二个参数：当前类的基类</span><br><span class="line">#type第三个参数：类的成员</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def func(self):</span><br><span class="line">    print(&quot;hello %s&quot;%self.name)</span><br><span class="line"></span><br><span class="line">def __init__(self,name,age):</span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = age</span><br><span class="line">Foo = type(&apos;Foo&apos;,(object,),&#123;&apos;func&apos;:func,&apos;__init__&apos;:__init__&#125;)</span><br><span class="line"></span><br><span class="line">f = Foo(&quot;jack&quot;,22)</span><br><span class="line">f.func()</span><br></pre></td></tr></table></figure></li></ul><p>那么问题来了，类默认是由 type 类实例化产生，type类中如何实现的创建类？类又是如何创建对象？</p><p>答：类中有一个属性 <strong>metaclass</strong>，其用来表示该类由 谁 来实例化创建，所以，我们可以为 <strong>metaclass</strong> 设置一个type类的派生类，从而查看 类 创建的过程</p><p>类的生成 调用 顺序依次是 <strong>new</strong> –&gt; <strong>init</strong> –&gt; <strong>call</strong></p><p> metaclass 详解文章：<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a> 得票最高那个答案写的非常好</p><h1 id="类的一些额外操作"><a href="#类的一些额外操作" class="headerlink" title="类的一些额外操作"></a>类的一些额外操作</h1><h2 id="isinstance-obj-cls-检查是否是某个类的对象"><a href="#isinstance-obj-cls-检查是否是某个类的对象" class="headerlink" title="isinstance(obj, cls)- 检查是否是某个类的对象"></a>isinstance(obj, cls)- 检查是否是某个类的对象</h2><p>检查是否obj是否是类 cls 的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">obj = Foo()</span><br><span class="line"> </span><br><span class="line">isinstance(obj, Foo)</span><br></pre></td></tr></table></figure><h2 id="issubclass-sub-super-检查是否是某个类的子类"><a href="#issubclass-sub-super-检查是否是某个类的子类" class="headerlink" title="issubclass(sub, super)-检查是否是某个类的子类"></a>issubclass(sub, super)-检查是否是某个类的子类</h2><p>检查sub类是否是 super 类的派生类/子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">class Bar(Foo):</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">issubclass(Bar, Foo)</span><br></pre></td></tr></table></figure><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>通过反射，传入字符，获取相对应的对象的内存地址，获取了之后就可以直接调用。</p><p>通过hasattr去判断是否存在在类中，如果存在则通过getattr去获取它并调用</p><p>因此，最简单的书写格式应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = xxx() # 实例化出一个对象</span><br><span class="line">choice = input(&quot;&gt;&gt;:&quot;).strip()</span><br><span class="line">if hasattr(d,choice):</span><br><span class="line">    func = getattr(d,choice)</span><br><span class="line">    func(这里输入参数调用)</span><br></pre></td></tr></table></figure><p>总结如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line"> </span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;wupeiqi&apos;</span><br><span class="line"> </span><br><span class="line">    def func(self):</span><br><span class="line">        return &apos;func&apos;</span><br><span class="line"> </span><br><span class="line">obj = Foo()</span><br><span class="line"> </span><br><span class="line"># #### 检查是否含有成员 ####</span><br><span class="line">hasattr(obj, &apos;name&apos;)</span><br><span class="line">hasattr(obj, &apos;func&apos;)</span><br><span class="line"> </span><br><span class="line"># #### 获取成员 ####</span><br><span class="line">getattr(obj, &apos;name&apos;)</span><br><span class="line">getattr(obj, &apos;func&apos;)</span><br><span class="line"> </span><br><span class="line"># #### 设置成员 ####</span><br><span class="line">setattr(obj, &apos;age&apos;, 18)</span><br><span class="line">setattr(obj, &apos;show&apos;, lambda num: num + 1)</span><br><span class="line"> </span><br><span class="line"># #### 删除成员 ####</span><br><span class="line">delattr(obj, &apos;name&apos;)</span><br><span class="line">delattr(obj, &apos;func&apos;)</span><br></pre></td></tr></table></figure><p>反射：</p><ul><li>hasattr(obj,name_str)：判断一个对象里面是否有对应的字符串的方法或属性</li><li>getattr(obj,name_str)：根据字符串去获取obj对象里的对应的方法的内存地址 </li><li>setattr(obj,’y’,z)：setattr(x, ‘y’, v) is equivalent to ``x.y = v’’。通过字符串去设置一个新的属性</li><li>delattr(obj,name_str)： 删除属性</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>做异常处理的原因：虽然程序出错了，但是我不想让用户看到这个错误信息。我已经预料到，程序可能会出这种错，出了这种错误，代表什么意思。这个时候，我就可以做一些预处理，提前做好预防，说如果出现指定的错误，我就输出我认为自定义的输出信息</p><p>默认情况下，出现异常之后，整个程序就会奔溃</p><p>下面我们写一段测试代码</p><h2 id="一次抓一个错误异常"><a href="#一次抓一个错误异常" class="headerlink" title="一次抓一个错误异常"></a>一次抓一个错误异常</h2><p>异常处理之前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Man(object):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def old(self):</span><br><span class="line">        print (&quot;&#123;name&#125; is &#123;age&#125; years old...&quot;.format(name=self.name,age=self.age))</span><br><span class="line"></span><br><span class="line">man1 = Man(&quot;wxh&quot;,26,&quot;df&quot;)</span><br></pre></td></tr></table></figure><p>执行之后的输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/wangxiaohua/PycharmProjects/python14/day07/exce.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    man1 = Man(&quot;wxh&quot;,26,&quot;df&quot;)</span><br><span class="line">TypeError: __init__() takes 3 positional arguments but 4 were given</span><br></pre></td></tr></table></figure><p>异常处理之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Man(object):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def old(self):</span><br><span class="line">        print (&quot;&#123;name&#125; is &#123;age&#125; years old...&quot;.format(name=self.name,age=self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    man1 = Man(&quot;wxh&quot;,26,&quot;df&quot;)</span><br><span class="line">except TypeError as e:</span><br><span class="line">    print (&quot;参数数量输入错误： &quot;,e)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print (&quot;未知错误&quot;,e)</span><br></pre></td></tr></table></figure><p>执行之后的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数数量输入错误：  __init__() takes 3 positional arguments but 4 were given</span><br></pre></td></tr></table></figure><h2 id="一次抓所有错误异常"><a href="#一次抓所有错误异常" class="headerlink" title="一次抓所有错误异常"></a>一次抓所有错误异常</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">man1 = Man(&quot;wxh&quot;,26)</span><br><span class="line">try:</span><br><span class="line">    man1.old(&quot;df&quot;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print (&quot;出错了&quot;,e)</span><br></pre></td></tr></table></figure><p>需要注意的是，这种操作一般不用</p><h2 id="else和finally用法"><a href="#else和finally用法" class="headerlink" title="else和finally用法"></a>else和finally用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    man1.old(&quot;df&quot;)</span><br><span class="line">except TypeError as e:</span><br><span class="line">    print (&quot;位置参数错误：&quot;,e)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print (&quot;未知错误&quot;,e)</span><br><span class="line">else: </span><br><span class="line">    print (&quot;一切正常时执行&quot;)</span><br><span class="line">finally:</span><br><span class="line">    print (&quot;不管有错没错都执行&quot;)</span><br></pre></td></tr></table></figure><p>注意，如果代码本身有错误，都没办法执行的话，是抓不到错误异常的，因为上面抓取错误异常指的是在代码执行时出现的异常</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>例如在MySQL中，它就是自己定义的异常，例如在连接超时的时候就会报错：MySQLConnectionFailed。</p><p>那么，我们也是可以自己定义这些异常的。</p><p><strong>格式： raise 异常名称(‘异常描述’)</strong></p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class WxhException(Exception):</span><br><span class="line">    def __init__(self,message):</span><br><span class="line">        super(LengthError,self).__init__()</span><br><span class="line">        self.message = message</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.message</span><br><span class="line">try:</span><br><span class="line">    raise WxhException(&quot;数据库连接失败&quot;)</span><br><span class="line">except WxhException as e:</span><br><span class="line">    print (e)</span><br></pre></td></tr></table></figure><p>自己写的异常需要我们自己去触发，它不会自动触发。</p><p>会自动触发的异常只有标准异常。</p><p>自己写的异常，系统不知道它的存在，也就是说系统不知道走到哪一步应该触发它，因为所有的逻辑都是我们认为的去判断的。</p><p><strong>自定义触发</strong></p><p>使用raise的语法去触发</p><p>raise WxhException(“数据库连接失败”)。括号中的输入是<strong>异常描述</strong>，<strong>同时也是参数</strong>，传入到这个类的构造方法当中</p><p>接下来，通过下面的内容去打印 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">except WxhException as e:</span><br><span class="line">    print (e)</span><br></pre></td></tr></table></figure><p>注意，这里就相当于是直接打印这个类，而不是对象，所以需要使用到<code>__str__</code>方法。</p><p>注意，在这里，下面的这2行代码可以不用写，但是不能写成别的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def __str__(self):</span><br><span class="line">    return self.message</span><br></pre></td></tr></table></figure><p>因此，自定义的这个异常类继承了Exception这个基类的异常，这个基类的异常在里面已经定义好了，只要你打印，它就会自动的把这个值给它打印出来，传什么就打印什么。</p><p>在这里，print(e)就相当于直接打印这个实例，因此需要def <code>__str__</code>方法的存在</p><p>逻辑顺序：</p><ol><li><p>在try中定义代码，如果符合条件，则使用raise手动的<strong>产生异常</strong>，异常的内容就是括号中的内容</p></li><li><p>接下来，使用exception去抓取这个异常</p></li><li><p>在exception的处理模块中，一般直接使用print（）语法将事先定义好的描述信息输出</p></li></ol><h1 id="python的单例模式"><a href="#python的单例模式" class="headerlink" title="python的单例模式"></a>python的单例模式</h1><p>作者：geekpy</p><p>链接：<a href="https://www.jianshu.com/p/ec6589e02e2f" target="_blank" rel="noopener">https://www.jianshu.com/p/ec6589e02e2f</a></p><p>來源：简书</p><p>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p><p>单例模式是设计模式中逻辑最简单，最容易理解的一个模式，简单到只需要一句话就可以理解，即“保证只有一个对象实例的模式”。问题的关键在于实现起来并没有想象的那么简单。不过我们还是先来讨论下为什么需要这个模式吧。</p><p>我们首先来看看单例模式的使用场景，然后再来分析为什么需要单例模式。</p><ul><li>Python的logger就是一个单例模式，用以日志记录</li><li>Windows的资源管理器是一个单例模式</li><li>线程池，数据库连接池等资源池一般也用单例模式</li><li>网站计数器</li></ul><p>从这些使用场景我们可以总结下什么情况下需要单例模式：</p><ol><li>当每个实例都会占用资源，而且实例初始化会影响性能，这个时候就可以考虑使用单例模式，它给我们带来的好处是只有一个实例占用资源，并且只需初始化一次；</li><li>当有同步需要的时候，可以通过一个实例来进行同步控制，比如对某个共享文件（如日志文件）的控制，对计数器的同步控制等，这种情况下由于只有一个实例，所以不用担心同步问题。</li></ol><p>当然所有使用单例模式的前提是我们的确用一个实例就可以搞定要解决的问题，而不需要多个实例，如果每个实例都需要维护自己的状态，这种情况下单例模式肯定是不适用的。<br> 接下来看看如何使用Python来实现一个单例模式。</p><p><strong>最开始</strong>的想法很简单，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    __instance = None</span><br><span class="line">    def __new__(cls, *args, **kwargs):  # 这里不能使用__init__，因为__init__是在instance已经生成以后才去调用的</span><br><span class="line">        if cls.__instance is None:</span><br><span class="line">            cls.__instance = super(Singleton, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">        return cls.__instance</span><br><span class="line"></span><br><span class="line">s1 = Singleton()</span><br><span class="line">s2 = Singleton()</span><br><span class="line">print (s1)</span><br><span class="line">print (s2)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Singleton object at 0x109cd39e8&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x109cd39e8&gt;</span><br></pre></td></tr></table></figure><p>可以看出两次创建对象，结果返回的是同一个对象实例，我们再让我们的例子更接近真实的使用场景来看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    __instance = None</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if cls.__instance is None:</span><br><span class="line">            cls.__instance = super(Singleton, cls).__new__(cls)</span><br><span class="line">        return cls.__instance</span><br><span class="line"></span><br><span class="line">    def __int__(self, status_number):</span><br><span class="line">        self.status_number = status_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Singleton(2)</span><br><span class="line">s2 = Singleton(5)</span><br><span class="line">print (s1)</span><br><span class="line">print (s2)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Singleton object at 0x10af2d1d0&gt;</span><br><span class="line">&lt;__main__.Singleton object at 0x10af2d1d0&gt;</span><br></pre></td></tr></table></figure><p>不过这个例子中有一个问题我们没有解决，那就是多线程的问题，当有多个线程同时去初始化对象时，就很可能同时判断__instance is None，从而进入初始化instance的代码中。所以为了解决这个问题，我们必须通过同步锁来解决这个问题。以下例子来自<a href="https://link.jianshu.com/?t=http://xiaorui.cc/2016/04/10/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BF%9D%E6%8C%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%94%AF%E4%B8%80/" target="_blank" rel="noopener">xiaorui</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">try:</span><br><span class="line">    from synchronize import make_synchronized</span><br><span class="line">except ImportError:</span><br><span class="line">    def make_synchronized(func):</span><br><span class="line">        import threading</span><br><span class="line">        func.__lock__ = threading.Lock()</span><br><span class="line"></span><br><span class="line">        def synced_func(*args, **kws):</span><br><span class="line">            with func.__lock__:</span><br><span class="line">                return func(*args, **kws)</span><br><span class="line"></span><br><span class="line">        return synced_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line">    instance = None</span><br><span class="line"></span><br><span class="line">    @make_synchronized</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if cls.instance is None:</span><br><span class="line">            cls.instance = object.__new__(cls, *args, **kwargs)</span><br><span class="line">        return cls.instance</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.blog = &quot;xiaorui.cc&quot;</span><br><span class="line"></span><br><span class="line">    def go(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def worker():</span><br><span class="line">    e = Singleton()</span><br><span class="line">    print id(e)</span><br><span class="line">    e.go()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    e1 = Singleton()</span><br><span class="line">    e2 = Singleton()</span><br><span class="line">    e1.blog = 123</span><br><span class="line">    print e1.blog</span><br><span class="line">    print e2.blog</span><br><span class="line">    print id(e1)</span><br><span class="line">    print id(e2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    test()</span><br><span class="line">    task = []</span><br><span class="line">    for one in range(30):</span><br><span class="line">        t = threading.Thread(target=worker)</span><br><span class="line">        task.append(t)</span><br><span class="line"></span><br><span class="line">    for one in task:</span><br><span class="line">        one.start()</span><br><span class="line"></span><br><span class="line">    for one in task:</span><br><span class="line">        one.join()</span><br></pre></td></tr></table></figure><p>至此我们的单例模式实现代码已经接近完美了，不过我们是否可以更简单地使用单例模式呢？答案是有的，接下来就看看如何更简单地使用单例模式。</p><p>在Python的官方网站给了两个例子是用装饰符来修饰类，从而使得类变成了单例模式，使得我们可以通过更加简单的方式去实现单例模式<br> 例子：（这里只给出一个例子，因为更简单，另外一个大家可以看官网<a href="https://link.jianshu.com?t=https://wiki.python.org/moin/PythonDecoratorLibrary#Singleton" target="_blank" rel="noopener">Singleton</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def singleton(cls):</span><br><span class="line">    instance = cls()</span><br><span class="line">    instance.__call__ = lambda: instance</span><br><span class="line">    return instance</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Sample use</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class Highlander:</span><br><span class="line">    x = 100</span><br><span class="line">    # Of course you can have any attributes or methods you like.</span><br><span class="line"></span><br><span class="line">Highlander() is Highlander() is Highlander #=&gt; True</span><br><span class="line">id(Highlander()) == id(Highlander) #=&gt; True</span><br><span class="line">Highlander().x == Highlander.x == 100 #=&gt; True</span><br><span class="line">Highlander.x = 50</span><br><span class="line">Highlander().x == Highlander.x == 50 #=&gt; True</span><br></pre></td></tr></table></figure><p>这里简单解释下：</p><ol><li>在定义class Highlander的时候已经执行完所有singleton装饰器中的代码，得到了一个instance，所以这之后所有对Highlander的调用实际上是在调用instance的<em><em>call</em></em> 方法。</li><li>我们通过lambda函数定义了<em><em>call</em></em>方法让它始终返回instance，因此Highlander()和Highlander都返回instance</li><li>同时由于在类定义代码执行时就已经创建了instance，所以后续不论是多线程还是单线程，在调用Highlander时都是在调用instance的<em><em>call</em></em>方法，也就无需同步了。<br> 最后我想说的是这种方法简直碉堡了～～～</li></ol><h1 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h1><h3 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h3><p>在介绍logging模块的日志流处理流程之前，我们先来介绍下logging模块的四大组件：</p><table><thead><tr><th>组件名称</th><th>对应类名</th><th>功能描述</th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供了应用程序可一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将logger创建的日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filter</td><td>提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table><p>logging模块就是通过这些组件来完成日志处理的，上面所使用的logging模块级别的函数也是通过这些组件对应的类来实现的。</p><h5 id="这些组件之间的关系描述："><a href="#这些组件之间的关系描述：" class="headerlink" title="这些组件之间的关系描述："></a>这些组件之间的关系描述：</h5><ul><li>日志器/记录器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等；</li><li>不同的处理器（handler）可以将日志输出到不同的位置；</li><li>日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置；</li><li>每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志；</li><li>每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。</li></ul><p>简单点说就是：<strong>日志器（logger）是入口</strong>，真正干活儿的是处理器（handler），处理器（handler）还可以通过过滤器（filter）和格式器（formatter）对要输出的日志内容做过滤和格式化等处理操作。</p><h1 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h1><h1 id="socket网络编程"><a href="#socket网络编程" class="headerlink" title="socket网络编程"></a>socket网络编程</h1><p>socket是将tcp的操作封装起来了，隐藏了tcp底层的很多复杂的实现过程</p><p>socket是对上层协议的封装</p><p>socket不光支持tcp/ip，还支持udp</p><p>socket只干两件事【收发数据】</p><ul><li>send</li><li>Receive </li></ul><p>socket会把三次握手这些东西都封装好</p><p>下面是伪代码</p><p>注意：先要有接收端，相当于服务端</p><p>发送端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import socket </span><br><span class="line">socket.TCP/IP  # 定义操作的协议类型</span><br><span class="line">connect(a.ip，a.port)</span><br><span class="line">socket.send(hello)</span><br><span class="line">socket.recv()</span><br><span class="line">socket.close()</span><br></pre></td></tr></table></figure><p>接收端/服务端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">socket.TCP/IP  #声明类型</span><br><span class="line">listen(0.0.0.0,6969)#一台机器上可能存在多个网卡，因此要指定ip地址和端口，同时也是唯一定位一个节点</span><br><span class="line">waiting()</span><br><span class="line">recv()</span><br><span class="line">send()</span><br><span class="line"></span><br><span class="line">服务器端不需要close</span><br></pre></td></tr></table></figure><p>客户端的流程</p><ol><li>导入socket</li><li>定义socket类型</li><li>连接远程机器</li><li>开始发送数据</li><li>接收数据</li><li>关闭socket</li></ol><p>client端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 声明socket类型，同时生成socket连接对象</span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((&apos;localhost&apos;,6969))</span><br><span class="line"></span><br><span class="line">client.send(b&quot;hello,world&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = client.recv(1024)</span><br><span class="line">print (&quot;recv: &quot;,data )</span><br><span class="line"></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure><p>server端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind((&apos;localhost&apos;,6969))</span><br><span class="line">server.listen()</span><br><span class="line">print (&quot;dd&quot;)</span><br><span class="line">conn,addr = server.accept()</span><br><span class="line">print (conn)</span><br><span class="line">print (addr)</span><br><span class="line"></span><br><span class="line">print (&quot;dd&quot;)</span><br><span class="line">data = conn.recv(1024)</span><br><span class="line"></span><br><span class="line">print (&quot;recv:&quot;,data)</span><br><span class="line">conn.send(data.upper())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.close()</span><br></pre></td></tr></table></figure><p>bytes类型 只能接受ascii里面的数据类型</p><p>上面的是不能传输中文的，我们需要传输中文的时候，就需要encode成为一个byte（encode将其转成ascii里面支持的格式）</p><p>解析使用decode</p><p>在socket中，所有的数据传输都需要使用这个bytes格式</p>]]></content>
    
    <summary type="html">
    
      day07-面向对象编程进阶及异常处理
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu更改apt源</title>
    <link href="http://yoursite.com/2018/08/28/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/ubuntu%E6%9B%B4%E6%94%B9apt%E6%BA%90/"/>
    <id>http://yoursite.com/2018/08/28/IT科学技术知识体系结构-Linux运维方向/Linux系统管理/ubuntu更改apt源/</id>
    <published>2018-08-28T06:17:44.000Z</published>
    <updated>2018-08-28T06:17:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在安装完ubuntu之后，我们一般都需要将apt源替换为阿里云等国内软件源站点，以便提高响应速度。</p><p>这里使用的是Ubuntu18.04发行版本</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>其实Ubuntu18.04版之前的任一版更改apt源为国内源方法早就有了，内容大同小异，我们应当掌握其规律了，其实每一版内容不同的地方就是版本号（或者官方一点的说：系统代号），所以我们先了解下新版本的系统代号：</p><p>使用如下命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -c</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:/etc/apt$ lsb_release -c</span><br><span class="line">Codename:bionic</span><br></pre></td></tr></table></figure><p>我们可以看到新版本的Ubuntu系统代号为bionic</p><p>同样的我们也可以得到之前任意版本的系统代号：</p><ul><li>Ubuntu 12.04 (LTS)代号为precise。</li><li>Ubuntu 14.04 (LTS)代号为trusty。</li><li>Ubuntu 15.04 代号为vivid。</li><li>Ubuntu 15.10 代号为wily。</li><li>Ubuntu 16.04 (LTS)代号为xenial。</li></ul><p>所以这也就解释了为什么我们百度出来的那么多方案里面内容不尽相同的原因，因为他们更改apt安装源时用的系统不一样。</p><p>下面开始实际操作</p><hr><h1 id="备份源文件"><a href="#备份源文件" class="headerlink" title="备份源文件"></a>备份源文件</h1><p>我们要修改的文件是sources.list，它在目录/etc/apt/下，sources.list是包管理工具apt所用的<strong><code>记录软件包仓库</code></strong>位置的配置文件，同样类型的还有位于 同目录下sources.list.d文件下的各种.list后缀的各文件。</p><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h1 id="编辑源文件内容"><a href="#编辑源文件内容" class="headerlink" title="编辑源文件内容"></a>编辑源文件内容</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>将原有的内容注释或删除掉，添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>配置格式说明：</p><p>我们可以看到sources.list文件的条目都是有格式的（通过上面的内容大家也看的出来），一般有如下形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://site.example.com/debian distribution component1 component2 component3</span><br><span class="line">deb-src http://site.example.com/debian distribution component1 component2 component3</span><br></pre></td></tr></table></figure><p>后面几个参数是对软件包的分类（Ubuntu下是main， restricted，universe ，multiverse这四个）</p><h1 id="补充-etc-apt-sources-list-详解"><a href="#补充-etc-apt-sources-list-详解" class="headerlink" title="补充-/etc/apt/sources.list 详解"></a>补充-/etc/apt/sources.list 详解</h1><p><code>/etc/apt/sources.list</code> 是包管理工具 <code>apt</code> 所用的记录软件包仓库位置的配置文件，同样的还有位于 <code>/etc/apt/sources.list.d/*.list</code> 的各文件。</p><p><code>sources.list</code> 文件中的条目一般都有如下所示的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://site.example.com/debian distribution component1 component2 component3</span><br><span class="line">deb-src http://site.example.com/debian distribution component1 component2 component3</span><br></pre></td></tr></table></figure><h2 id="档案类型-Archive-type"><a href="#档案类型-Archive-type" class="headerlink" title="档案类型 (Archive type)"></a>档案类型 (Archive type)</h2><p>条目的第一个词 <code>deb</code> 或是 <code>deb-src</code> 表明了所获取的软件包档案类型。</p><p>其中：</p><ul><li><p><strong>deb</strong></p><p>档案类型为二进制预编译软件包，一般我们所用的档案类型。</p></li><li><p><strong>deb-src</strong></p><p>档案类型为用于编译二进制软件包的源代码。</p></li></ul><h2 id="仓库地址-Repository-URL"><a href="#仓库地址-Repository-URL" class="headerlink" title="仓库地址 (Repository URL)"></a>仓库地址 (Repository URL)</h2><p>条目的第二个词则是软件包所在仓库的地址。我们可以更换仓库地址为其他地理位置更靠近自己的镜像来提高下载速度。</p><p>常用镜像地址列表：</p><ul><li><p><strong>Debian</strong></p><p><a href="https://www.debian.org/mirror/list" target="_blank" rel="noopener">https://www.debian.org/mirror/list</a></p></li><li><p><strong>Ubuntu</strong></p><p><a href="http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/源列表</a></p></li></ul><h2 id="发行版-Distribution"><a href="#发行版-Distribution" class="headerlink" title="发行版 (Distribution)"></a>发行版 (Distribution)</h2><p>跟在仓库地址后的是发行版。发行版有两种分类方法，一类是发行版的具体代号，如 <code>xenial</code>,<code>trusty</code>, <code>precise</code> 等；还有一类则是发行版的发行类型，如<code>oldstable</code>, <code>stable</code>, <code>testing</code> 和 <code>unstable</code>。</p><p>另外，在发行版后还可能有进一步的指定，如 <code>xenial-updates</code>, <code>trusty-security</code>, <code>stable-backports</code> 等。</p><h2 id="软件包分类-Component"><a href="#软件包分类-Component" class="headerlink" title="软件包分类 (Component)"></a>软件包分类 (Component)</h2><p>跟在发行版之后的就是软件包的具体分类了，可以有一个或多个。</p><p>不同的 Linux 发行版对软件有着不同的分类，如：</p><h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h3><ul><li><p><strong>main</strong></p><p>包含符合 <a href="https://www.debian.org/social_contract#guidelines" target="_blank" rel="noopener">DFSG</a> 指导原则的自由软件包，而且这些软件包不依赖不符合该指导原则的软件包。这些软件包被视为 Debian 发型版的一部分。</p></li><li><p><strong>contrib</strong></p><p>包含符合 <a href="https://www.debian.org/social_contract#guidelines" target="_blank" rel="noopener">DFSG</a> 指导原则的自由软件包，不过这些软件包依赖不在 <em>main</em> 分类中的软件包。</p></li><li><p><strong>non-free</strong></p><p>包含不符合 <a href="https://www.debian.org/social_contract#guidelines" target="_blank" rel="noopener">DFSG</a> 指导原则的非自由软件包。</p></li></ul><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><ul><li><p><strong>main</strong></p><p>官方支持的<a href="http://www.ubuntu.com/about/about-ubuntu/our-philosophy" target="_blank" rel="noopener">自由</a>软件。</p></li><li><p><strong>restricted</strong></p><p>官方支持的非完全<a href="http://www.ubuntu.com/about/about-ubuntu/our-philosophy" target="_blank" rel="noopener">自由</a>的软件。</p></li><li><p><strong>universe</strong></p><p>社区维护的自由软件。</p></li><li><p><strong>multiverse</strong></p><p>非自由软件。</p></li></ul><p>Ubuntu 对软件包的分类可以用下表来表示（参考自 <a href="https://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29#Package_classification_and_support" target="_blank" rel="noopener">Wikipedia</a>）：</p><table><thead><tr><th></th><th>自由软件</th><th>非自由软件</th></tr></thead><tbody><tr><td>官方支持的</td><td>Main</td><td>Restricted</td></tr><tr><td>非官方支持的</td><td>Universe</td><td>Multiverse</td></tr></tbody></table><h1 id="补充-update和upgrade"><a href="#补充-update和upgrade" class="headerlink" title="补充-update和upgrade"></a>补充-update和upgrade</h1><p>每个LINUX的发行版，比如ubuntu、centos等，都会维护一个自己的软件仓库，我们常用的几乎所有软件都在这里面。这里面的软件绝对安全，而且绝对的能正常安装。</p><p>在UBUNTU下，我们维护一个源列表，源列表里面都是一些网址信息，这每一条网址就是一个源，这个地址指向的数据标识着这台源服务器上有哪些软件可以安装使用。</p><p>编辑源命令：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.<span class="keyword">list</span></span><br></pre></td></tr></table></figure><p>在这个文件里加入或者注释（加#）掉一些源后，保存。这时候，我们的源列表里指向的软件就会增加或减少一部分。</p><p>获得最近的软件包的列表:(列表中包含一些包的信息，比如这个包是否更新过)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>这个命令，会访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。软件包管理器里看到的软件列表，都是通过update命令更新的。</p><p>update后，可能需要upgrade一下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>这个命令，会把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。如果你的软件都是最新版本，会提示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。</span><br></pre></td></tr></table></figure><p><strong>总而言之，update是更新软件列表，upgrade是更新软件。</strong></p><p>注意：一般在执行 sudo apt-get upgrade 命令之前需要先执行一下 sudo apt-get update；这其实和windows下的软件检测更新是一样的，需要更新的会帮你自动更新并安装好</p><p>apt-get update 命令会同步使用者端和APT服务器的RPM 索引清单（package list），APT 服务器的RPM 索引清单置于base 资料夹内，使用者端电脑取得base 资料夹内的bz2 RPM 索引清单压缩档后，会将其解压置放于/var/state/apt/lists/，而使用者使用apt-get install 或apt-get dist-upgrade 指令的时候，就会将这个资料夹内的资料和使用者端电脑内的RPM 资料库比对，如此一来就可以知道那些RPM 已安装、未安装、或是可以升级的。</p>]]></content>
    
    <summary type="html">
    
      ubuntu更改apt源
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="Linux系统管理" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="ubuntu更改apt源" scheme="http://yoursite.com/tags/ubuntu%E6%9B%B4%E6%94%B9apt%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>DNS记录类型简介</title>
    <link href="http://yoursite.com/2018/08/28/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/DNS/DNS%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/08/28/IT科学技术知识体系结构-Linux运维方向/网络知识及网络服务/网络知识/DNS/DNS记录类型简介/</id>
    <published>2018-08-28T03:54:17.000Z</published>
    <updated>2018-08-28T03:54:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>DNS：（Domain Name System，域名系统），因特网上作为域名和<a href="http://baike.baidu.com/view/3930.htm" target="_blank" rel="noopener">IP地址</a>相互映射的一个<a href="http://baike.baidu.com/view/68389.htm" target="_blank" rel="noopener">分布式数据库</a>，能够使用户更方便的访问<a href="http://baike.baidu.com/view/6825.htm" target="_blank" rel="noopener">互联网</a>，而不用去记住能够被机器直接读取的IP数串。通过<a href="http://baike.baidu.com/view/23880.htm" target="_blank" rel="noopener">主机</a>名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。使用端口号53。</p><p>DNS服务器：用于对域名进行解析的域名解析服务器。</p><p>DNS代理：用于代理域名服务器，对客户端的查询请求进行响应（一般是本地查找，查找不到再向代理的服务器转发客户端的查询请求）</p><h1 id="dns记录类型介绍"><a href="#dns记录类型介绍" class="headerlink" title="dns记录类型介绍"></a>dns记录类型介绍</h1><h2 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h2><p>说明：WEB服务器的IP指向</p><p>A （Address）记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置域名的子域名。通俗来说A记录就是服务器的IP,域名绑定A记录就是告诉DNS,当你输入域名的时候给你引导向设置在DNS的A记录所对应的服务器。 </p><p>简单的说，A记录是指定域名对应的IP地址。</p><h2 id="AAAA记录"><a href="#AAAA记录" class="headerlink" title="AAAA记录"></a>AAAA记录</h2><p>作用同A记录，只不过该记录是将域名解析到一个指定的<strong>IPV6</strong>的IP上</p><h2 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h2><p>通常称别名解析。可以将注册的不同域名都转到一个域名记录上，由这个域名记录统一解析管理</p><p>这种记录允许您将多个名字映射到同一台计算机。 通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。 它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。 这两个别名的全称就是“www.mydomain.com”和“mail.mydomain.com”。实际上他们都指向“host.mydomain.com”。</p><p>同样的方法可以用于当您拥有多个域名需要指向同一服务器IP，此时您就可以将一个域名做A记录指向服务器IP然后将其他的域名做别名到之前做A记录的域名上，那么当您的服务器IP地址变更时您就可以不必麻烦的一个一个域名更改指向了 只需要更改做A记录的那个域名其他做别名的那些域名的指向也将自动更改到新的IP地址上了。</p><h2 id="NS记录"><a href="#NS记录" class="headerlink" title="NS记录"></a>NS记录</h2><p>解析服务器记录，用来表明由哪台服务器对该域名进行解析。</p><p>这里的NS记录只对子域名生效。</p><p>例如用户希望由12.34.56.78这台服务器解析news.mydomain.com，则需要设置news.mydomain.com的NS记录。 </p><p>说明： </p><ul><li>“优先级”中的数字越小表示级别越高； </li><li>“IP地址/主机名”中既可以填写IP地址，也可以填写像ns.mydomain.com这样的主机地址，但必须保证该主机地址有效。如，将 news.mydomain.com的NS记录指向到ns.mydomain.com，在设置NS记录的同时还需要设置ns.mydomain.com的 指向，否则NS记录将无法正常解析； </li><li>NS记录优先于A记录。即，如果一个主机地址同时存在NS记录和A记录，则A记录不生效。这里的NS记录只对子域名生效。</li></ul><h2 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h2><p>MX（Mail Exchanger）记录是邮件交换记录，它指向一个邮件服务器，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器。例如，当Internet上的某用户要发一封信给 user@mydomain.com 时，该用户的邮件系统通过DNS查找mydomain.com这个域名的MX记录，如果MX记录存在， 用户计算机就将邮件发送到MX记录所指定的邮件服务器上。</p><hr><p>其他的记录类型涉及到的时候再详细补充</p>]]></content>
    
    <summary type="html">
    
      DNS记录类型简介
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="网络知识及网络服务" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="网络知识" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
      <category term="DNS" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/DNS/"/>
    
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu设置ssh服务</title>
    <link href="http://yoursite.com/2018/08/26/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/ubuntu%E8%AE%BE%E7%BD%AEssh%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/08/26/IT科学技术知识体系结构-Linux运维方向/Linux系统管理/ubuntu设置ssh服务/</id>
    <published>2018-08-26T09:49:54.000Z</published>
    <updated>2018-08-26T09:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，安装完ubuntu之后，操作系统不会像centos一样会自动把openssh-server给安装上，也就是说，在系统安装完毕之后，我们还需要进行额外的操作，才能通过ssh的方式远程访问我们的ubuntu系统。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>SSH分客户端openssh-client和openssh-server</p><p>如果你只是想登陆别的机器，那么只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。</p><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>在命令行中使用如下命令进行安装</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>ssh-server配置文件位于/etc/ssh/sshd_config，在这里可以定义SSH的服务端口，默认端口是22，你可以自己定义成其他端口号。</p><p>通过修改配置文件/etc/ssh/sshd_config，可以进行修改ssh登录端口、禁止root登录等一系列操作，修改端口可以防止被端口扫描。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>默认情况下，安装完毕之后将会自动启动，我们可用用过ps来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -elf | grep sshd</span><br></pre></td></tr></table></figure><p>如果没有启动的话，我们执行以下命令启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      ubuntu设置ssh服务
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="Linux系统管理" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="ubuntu设置ssh服务" scheme="http://yoursite.com/tags/ubuntu%E8%AE%BE%E7%BD%AEssh%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/08/23/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker+k8s/Docker%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/08/23/IT科学技术知识体系结构-Linux运维方向/虚拟化/Docker+k8s/Docker入门与实践/</id>
    <published>2018-08-23T09:42:27.000Z</published>
    <updated>2018-08-23T09:42:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li>书籍：《Docker技术入门与实战 第2版》</li></ul><hr><h1 id="第1章-基础知识"><a href="#第1章-基础知识" class="headerlink" title="第1章 基础知识"></a>第1章 基础知识</h1><h2 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h2><h3 id="有关虚拟化"><a href="#有关虚拟化" class="headerlink" title="有关虚拟化"></a>有关虚拟化</h3><p>虚拟化技术是一个通用的概念，在不同领域有不同的理解，在计算领域，一般指的是计算虚拟化（computing Virtualization），或通常说的服务器虚拟化。</p><p>维基百科定义如下：“虚拟化是一种资源管理技术”，是将计算机的各种实体资源，例如服务器、网络、内存及存储等，予以抽象，转换后呈现出来的，打破实体结构间的不可切割的障碍，使用户可以比原来的组态更好的方式来应用这些资源</p><p>传统来看，虚拟化既可以通过硬件模拟来实现（xen、esxi等），也可以通过操作系统软件来实现（KVM等）。而容器技术则更为优雅，它充分利用了操作系统本身已有的机制和特性，可以实现远超传统虚拟机的轻量级虚拟化。因此，有人甚至把它称为“新一代的虚拟化”技术，并将<strong>基于容器打造的云平台亲切地称之为“容器云”</strong></p><h3 id="什么docker"><a href="#什么docker" class="headerlink" title="什么docker"></a>什么docker</h3><p>Docker的构想是要实现“build,ship and run any app,anywhere”,即通过对应用程序的封装、分发、部署、运行生命周期。达到应用组件，“一次封装，到处运行”的目的。这里的应用组件，既可以是一个web应用、一个编译环境、也可以是一套数据库平台服务，甚至是一个操作系统或者集群</p><p>可以说，Docker首次为应用的开发、运行和部署提供了“一站式”的实用解决方案</p><p>IBM DeveloperWorks网站关于容器技术的描述十分准确：“容器技术有效地将由单个操作系统管理的资源划分到孤立的组中，以更好的在孤立的组之间平衡有冲突的资源使用需求”</p><p>总结：Docker是一项容器技术，是一个开源项目</p><h3 id="从LXC从到Docker"><a href="#从LXC从到Docker" class="headerlink" title="从LXC从到Docker"></a>从LXC从到Docker</h3><p>Docker技术的主要实现参考的是Linux容器技术（Linux Containers LXC）</p><p>在LXC的基础之上，Docker进一步优化了容器的使用体验，让它进入了寻常百姓家。</p><p>优化项目：</p><p>首先，Docker提供了各种容器管理工具（如分发、版本、移植等），让用户无需关注底层的操作，可以简单明了地管理和使用容器。</p><p>其次，docker引入了<strong>分层文件系统构建和高效的镜像机制</strong>，降低了迁移难度极大地提升了用户体验。用户操作docker就像操作应用自身一样简单。</p><h3 id="使用Docker的好处"><a href="#使用Docker的好处" class="headerlink" title="使用Docker的好处"></a>使用Docker的好处</h3><p>在云时代，开发者创建的应用需要要很方便的在网络上传播，也就是说，应用必须要脱离底层物理硬件的限制，同时必须是“任何时间，任何地点”都可获取的。因此，开发者需要一种新型的创建分布式应用程序的方式，<strong>快速分发和部署</strong>，这正是docker所能够提供的最大优势。</p><p>举例来说，如果要部署LAMP平台，需要分别部署mysql，apache，php等，然后再进行一系列的配置，这样的配置非常繁琐并且容易出错。并且如果需要服务器迁移，往往需要重新部署。</p><p>docker提供了一种更为聪明的方式，通过容器来打包应用。解耦应用和运行平台。这意味着在进行应用迁移的时候，只需要再新的机器上面再启动容器就可以了，不需要再进行重新部署等操作。无论服务器是否是同一类型的平台架构。这节约了大量的时间，并降低了部署过程出现问题的风险。</p><h3 id="Docker在开发和运维中的优势"><a href="#Docker在开发和运维中的优势" class="headerlink" title="Docker在开发和运维中的优势"></a>Docker在开发和运维中的优势</h3><p>具体来说，Docker在开发和运维过程中，具有如下几个方面的优势：</p><ul><li>更快速的交付和部署</li></ul><p>使用镜像来快速构建一套标准环境，</p><ul><li>更高效的资源利用</li></ul><p>docker容器不需要额外的虚拟化管理程序支持，它是内核级别的虚拟化，可以实现更高的性能</p><ul><li>更轻松的迁移和扩展</li></ul><p>docker容器几乎可以在任何的平台上运行，包括物理机，虚拟机，公有云，私有云，个人电脑，服务器等。</p><ul><li>更简单的更新管理</li></ul><p>使用dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作，并且所有的修改都是以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</p><h3 id="Docker与虚拟机的比较"><a href="#Docker与虚拟机的比较" class="headerlink" title="Docker与虚拟机的比较"></a>Docker与虚拟机的比较</h3><ul><li><p>docker容器很快，启动和停止可以在秒级实现，而传统的虚拟机方式需要数分钟</p></li><li><p>docker容器对系统资源的需求很少，一台主机可以同时运行数千个docker容器</p></li><li><p>docker通过类似git设计理念的操作来方便用户获取，分发和应用镜像，存储复用，增量更新。</p></li><li><p>docker通过dockerfile支持灵活的自动化创建和部署机制，提高工作效率，使流程标准化。</p></li></ul><h3 id="Docker和核心价值"><a href="#Docker和核心价值" class="headerlink" title="Docker和核心价值"></a>Docker和核心价值</h3><p>docker的核心价值在于，他很有可能改变传统的软件“交付”方式和运行方式。传统的交付源码或者交付软件的方式的最大问题在于，软件运行期间所“依赖的环境”是无法控制的、不能标准化的，IT人员常常需要耗费很多精力来解决因为“依赖的环境”而导致软件运行出现的各种问题。</p><p>而docker将<strong>软件与其“依赖的环境”打包在一起</strong>，以镜像的方式交付，让软件运行在“标准的环境中”，这非常符合云计算的要求。这种变革一旦被IT人员接受，可能会对产业链带来很大的冲击，我们熟悉的apt-get、yum是否会逐渐被docker pull取代？</p><p>从这一点可以毫不夸张的说，docker是革命性的，它重新定义了软件开发、测试、交付和部署的流程。我们交付的不再是代码、配置文件、数据库定义等。而是整个应用程序运行环境：“OS+各种中间件、类库+应用程序代码”</p><p>有了标准化的运行环境，再加上对CPU、内存、磁盘、网络等动态资源的限制，docker构造了一个“轻量级虚拟环境”，传统虚拟机的绝大多数使用场景可以被docker取代，这将给IT基础设施带来一次更大的冲击；传统虚拟化（KVM、XEN、VMWare）将会何去何从？此外，docker秒级创建/删除虚拟机以及<strong>动态调整资源</strong>的能力，也非常契合云计算的“实例水平扩展”、“资源动态调整”的需求，docker很有可能成为云计算的基石。</p><h3 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h3><p>通过上面的介绍，可以总结出以下几个使用docker的场景</p><ul><li><p>业务高峰期通过启动大量容器进行横向扩展</p></li><li><p>应用需要经常迁移或者多环境运行</p></li></ul><h2 id="核心概念-名词解释"><a href="#核心概念-名词解释" class="headerlink" title="核心概念/名词解释"></a>核心概念/名词解释</h2><p>只有理解了这三个核心概念，才能顺利的理解Docker容器的整个生命周期。</p><p>docker的大部分操作都围绕着它的三个核心概念：<strong>镜像、容器和仓库</strong>展开。因此准确把握这三大核心概念对于掌握docker技术尤为重要。</p><h3 id="三剑客之镜像-Image"><a href="#三剑客之镜像-Image" class="headerlink" title="三剑客之镜像-Image"></a>三剑客之镜像-Image</h3><p>Docker镜像类似<strong>虚拟机镜像</strong>，可以将它理解为一个<strong>只读的模板</strong>。例如，一个镜像可以包含一个基本的操作系统环境，里面仅安装了apache应用程序（或者其他需要的程序），这个时候，可以把它称之为一个apache镜像。</p><p>镜像是创建Docker容器的基础。通过<strong>版本管理和增量的文件系统</strong>，Docker提供了一套十分简单的机制来<strong>创建和更新删除</strong>现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并且直接使用</p><p>功能总结</p><ul><li><p>只读的模板（包含OS+应用）</p></li><li><p>版本管理和增量文件系统的机制在其之上</p></li><li><p>操作：自行创建或网上下载、更新、删除</p></li></ul><h3 id="三剑客之容器-Container"><a href="#三剑客之容器-Container" class="headerlink" title="三剑客之容器-Container"></a>三剑客之容器-Container</h3><p>我们可以将Docker的容器理解为一种轻量级的沙盒（sanbox）。</p><p>Docker利用容器来<strong>运行和隔离</strong>应用（镜像）。</p><p>容器是从镜像创建的应用运行实例，可以将指定的镜像<strong>启动、开始、停止、删除</strong>。而这些容器都是彼此相互隔离的，互不可见的。【容器是镜像的隔离运行单元】</p><p>每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止都十分快速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。</p><p>每个容器都是一个操作系统实例</p><p><strong>容器的功能</strong></p><ul><li>通过容器打包运行应用</li></ul><p>解耦应用和运行平台。这意味着在进行应用迁移的时候，只需要再新的机器上面再启动容器就可以了，不需要再进行重新部署等操作。无论服务器是否是同一类型的平台架构。</p><ul><li>隔离应用</li></ul><p><strong>容器的组成结构</strong></p><ul><li><p>上层：实际应用</p></li><li><p>下层：操作系统环境（主要是内核+函数库）</p></li></ul><h3 id="三剑客之仓库-Repository"><a href="#三剑客之仓库-Repository" class="headerlink" title="三剑客之仓库-Repository"></a>三剑客之仓库-Repository</h3><p>docker仓库类似于代码仓库，它是docker集中存放镜像文件的场所</p><p>需要注意docker仓库和仓库注册服务器（Registry）的区别。</p><ul><li><p>仓库注册服务器是存放仓库的地方，其中往往存放着多个仓库。</p></li><li><p>每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的tag（标签）来进行区分。</p></li></ul><p>根据所存储的镜像公开与否，Docker仓库可以分为两种形式。目前，最大公开仓库是官方提供的docker Hub，其中存放了数量庞大的镜像供用户下载。国内不少云服务提供商（时速云，阿里云等）也提供了仓库的本地源，可以提供稳定的国内访问</p><p>docker也支持用户在本地网络内创建一个只能自己访问的私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到指定的公有或者私有仓库有。这样用户下次在另外一台机器上使用该镜像时，只需要将其从仓库上pull下来就可以。</p><h3 id="Docker-EE和Docker-CE"><a href="#Docker-EE和Docker-CE" class="headerlink" title="Docker-EE和Docker-CE"></a>Docker-EE和Docker-CE</h3><p>Docker Engine改为Docker CE（社区版）, Docker Community Edition</p><p>Docker Data Center改为Docker EE（企业版）, Docker Enterprise Edition</p><p>在Docker三个定价层增加了额外的支付产品和支持</p><p>Docker社区版（CE）是为了开发人员或小团队创建基于容器的应用,与团队成员分享和自动化的开发管道。docker-ce提供了简单的安装和快速的安装，以便可以立即开始开发。docker-ce集成和优化，基础设施。 </p><p>Docker企业版（EE）是专为企业的发展和IT团队建立谁。docker-ee为企业提供最安全的容器平台，以应用为中心的平台。</p><h1 id="第2章-安装配置"><a href="#第2章-安装配置" class="headerlink" title="第2章 安装配置"></a>第2章 安装配置</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>docker目前只能运行在64为平台上，并且要求内核版本不低于3.10，实际上内核越新越好，过低的内核版本容易造成功能不稳定。</p><h3 id="centos环境下安装docker"><a href="#centos环境下安装docker" class="headerlink" title="centos环境下安装docker"></a>centos环境下安装docker</h3><p>安装依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \ device-mapper-persistent-data \lvm2</span><br></pre></td></tr></table></figure><p>添加yum源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum-config-manager \ --add-repo \</span><br><span class="line">https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>安装docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum -y install docker-ce</span><br></pre></td></tr></table></figure><h3 id="ubuntu环境安装docker"><a href="#ubuntu环境安装docker" class="headerlink" title="ubuntu环境安装docker"></a>ubuntu环境安装docker</h3><p><strong>卸载老旧版本的docker</strong></p><p>Older versions of Docker were called <code>docker</code> or <code>docker-engine</code>. If these are installed, uninstall them:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><p><strong>安装软件源</strong></p><ol><li><p>Update the <code>apt</code> package index:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>Install packages to allow <code>apt</code> to use a repository over HTTPS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>Add Docker’s official GPG key:</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>Verify that you now have the key with the fingerprint <code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code>, by searching for the last 8 characters of the fingerprint.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"></span><br><span class="line">pub   4096R/0EBFCD88 2017-02-22</span><br><span class="line">      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid                  Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   4096R/F273FCD8 2017-02-22</span><br></pre></td></tr></table></figure><ol><li>Use the following command to set up the <strong>stable</strong> repository. You always need the <strong>stable</strong> repository, even if you want to install builds from the <strong>edge</strong> or <strong>test</strong> repositories as well. To add the <strong>edge</strong> or <strong>test</strong> repository, add the word <code>edge</code> or <code>test</code> (or both) after the word <code>stable</code> in the commands below.</li></ol><blockquote><p><strong>Note</strong>: The <code>lsb_release -cs</code> sub-command below returns the name of your Ubuntu distribution, such as <code>xenial</code>. Sometimes, in a distribution like Linux Mint, you might have to change <code>$(lsb_release -cs)</code> to your parent Ubuntu distribution. For example, if you are using <code>Linux Mint Rafaela</code>, you could use <code>trusty</code>.</p></blockquote><ul><li>x86_64 / amd64</li><li>armhf</li><li>IBM Power (ppc64le)</li><li>IBM Z (s390x)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure><p><strong>安装docker-ce</strong></p><p>Install the latest version of Docker CE, or go to the next step to install a specific version. Any existing installation of Docker is replaced.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><p>On production systems, you should install a specific version of Docker CE instead of always using the latest. This output is truncated. List the available versions.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">docker-ce | 17.09.0~ce-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages</span><br></pre></td></tr></table></figure><p>我这里的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"> docker-ce | 18.06.1~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br><span class="line"> docker-ce | 18.06.0~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br><span class="line"> docker-ce | 18.03.1~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br></pre></td></tr></table></figure><p>The contents of the list depend upon which repositories are enabled. Choose a specific version to install. The second column is the version string. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by an equals sign (<code>=</code>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce=&lt;VERSION&gt;</span><br></pre></td></tr></table></figure><p>The Docker daemon starts automatically.</p><ol><li><p>Verify that Docker CE is installed correctly by running the <code>hello-world</code> image.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure></li></ol><p><strong>配置开机自启动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p><strong>卸载docker</strong></p><ol><li><p>Uninstall the Docker CE package:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure></li><li><p>Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure></li></ol><p>You must delete any edited configuration files manually.</p><h2 id="配置Docker服务"><a href="#配置Docker服务" class="headerlink" title="配置Docker服务"></a>配置Docker服务</h2><h3 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a><strong>权限配置</strong></h3><p>为了避免每次使用docker命令都需要sudo使用特权身份，可以将当前用户加入安装中自动创建的docker用户组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker [username]</span><br></pre></td></tr></table></figure><p>关于这部分的内容-查看：<a href="https://docs.docker.com/v17.09/engine/installation/linux/linux-postinstall/" target="_blank" rel="noopener">Post-installation steps for Linux</a></p><p>后续需要单独写一篇文章写docker的启动权限问题</p><h3 id="配置文件不存在问题"><a href="#配置文件不存在问题" class="headerlink" title="配置文件不存在问题"></a><strong>配置文件不存在问题</strong></h3><p>docker服务的默认配置文件为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu中：/etc/default/docker</span><br><span class="line">centos中：/etc/sysconfig/docker</span><br></pre></td></tr></table></figure><p>在该配置文件中，我们可以通过修改其中的<strong>DOCKER_OPTS</strong>来修改服务<strong>启动的参数</strong></p><p>但是实际情况，安装完docker之后，是没有改配置文件的</p><p>因此在docker的高版本之后，配置文件变成了：/etc/docker/key.json</p><p>官方参考配置文档：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd//#daemon-configuration-file</a></p><h2 id="cd-启动Docker服务"><a href="#cd-启动Docker服务" class="headerlink" title="cd 启动Docker服务"></a>cd 启动Docker服务</h2><p> 在Centos 7 中，我们可以使用如下命令启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># systemctl enable  docker</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload     #加载配置</span><br></pre></td></tr></table></figure><h1 id="第3章-使用Docker镜像"><a href="#第3章-使用Docker镜像" class="headerlink" title="第3章 使用Docker镜像"></a>第3章 使用Docker镜像</h1><p>镜像（image）是Docker三大核心概念中最为重要的，自Docker诞生之日起，“镜像”就是相关社区最为热门的关键词。</p><p>docker运行容器前需要本地存在对应的镜像，如果镜像没有保存在本地，docker会尝试先从默认镜像仓库下载（默认使用docker Hub公共注册服务器中的仓库），用户也可以通过配置，使用自定义的镜像仓库。</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>镜像是运行容器的前提，官方的docker Hub网站已经提供了数十万个镜像供大家开放下载。</p><p>可以使用docker pull命令直接从docker Hub 镜像源来下载镜像。该命令的格式为docker pull NAME[:TAG]。其中，NAME是镜像仓库的名称（用来区分镜像），TAG是镜像的标签（往往用来表示版本信息）。例如：ubuntu系统是NAME，14.04是TAG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure><hr><p><strong>注意：</strong></p><p>如果不显性的制定TAG，该命令会自动选择latest标签，这会下载仓库中最新版本的镜像。</p><p>镜像的latest标签意味着该镜像的内容会跟踪最新的非稳定版本而发布，内部是不稳定的。</p><p>在生产环境中禁止忽略镜像的标签信息或者使用默认的latest标签</p><hr><h3 id="镜像的分层特性"><a href="#镜像的分层特性" class="headerlink" title="镜像的分层特性"></a>镜像的分层特性</h3><p>镜像文件一般由若干层（layer）构成，每一层都有一个唯一的id（完整的id有256比特，由64个十六进制字符组成）。</p><p>使用docker pull命令下载时会获取并输出镜像的各层信息。<strong>当不同的镜像包括相同的层时，本地仅存储该层的一份内容，减少了需要的存储空间。</strong></p><h3 id="镜像的重名问题"><a href="#镜像的重名问题" class="headerlink" title="镜像的重名问题"></a>镜像的重名问题</h3><p>在使用不同的镜像仓库时，可能会出现镜像重名的情况？</p><p>严格来讲，镜像的仓库名称中还应该添加仓库地址（即仓库注册服务器（Registry））的地址作为前缀，默认我们使用的是docker Hub的服务，该前缀可以忽略不写。</p><p>例如：docker pull ubuntu:14.04 命令相当于docker pull registry.hub.docker.com/ubuntu:14.04命令。</p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>下载镜像到本地之后，即可随时使用该镜像，例如利用该镜像创建一个容器，在其中运行bash应用，执行ping localhost命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master yum.repos.d]# docker run -it ubuntu:14.04 bash</span><br></pre></td></tr></table></figure><h2 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h2><h3 id="使用images命令列出镜像"><a href="#使用images命令列出镜像" class="headerlink" title="使用images命令列出镜像"></a>使用images命令列出镜像</h3><p>使用docker images命令可以列出本地主机上已有镜像的基本信息。、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker images</span><br></pre></td></tr></table></figure><p>​                                                 </p><p>在列出的信息中，可以看到以下几个字段信息：</p><ul><li><p>来自于哪个仓库           REPOSITORY</p></li><li><p>镜像的TAG（标签）信息，标签知识标记，并不能识别镜像内容</p></li><li><p>镜像的ID（唯一标识镜像）。IMAGE ID</p></li><li><p>创建时间        CREATED</p></li><li><p>镜像大小               SIZE</p></li></ul><p>其中镜像的ID信息十分重要，它唯一标识了镜像。在使用镜像ID的时候，一般可以使用该ID的前若干个字符组成的可区分串来替代完整的ID。</p><p>镜像大小信息只是标识该镜像的逻辑体积的大小，实际上由于相同的镜像层本地只会存储一份，物理上占用的存储空间会小于各镜像的逻辑体积之和。</p><p>images支持的的选项参数：</p><ul><li><p>-a    –all=true|false         列出所有的镜像文件（包括临时文件），默认为否</p></li><li><p>–digests=true|false          列出镜像的数字摘要值，默认为否</p></li><li><p>-f    –filter=[]                过滤列出的镜像</p></li><li><p>…..</p></li></ul><p>具体可以通过man docker-images 进行查看。</p><h3 id="使用tag命令添加镜像标签"><a href="#使用tag命令添加镜像标签" class="headerlink" title="使用tag命令添加镜像标签"></a>使用tag命令添加镜像标签</h3><p>为了方便在后续的工作中使用特定镜像，还可以使用docker tag命令来为本地镜像任意添加新的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker tag ubuntu:14.04 ubuntu:my14.04</span><br></pre></td></tr></table></figure><p>  注意：docker tag命令添加的标签实际上起到了类似链接的作用</p><h3 id="使用inspect命令查看详细信息"><a href="#使用inspect命令查看详细信息" class="headerlink" title="使用inspect命令查看详细信息"></a>使用inspect命令查看详细信息</h3><p>使用docker inspect命令可以获取该镜像的详细信息，包括制作者，使用架构，各层的数字摘要等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker inspect ubuntu:14.04</span><br></pre></td></tr></table></figure><p>返回的是一个JSON格式的消息，如果我们只要其中一项内容时，可以使用参数-f来指定，例如，获取镜像的Architecture参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker inspect ubuntu:14.04 -f &#123;&#123;&quot;.Architecture&quot;&#125;&#125;</span><br><span class="line">amd64</span><br></pre></td></tr></table></figure><h3 id="使用history命令查看镜像历史"><a href="#使用history命令查看镜像历史" class="headerlink" title="使用history命令查看镜像历史"></a>使用history命令查看镜像历史</h3><p>既然镜像由多个层组成，那么怎么知道各个层的内容具体是什么呢？这时候可以使用history子命令，该命令将列出各层的创建信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker history ubuntu:14.04</span><br><span class="line"></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line"></span><br><span class="line">a35e70164dfb        12 days ago         /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;do…   7B                  </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c sed -i &apos;s/^#\s(deb.universe)$…   2.76kB              </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c rm -rf /var/lib/apt/lists/*          0B                  </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /…   195kB               </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c #(nop) ADD file:3900b83a46e97708a…   222MB</span><br></pre></td></tr></table></figure><h2 id="搜寻镜像"><a href="#搜寻镜像" class="headerlink" title="搜寻镜像"></a>搜寻镜像</h2><p>使用docker search命令来搜索源端仓库中共享的镜像，默认搜索官方仓库中的镜像。</p><p>用法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search TERM</span><br></pre></td></tr></table></figure><p>支持的主要参数为：</p><ul><li><p>–automated=true|false：仅显示自动创建的镜像，默认为否。</p></li><li><p>–no-trubc=true|false：输出信息不截断显示，默认为否</p></li><li><p>-s     –starts=X：指定仅显示评价为指定星级以上的镜像，默认为0，即输出所有的镜像。</p></li></ul><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><h3 id="使用标签删除镜像"><a href="#使用标签删除镜像" class="headerlink" title="使用标签删除镜像"></a>使用标签删除镜像</h3><p>使用docker rmi命令可以删除镜像，命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi IMAGE [IMAGE…]</span><br><span class="line"></span><br><span class="line">其中IMAGE可以为标签或ID,例如：ubuntu:my14.04</span><br></pre></td></tr></table></figure><p>​                                                 </p><p>注意：当同一个镜像拥有多个标签的时候，docker rmi命令只是删除该镜像多个标签中的制定标签而已，并不影响镜像文件。因此上述操作相当于只是删除了镜像a35e70164dfb的一个标签而已。</p><p>但是，当镜像只是剩下一个标签的时候，此时再使用docker rmi 命令会彻底删除镜像。</p><h3 id="使用镜像ID删除镜像"><a href="#使用镜像ID删除镜像" class="headerlink" title="使用镜像ID删除镜像"></a>使用镜像ID删除镜像</h3><p>当使用docker rmi（remove image）命令，并且后面跟上镜像的ID（也可以是能进行区分的部分ID串前缀）时，会先尝试删除所有指向该镜像，然后再删除该镜像文件本身</p><p>命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi xxxx(ID)</span><br></pre></td></tr></table></figure><p>注意：使用该命令可以彻底将该镜像删除，而不是只是删除对应的标签，请务必注意。</p><hr><p>注意：</p><p>当有该镜像创建的容器存在时，镜像文件默认是无法被删除的</p><p>试图删除该镜像，docker会提示有容器正在运行，无法删除</p><p>如果要强行删除镜像，可以使用-f参数</p><hr><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>创建镜像的方法主要有三种：</p><ul><li><p>基于已有镜像的容器创建</p></li><li><p>基于本地模板导入</p></li><li><p>基于dockerfile创建</p></li></ul><h3 id="基于已有镜像的容器创建"><a href="#基于已有镜像的容器创建" class="headerlink" title="基于已有镜像的容器创建"></a>基于已有镜像的容器创建</h3><p>当运行一个容器后，内部发生了变化，我们可以把这个发生了变化的容器做成一个新的镜像。</p><p>该方法主要是通过docker commit命令。</p><p>命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [options] container [repository[:tag]]</span><br></pre></td></tr></table></figure><p>主要选项包括：</p><ul><li><p>-a     –author=””：作者信息</p></li><li><p>-c     –change=[]：提交的时候之心dockerfile指令，</p></li><li><p>-m   –message=””：提交消息</p></li><li><p>-p    –pause=true     提交时暂停容器运行</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -it ubuntu:14.04 /bin/bash</span><br><span class="line"></span><br><span class="line">root@fdbe2f28b1d6:/# touch test</span><br><span class="line"></span><br><span class="line">root@fdbe2f28b1d6:/# exit</span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line">[root@master ~]# docker commit -m &quot;add a new file&quot; -a &quot;wxh&quot; fdbe2f28b1d6 test:0.1</span><br><span class="line"></span><br><span class="line">sha256:cd9c21826184f9e65e11644f826fb97918d40d469aa5e3fd8827cbcac19351ed</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker images 查看</span><br></pre></td></tr></table></figure><p>I’m just </p><p>​                                                   </p><h3 id="基于本地模板导入"><a href="#基于本地模板导入" class="headerlink" title="基于本地模板导入"></a>基于本地模板导入</h3><p>这部分不常用，详见书籍《docker技术入门与实践》-p32</p><h3 id="基于dockerfile创建"><a href="#基于dockerfile创建" class="headerlink" title="基于dockerfile创建"></a>基于dockerfile创建</h3><h5 id="官方案例"><a href="#官方案例" class="headerlink" title="官方案例"></a>官方案例</h5><p>下面是docker官方案例，有一定的代表性</p><p>链接地址：<a href="https://docs.docker.com/v17.09/get-started/part2/#dockerfile" target="_blank" rel="noopener">https://docs.docker.com/v17.09/get-started/part2/#dockerfile</a></p><p><code>Dockerfile</code> will define what goes on in the environment inside your container. Access to resources like networking interfaces and disk drives is virtualized inside this environment, which is isolated from the rest of your system, so you have to map ports to the outside world, and be specific about what files you want to “copy in” to that environment. However, after doing that, you can expect that the build of your app defined in this <code>Dockerfile</code> will behave exactly the same wherever it runs.</p><p><strong><code>Dockerfile</code></strong></p><p>Create an empty directory. Change directories (<code>cd</code>) into the new directory, create a file called <code>Dockerfile</code>, copy-and-paste the following content into that file, and save it. Take note of the comments that explain each statement in your new Dockerfile.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to /app</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at /app</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>Are you behind a proxy server?</p><p>Proxy servers can block connections to your web app once it’s up and running. If you are behind a proxy server, add the following lines to your Dockerfile, using the <code>ENV</code> command to specify the host and port for your proxy servers:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; # Set proxy server, replace host:port with values for your servers</span><br><span class="line">&gt; ENV http_proxy host:port</span><br><span class="line">&gt; ENV https_proxy host:port</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>Add these lines before the call to <code>pip</code> so that the installation succeeds.</p></blockquote><p>This <code>Dockerfile</code> refers to a couple of files we haven’t created yet, namely <code>app.py</code> and <code>requirements.txt</code>. Let’s create those next.</p><p><strong>The app itself</strong></p><p>Create two more files, <code>requirements.txt</code> and <code>app.py</code>, and put them in the same folder with the <code>Dockerfile</code>. This completes our app, which as you can see is quite simple. When the above <code>Dockerfile</code> is built into an image, <code>app.py</code> and <code>requirements.txt</code> will be present because of that <code>Dockerfile</code>’s <code>ADD</code> command, and the output from <code>app.py</code> will be accessible over HTTP thanks to the <code>EXPOSE</code>command.</p><p><strong>requirements.txt</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p><strong>app.py</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure><p>Now we see that <code>pip install -r requirements.txt</code> installs the Flask and Redis libraries for Python, and the app prints the environment variable <code>NAME</code>, as well as the output of a call to <code>socket.gethostname()</code>. Finally, because Redis isn’t running (as we’ve only installed the Python library, and not Redis itself), we should expect that the attempt to use it here will fail and produce the error message.</p><blockquote><p><strong>Note</strong>: Accessing the name of the host when inside a container retrieves the container ID, which is like the process ID for a running executable.</p></blockquote><p>That’s it! You don’t need Python or anything in <code>requirements.txt</code> on your system, nor will building or running this image install them on your system. It doesn’t seem like you’ve really set up an environment with Python and Flask, but you have.</p><p><strong>Build the app</strong></p><p>We are ready to build the app. Make sure you are still at the top level of your new directory. Here’s what <code>ls</code> should show:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Dockerfileapp.pyrequirements.txt</span><br></pre></td></tr></table></figure><p>Now run the build command. This creates a Docker image, which we’re going to tag using <code>-t</code> so it has a friendly name.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .</span><br></pre></td></tr></table></figure><p>Where is your built image? It’s in your machine’s local Docker image registry:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">REPOSITORY            TAG                 IMAGE ID</span><br><span class="line">friendlyhello         latest              326387cea398</span><br></pre></td></tr></table></figure><p><strong>Run the app</strong></p><p>Run the app, mapping your machine’s port 4000 to the container’s published port 80 using <code>-p</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure><p>You should see a message that Python is serving your app at <code>http://0.0.0.0:80</code>. But that message is coming from inside the container, which doesn’t know you mapped port 80 of that container to 4000, making the correct URL <code>http://localhost:4000</code>.</p><p>Go to that URL in a web browser to see the display content served up on a web page.</p><p>Now let’s run the app in the background, in detached mode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure><p>You get the long container ID for your app and then are kicked back to your terminal. Your container is running in the background. You can also see the abbreviated container ID with <code>docker container ls</code> (and both work interchangeably when running commands):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED</span><br><span class="line">1fa4ab2cf395        friendlyhello       &quot;python app.py&quot;     28 seconds ago</span><br></pre></td></tr></table></figure><p>You’ll see that <code>CONTAINER ID</code> matches what’s on <code>http://localhost:4000</code>.</p><p>Now use <code>docker container stop</code> to end the process, using the <code>CONTAINER ID</code>, like so:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop 1fa4ab2cf395</span><br></pre></td></tr></table></figure><h2 id="载入和导出镜像"><a href="#载入和导出镜像" class="headerlink" title="载入和导出镜像"></a>载入和导出镜像</h2><p>用户可以使用docker save和docker load命令来存出和载入镜像</p><h3 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h3><p>如果要导出镜像到本地文件，可以使用docker save命令。例如导出本地的ubunt:14.04镜像为ubuntu_14.04.tar。如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker save -o ubuntu:14.04.tar ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h3><p>可以使用docker load将导出的tar文件再导入到本地的镜像库，例如从上述文件导入镜像到本地镜像列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker load --input ubuntu\:14.04.tar</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker load &lt; ubuntu\:14.04.tar</span><br></pre></td></tr></table></figure><p>该命令将导入镜像及其相关的元数据信息（包括标签等）。导入成功之后，可以使用docker images命令进行查看。</p><h2 id="上传和下载镜像"><a href="#上传和下载镜像" class="headerlink" title="上传和下载镜像"></a>上传和下载镜像</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>首先在docker hub网站完成注册</p><p>可以通过执行 <strong>docker login</strong> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><p>你可以通过 <strong>docker logout</strong> 退出登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:~$ sudo docker login</span><br><span class="line">[sudo] password for wxh:</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">Username: watchmen1992</span><br><span class="line">Password:</span><br><span class="line">WARNING! Your password will be stored unencrypted in /home/wxh/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">wxh@wxh-ThinkPad-E570:~$</span><br></pre></td></tr></table></figure><h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>可以使用docker push命令上传镜像到仓库，默认上传到docker Hub官方仓库（需要在前面进行登录）</p><p>在进行上传之前，我们需要将指定的image镜像打上tag标签</p><p>命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag image username/repository:tag</span><br><span class="line">docker push NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</span><br></pre></td></tr></table></figure><p>例如这里是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:~/.docker$ sudo docker images</span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">friendlyhello              latest              028a0a8d1a73        18 hours ago        132MB</span><br><span class="line">python                     2.7-slim            40792d8a2d6d        4 weeks ago         120MB</span><br><span class="line">hello-world                latest              2cb0d9787c4d        7 weeks ago         1.85kB</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker tag friendlyhello watchmen1992/get_started:part1</span><br></pre></td></tr></table></figure><p>然后push上传</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:~/.docker$ sudo docker push watchmen1992/get_started:part1</span><br><span class="line">The push refers to repository [docker.io/watchmen1992/get_started]</span><br><span class="line">88d851af045c: Pushed</span><br><span class="line">aa5497e6a355: Pushed</span><br><span class="line">d4f7cf378376: Pushed</span><br><span class="line">1ea4f6a807ba: Mounted from library/python</span><br><span class="line">fda4dc055a55: Mounted from library/python</span><br><span class="line">e8fc09a140cf: Mounted from library/python</span><br><span class="line">cdb3f9544e4c: Mounted from library/python</span><br><span class="line">part1: digest: sha256:ded675c46615053ef0a655b163228e50a0e58172003f78f319dad46ee09dac9a size: 1788</span><br></pre></td></tr></table></figure><p>上传之后，我们在docker hub的页面就可以看到新增内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 username/repository:tag</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:~/.docker$ sudo docker run  -p 4000:80 watchmen1992/get_started:part1</span><br><span class="line"></span><br><span class="line">[sudo] password for wxh:</span><br><span class="line"> * Serving Flask app &quot;app&quot; (lazy loading)</span><br><span class="line"> * Environment: production</span><br><span class="line">   WARNING: Do not use the development server in a production environment.</span><br><span class="line">   Use a production WSGI server instead.</span><br><span class="line"> * Debug mode: off</span><br><span class="line"> * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)</span><br><span class="line"></span><br><span class="line">192.168.101.72 - - [30/Aug/2018 03:32:34] &quot;GET / HTTP/1.1&quot; 200 -</span><br></pre></td></tr></table></figure><p>在上传之后，我们就能直接调用仓库的镜像去启动容器</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><h1 id="第4章-使用Docker容器"><a href="#第4章-使用Docker容器" class="headerlink" title="第4章 使用Docker容器"></a>第4章 使用Docker容器</h1><p>容器是docker的另一个和细腻概念。简单来说，容器是镜像的一个运行实例。所不同的是，镜像是静态的只读文件，而容器带有运行时需要的可写文件层。</p><h2 id="创建启动容器"><a href="#创建启动容器" class="headerlink" title="创建启动容器"></a>创建启动容器</h2><h3 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h3><p>使用docker create命令新建一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：docker create -it ubuntu:latest</span><br></pre></td></tr></table></figure><p>注意：使用该命令新建的容器<strong>处于停止状态</strong>，可以使用docker start命令来启动它。</p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>使用docker start 命令来启动一个已经创建的容器，例如启动刚创建的ubuntu容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start af</span><br></pre></td></tr></table></figure><h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><p>除了创建容器后通过start命令来启动，也可以直接新建并启动容器。</p><p>所需要的命令主要为:docker run。等价于先执行docker create命令，再执行docker start命令</p><p>例如，下面的命令输出一个“hello world”之后容器终止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run ubuntu:14.04 /bin/echo &quot;hello,world&quot;</span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure><p>​                                                </p><p>当利用docker run命令来创建并启动容器时，docker在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库中下载</li><li>利用镜像创建一个容器，并启动该容器</li><li>分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中</li><li>从网桥的地址池配置一个IP地址给容器</li><li>执行用户执行的应用程序</li><li>执行完毕后容器被自动终止</li></ul><p>下面命令启动一个bash终端，允许用户进行交互</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -it ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure><p>-t选项让docker分配一个伪终端，并绑定到容器的标准输入上，一则让容器的标准输入保持打开。更多的命令可以通过 man docker-run进行查看。</p><hr><p>注意：</p><p>对于所创建的bash容器，当使用exit命令退出之后，容器就自动处于退出状态了，这是因为对于docker容器来说，当运行的应用退出之后，容器也就没有继续运行的必要了</p><hr><h3 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h3><p>更多的时候，需要让docker容器在后台以守护态（daemonized）形式运行。此时可以添加-d参数来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d  ubuntu:14.04 /bin/bash -c &quot;while true;do echo hello,world;sleep 1;done&quot;</span><br></pre></td></tr></table></figure><p>此时，要获取容器的输出信息，可以使用如下的docker logs命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker logs 9e7</span><br></pre></td></tr></table></figure><p>退出错误代码</p><ul><li><p>125         docker daemon执行出错，例如指定了不支持的docker命令参数</p></li><li><p>126         所指定命令无法执行，例如权限出错</p></li><li><p>127         容器内命令无法找到</p></li></ul><p>当命令执行出错时，会默认返回错误码</p><h3 id="容器参数"><a href="#容器参数" class="headerlink" title="容器参数"></a>容器参数</h3><p>详见书籍《docker技术从入门到实践》p35-37</p><ul><li><p>–rm  容器在终止后会立刻删除</p></li><li><p>-d           守护态启动，注意—rm和-d不能同时使用</p></li></ul><h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用docker stop来终止一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令格式为：docker stop -t|--time[=10]</span><br></pre></td></tr></table></figure><p>该命令首先向容器发送SIGTERM信号，等待一段超时时间（默认为10秒）后，再发送SIGKILL信号来终止容器</p><p>​                                                  </p><p>当容器中指定的应用终结时，容器也会自动终止。</p><p>处于终止状态的容器，可以通过start命令来重新启动</p><p>此外，docker restart 命令会将一个运行态的容器先终止，然后再重新启动它</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><h3 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h3><p>这种方法，同一时间只能有一个活动窗口。不建议</p><h3 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h3><p>通过exec命令对容器执行操作是最为推荐的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker start 9e708d44e39a</span><br><span class="line">9e708d44e39a</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker exec -it 9e7 /bin/bash</span><br><span class="line">root@9e708d44e39a:/#</span><br></pre></td></tr></table></figure><p>比较常用的参数有：</p><ul><li><p>-i            –interactive=true|false             打开标准输入接受用户输入命令，默认为false。</p></li><li><p>–privileged=true|false             是否给执行命令以最高权限，默认为false。</p></li><li><p>-t     –tty=true|false         分配伪终端，默认为false</p></li><li><p>-u    –user=””         执行命令的用户名或者ID</p></li></ul><h3 id="nsenter工具"><a href="#nsenter工具" class="headerlink" title="nsenter工具"></a>nsenter工具</h3><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><ul><li><p>docker ps               查看运行中的容器</p></li><li><p>docker ps  -a          查看所有容器，包括运行的与停止的</p></li><li><p>docker ps -qa          查看所有容器ID</p></li></ul><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用docker rm命令来删除处于终止或者退出状态的容器</p><p>命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f|--force [-v|--volumes] container [container…]</span><br></pre></td></tr></table></figure><p>主要支持的选项包括：</p><ul><li><p>-f            –force=false     是否强行终止并删除一个运行中的容器</p></li><li><p>-l            –link=false      删除容器的连接，但是保留容器</p></li><li><p>-v           –volumes=false       删除容器挂载的数据卷</p></li></ul><p>默认情况下，docker rm命令只能删除处于终止或者退出状态的容器，并不能删除还是处于运行状态的容器。</p><p>如果要删除一个运行中的容器，可以添加-f参数。该命令首先向容器发送SIGKILL信号给容器，终止其中的应用，之后强行删除。</p><h2 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker export -o test_for_run.tar ce5</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">docker export e81 &gt; test_for_stop.tar</span><br></pre></td></tr></table></figure><h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><p>导出的文件可以使用docker import命令导入变成镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import test_for_run.tar – test/ubuntu:v1.0</span><br></pre></td></tr></table></figure><p>实际上，既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以用docker import命令来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也更大。此外，从容器快照文件导入时可以重新制定标签等元数据信息</p><h1 id="第5章-访问docker仓库"><a href="#第5章-访问docker仓库" class="headerlink" title="第5章 访问docker仓库"></a>第5章 访问docker仓库</h1><p>仓库（repositroy）是集中存放镜像的地方，分为公共仓库和私有仓库。</p><p>注意：注册服务器是存放仓库的服务器</p><h2 id="docker-hub公共镜像市场"><a href="#docker-hub公共镜像市场" class="headerlink" title="docker hub公共镜像市场"></a>docker hub公共镜像市场</h2><p>默认使用的镜像来源都是docker  hub中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search lnmp</span><br></pre></td></tr></table></figure><h2 id="时速云镜像市场"><a href="#时速云镜像市场" class="headerlink" title="时速云镜像市场"></a>时速云镜像市场</h2><h2 id="搭建本地私有仓库"><a href="#搭建本地私有仓库" class="headerlink" title="搭建本地私有仓库"></a>搭建本地私有仓库</h2><h3 id="使用registry镜像创建私有仓库"><a href="#使用registry镜像创建私有仓库" class="headerlink" title="使用registry镜像创建私有仓库"></a>使用registry镜像创建私有仓库</h3><p>安装docker之后，可以通过官方提供的<strong>registry</strong>镜像来简单搭建一套本地私有仓库环境:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p>它将自动下载并且启动一个registry容器，创建本地的私有仓库服务</p><p>在默认情况下，会将仓库创建在容器的/tmp/registry目录下。可以通过-v参数来将镜像文件存放在本地的指定路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000  -v /opt/data/registry:/tmp/registry  registry</span><br></pre></td></tr></table></figure><h3 id="管理私有仓库-上传镜像"><a href="#管理私有仓库-上传镜像" class="headerlink" title="管理私有仓库-上传镜像"></a>管理私有仓库-上传镜像</h3><p>因为docker images中的字段，REPOSITORY表示仓库信息，因此，我们在创建了私有仓库之后，要使用镜像，需要对镜像进行tag标签的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker tag ubuntu:14.04 47.93.54.101:5000/test</span><br></pre></td></tr></table></figure><p>上述命令解释：</p><p>使用tag命令将ubuntu镜像标记为47.93.54.101:5000/test【也就是这个仓库下的】</p><p>47.93.54.101:5000是仓库注册服务器，test是仓库名称，test:[name]后面接的是tag信息，没有写的话，默认是latest</p><p>接下来使用docker push上传标记的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker push 47.93.54.101:5000/test</span><br></pre></td></tr></table></figure><hr><p>注意：</p><p>客户端采用https，docker registry未采用https服务，由于服务端没有采用https方式，因此客户端无法使用默认的https形式pull镜像，因此我们要做一些操作</p><hr><ul><li>服务端：</li></ul><p>在/etc/docker/目录下，创建daemon.json文件。在文件中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master docker]# cat daemon.json</span><br><span class="line"></span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;47.93.54.101:5000&quot;]&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><p>在/etc/docker/目录下，创建daemon.json文件。在文件中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master docker]# cat daemon.json</span><br><span class="line"></span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;47.93.54.101:5000&quot;]&#125;</span><br></pre></td></tr></table></figure><p>注意：不光服务端要配置，客户端也需要配置</p><p>配置完毕之后，我们就可以看到客户端能够正常的拉取我们私有仓库中的镜像</p><h1 id="第6章-Docker数据管理"><a href="#第6章-Docker数据管理" class="headerlink" title="第6章 Docker数据管理"></a>第6章 Docker数据管理</h1><p>生产环境中使用docker的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。</p><p>容器中管理数据主要有2种方式</p><ul><li><p>数据卷（data volumes）：容器内数据直接映射到本地主机环境</p></li><li><p>数据卷容器（data volumes containers）：使用特定容器维护数据卷。</p></li></ul><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可以供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于linux的mount挂载操作。</p><p>数据卷可以提供很多有用的特性：</p><ul><li><p>数据卷可以在容器之间共享和重用，容器键传递数据将变得高效方便。</p></li><li><p>对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作。</p></li><li><p>对数据卷的更新不会影响镜像，解耦了应用和数据</p></li><li><p>卷会一直存在，直到没有容器使用，可以安全的卸载它。</p></li></ul><h3 id="在容器内创建一个数据卷"><a href="#在容器内创建一个数据卷" class="headerlink" title="在容器内创建一个数据卷"></a>在容器内创建一个数据卷</h3><p>在用docker run命令的时候，使用-v标记可以在容器内创建一个数据卷。多次重复使用-v标记可以创建多个数据卷。</p><p>下面使用 training/webapp镜像创建一个web容器，并创建一个数据卷挂载到容器的/webapp目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -P --name web -v /webapp training/webapp python app.py</span><br></pre></td></tr></table></figure><p>​                                                 </p><p>注意：这里是在容器内部创建一个目录，而不是宿主机上创建</p><p>-P是将容器服务暴露的端口，是自动映射到本地主机的临时端口       </p><h3 id="挂载宿主机目录作为数据卷"><a href="#挂载宿主机目录作为数据卷" class="headerlink" title="挂载宿主机目录作为数据卷"></a>挂载宿主机目录作为数据卷</h3><p>使用-v标记也可以指定挂载一个本地的已有目录到容器中去作为数据卷【推荐方式】</p><p>[root@master ~]# docker run -d -P –name web -v /src/webapp:/opt/webapp training/webapp python app.py</p><p>上述命令加载主机的/src/webapp目录到容器的/opt/webapp目录</p><p>本地目录的路径必须是绝对路径，如果目录不存在，docker会自动创建</p><p>注意：docker挂载数据卷的默认权限是读写（rw）,用户也可以通过ro指定为只读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</span><br></pre></td></tr></table></figure><p><strong>设置为ro</strong>之后，容器内对所挂载数据卷内的数据就无法修改了。</p><p>​                                                  </p><p> 使用这个功能，在进行一些测试的时候十分方便，比如用户可以将一些程序或者数据放到本地目录中，然后再容器内运行和使用</p><h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p>-v标记也可以从主机挂载单个文件到容器中作为数据卷（对应容器中的某一个文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run –rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>注意：如果直接挂载一个文件到容器中，使用文件编辑工具，包括vi或者sed等，可能会造成文件inode的概念，从docker 1.1.0版本起，这会导致报错，所以推荐的方式是直接挂载目录。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果用户需要再多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。</p><p>首先，创建一个数据卷容器dbdata，并在其中创建一个数据卷挂载到/dbdata：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /dbdata --name dbdata ubuntu</span><br></pre></td></tr></table></figure><p>【这个dbdata是在容器内部的一个目录，请注意】</p><p>作用是：定义一个数据卷</p><p>然后，可以在其他容器中使用–volumes-from来挂载dbdata容器中的数据卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from  dbdata --name db1 ubuntu</span><br></pre></td></tr></table></figure><p>在容器dbdata中查看，数据已经同步过来                        </p><p>可以多次使用 –volume-from参数来从多个容器挂载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷。</p><p>注意：如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时，显式使用docker rm -v命令来指定同时删除关联的容器。</p><p>使用数据卷容器可以让用户在容器之间自由地升级和移动数据卷。</p><h2 id="利用数据卷容器来迁移"><a href="#利用数据卷容器来迁移" class="headerlink" title="利用数据卷容器来迁移"></a>利用数据卷容器来迁移</h2><p>可以利用数据卷容器对其中的数据卷进行备份、恢复、以实现数据的迁移。</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>使用下面的命令来备份dbdata数据卷容器内的数据卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run --volumes-from  dbdata -v $(pwd):/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdata</span><br><span class="line"></span><br><span class="line">tar: Removing leading `/&apos; from member names</span><br><span class="line">/dbdata/</span><br><span class="line">/dbdata/a</span><br><span class="line">/dbdata/db1</span><br></pre></td></tr></table></figure><p>命令解析：</p><p>首先利用ubuntu镜像创建了一个容器worker，使用–volumes-from dbdata参数来让worker容器挂载dbdata容器的数据卷。</p><p>然后使用-v参数，挂载本地的当前目录到worker容器内部的/backup目录。</p><p>worker容器启动之后，使用tar命令，将/dbdata目录备份到容器内的/backup目录下，也就是宿主机的当前目录下。即可完成整个备份过程。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>数据操作都需要借助容器来完成，需要借助容器来打通一个通道。</p><p>恢复数据的思路（这里指的是恢复数据到另一个没有数据的数据卷容器中）：</p><ul><li><p>创建一个新的数据卷容器</p></li><li><p>创建一个新的容器，挂载该容器（–volumes-from参数）</p></li><li><p>挂载本地的目录到/backup下（这时该目录下就会有本地的数据），然后解压其中的数据</p></li></ul><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure><h1 id="第7章-端口映射与容器互联"><a href="#第7章-端口映射与容器互联" class="headerlink" title="第7章 端口映射与容器互联"></a>第7章 端口映射与容器互联</h1><p>在实际情况中，是需要多个服务组件容器共同协作的情况，因此往往需要多个容器之间能够互相访问到对方的服务。</p><p>除了通过网络来进行访问，docker还提供了两个功能满足服务访问的基本需求：</p><ul><li><p>一个是允许映射容器内应用的服务端口到本地宿主主机</p></li><li><p>另一个是互联机制实现多个容器键通过容器名称来来快速访问</p></li></ul><p>在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。</p><h2 id="端口映射实现访问容器"><a href="#端口映射实现访问容器" class="headerlink" title="端口映射实现访问容器"></a>端口映射实现访问容器</h2><h3 id="所有接口的随机端口"><a href="#所有接口的随机端口" class="headerlink" title="所有接口的随机端口"></a>所有接口的随机端口</h3><p>可以通过-P或者-p参数来指定端口映射。</p><ul><li>当使用-P时，映射一个49000-49900的端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure><p>​                                                  </p><p>可以通过docker logs -f [id]来查看应用信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker logs -f 4336a2dbe777</span><br></pre></td></tr></table></figure><h3 id="所有接口的指定端口"><a href="#所有接口的指定端口" class="headerlink" title="所有接口的指定端口"></a>所有接口的指定端口</h3><p>命令格式：hostport:containerport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>使用该命令映射所有接口地址</p><p>此时绑定所有接口上的所有地址，将本地的5000端口映射搭配容器的5000端口</p><h3 id="指定地址的指定端口"><a href="#指定地址的指定端口" class="headerlink" title="指定地址的指定端口"></a>指定地址的指定端口</h3><p>命令格式：IP:hostport:containerport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>指定使用本机的哪一个地址进行端口映射</p><h3 id="指定地址的任意端口"><a href="#指定地址的任意端口" class="headerlink" title="指定地址的任意端口"></a>指定地址的任意端口</h3><p>命令格式：IP::containerport</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>还可以使用udp标记来指定udp端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 127.0.0.1::5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure><h2 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h2><p>命令语法：docker port 容id  [port]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker port  4336a2dbe777</span><br><span class="line"></span><br><span class="line">5000/tcp -&gt; 0.0.0.0:32773</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker port  4336a2dbe777 5000</span><br><span class="line"></span><br><span class="line">0.0.0.0:32773</span><br></pre></td></tr></table></figure><h2 id="互联机制实现便捷互访"><a href="#互联机制实现便捷互访" class="headerlink" title="互联机制实现便捷互访"></a>互联机制实现便捷互访</h2><p>容器的互联（link）是一种让多个容器中应用进行快速交互的方式。他会在源和接受容器之间创建连接关系，接受容器可以通过容器名称快速访问到源容器，而不用指定具体的IP地址。</p><h3 id="自定义容器名称"><a href="#自定义容器名称" class="headerlink" title="自定义容器名称"></a>自定义容器名称</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>连接系统通过容器名称来执行，因此需要给每个容器都定义一个名称。</p><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>使用—link参数可以让容器之间安全地进行交互</p><p>link参数格式为：–link name:alias</p><p>docker通过两种方式为容器公开连接信息。</p><ul><li><p>更新环境变量</p></li><li><p>更新/etc/hosts文件。</p></li></ul><p>以下为参考案例：</p><p>首先创建一个新的数据库容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master registry]# docker run -d --name db training/postgres</span><br></pre></td></tr></table></figure><p>创建一个新的web容器，并将它连接到db容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master registry]# docker run -d -P --name web --link db:db training/webapp python app.py</span><br></pre></td></tr></table></figure><p>​                                                 </p><p>查看容器之间的连接信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master registry]# docker run --rm --name web2 --link db:db training/webapp env</span><br></pre></td></tr></table></figure><p>查看hosts信息(cat /etc/hosts)</p><p>可以看到，hosts文件中包含db的信息和自身的配置信息。</p><p>以上都是单机中多容器之间的互联，后续还会涉及跨主机之间的容器通信。</p><h1 id="第8章-使用dockerfile创建镜像"><a href="#第8章-使用dockerfile创建镜像" class="headerlink" title="第8章 使用dockerfile创建镜像"></a>第8章 使用dockerfile创建镜像</h1><h1 id="第9章-docker网络"><a href="#第9章-docker网络" class="headerlink" title="第9章 docker网络"></a>第9章 docker网络</h1><h1 id="镜像仓库之-Harbor"><a href="#镜像仓库之-Harbor" class="headerlink" title="镜像仓库之-Harbor"></a>镜像仓库之-Harbor</h1><p>github主页：<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">https://github.com/goharbor/harbor</a></p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li><p><strong>Role based access control</strong>: Users and repositories are organized via ‘projects’ and a user can have different permission for images under a project.</p><blockquote><p>用户和镜像仓库是通过项目关联起来的，不同用户在该项目下拥有不同的权限</p></blockquote></li><li><p><strong>Policy based image replication</strong>: Images can be replicated (synchronized) between multiple registry instances, with auto-retry on errors. Great for load balancing, high availability, multi-datacenter, hybrid and multi-cloud scenarios.</p><blockquote><p>镜像将在多个注册实例中复制，实现高可用、负载均衡、多路选择等功能</p></blockquote></li><li><p><strong>Vulnerability Scanning</strong>: Harbor scans images regularly and warns users of vulnerabilities.</p><blockquote><p>高危扫描：harbor将会在规律的扫描镜像并且提醒用户相关的危险</p></blockquote></li><li><p><strong>LDAP/AD support</strong>: Harbor integrates with existing enterprise LDAP/AD for user authentication and management.</p><blockquote><p>harbor可以聚合企业现在的LDAP/AD等实现用户认证和管理</p></blockquote></li><li><p><strong>Image deletion &amp; garbage collection</strong>: Images can be deleted and their space can be recycled.</p><blockquote><p>镜像删除和垃圾收集</p></blockquote></li><li><p><strong>Notary</strong>: Image authenticity can be ensured.</p><blockquote><p>可以保证镜像的可靠性</p></blockquote></li><li><p><strong>Graphical user portal</strong>: User can easily browse, search repositories and manage projects.</p><blockquote><p>图形化的用户入口：可以浏览，检索，管理项目</p></blockquote></li><li><p><strong>Auditing</strong>: All the operations to the repositories are tracked.</p><blockquote><p>审计：所有的操作都可以被追踪</p></blockquote></li><li><p><strong>RESTful API</strong>: RESTful APIs for most administrative operations, easy to integrate with external systems.</p><blockquote><p>提供api</p></blockquote></li><li><p><strong>Easy deployment</strong>: Provide both an online and offline installer.</p><blockquote><p>部署简单，提供在线和离线两种安装方式</p></blockquote></li></ul><p>### </p><h2 id="Architecture-体系结构"><a href="#Architecture-体系结构" class="headerlink" title="Architecture-体系结构"></a>Architecture-体系结构</h2><p><img src="https://camo.githubusercontent.com/e0de62fb4f08efedd2c5abd44786410d3af06c7b/687474703a2f2f7777772e7468696e6b2d666f756e6472792e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30392f61727469636c65315f696d616765322e706e67" alt="img"></p><p>As depicted in the above diagram, Harbor comprises 6 components:</p><p><strong>Proxy:</strong> Components of Harbor, such as registry, UI and token services, are all behind a reversed proxy. The proxy forwards requests from browsers and Docker clients to various backend services.</p><blockquote><p>harbor使用代理结构，外部的客户端（浏览器或者docker client）访问调用是通过代理层去实现的</p></blockquote><p><strong>Registry:</strong> Responsible for storing Docker images and processing Docker push/pull commands. As Harbor needs to enforce access control to images, the Registry will direct clients to a token service to obtain a valid token for each pull or push request.</p><blockquote><p>注册部分：响应操作docker镜像的请求</p><p>harbor为了确保安全性，客户端在调用的时候，需要取得valid token才可以进行操作</p></blockquote><p><strong>Core services:</strong> Harbor’s core functions, which mainly provides the following services:</p><p><strong>UI:</strong> a graphical user interface to help users manage images on the Registry Webhook: Webhook is a mechanism configured in the Registry so that image status changes in the Registry can be populated to the Webhook endpoint of Harbor. Harbor uses webhook to update logs, initiate replications, and some other functions. Token service: Responsible for issuing a token for every docker push/pull command according to a user’s role of a project. If there is no token in a request sent from a Docker client, the Registry will redirect the request to the token service. Database: Database stores the meta data of projects, users, roles, replication policies and images.</p><blockquote><p>提供一个图形的用户入口，方便用户在注册钩子系统（registry webhook）中管理镜像。</p></blockquote><p><strong>Job services:</strong> used for image replication, local images can be replicated(synchronized) to other Harbor instances.</p><p><strong>Log collector:</strong> Responsible for collecting logs of other modules in a single place.</p><h2 id="安装配置harbor"><a href="#安装配置harbor" class="headerlink" title="安装配置harbor"></a>安装配置harbor</h2><p>参考文献：<a href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md" target="_blank" rel="noopener">https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md</a></p><h3 id="环境要求："><a href="#环境要求：" class="headerlink" title="环境要求："></a>环境要求：</h3><p>Harbor is deployed as several Docker containers, and, therefore, can be deployed on any Linux distribution that supports Docker. The target host requires Python, Docker, and Docker Compose to be installed.</p><p><strong>Hardware</strong></p><table><thead><tr><th>Resource</th><th>Capacity</th><th>Description</th></tr></thead><tbody><tr><td>CPU</td><td>minimal 2 CPU</td><td>4 CPU is prefered</td></tr><tr><td>Mem</td><td>minimal 4GB</td><td>8GB is prefered</td></tr><tr><td>Disk</td><td>minimal 40GB</td><td>160GB is prefered</td></tr></tbody></table><p><strong>Software</strong></p><table><thead><tr><th>Software</th><th>Version</th><th>Description</th></tr></thead><tbody><tr><td>Python</td><td>version 2.7 or higher</td><td>Note that you may have to install Python on Linux distributions (Gentoo, Arch) that do not come with a Python interpreter installed by default</td></tr><tr><td>Docker engine</td><td>version 1.10 or higher</td><td>For installation instructions, please refer to: <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a></td></tr><tr><td>Docker Compose</td><td>version 1.6.0 or higher</td><td>For installation instructions, please refer to: <a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">https://docs.docker.com/compose/install/</a></td></tr><tr><td>Openssl</td><td>latest is prefered</td><td>Generate certificate and keys for Harbor</td></tr></tbody></table><p><strong>Network ports</strong></p><table><thead><tr><th>Port</th><th>Protocol</th><th>Description</th></tr></thead><tbody><tr><td>443</td><td>HTTPS</td><td>Harbor UI and API will accept requests on this port for https protocol</td></tr><tr><td>4443</td><td>HTTPS</td><td>Connections to the Docker Content Trust service for Harbor, only needed when Notary is enabled</td></tr><tr><td>80</td><td>HTTP</td><td>Harbor UI and API will accept requests on this port for http protocol</td></tr></tbody></table><p>Installation Steps**</p><p>The installation steps boil down to the following</p><ol><li>Download the installer;</li><li>Configure <strong>harbor.cfg</strong>;</li><li>Run <strong>install.sh</strong> to install and start Harbor;</li></ol><p>实际操作：</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar xvf harbor-online-installer-&lt;version&gt;.tgz</span><br></pre></td></tr></table></figure><p>安装docker-ce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils   device-mapper-persistent-data   lvm2</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager     --add-repo     https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><p>启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost tools]# systemctl start  docker</span><br><span class="line">[root@localhost tools]# systemctl enable  docker</span><br></pre></td></tr></table></figure><p>安装Docker Compose</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Configuration parameters are located in the file <strong>harbor.cfg</strong></p><p>There are two categories of parameters in harbor.cfg, <strong>required parameters</strong> and <strong>optional parameters</strong>.</p><ul><li><p><strong>required parameters</strong>: These parameters are required to be set in the configuration file. They will take effect if a user updates them in <code>harbor.cfg</code> and run the <code>install.sh</code> script to reinstall Harbor.</p></li><li><p><strong>optional parameters</strong>: These parameters are optional for updating, i.e. user can leave them as default and update them on Web UI after Harbor is started. If they are set in <code>harbor.cfg</code>, they only take effect in the first launch of Harbor. Subsequent update to these parameters in <code>harbor.cfg</code> will be ignored.</p><p><strong>Note:</strong> If you choose to set these parameters via the UI, be sure to do so right after Harbor is started. In particular, you must set the desired <strong>auth_mode</strong> before registering or creating any new users in Harbor. When there are users in the system (besides the default admin user), <strong>auth_mode</strong> cannot be changed.</p></li></ul><p>配置文件中有2种配置内容，一种是必须配置的参数，一种是可选参数</p><ul><li>可选参数：如果你将可选参数设置在配置文件里面，也可以在安装完毕只有在web UI上进行设置，如果在启动之前配置在配置文件里面，那么当启动之后再在web上修改，那么修改将会是无效的，不会被刷新到配置文件当中。</li><li>可选参数：可以再harbor启动之后，在web界面进行更新，如果这些参数是在在配置文件中的，那么不会即时生效。配置文件中的只会在启动之后生效</li></ul><p>修改完毕之后的配置如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@app028-dev harbor]# less harbor.cfg  | egrep -v &apos;^$|^#&apos;</span><br><span class="line">hostname = dhub-dev.dwbops.com</span><br><span class="line">ui_url_protocol = https</span><br><span class="line">max_job_workers = 3</span><br><span class="line">customize_crt = on</span><br><span class="line">ssl_cert = /data/cert/server.cer</span><br><span class="line">ssl_cert_key = /data/cert/server.key</span><br><span class="line">secretkey_path = /data</span><br><span class="line">admiral_url = NA</span><br><span class="line">log_rotate_count = 50</span><br><span class="line">log_rotate_size = 200M</span><br><span class="line">email_identity =</span><br><span class="line">email_server = smtp.mydomain.com</span><br><span class="line">email_server_port = 25</span><br><span class="line">email_username = sample_admin@mydomain.com</span><br><span class="line">email_password = abc</span><br><span class="line">email_from = admin &lt;sample_admin@mydomain.com&gt;</span><br><span class="line">email_ssl = false</span><br><span class="line">email_insecure = false</span><br><span class="line">harbor_admin_password = dHarbor12345</span><br><span class="line">auth_mode = db_auth</span><br><span class="line">ldap_url = ldaps://ldap.mydomain.com</span><br><span class="line">ldap_basedn = ou=people,dc=mydomain,dc=com</span><br><span class="line">ldap_uid = uid</span><br><span class="line">ldap_scope = 2</span><br><span class="line">ldap_timeout = 5</span><br><span class="line">ldap_verify_cert = true</span><br><span class="line">self_registration = on</span><br><span class="line">token_expiration = 30</span><br><span class="line">project_creation_restriction = everyone</span><br><span class="line">db_host = mysql</span><br><span class="line">db_password = root123</span><br><span class="line">db_port = 3306</span><br><span class="line">db_user = root</span><br><span class="line">redis_url =</span><br><span class="line">clair_db_host = postgres</span><br><span class="line">clair_db_password = password</span><br><span class="line">clair_db_port = 5432</span><br><span class="line">clair_db_username = postgres</span><br><span class="line">clair_db = postgres</span><br><span class="line">uaa_endpoint = uaa.mydomain.org</span><br><span class="line">uaa_clientid = id</span><br><span class="line">uaa_clientsecret = secret</span><br><span class="line">uaa_verify_cert = true</span><br><span class="line">uaa_ca_cert = /path/to/ca.pem</span><br><span class="line">registry_storage_provider_name = filesystem</span><br><span class="line">registry_storage_provider_config =</span><br></pre></td></tr></table></figure><p>自己做测试时，将url类型设置成为http，并且将域名设置成为：harbar.wxh.com</p><p>修改完配置之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./install.sh</span><br></pre></td></tr></table></figure><p>整个的安装过程如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost harbor]# ./install.sh</span><br><span class="line"></span><br><span class="line">[Step 0]: checking installation environment ...</span><br><span class="line"></span><br><span class="line">Note: docker version: 18.06.1</span><br><span class="line"></span><br><span class="line">Note: docker-compose version: 1.22.0</span><br><span class="line"></span><br><span class="line">[Step 1]: loading Harbor images ...</span><br><span class="line">651f69aef02c: Loading layer [==================================================&gt;]  135.8MB/135.8MB</span><br><span class="line">40a1aad64343: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">3fe2713e4072: Loading layer [==================================================&gt;]  12.16MB/12.16MB</span><br><span class="line">ba3a1eb0e375: Loading layer [==================================================&gt;]   17.3MB/17.3MB</span><br><span class="line">447427ec5e1a: Loading layer [==================================================&gt;]  15.87kB/15.87kB</span><br><span class="line">4ccb4026663c: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">16faa95946a1: Loading layer [==================================================&gt;]  29.46MB/29.46MB</span><br><span class="line">Loaded image: vmware/notary-server-photon:v0.5.1-v1.4.0</span><br><span class="line">fa7ba9fd42c9: Loading layer [==================================================&gt;]  10.95MB/10.95MB</span><br><span class="line">4e400f9ae23e: Loading layer [==================================================&gt;]   17.3MB/17.3MB</span><br><span class="line">2802fb27c88b: Loading layer [==================================================&gt;]  15.87kB/15.87kB</span><br><span class="line">e6367a4e1e1e: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">8ece8dfcdd98: Loading layer [==================================================&gt;]  28.24MB/28.24MB</span><br><span class="line">Loaded image: vmware/notary-signer-photon:v0.5.1-v1.4.0</span><br><span class="line">a7dd1a8afcaf: Loading layer [==================================================&gt;]  396.7MB/396.7MB</span><br><span class="line">05adebbe496f: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">86eb534949fa: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">d7f127c69380: Loading layer [==================================================&gt;]   7.68kB/7.68kB</span><br><span class="line">5ac1c4dc5ee9: Loading layer [==================================================&gt;]  1.536kB/1.536kB</span><br><span class="line">d0bec56b5b1a: Loading layer [==================================================&gt;]  9.728kB/9.728kB</span><br><span class="line">4bbe83860556: Loading layer [==================================================&gt;]   2.56kB/2.56kB</span><br><span class="line">e526f9e6769f: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">Loaded image: vmware/harbor-db:v1.4.0</span><br><span class="line">1cff102bbda2: Loading layer [==================================================&gt;]  154.1MB/154.1MB</span><br><span class="line">04c9f3e07de1: Loading layer [==================================================&gt;]  10.75MB/10.75MB</span><br><span class="line">7b6c7bf54f5c: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">42f8acdb7fe3: Loading layer [==================================================&gt;]  48.13kB/48.13kB</span><br><span class="line">5b6299d0a1df: Loading layer [==================================================&gt;]   10.8MB/10.8MB</span><br><span class="line">Loaded image: vmware/clair-photon:v2.0.1-v1.4.0</span><br><span class="line">6534131f457c: Loading layer [==================================================&gt;]  94.76MB/94.76MB</span><br><span class="line">73f582101e4b: Loading layer [==================================================&gt;]  6.656kB/6.656kB</span><br><span class="line">86d847823c48: Loading layer [==================================================&gt;]  6.656kB/6.656kB</span><br><span class="line">Loaded image: vmware/postgresql-photon:v1.4.0</span><br><span class="line">5cd250d5a352: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">ad3fd52b54f3: Loading layer [==================================================&gt;]  14.99MB/14.99MB</span><br><span class="line">13b1e24cc368: Loading layer [==================================================&gt;]  14.99MB/14.99MB</span><br><span class="line">Loaded image: vmware/harbor-adminserver:v1.4.0</span><br><span class="line">c26c69706710: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">223f6fe02cc8: Loading layer [==================================================&gt;]  23.45MB/23.45MB</span><br><span class="line">1fc843c8698a: Loading layer [==================================================&gt;]  7.168kB/7.168kB</span><br><span class="line">e09293610ee7: Loading layer [==================================================&gt;]  10.39MB/10.39MB</span><br><span class="line">d59f9780b1d8: Loading layer [==================================================&gt;]  23.44MB/23.44MB</span><br><span class="line">Loaded image: vmware/harbor-ui:v1.4.0</span><br><span class="line">dd4753242e59: Loading layer [==================================================&gt;]  73.07MB/73.07MB</span><br><span class="line">95aed61ca251: Loading layer [==================================================&gt;]  3.584kB/3.584kB</span><br><span class="line">1864f9818562: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">da2a19f80b81: Loading layer [==================================================&gt;]  4.096kB/4.096kB</span><br><span class="line">058531639e75: Loading layer [==================================================&gt;]  3.584kB/3.584kB</span><br><span class="line">a84e69fb619b: Loading layer [==================================================&gt;]  10.24kB/10.24kB</span><br><span class="line">Loaded image: vmware/harbor-log:v1.4.0</span><br><span class="line">b1056051f246: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">07678065e08b: Loading layer [==================================================&gt;]  19.19MB/19.19MB</span><br><span class="line">a2d9bdb8f5fb: Loading layer [==================================================&gt;]  19.19MB/19.19MB</span><br><span class="line">Loaded image: vmware/harbor-jobservice:v1.4.0</span><br><span class="line">7f58ce57cd5e: Loading layer [==================================================&gt;]  4.805MB/4.805MB</span><br><span class="line">Loaded image: vmware/nginx-photon:v1.4.0</span><br><span class="line">4c8965978b77: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">1466c942edde: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">ac5c17331735: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">86824c7c466a: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">fd3bd0e70d67: Loading layer [==================================================&gt;]   22.8MB/22.8MB</span><br><span class="line">b02195d77636: Loading layer [==================================================&gt;]   22.8MB/22.8MB</span><br><span class="line">Loaded image: vmware/registry-photon:v2.6.2-v1.4.0</span><br><span class="line">Loaded image: vmware/photon:1.0</span><br><span class="line">Loaded image: vmware/mariadb-photon:v1.4.0</span><br><span class="line">454c81edbd3b: Loading layer [==================================================&gt;]  135.2MB/135.2MB</span><br><span class="line">e99db1275091: Loading layer [==================================================&gt;]  395.4MB/395.4MB</span><br><span class="line">051e4ee23882: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">6cca4437b6f6: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">1d48fc08c8bc: Loading layer [==================================================&gt;]   7.68kB/7.68kB</span><br><span class="line">0419724fd942: Loading layer [==================================================&gt;]  1.536kB/1.536kB</span><br><span class="line">526b2156bd7a: Loading layer [==================================================&gt;]  637.8MB/637.8MB</span><br><span class="line">9ebf6900ecbd: Loading layer [==================================================&gt;]  78.34kB/78.34kB</span><br><span class="line">Loaded image: vmware/harbor-db-migrator:1.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Step 2]: preparing environment ...</span><br><span class="line">Generated and saved secret to file: /data/secretkey</span><br><span class="line">Generated configuration file: ./common/config/nginx/nginx.conf</span><br><span class="line">Generated configuration file: ./common/config/adminserver/env</span><br><span class="line">Generated configuration file: ./common/config/ui/env</span><br><span class="line">Generated configuration file: ./common/config/registry/config.yml</span><br><span class="line">Generated configuration file: ./common/config/db/env</span><br><span class="line">Generated configuration file: ./common/config/jobservice/env</span><br><span class="line">Generated configuration file: ./common/config/log/logrotate.conf</span><br><span class="line">Generated configuration file: ./common/config/jobservice/app.conf</span><br><span class="line">Generated configuration file: ./common/config/ui/app.conf</span><br><span class="line">Generated certificate, key file: ./common/config/ui/private_key.pem, cert file: ./common/config/registry/root.crt</span><br><span class="line">The configuration files are ready, please use docker-compose to start the service.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Step 3]: checking existing instance of Harbor ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Step 4]: starting Harbor ...</span><br><span class="line">Creating network &quot;harbor_harbor&quot; with the default driver</span><br><span class="line">Creating harbor-log ... done</span><br><span class="line">Creating harbor-db          ... done</span><br><span class="line">Creating registry           ... done</span><br><span class="line">Creating harbor-adminserver ... done</span><br><span class="line">Creating harbor-ui          ... done</span><br><span class="line">Creating nginx              ... done</span><br><span class="line">Creating harbor-jobservice  ... done</span><br><span class="line"></span><br><span class="line">✔ ----Harbor has been installed and started successfully.----</span><br><span class="line"></span><br><span class="line">Now you should be able to visit the admin portal at http://harbar.wxh.com.</span><br><span class="line">For more details, please visit https://github.com/vmware/harbor .</span><br><span class="line"></span><br><span class="line">[root@localhost harbor]#</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h5 id="Required-parameters"><a href="#Required-parameters" class="headerlink" title="Required parameters:"></a>Required parameters:</h5><ul><li><p><strong>hostname</strong>: The target host’s hostname, which is used to access the UI and the registry service. It should be the IP address or the fully qualified domain name (FQDN) of your target machine, e.g., <code>192.168.1.10</code> or <code>reg.yourdomain.com</code>. <em>Do NOT use localhost or 127.0.0.1 for the hostname - the registry service needs to be accessible by external clients!</em></p><blockquote><p><strong>hostname一般配置为域名</strong>,也就是整个harbor的入口</p></blockquote></li><li><p><strong>ui_url_protocol</strong>: (<strong>http</strong> or <strong>https</strong>. Default is <strong>http</strong>) The protocol used to access the UI and the token/notification service. If Notary is enabled, this parameter has to be <em>https</em>. By default, this is <em>http</em>. To set up the https protocol, refer to <strong>Configuring Harbor with HTTPS Access</strong>.</p><blockquote><p><strong>走HTT还是HTTPS</strong></p></blockquote></li><li><p><strong>db_password</strong>: The root password for the MySQL database used for <strong>db_auth</strong>. <em>Change this password for any production use!</em></p></li><li><p><strong>max_job_workers</strong>: (default value is <strong>3</strong>) The maximum number of replication workers in job service. For each image replication job, a worker synchronizes all tags of a repository to the remote destination. Increasing this number allows more concurrent replication jobs in the system. However, since each worker consumes a certain amount of network/CPU/IO resources, please carefully pick the value of this attribute based on the hardware resource of the host.</p><blockquote><p><strong>做复制工作的进程数量，默认3个，这些进程，将这些镜像同步到远端的存储中</strong></p><p>每个进程都需要消耗系统的资源，因此合理设置数量</p></blockquote></li><li><p><strong>customize_crt</strong>: (<strong>on</strong> or <strong>off</strong>. Default is <strong>on</strong>) When this attribute is <strong>on</strong>, the prepare script creates private key and root certificate for the generation/verification of the registry’s token. Set this attribute to <strong>off</strong> when the key and root certificate are supplied by external sources. Refer to <a href="https://github.com/goharbor/harbor/blob/master/docs/customize_token_service.md" target="_blank" rel="noopener">Customize Key and Certificate of Harbor Token Service</a> for more info.</p></li><li><p><strong>ssl_cert</strong>: The path of SSL certificate, it’s applied only when the protocol is set to https</p></li><li><p><strong>ssl_cert_key</strong>: The path of SSL key, it’s applied only when the protocol is set to https</p></li><li><p><strong>secretkey_path</strong>: The path of key for encrypt or decrypt the password of a remote registry in a replication policy.</p></li><li><p><strong>log_rotate_count</strong>: Log files are rotated <strong>log_rotate_count</strong> times before being removed. If count is 0, old versions are removed rather than rotated.</p></li><li><p><strong>log_rotate_size</strong>: Log files are rotated only if they grow bigger than <strong>log_rotate_size</strong> bytes. If size is followed by k, the size is assumed to be in kilobytes. If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G are all valid.</p></li><li><p><strong>http_proxy</strong>: Config http proxy for Clair, e.g. <code>http://my.proxy.com:3128</code>.</p></li><li><strong>https_proxy</strong>: Config https proxy for Clair, e.g. <code>http://my.proxy.com:3128</code>.</li><li><strong>no_proxy</strong>: Config no proxy for Clair, e.g. <code>127.0.0.1,localhost,core,registry</code>.</li></ul><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><h3 id="上传镜像-1"><a href="#上传镜像-1" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>push的格式为：docker push reg.yourdomain.com/myproject/myrepo:mytag</p><p>注意首先需要登录</p><p>将要上传的镜像打上标志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag hello-world harbar.wxh.com/apps/hello-world</span><br><span class="line"></span><br><span class="line">docker push harbar.wxh.com/apps/hello-world</span><br></pre></td></tr></table></figure><p>这种上传的话，默认是打上latest的标志</p><p>打上指定的标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag hello-world harbar.wxh.com/apps/hello-world:v1</span><br><span class="line">docker push harbar.wxh.com/apps/hello-world:v1</span><br></pre></td></tr></table></figure><h2 id="harbor镜像删除"><a href="#harbor镜像删除" class="headerlink" title="harbor镜像删除"></a>harbor镜像删除</h2><p>在web页面上删除镜像实际上只是执行的软删除，因为镜像存在很强的文件系统依赖关系</p><p>Harbor的UI界面上先删除镜像，但这个操作并没有删除磁盘上存放的镜像文件，只是镜像文件manifest的映射关系，还需要通过GC来删除。</p><p><strong>CAUTION: If both tag A and tag B refer to the same image, after deleting tag A, B will also get deleted. if you enabled content trust, you need to use notary command line tool to delete the tag’s signature before you delete an image.</strong></p><p>注意，如果标签A和B都指向都一个镜像（比如hello-world的2个镜像），那么删除一个之后，另外一个也会消失</p><p>先停止Harbor：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><p>通过带有–dry-run选项，可以<strong>查看</strong>到将要删除的镜像文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name gc --rm --volumes-from registry vmware/registry:2.6.2-photon garbage-collect --dry-run /etc/registry/config.yml1</span><br></pre></td></tr></table></figure><p>不带–dry-run选项，直接<strong>执行删除</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name gc --rm --volumes-from registry vmware/registry:2.6.2-photon garbage-collect /etc/registry/config.yml1</span><br></pre></td></tr></table></figure><p>再启动Harbor：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose start</span><br></pre></td></tr></table></figure><h3 id="使用harbor-go-client"><a href="#使用harbor-go-client" class="headerlink" title="使用harbor-go-client"></a>使用harbor-go-client</h3><p>项目地址：<a href="https://github.com/moooofly/harbor-go-client" target="_blank" rel="noopener">https://github.com/moooofly/harbor-go-client</a></p><p>操作步骤：</p><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/moooofly/harbor-go-client</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>在执行make的时候，可能会存在很多的依赖关系</p><p>有以下依赖关系需要解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/alecthomas/gometalinter</span><br></pre></td></tr></table></figure><h3 id="镜像清理策略"><a href="#镜像清理策略" class="headerlink" title="镜像清理策略"></a>镜像清理策略</h3><p>需求：</p><ul><li><p>暂时不做删除 repo 的处理【这部分手动处理】</p></li><li><p>保留 60 天内创建的所有 tag ，在 60 天之前创建的 tag ，额外保留 10 个；</p></li><li><p>标签数只有 1的镜像，不清理</p></li><li>保留最后一次更新的tag，有些image比较稳定，有可能超过60天都没有修改，但是却一直在用</li><li>针对一些特殊的（比如每天5个tag的镜像，那么60天就有300个），这个单独特殊处理</li></ul><p>最终：</p><ul><li>针对 tag ：保留 60 天内创建的所有 tag ，在 60 天之前创建的 tag ，额外保留 10 个；</li><li>针对 repo ：暂时不做删除 repo 的处理（不太好确定 repo 是否还在使用，理论上讲每个 repo 下至少应该有一个 tag 是被需要的；若打算删除，则建议 repo 负责人自行进行删除操作）；</li><li>私有仓库暂时不做处理；</li></ul><p><strong>具体实现：</strong></p><ul><li>harbor 主要概念的关系：1 个 project -&gt; 每个 project 下具有 N 种不同的 repos &gt; 每个 repo 下具有 M 个 tags</li><li>project 有创建时间，但这个对我们的处理策略来说没有用处；</li><li>repo 有创建时间和 pull 时间，该 pull 时间对应 repo 下任意一个 tag ，最新一次，被拉取的那个时间</li><li>tag 有创建时间，但没有针对 tag 的 pull 时间（harbor 中定义的数据结构中不支持）；</li></ul><p>因此</p><ul><li>保留 60 天内的 tag”，这个根据 tag 的创建时间<ul><li>“60 天之外的看 pull 的数量，关注 60 天之外是不是被 pull 过”，由于 pull 数量是针对 repo 整体的，无法对应到具体的 tag ，即在 API 层面无法方便的知道哪些 tag 最近被 pull 过（当然如果一定要做，就只能沟通分析 log 来搞，性价比不高），所以，只能根据 tag 创建时间的先后，“武断”的认为，后创建的 tag 应该是用户最想保留的；</li></ul></li><li>“如果没有被 pull 过，则只保留最新 5 个 tag”，根据上一条的说明，某个 tag 是否被 pull 过是无法知道的，但目前可以做到根据 tag 的创建时间进行保留（满足保留最新 N 个需求）；</li></ul><h2 id="harbor镜像复制"><a href="#harbor镜像复制" class="headerlink" title="harbor镜像复制"></a>harbor镜像复制</h2><p>参考链接：<a href="https://github.com/goharbor/harbor/blob/master/docs/user_guide.md" target="_blank" rel="noopener">https://github.com/goharbor/harbor/blob/master/docs/user_guide.md</a></p><p>该功能是面向项目的，系统管理员设置之后，匹配了过滤规则的项目，在触发了事先定义好的触发条件之后，这些项目就会被复制到远程的另一个仓库中。</p><p>如果在远程镜像仓库中，改项目不存在，那么就会自动创建这个项目</p><p>如果在远程仓库中，这个项目已经存在，并且配置的用户对这个项目没有写的权限，那么这个操作将会失败</p><p>注意：用户信息不会被复制</p><p>因为网络的原因，在复制传输的过程中，可能会出现一些延迟。如果复制job是因为网络原因而导致失败的，那么这个任务将会在几分钟之后再次尝试，一直尝试，知道网络恢复正常。</p><p>注意：因为api等原因，不同版本的镜像复制可能会失败，所以尽量使用同一个版本。</p><h3 id="创建复制规则"><a href="#创建复制规则" class="headerlink" title="创建复制规则"></a>创建复制规则</h3><p>Click <code>NEW REPLICATION RULE</code> under <code>Administration-&gt;Replications</code></p><p>注意，在创建endpoint的时候，直接test connection是会报错：“harbor Failed to ping endpoint”</p><p>这是因为网络问题导致，在内网访问的时候，还需要额外的添加hosts文件，详见注意事项</p><p>注意：在创建完毕之后，默认不会执行同步，需要手动点击一下replication</p><h3 id="删除replication规则"><a href="#删除replication规则" class="headerlink" title="删除replication规则"></a>删除replication规则</h3><p>Only rules which have no pending/running/retrying jobs can be deleted.</p><p>只有当改规则下面没有正在运行或者等待运行或者正在重传的jobs时，才可以删除</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在创建endpoint的时候，如果事先没有再容器内存配置对端的地址，那么会报连接错误</p><p>官方的issues：<a href="https://github.com/goharbor/harbor/issues/2221" target="_blank" rel="noopener">https://github.com/goharbor/harbor/issues/2221</a></p><h2 id="Harborclient"><a href="#Harborclient" class="headerlink" title="Harborclient"></a>Harborclient</h2><p>详见页面：<a href="https://github.com/int32bit/python-harborclient/blob/master/README.zh.md" target="_blank" rel="noopener">https://github.com/int32bit/python-harborclient/blob/master/README.zh.md</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>1&gt; Why can not push image 192.168.0.1/hello-world:latest to Harbor?</p><p>[<strong>A</strong>] At least two namespaces are needed for repository name in Harbor, so tag the image as 192.168.0.1/project_name/hello-world:latest should fix this. (Create the project on the web page first)</p><p>也就是说，在上传镜像的时候，应该是下面这种格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.0.1/project_name/hello-world:latest</span><br></pre></td></tr></table></figure><p>因为在harbor中有项目的概念，也就是：访问地址/项目名称/镜像名称/版本标签</p><p>在使用dockerhub等进行镜像仓库的时候，用户名/id就是项目名称，因此不能创建多个项目名称，因为这种方式适合个人，但是不适用于企业。</p><p>企业中需要根据不同的项目类型进行分类存储，例如：apps、中间件等</p><h3 id="证书问题"><a href="#证书问题" class="headerlink" title="证书问题"></a>证书问题</h3><p>证书生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -sha256 -x509 -days 365 -nodes -newkey rsa:4096 -keyout  harbar.wxh.com.key -out harbar.wxh.com.crt</span><br></pre></td></tr></table></figure><p>注意，一些name的字段要配置成为域名harbar.wxh.com</p><p>生成之后，将证书存放到指定位置，然后修改配置文件指向这些证书文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">less harbor.cfg  | egrep -v &quot;^$|^#&quot;</span><br><span class="line">ssl_cert = /data/cert/harbar.wxh.com.crt</span><br><span class="line">ssl_cert_key = /data/cert/harbar.wxh.com.key</span><br></pre></td></tr></table></figure><p>然后需要对docker进行一些配置</p><p>mkdir -p /etc/docker/certs.d/harbar.wxh.com</p><p>然后将上面的文件复制到这个目录之下，并将/data/cert/harbar.wxh.com.crt重命名为/data/cert/harbar.wxh.com.cert</p><h2 id="文件创建为目录问题"><a href="#文件创建为目录问题" class="headerlink" title="文件创建为目录问题"></a>文件创建为目录问题</h2><p>/data1/harbor/data/secretkey  </p><p>secretkey为文件，而不是目录，在一些时候可能会出现这种问题，当出现这种问题的时候，将该目录清空，然后重新安装即可</p><h1 id="汇总-docker常用命令"><a href="#汇总-docker常用命令" class="headerlink" title="汇总-docker常用命令"></a>汇总-docker常用命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyname .  # Create image using this directory&apos;s Dockerfile</span><br><span class="line">docker run -p 4000:80 friendlyname  # Run &quot;friendlyname&quot; mapping port 4000 to 80</span><br><span class="line">docker run -d -p 4000:80 friendlyname         # Same thing, but in detached mode</span><br><span class="line">docker container ls                                # List all running containers</span><br><span class="line">docker container ls -a             # List all containers, even those not running</span><br><span class="line">docker container stop &lt;hash&gt;           # Gracefully stop the specified container</span><br><span class="line">docker container kill &lt;hash&gt;         # Force shutdown of the specified container</span><br><span class="line">docker container rm &lt;hash&gt;        # Remove specified container from this machine</span><br><span class="line">docker container rm $(docker container ls -a -q)         # Remove all containers</span><br><span class="line">docker image ls -a                             # List all images on this machine</span><br><span class="line">docker image rm &lt;image id&gt;            # Remove specified image from this machine</span><br><span class="line">docker image rm $(docker image ls -a -q)   # Remove all images from this machine</span><br><span class="line">docker login             # Log in this CLI session using your Docker credentials</span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  # Tag &lt;image&gt; for upload to registry</span><br><span class="line">docker push username/repository:tag            # Upload tagged image to registry</span><br><span class="line">docker run username/repository:tag                   # Run image from a registry</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Docker入门与实践
    
    </summary>
    
      <category term="IT科学技术知识体系结构-Linux运维方向" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/"/>
    
      <category term="虚拟化" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Docker+k8s" scheme="http://yoursite.com/categories/IT%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Linux%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker-k8s/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>day06-面向对象编程</title>
    <link href="http://yoursite.com/2018/08/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/day06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/20/编程语言/Python/老男孩视频学习笔记/day06-面向对象编程/</id>
    <published>2018-08-20T12:58:43.000Z</published>
    <updated>2018-08-20T12:58:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向过程-VS-面向对象"><a href="#面向过程-VS-面向对象" class="headerlink" title="面向过程 VS 面向对象"></a>面向过程 VS 面向对象</h1><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a><strong>编程范式</strong></h2><p>编程是 程序 员 用特定的<strong>语法+数据结构+算法</strong>组成的代码来告诉计算机如何执行任务的过程 （算法：其实就是解决一些问题的套路</p><p>一个程序是程序员为了得到一个任务结果而编写的一组指令的集合</p><p>正所谓条条大路通罗马，实现一个任务的方式有很多种不同的方式， 对这些不同的编程方式的特点进行归纳总结得出来的编程方式类别，即为编程范式。</p><p>不同的编程范式本质上代表对各种类型的任务采取的不同的解决问题的思路， 大多数语言只支持一种编程范式，当然也有些语言可以同时支持多种编程范式。 两种最重要的编程范式分别是面向过程编程和面向对象编程。</p><p>范式可以理解为某一个行业的标准，例如羽毛球中的标准动作（挥拍，高远球，走位等），基本上已经达成了统一的标准，那么编程也是一样的，目前已经想成了两种标准，分别适用于两种不同的应用场景，也可以理解为两套羽毛球标准，分别适用于不同的应用场景当中。</p><h2 id="面向过程编程-Procedural-Programming"><a href="#面向过程编程-Procedural-Programming" class="headerlink" title="面向过程编程(Procedural Programming)"></a><strong>面向过程编程(Procedural Programming)</strong></h2><p>Procedural programming uses a list of instructions to tell the computer what to do step-by-step. </p><p>面向过程编程，使用一系列的指令来告诉计算机一步一步的去做什么操作</p><p>面向过程编程依赖 - 你猜到了- procedures，一个procedure包含一组要被进行计算的步骤， 面向过程又被称为top-down languages， 就是程序从上到下一步步执行，一步步从上到下，从头到尾的解决问题 。</p><p><strong>核心思想：基本设计思路就是程序一开始是要着手解决一个大的问题，然后把一个大问题分解成很多个小问题或子过程，这些子过程再执行的过程再继续分解直到小问题足够简单到可以在一个小步骤范围内解决。</strong></p><p>举个典型的面向过程的例子， 数据库备份， 分三步，连接数据库，备份数据库，测试备份文件可用性。</p><p>这样做的问题也是显而易见的，就是如果你要对程序进行修改，对你修改的那部分有依赖的各个部分你都也要跟着修改，举个例子，如果程序开头你设置了一个变量值 为1 ， 但如果其它子过程依赖这个值 为1的变量才能正常运行，那如果你改了这个变量，那这个子过程你也要修改，假如又有一个其它子程序依赖这个子过程 ， 那就会发生一连串的影响，随着程序越来越大， 这种编程方式的维护难度会越来越高。  所以我们一般认为， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程的方式是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护 的， 那还是用面向对象最方便了。</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>OOP编程是利用“类”和“对象”来创建各种模型来实现对真实世界的描述，使用面向对象编程的原因一方面是因为它可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使它人更加容易理解你的代码逻辑，从而使团队开发变得更从容。</p><p>面向对象的几个核心特性如下</p><h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a><strong>Class 类</strong></h3><p>一个类即是对一类拥有相同属性的对象的抽象、蓝图、原型。在类中定义了这些对象的都具备的属性（variables(data)）、共同的方法</p><p>世间万物，皆可分类！</p><p>世间万物，皆为对象！</p><h3 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a><strong>Object 对象</strong></h3><p>一个对象即是一个类的实例化后实例，一个类必须经过实例化后方可在程序中调用，一个类可以实例化多个对象，每个对象亦可以有不同的属性，就像人类是指所有人，每个人是指具体的对象，人与人之前有共性，亦有不同</p><h3 id="Encapsulation-封装"><a href="#Encapsulation-封装" class="headerlink" title="Encapsulation 封装"></a><strong>Encapsulation 封装</strong></h3><p>在类中对数据的赋值、内部调用对外部用户是透明的，这使类变成了一个胶囊或容器，里面包含着类的数据和方法</p><p>例如，可以把类的方法都封装起来，内部的代码不会被暴露在外部，而是隐藏起来，只需要调用即可使用该功能</p><h3 id="Inheritance-继承"><a href="#Inheritance-继承" class="headerlink" title="Inheritance 继承"></a><strong>Inheritance 继承</strong></h3><p>一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承</p><h3 id="Polymorphism-多态"><a href="#Polymorphism-多态" class="headerlink" title="Polymorphism 多态"></a><strong>Polymorphism 多态</strong></h3><p>多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，指一个基类中派生出了不同的子类，且每个子类在继承了同样的方法名的同时又<strong>对父类的方法做了不同的实现</strong>，这就是同一种事物表现出的多种形态。</p><p>编程其实就是一个将具体世界进行抽象化的过程，多态就是抽象化的一种体现，把一系列具体事物的共同点抽象出来, 再通过这个抽象的事物, 与不同的具体事物进行对话。<br>对不同类的对象发出相同的消息将会有不同的行为。比如，你的老板让所有员工在九点钟开始工作, 他只要在九点钟的时候说：“开始工作”即可，而不需要对销售人员说：“开始销售工作”，对技术人员说：“开始技术工作”, 因为“员工”是一个抽象的事物, 只要是员工就可以开始工作，他知道这一点就行了。至于每个员工，当然会各司其职，做各自的工作。</p><p>在这里，工作就相当于父类的方法，而子类继承了之后，针对这个方法，会有不同的实现方式。 相当于是同一个东西，表面上是明确的不变，但是内部是不断在变化的。</p><p>多态允许将子类的对象当作父类的对象使用，某父类型的引用指向其子类型的对象,调用的方法是该子类型的方法。这里引用和调用方法的代码编译前就已经决定了,而引用所指向的对象可以在运行期间动态绑定</p><p>封装、继承、多态是面向对象的3个特性</p><h1 id="面向对象编程-Object-Oriented-Programming-介绍"><a href="#面向对象编程-Object-Oriented-Programming-介绍" class="headerlink" title="面向对象编程(Object-Oriented Programming )介绍"></a>面向对象编程(<strong>Object-Oriented Programming</strong> )介绍</h1><p>对于编程语言的初学者来讲，OOP不是一个很容易理解的编程方式，大家虽然都按老师讲的都知道OOP的三大特性是继承、封装、多态，并且大家也都知道了如何定义类、方法等面向对象的常用语法，但是一到真正写程序的时候，还是很多人喜欢用函数式编程来写代码，特别是初学者，很容易陷入一个窘境就是“我知道面向对象，我也会写类，但我依然没发现在使用了面向对象后，对我们的程序开发效率或其它方面带来什么好处，因为我使用函数编程就可以减少重复代码并做到程序可扩展了，为啥子还用面向对象？”。 对于此，我个人觉得原因应该还是因为你没有充分了解到面向对象能带来的好处，今天我就写一篇关于面向对象的入门文章，希望能帮大家更好的理解和使用面向对象编程。  </p><p>无论用什么形式来编程，我们都要明确记住以下原则：</p><ol><li><strong>写重复代码是非常不好的低级行为</strong></li><li><strong>你写的代码需要经常变更</strong> </li></ol><p>开发正规的程序跟那种写个运行一次就扔了的小脚本一个很大不同就是，你的代码总是需要不断的更改，不是修改bug就是添加新功能等，所以为了日后方便程序的修改及扩展，你写的代码一定要遵循易读、易改的原则（专业数据叫可读性好、易扩展）。</p><p>如果你把一段同样的代码复制、粘贴到了程序的多个地方以实现在程序的各个地方调用 这个功能，那日后你再对这个功能进行修改时，就需要把程序里多个地方都改一遍，这种写程序的方式是有问题的，因为如果你不小心漏掉了一个地方没改，那可能会导致整个程序的运行都 出问题。 因此我们知道 在开发中一定要努力避免写重复的代码，否则就相当于给自己再挖坑。</p><p>还好，函数的出现就能帮我们轻松的解决重复代码的问题，对于需要重复调用的功能，只需要把它写成一个函数，然后在程序的各个地方直接调用这个函数名就好了，并且当需要修改这个功能时，只需改函数代码，然后整个程序就都更新了。</p><p>其实OOP编程的主要作用也是使你的代码修改和扩展变的更容易，那么小白要问了，既然函数都能实现这个需求了，还要OOP干毛线用呢？ 呵呵，说这话就像，古时候，人们打仗杀人都用刀，后来出来了枪，它的主要功能跟刀一样，也是杀人，然后小白就问，既然刀能杀人了，那还要枪干毛线，哈哈，显而易见，因为枪能更好更快更容易的杀人。函数编程与OOP的主要区别就是OOP可以使程序更加容易扩展和易更改。</p><h2 id="init-和self"><a href="#init-和self" class="headerlink" title="__init__和self"></a><code>__init__</code>和self</h2><p>类的写法是下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    def __init__(self,name,type):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line"></span><br><span class="line">    def sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog1 = Dog(&apos;wxh&apos;,&apos;二哈&apos;)</span><br><span class="line"></span><br><span class="line">dog1.sayhi()</span><br></pre></td></tr></table></figure><p><strong>其实self,就是实例本身！你实例化时python会自动把这个实例本身通过self参数传进去。</strong></p><p>上面的这个<strong>init</strong>()叫做<strong>初始化方法(或构造方法)</strong>， 在类被调用时，这个方法(虽然它是函数形式，但在类中就不叫函数了,叫方法)会自动执行，进行一些初始化的动作<br>我们这里写<code>__init__</code>(self,name,role,weapon,life_value=100,money=15000)就是要在创建一个角色时给它设置这些属性，那么这第一个参数self是干毛用的呢？ </p><p>初始化一只狗，就需要调用这个类一次： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`r1 ``=` `Role(``&apos;Alex&apos;``,``&apos;police&apos;``,&apos;AK47’) ``#生成一个角色 , 会自动把参数传给Role下面的__init__(...)方法``r2 ``=` `Role(``&apos;Jack&apos;``,``&apos;terrorist&apos;``,&apos;B22’)  ``#生成一个角色`</span><br></pre></td></tr></table></figure><p>我们看到，上面的创建角色时，我们并没有给<code>__init__</code>传值，程序也没未报错，是因为，类在调用它自己的<strong>init</strong>(…)时自己帮你给self参数赋值了， </p><p>我们再来定义一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Role(object): #定义一个类， class是定义类的语法，Role是类名，(object)是新式类的写法，必须这样写，以后再讲为什么</span><br><span class="line">    def __init__(self,name,role,weapon,life_value=100,money=15000): #初始化函数，在生成一个角色时要初始化的一些属性就填写在这里</span><br><span class="line">        self.name = name #__init__中的第一个参数self,和这里的self都 是什么意思？ 看下面解释</span><br><span class="line">        self.role = role</span><br><span class="line">        self.weapon = weapon</span><br><span class="line">        self.life_value = life_value</span><br><span class="line">        self.money = money</span><br><span class="line">    def buy_gun(self,gun_name):</span><br><span class="line">        print(“%s has just bought %s” %(self.name,gun_name) )</span><br></pre></td></tr></table></figure><p>当执行r1 = Role(‘Alex’,’police’,’AK47<strong>’</strong>)创建一个对象时，python的解释器其实干了两件事：</p><ol><li>在内存中开辟一块空间指向r1这个变量名</li><li>调用Role这个类并执行其中的<code>__init__</code>(…)方法，相当于Role.<code>__init__</code>(r1,’Alex’,’police’,AK47’),这么做是为什么呢？ 是为了把’Alex’,’police’,’AK47’这3个值跟刚开辟的r1关联起来，是为了把’Alex’,’police’,’AK47’这3个值跟刚开辟的r1关联起来，是为了把’Alex’,’police’,’AK47’这3个值跟刚开辟的r1关联起来，重要的事情说3次， 因为关联起来后，你就可以直接r1.name, r1.weapon 这样来调用啦。所以，为实现这种关联，在调用<code>__init__</code>方法时，就必须把r1这个变量也传进去，否则<code>__init__</code>不知道要把那3个参数跟谁关联呀。</li><li>所以这个<code>__init__</code>(…)方法里的，self.name = name , self.role = role 等等的意思就是要把这几个值 存到r1的内存空间里。</li></ol><p><code>__init__(…)</code>基本懂了，但后面的那几个函数，噢 不对，后面那几个方法 为什么也还需要self参数么？ 不是在初始化角色的时候 ，就已经把角色的属性跟r1绑定好了么？ </p><p>上面这个方法通过类调用的话要写成如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`r1 ``=` `Role(``&apos;Alex&apos;``,``&apos;police&apos;``,``&apos;AK47&apos;``)``r1.buy_gun(``&quot;B21”) #python 会自动帮你转成 Role.buy_gun(r1,”B21&quot;``)`</span><br></pre></td></tr></table></figure><p>执行结果</p><p>#Alex has just bought B21 </p><p>我们依然没给self传值 ，但Python还是会自动的帮你把r1 赋值给self这个参数， 为什么呢？ 因为，你在buy_gun(..)方法中可能要访问r1的一些其它属性呀， 比如这里就访问 了r1的名字，怎么访问呢？你得告诉这个方法呀，于是就把r1传给了这个self参数，然后在buy_gun里调用 self.name 就相当于调用r1.name 啦，如果还想知道r1的生命值 有多少，直接写成self.life_value就可以了。 说白了就是在调用类中的一个方法时，你得告诉人家你是谁。</p><p>好啦， 总结一下2点：</p><ol><li>上面的这个r1 = Role(‘Alex’,’police’,’AK47<strong>’</strong>)动作，叫做类的“实例化”， 就是把一个虚拟的抽象的类，通过这个动作，变成了一个具体的对象了， 这个对象就叫做实例</li><li>刚才定义的这个类体现了面向对象的第一个基本特性，封装，<strong>其实就是使用构造方法将内容封装到某个具体对象中，然后通过对象直接或者self间接获取被封装的内容</strong></li></ol><h1 id="父类继承object的原因"><a href="#父类继承object的原因" class="headerlink" title="父类继承object的原因"></a>父类继承object的原因</h1><p>引用知乎，链接：<a href="https://www.zhihu.com/question/19754936/answer/202650790" target="_blank" rel="noopener">https://www.zhihu.com/question/19754936/answer/202650790</a></p><p>继承 object 类的是新式类，不继承 object 类的是经典类，在 Python 2.7 里面新式类和经典类在多继承方面会有差异：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def foo(self):</span><br><span class="line">        print(&apos;called A.foo()&apos;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class C(A):</span><br><span class="line">    def foo(self):</span><br><span class="line">        print(&apos;called C.foo()&apos;)</span><br><span class="line"></span><br><span class="line">class D(B, C): </span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    d = D() </span><br><span class="line">    d.foo()</span><br></pre></td></tr></table></figure><p>B、C 是 A 的子类，D 多继承了 B、C 两个类，其中 C 重写了 A 中的 foo() 方法。</p><p>如果 A 是经典类（如上代码），当调用 D 的实例的 foo() 方法时，Python 会按照深度优先的方法去搜索 foo() ，路径是 B-A-C ，执行的是 A 中的 foo() ；</p><p>如果 A 是新式类，当调用 D 的实例的 foo() 方法时，Python 会按照广度优先的方法去搜索 foo() ，路径是 B-C-A ，执行的是 C 中的 foo() 。</p><p>因为 D 是直接继承 C 的，从逻辑上说，执行 C 中的 foo() 更加合理，因此新式类对多继承的处理更为合乎逻辑。</p><p>在 Python 3.x 中的新式类貌似已经兼容了经典类，无论 A 是否继承 object 类， D 实例中的 foo() 都会执行 C 中的 foo() 。但是在 Python 2.7 中这种差异仍然存在，因此还是推荐使用新式类，要继承 object 类。</p><h1 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class animal(object):</span><br><span class="line">    n = &quot;dff&quot;</span><br><span class="line">    def __init__(self,name,type):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line"></span><br><span class="line">    def sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line">    def talk(self):</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = animal(&quot;wxh&quot;,&quot;二哈&quot;)</span><br><span class="line">print (animal.n)</span><br><span class="line">print (a1.n,a1.name)</span><br><span class="line">执行后输出为：</span><br><span class="line">dff</span><br><span class="line">dff wxh</span><br></pre></td></tr></table></figure><p>注意：如果类变量和实例变量的名称一致，那么生效的是实例变量，也就是局部生效</p><p>类变量：所有实例共用的属性，节省开销</p><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>作用：在实例/对象释放、销毁的时候自动执行的，通常用于一些收尾工作，例如关闭一些数据库连接，关闭打开的临时文件。</p><p>注意：不是在实例/对象结束的时候执行，而是在释放或者销毁的时候自动执行，通过下方的代码可以看出效果</p><p>书写格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class animal(object):</span><br><span class="line">    name = &quot;dff&quot;</span><br><span class="line">    def __init__(self,name,type):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line"></span><br><span class="line">    def sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line">    def talk(self):</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;析构函数&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = animal(&quot;wxh&quot;,&quot;二哈&quot;)</span><br><span class="line">a2 = animal(&quot;wxg&quot;,&quot;金毛&quot;)</span><br><span class="line">print (animal.name)</span><br><span class="line">print (a1.name)</span><br><span class="line">print(a2.name)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dff</span><br><span class="line">wxh</span><br><span class="line">wxg</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br></pre></td></tr></table></figure><p>手动的删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class animal(object):</span><br><span class="line">    name = &quot;dff&quot;</span><br><span class="line">    def __init__(self,name,type):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line"></span><br><span class="line">    def sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line">    def talk(self):</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;析构函数&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = animal(&quot;wxh&quot;,&quot;二哈&quot;)</span><br><span class="line">a2 = animal(&quot;wxg&quot;,&quot;金毛&quot;)</span><br><span class="line">print (animal.name)</span><br><span class="line">print (a1.name)</span><br><span class="line">del a1</span><br><span class="line">print(a2.name)</span><br></pre></td></tr></table></figure><p>这种情况下执行后的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dff</span><br><span class="line">wxh</span><br><span class="line">析构函数</span><br><span class="line">wxg</span><br><span class="line">析构函数</span><br></pre></td></tr></table></figure><h1 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h1><p>在构造方法中定义的私有属性，直接调用获取是不行的，要想使用的话，需要在定义一个方法，在内部进行访问之后，再将值返回出去。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class animal(object):</span><br><span class="line">    name = &quot;dff&quot;</span><br><span class="line">    def __init__(self,name,type,attr):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line">        self.__private_att = attr</span><br><span class="line"></span><br><span class="line">    def sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line">    def talk(self):</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;析构函数&quot;)</span><br><span class="line"></span><br><span class="line">    def show_pri(self):</span><br><span class="line">        print (&quot;the private attr is &#123;private&#125;&quot;.format(private=self.__private_att))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = animal(&quot;wxh&quot;,&quot;二哈&quot;,&quot;pri_test&quot;)</span><br><span class="line">print (a1.name)</span><br><span class="line">a1.show_pri()</span><br><span class="line">print (a1.__private_att)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wxh</span><br><span class="line">the private attr is pri_test</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">析构函数</span><br><span class="line">  File &quot;/Users/wangxiaohua/PycharmProjects/python14/day06/classtest.py&quot;, line 23, in &lt;module&gt;</span><br><span class="line">    print (a1.__private_att)</span><br><span class="line">AttributeError: &apos;animal&apos; object has no attribute &apos;__private_att&apos;</span><br></pre></td></tr></table></figure><p>可以看到，我们使用定义的这个方法去调用是不会报错的，但是直接显示该对象的私有属性的时候，是无法显示的。</p><h1 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h1><p>私有方法和私有属性也是一样的，在定义的是前面加上<strong>__</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class animal(object):</span><br><span class="line">    name = &quot;dff&quot;</span><br><span class="line">    def __init__(self,name,type,attr):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type = type</span><br><span class="line">        self.__private_att = attr</span><br><span class="line"></span><br><span class="line">    def __sayhi(self):</span><br><span class="line">        print (&quot;hello, I am a dog,my name is &#123;name&#125;&quot;.format(name=self.name))</span><br><span class="line"></span><br><span class="line">    def talk(self):</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;析构函数&quot;)</span><br><span class="line"></span><br><span class="line">    def show_pri(self):</span><br><span class="line">        print (&quot;the private attr is &#123;private&#125;&quot;.format(private=self.__private_att))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = animal(&quot;wxh&quot;,&quot;二哈&quot;,&quot;pri_test&quot;)</span><br><span class="line">print (a1.name)</span><br><span class="line">a1.show_pri()</span><br><span class="line">a1.__sayhi()</span><br></pre></td></tr></table></figure><p>执行后输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wxh</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">the private attr is pri_test</span><br><span class="line">  File &quot;/Users/wangxiaohua/PycharmProjects/python14/day06/classtest.py&quot;, line 24, in &lt;module&gt;</span><br><span class="line">析构函数</span><br><span class="line">    a1.__sayhi()</span><br><span class="line">AttributeError: &apos;animal&apos; object has no attribute &apos;__sayhi&apos;</span><br></pre></td></tr></table></figure><h1 id="子类继承"><a href="#子类继承" class="headerlink" title="子类继承"></a>子类继承</h1><h2 id="保留父类属性"><a href="#保留父类属性" class="headerlink" title="保留父类属性"></a>保留父类属性</h2><p>在继承之后，可以在子类中将父类的方法进行重构，但是重构的话，父类原有的动作就不会保留，那么，当我们需要保留父类的内容，也就是说子类是添加操作，在调用的时候，先执行父类的代码，再执行子类的代码，那么这种方式应该如何实现？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class People(object):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;&#123;name&#125; is eating&quot;.format(name=self.name))</span><br><span class="line">    def age(self):</span><br><span class="line">        print(&quot;&#123;name&#125; is &#123;age&#125; years old&quot;.format(name=self.name,age=self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Man(People):</span><br><span class="line">    def eat(self):</span><br><span class="line">        People.eat(self)</span><br><span class="line">        print(&quot;subclass content&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">man1 = Man(&quot;wxh&quot;,11)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">man1.eat()</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wxh is eating</span><br><span class="line">subclass content</span><br></pre></td></tr></table></figure><p>默认情况下，我们不做任何修改的话，就会继承父类的属性</p><h2 id="子类添加私有属性"><a href="#子类添加私有属性" class="headerlink" title="子类添加私有属性"></a>子类添加私有属性</h2><p>在继承父类的之后，如果想要添加自己的属性，那么需要使用下面的这种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class People(object):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;&#123;name&#125; is eating&quot;.format(name=self.name))</span><br><span class="line">    def age(self):</span><br><span class="line">        print(&quot;&#123;name&#125; is &#123;age&#125; years old&quot;.format(name=self.name,age=self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Man(People):</span><br><span class="line">    def __init__(self,name,age,money):</span><br><span class="line">        People.__init__(self,name,age)</span><br><span class="line">        self.money = money</span><br><span class="line">        print (&quot;&#123;name&#125; has &#123;money&#125;$&quot;.format(name=self.name,money=self.money))</span><br><span class="line">    def eat(self):</span><br><span class="line">        People.eat(self)</span><br><span class="line">        print(&quot;subclass content&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">man1 = Man(&quot;wxh&quot;,11,&quot;1000&quot;)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wxh has 1000 $</span><br></pre></td></tr></table></figure><p>可以知道，这个输出并没有调用什么方法，而是子类的构造函数（<code>__init__</code>）输出的</p><p>说明：</p><ul><li>因为是完全覆盖的父类，因此需要把父类的参数全部写一遍</li><li><p>然后再调用父类的方法</p></li><li><p>在子类中重新编写构造方法，注意在定义的时候，父类的属性还是要保留，不能直接覆盖，因为在后续使用的时候，实例化这个子类之后，如果还需要调用父类的属性的时候，还需要有这个属性</p></li><li><p>子类的构造方法中需要需要再调用父类的构造方法（因为父类的构造方法中可能会比较复杂，所有采取直接调用的方式），注意，传入的参数是子类在最外层继承父类的，需要保持一致</p></li><li>调用了父类的构造方法之后，再在下方定义子类的属性</li></ul><p>父类的继承还有另外一种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">People.__init__(self,name,age)</span><br><span class="line">可以写成</span><br><span class="line">super(Man,self).__init__(name,age)</span><br></pre></td></tr></table></figure><p>super是一种内置的方法</p><p>使用这种方式的话，之后如果父类的名称修改了，那么只需要在继承的括号中修改，函数体中不需要再修改。</p><p>但是在涉及到继承多个类的时候，并且父类的属性不同时，这种方式就比不是太友好</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class People(object):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;&#123;name&#125; is eating&quot;.format(name=self.name))</span><br><span class="line">    def age(self):</span><br><span class="line">        print(&quot;&#123;name&#125; is &#123;age&#125; years old&quot;.format(name=self.name,age=self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Relation(object):</span><br><span class="line">    def makefriend(self,object):</span><br><span class="line">        print (&quot;&#123;name1&#125; is make friend with &#123;name2&#125;&quot;.format(name1=self.name,name2=object.name))</span><br><span class="line"></span><br><span class="line">class Man(People,Relation):</span><br><span class="line">    def __init__(self,name,age,money):</span><br><span class="line">        # People.__init__(self,name,age)</span><br><span class="line">        super(Man,self).__init__(name,age)</span><br><span class="line"></span><br><span class="line">        self.money = money</span><br><span class="line">        # print (&quot;&#123;name&#125; has &#123;money&#125;$&quot;.format(name=self.name,money=self.money))</span><br><span class="line">    def eat(self):</span><br><span class="line">        People.eat(self)</span><br><span class="line">        print(&quot;subclass content&quot;)</span><br><span class="line"></span><br><span class="line">class Woman(People,Relation):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        People.__init__(self,name,age)</span><br><span class="line">    def get_birth(self):</span><br><span class="line">        print (&quot;&#123;name&#125; git_birth&quot;.format(name=self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">man1 = Man(&quot;wxh&quot;,11,&quot;1000&quot;)</span><br><span class="line"></span><br><span class="line">women1 = Woman(&quot;xxx&quot;,11)</span><br></pre></td></tr></table></figure><p>执行后输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wxh is make friend with xxx</span><br></pre></td></tr></table></figure><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态特性：一种接口，多种实现</p><p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p><p>那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。</p><p>Pyhon 很多语法都是支持多态的，比如 len(),sorted(), 你给len传字符串就返回字符串的长度，传列表就返回列表长度。</p><p>Python多态示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Animal(object):</span><br><span class="line">    def __init__(self, name):  # Constructor of the class</span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line">    def talk(self):              # Abstract method, defined by convention only</span><br><span class="line">        raise NotImplementedError(&quot;Subclass must implement abstract method&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def talk(self):</span><br><span class="line">        print(&apos;%s: 喵喵喵!&apos; %self.name)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def talk(self):</span><br><span class="line">        print(&apos;%s: 汪！汪！汪！&apos; %self.name)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def func(obj): #一个接口，多种形态</span><br><span class="line">    obj.talk()</span><br><span class="line"> </span><br><span class="line">c1 = Cat(&apos;小晴&apos;)</span><br><span class="line">d1 = Dog(&apos;李磊&apos;)</span><br><span class="line"> </span><br><span class="line">func(c1)</span><br><span class="line">func(d1)</span><br></pre></td></tr></table></figure><p>简单的说，多态其实就是子类重新实现父类的方法，实现接口的重用，然后通过重新定义一个接口去匹配调用</p><p>最终，我们要把这个函数放置到父类当中</p><p>然后通过下面的方式去调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man1 = Man(&quot;wxh&quot;,11,&quot;1000&quot;)</span><br><span class="line">People.people_eat(man1)</span><br></pre></td></tr></table></figure><h1 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h1><p>很多同学都是学会了面向对象的语法，却依然写不出面向对象的程序，原因是什么呢？原因就是因为你还没掌握一门面向对象设计利器， 你说我读书少别骗我， 什么利器？  </p><p>答案就是:<strong>领域建模</strong>。 从领域模型开始,我们就开始了面向对象的分析和设计过程,可以说,领域模型是完成从需求分析到面向 对象设计的一座桥梁。 </p><p>领域模型,顾名思义,就是需求所涉及的领域的一个建模,更通俗的讲法是业务模型。 参考百度百科(<a href="http://baike.baidu.cn/view/757895.htm" target="_blank" rel="noopener">http://baike.baidu.cn/view/757895.htm</a> ),领域模型定义如下: </p><p>从这个定义我们可以看出,领域模型有两个主要的作用:</p><ol><li>发掘重要的业务领域概念</li><li>建立业务领域概念之间的关系 </li></ol><p><strong>领域建模三字经</strong> </p><p>领域模型如此重要,很多同学可能会认为领域建模很复杂,需要很高的技巧。然而事实上领域建模非常简 单,简单得有点难以让人相信,领域建模的方法概括一下就是“<strong>找名词</strong>”! 许多同学看到这个方法后估计都会笑出来:太假了吧,这么简单,找个初中生都会啊,那我们公司那些分 析师和设计师还有什么用哦?</p><p>分析师和设计师当然有用,后面我们会看到,即使是简单的找名词这样的操作,也涉及到分析和提炼,而 不是简单的摘取出来就可,这种情况下分析师和设计师的经验和技能就能够派上用场了。但领域模型分析 也确实相对简单,即使没有丰富的经验和高超的技巧,至少也能完成一个能用的领域模型。 </p><p>虽然我们说“找名词”很简单,但一个关键的问题还没有说明:<strong>从哪里找</strong>? 如果你还记得领域模型是“需求到面向对象的桥梁”,那么你肯定一下子就能想到:从需求模型中找,具 体来说就是从用例中找。 </p><p>归纳一下域建模的方法就是“<strong>从用例中找名词</strong>”。 当然,找到名词后,为了能够更加符合面向对象的要求和特点,我们还需要对这些名词进一步完善,这就 是接下来的步骤:<strong>加属性,连关系</strong>! </p><p>  最后我们总结出领域建模的三字经方法:<strong>找名词、加属性、连关系</strong>。 </p>]]></content>
    
    <summary type="html">
    
      day06-面向对象编程
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="老男孩视频学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="老男孩视频" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>python import模块相关问题</title>
    <link href="http://yoursite.com/2018/08/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/python-import%E6%A8%A1%E5%9D%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/16/编程语言/Python/基础知识/python-import模块相关问题/</id>
    <published>2018-08-16T04:50:21.000Z</published>
    <updated>2018-08-16T04:50:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><ul><li><a href="https://www.kancloud.cn/st_afei/python_info_ylf/344146" target="_blank" rel="noopener">关于python——import问题</a></li><li><a href="http://codingpy.com/article/python-import-101/" target="_blank" rel="noopener">python导入模块的几种姿势</a></li></ul><h1 id="python-import"><a href="#python-import" class="headerlink" title="python import"></a>python import</h1><p>在python中，每个py文件被称之为模块，每个具有<code>__init__.py</code>文件的目录被称为包。只要模块或者包所在的目录在sys.path中，就可以使用import 模块或import 包来使用。</p><p>作为一名新手Python程序员，你首先需要学习的内容之一就是如何导入模块或包。但是我注意到，那些许多年来不时使用Python的人并不是都知道Python的导入机制其实非常灵活。在本文中，我们将探讨以下话题：</p><ul><li>常规导入（regular imports）</li><li>使用from语句导入</li><li>相对导入（relative imports）</li><li>可选导入（optional imports）</li><li>本地导入（local imports）</li><li>导入注意事项</li></ul><h2 id="常规导入"><a href="#常规导入" class="headerlink" title="常规导入"></a>常规导入</h2><p>常规导入应该是最常使用的导入方式，大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br></pre></td></tr></table></figure><p>你只需要使用<code>import</code>一词，然后指定你希望导入的模块或包即可。通过这种方式导入的好处是可以一次性导入多个包或模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import os, sys, time</span><br></pre></td></tr></table></figure><p>虽然这节省了空间，但是却违背了Python风格指南。<strong>Python风格指南建议将每个导入语句单独成行</strong>。</p><p>有时在导入模块时，你想要重命名这个模块。这个功能很容易实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys as system</span><br><span class="line"></span><br><span class="line">print(system.platform)</span><br></pre></td></tr></table></figure><p>上面的代码将我们导入的<code>sys</code>模块重命名为<code>system</code>。我们可以按照和以前一样的方式调用模块的方法，但是可以用一个新的模块名。也有某些子模块必须要使用点标记法才能导入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.error</span><br></pre></td></tr></table></figure><p>这个情况不常见，但是对此有所了解总是没有坏处的。</p><p>注意：</p><ul><li>import导入为绝对导入</li><li>import 只能导入模块，不能导入模块中的对象（类、函数、变量等)</li></ul><blockquote><p>Python 中所有加载到内存的模块都放在 sys.modules 。当 import 一个模块时首先会在这个列表中查找是否已经加载了此模块，如果没有加载则从 sys.path 目录中按照模块名称查找模块文件，找到后将模块载入内存，并加到 sys.modules 中。只有存在sys.path中的模块才会被正确导入。 </p><p>一个模块不会重复载入。多个不同的模块都可以用 import 引入同一个模块到自己的 Local 名字空间，其实背后的 PyModuleObject 对象只有一个。 </p><p>一个容易忽略的问题：import 只能导入模块，不能导入模块中的对象（类、函数、变量等）。例如：模块 A（A.py）中有个函数 getName，另一个模块不能通过 import A.getName 将 getName导入到本模块，只能用 from A import getName。 </p><p>同级目录下，可以使用import直接导入所需模块</p></blockquote><h2 id="使用from语句导入"><a href="#使用from语句导入" class="headerlink" title="使用from语句导入"></a>使用from语句导入</h2><p>很多时候你只想要导入一个模块或库中的某个部分。我们来看看在Python中如何实现这点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from functools import lru_cache</span><br></pre></td></tr></table></figure><p>上面这行代码可以让你直接调用<code>lru_cache</code>。如果你按常规的import方式导入<code>functools</code>，那么你就必须像这样调用<code>lru_cache</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functools.lru_cache(*args)</span><br></pre></td></tr></table></figure><p>根据你实际的使用场景，上面的做法可能是更好的。在复杂的代码库中，能够看出某个函数是从哪里导入的这点很有用的。不过，如果你的代码维护的很好，模块化程度高，那么只从某个模块中导入一部分内容也是非常方便和简洁的。</p><p>当然，你还可以使用from方法导入模块的全部内容，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from os import *</span><br></pre></td></tr></table></figure><p>这种做法在少数情况下是挺方便的，但是这样也会打乱你的命名空间。问题在于，你可能定义了一个与导入模块中名称相同的变量或函数，这时如果你试图使用<code>os</code>模块中的同名变量或函数，实际使用的将是你自己定义的内容。因此，你最后可能会碰到一个相当让人困惑的逻辑错误。<strong>标准库中我唯一推荐全盘导入的模块只有Tkinter</strong>。</p><p>如果你正好要写自己的模块或包，有人会建议你在<code>__init__.py</code>文件中导入所有内容，让模块或者包使用起来更方便。我个人更喜欢显示地导入，而非隐式地导入。</p><p>你也可以采取折中方案，从一个包中导入多个项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from os import path, walk, unlink</span><br><span class="line">from os import uname, remove</span><br></pre></td></tr></table></figure><p>在上述代码中，我们从<code>os</code>模块中导入了5个函数。你可能注意到了，我们是通过多次从同一个模块中导入实现的。当然，如果你愿意的话，你也可以使用圆括号一次性导入多个项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from os import (path, walk, unlink, uname, </span><br><span class="line">                remove, rename)</span><br></pre></td></tr></table></figure><p>这是一个有用的技巧，不过你也可以换一种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from os import path, walk, unlink, uname, \</span><br><span class="line">                remove, rename</span><br></pre></td></tr></table></figure><p>上面的反斜杠是Python中的续行符，告诉解释器这行代码延续至下一行。</p><h2 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h2><p><a href="https://www.python.org/dev/peps/pep-0328/" target="_blank" rel="noopener">PEP 328</a>介绍了引入相对导入的原因，以及选择了哪种语法。具体来说，是使用句点来决定如何相对导入其他包或模块。这么做的原因是为了避免偶然情况下导入标准库中的模块产生冲突。这里我们以PEP 328中给出的文件夹结构为例，看看相对导入是如何工作的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_package/</span><br><span class="line">    __init__.py</span><br><span class="line">    subpackage1/</span><br><span class="line">        __init__.py</span><br><span class="line">        module_x.py</span><br><span class="line">        module_y.py</span><br><span class="line">    subpackage2/</span><br><span class="line">        __init__.py</span><br><span class="line">        module_z.py</span><br><span class="line">    module_a.py</span><br></pre></td></tr></table></figure><p>在本地磁盘上找个地方创建上述文件和文件夹。在顶层的<code>__init__.py</code>文件中，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import subpackage1</span><br><span class="line">from . import subpackage2</span><br></pre></td></tr></table></figure><p>接下来进入<code>subpackage1</code>文件夹，编辑其中的<code>__init__.py</code>文件，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from . import module_x</span><br><span class="line">from . import module_y</span><br></pre></td></tr></table></figure><p>现在编辑<code>module_x.py</code>文件，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from .module_y import spam as ham</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ham()</span><br></pre></td></tr></table></figure><p>最后编辑<code>module_y.py</code>文件，输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def spam():</span><br><span class="line">    print(&apos;spam &apos; * 3)</span><br></pre></td></tr></table></figure><p>打开终端，<code>cd</code>至<code>my_package</code>包所在的文件夹，但不要进入<code>my_package</code>。在这个文件夹下运行Python解释器。我使用的是IPython，因为它的自动补全功能非常方便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import my_package</span><br><span class="line"></span><br><span class="line">In [2]: my_package.subpackage1.module_x</span><br><span class="line">Out[2]: &lt;module &apos;my_package.subpackage1.module_x&apos; from &apos;my_package/subpackage1/module_x.py&apos;&gt;</span><br><span class="line"></span><br><span class="line">In [3]: my_package.subpackage1.module_x.main()</span><br><span class="line">spam spam spam</span><br></pre></td></tr></table></figure><p>相对导入适用于你最终要放入包中的代码。如果你编写了很多相关性强的代码，那么应该采用这种导入方式。<strong>你会发现PyPI上有很多流行的包也是采用了相对导入</strong>。还要注意一点，如果你想要跨越多个文件层级进行导入，只需要使用多个句点即可。不过，<strong>PEP 328建议相对导入的层级不要超过两层</strong>。</p><p>还要注意一点，如果你往<code>module_x.py</code>文件中添加了<code>if __name__ == ‘__main__’</code>，然后试图运行这个文件，你会碰到一个很难理解的错误。编辑一下文件，试试看吧！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from . module_y import spam as ham</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ham()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # This won&apos;t work!</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>现在从终端进入<code>subpackage1</code>文件夹，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python module_x.py</span><br></pre></td></tr></table></figure><p>如果你使用的是Python 2，你应该会看到下面的错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;module_x.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from . module_y import spam as ham</span><br><span class="line">ValueError: Attempted relative import in non-package</span><br></pre></td></tr></table></figure><p>如果你使用的是Python 3，错误信息大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;module_x.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from . module_y import spam as ham</span><br><span class="line">SystemError: Parent module &apos;&apos; not loaded, cannot perform relative import</span><br></pre></td></tr></table></figure><p>这指的是，<code>module_x.py</code>是某个包中的一个模块，而你试图以脚本模式执行，但是<strong>这种模式不支持相对导入</strong>。</p><p>如果你想在自己的代码中使用这个模块，那么你必须将其添加至Python的导入检索路径（import search path）。最简单的做法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&apos;/path/to/folder/containing/my_package&apos;)</span><br><span class="line">import my_package</span><br></pre></td></tr></table></figure><p>注意，你需要添加的是<code>my_package</code>的上一层文件夹路径，而不是<code>my_package</code>本身。原因是<code>my_package</code>就是我们想要使用的包，所以如果你添加它的路径，那么将无法使用这个包。</p><p>我们接下来谈谈可选导入。</p><h2 id="可选导入（Optional-imports）"><a href="#可选导入（Optional-imports）" class="headerlink" title="可选导入（Optional imports）"></a>可选导入（Optional imports）</h2><p>如果你希望优先使用某个模块或包，但是同时也想在没有这个模块或包的情况下有备选，你就可以使用可选导入这种方式。这样做可以导入支持某个软件的多种版本或者实现性能提升。以<a href="http://pythonhosted.org/github2/_modules/github2/request.html" target="_blank" rel="noopener">github2包</a>中的代码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    # For Python 3</span><br><span class="line">    from http.client import responses</span><br><span class="line">except ImportError:  # For Python 2.5-2.7</span><br><span class="line">    try:</span><br><span class="line">        from httplib import responses  # NOQA</span><br><span class="line">    except ImportError:  # For Python 2.4</span><br><span class="line">        from BaseHTTPServer import BaseHTTPRequestHandler as _BHRH</span><br><span class="line">        responses = dict([(k, v[0]) for k, v in _BHRH.responses.items()])</span><br></pre></td></tr></table></figure><p><code>lxml</code>包也有使用可选导入方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    from urlparse import urljoin</span><br><span class="line">    from urllib2 import urlopen</span><br><span class="line">except ImportError:</span><br><span class="line">    # Python 3</span><br><span class="line">    from urllib.parse import urljoin</span><br><span class="line">    from urllib.request import urlopen</span><br></pre></td></tr></table></figure><p>正如以上示例所示，<strong>可选导入的使用很常见，是一个值得掌握的技巧</strong>。</p><h2 id="局部导入"><a href="#局部导入" class="headerlink" title="局部导入"></a>局部导入</h2><p>当你在局部作用域中导入模块时，你执行的就是局部导入。如果你在Python脚本文件的顶部导入一个模块，那么你就是在将该模块导入至全局作用域，这意味着之后的任何函数或方法都可能访问该模块。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import sys  # global scope</span><br><span class="line"></span><br><span class="line">def square_root(a):</span><br><span class="line">    # This import is into the square_root functions local scope</span><br><span class="line">    import math</span><br><span class="line">    return math.sqrt(a)</span><br><span class="line"></span><br><span class="line">def my_pow(base_num, power):</span><br><span class="line">    return math.pow(base_num, power)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print(square_root(49))</span><br><span class="line">    print(my_pow(2, 3))</span><br></pre></td></tr></table></figure><p>这里，我们将<code>sys</code>模块导入至全局作用域，但我们并没有使用这个模块。然后，在<code>square_root</code>函数中，我们将<code>math</code>模块导入至该函数的局部作用域，这意味着<code>math</code>模块只能在<code>square_root</code>函数内部使用。如果我们试图在<code>my_pow</code>函数中使用<code>math</code>，会引发<code>NameError</code>。试着执行这个脚本，看看会发生什么。</p><p>使用局部作用域的好处之一，是你使用的模块可能需要很长时间才能导入，如果是这样的话，将其放在某个不经常调用的函数中或许更加合理，而不是直接在全局作用域中导入。老实说，我几乎从没有使用过局部导入，主要是因为如果模块内部到处都有导入语句，会很难分辨出这样做的原因和用途。<strong>根据约定，所有的导入语句都应该位于模块的顶部</strong>。</p><h2 id="导入注意事项"><a href="#导入注意事项" class="headerlink" title="导入注意事项"></a>导入注意事项</h2><p>在导入模块方面，有几个程序员常犯的错误。这里我们介绍两个。</p><ul><li>循环导入（circular imports）</li><li>覆盖导入（Shadowed imports，暂时翻译为覆盖导入）</li></ul><p>先来看看循环导入。</p><h3 id="循环导入"><a href="#循环导入" class="headerlink" title="循环导入"></a>循环导入</h3><p>如果你创建两个模块，二者相互导入对方，那么就会出现循环导入。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># a.py</span><br><span class="line">import b</span><br><span class="line"></span><br><span class="line">def a_test():</span><br><span class="line">    print(&quot;in a_test&quot;)</span><br><span class="line">    b.b_test()</span><br><span class="line"></span><br><span class="line">a_test()</span><br></pre></td></tr></table></figure><p>然后在同个文件夹中创建另一个模块，将其命名为<code>b.py</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import a</span><br><span class="line"></span><br><span class="line">def b_test():</span><br><span class="line">    print(&apos;In test_b&quot;&apos;)</span><br><span class="line">    a.a_test()</span><br><span class="line"></span><br><span class="line">b_test()</span><br></pre></td></tr></table></figure><p>如果你运行任意一个模块，都会引发<code>AttributeError</code>。这是因为这两个模块都在试图导入对方。简单来说，模块<code>a</code>想要导入模块<code>b</code>，但是因为模块<code>b</code>也在试图导入模块<code>a</code>（这时正在执行），模块<code>a</code>将无法完成模块<code>b</code>的导入。我看过一些解决这个问题的破解方法（hack），但是<strong>一般来说，你应该做的是重构代码，避免发生这种情况</strong>。</p><h3 id="覆盖导入"><a href="#覆盖导入" class="headerlink" title="覆盖导入"></a>覆盖导入</h3><p>当你创建的模块与标准库中的模块同名时，如果你导入这个模块，就会出现覆盖导入。举个例子，创建一个名叫<code>math.py</code>的文件，在其中写入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line">def square_root(number):</span><br><span class="line">    return math.sqrt(number)</span><br><span class="line"></span><br><span class="line">square_root(72)</span><br></pre></td></tr></table></figure><p>现在打开终端，试着运行这个文件，你会得到以下回溯信息（traceback）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;math.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    import math</span><br><span class="line">  File &quot;/Users/michael/Desktop/math.py&quot;, line 6, in &lt;module&gt;</span><br><span class="line">    square_root(72)</span><br><span class="line">  File &quot;/Users/michael/Desktop/math.py&quot;, line 4, in square_root</span><br><span class="line">    return math.sqrt(number)</span><br><span class="line">AttributeError: module &apos;math&apos; has no attribute &apos;sqrt&apos;</span><br></pre></td></tr></table></figure><p>这到底是怎么回事？其实，你运行这个文件的时候，Python解释器首先在当前运行脚本所处的的文件夹中查找名叫<code>math</code>的模块。在这个例子中，解释器找到了我们正在执行的模块，试图导入它。但是我们的模块中并没有叫<code>sqrt</code>的函数或属性，所以就抛出了<code>AttributeError</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们讲了很多有关导入的内容，但是还有部分内容没有涉及。<a href="https://www.python.org/dev/peps/pep-0302/" target="_blank" rel="noopener">PEP 302</a>中介绍了导入钩子（import hooks），支持实现一些非常酷的功能，比如说直接从github导入。Python标准库中还有一个<a href="https://docs.python.org/3/library/importlib.html" target="_blank" rel="noopener">importlib</a>模块，值得查看学习。当然，你还可以多看看别人写的代码，不断挖掘更多好用的妙招。</p>]]></content>
    
    <summary type="html">
    
      python import模块相关问题
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
