<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Docker," />





  <link rel="alternate" href="/atom.xml" title="Watchmen1992's Blog" type="application/atom+xml" />






<meta name="description" content="Docker入门与实践">
<meta name="keywords" content="Docker">
<meta property="og:type" content="article">
<meta property="og:title" content="Watchmen1992&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/2018/08/23/IT科学技术知识体系结构-Linux运维方向/虚拟化/Docker/Docker入门与实践/index.html">
<meta property="og:site_name" content="Watchmen1992&#39;s Blog">
<meta property="og:description" content="Docker入门与实践">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://camo.githubusercontent.com/e0de62fb4f08efedd2c5abd44786410d3af06c7b/687474703a2f2f7777772e7468696e6b2d666f756e6472792e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30392f61727469636c65315f696d616765322e706e67">
<meta property="og:updated_time" content="2018-08-23T09:42:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Watchmen1992&#39;s Blog">
<meta name="twitter:description" content="Docker入门与实践">
<meta name="twitter:image" content="https://camo.githubusercontent.com/e0de62fb4f08efedd2c5abd44786410d3af06c7b/687474703a2f2f7777772e7468696e6b2d666f756e6472792e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30392f61727469636c65315f696d616765322e706e67">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/08/23/IT科学技术知识体系结构-Linux运维方向/虚拟化/Docker/Docker入门与实践/"/>





  <title> | Watchmen1992's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?07235ad5687ee838f373b31c7c687d23";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Watchmen1992's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">锦瑟年华当与书香为度，是为不负天地人生。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/23/IT科学技术知识体系结构-Linux运维方向/虚拟化/Docker/Docker入门与实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XiaoHua WANG">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Watchmen1992's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-23T17:42:27+08:00">
                2018-08-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-08-23T17:42:27+08:00">
                2018-08-23
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT科学技术知识体系结构-Linux运维方向/" itemprop="url" rel="index">
                    <span itemprop="name">IT科学技术知识体系结构-Linux运维方向</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT科学技术知识体系结构-Linux运维方向/虚拟化/" itemprop="url" rel="index">
                    <span itemprop="name">虚拟化</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT科学技术知识体系结构-Linux运维方向/虚拟化/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/23/IT科学技术知识体系结构-Linux运维方向/虚拟化/Docker/Docker入门与实践/" class="leancloud_visitors" data-flag-title="">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          
              <div class="post-description">
                  Docker入门与实践
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>参考文献：</p>
<ul>
<li>书籍：《Docker技术入门与实战 第2版》</li>
</ul>
<hr>
<h1 id="第1章-基础知识"><a href="#第1章-基础知识" class="headerlink" title="第1章 基础知识"></a>第1章 基础知识</h1><h2 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h2><h3 id="有关虚拟化"><a href="#有关虚拟化" class="headerlink" title="有关虚拟化"></a>有关虚拟化</h3><p>虚拟化技术是一个通用的概念，在不同领域有不同的理解，在计算领域，一般指的是计算虚拟化（computing Virtualization），或通常说的服务器虚拟化。</p>
<p>维基百科定义如下：“虚拟化是一种资源管理技术”，是将计算机的各种实体资源，例如服务器、网络、内存及存储等，予以抽象，转换后呈现出来的，打破实体结构间的不可切割的障碍，使用户可以比原来的组态更好的方式来应用这些资源</p>
<p>传统来看，虚拟化既可以通过硬件模拟来实现（xen、esxi等），也可以通过操作系统软件来实现（KVM等）。而容器技术则更为优雅，它充分利用了操作系统本身已有的机制和特性，可以实现远超传统虚拟机的轻量级虚拟化。因此，有人甚至把它称为“新一代的虚拟化”技术，并将<strong>基于容器打造的云平台亲切地称之为“容器云”</strong></p>
<h3 id="什么docker"><a href="#什么docker" class="headerlink" title="什么docker"></a>什么docker</h3><p>Docker的构想是要实现“build,ship and run any app,anywhere”,即通过对应用程序的封装、分发、部署、运行生命周期。达到应用组件，“一次封装，到处运行”的目的。这里的应用组件，既可以是一个web应用、一个编译环境、也可以是一套数据库平台服务，甚至是一个操作系统或者集群</p>
<p>可以说，Docker首次为应用的开发、运行和部署提供了“一站式”的实用解决方案</p>
<p>IBM DeveloperWorks网站关于容器技术的描述十分准确：“容器技术有效地将由单个操作系统管理的资源划分到孤立的组中，以更好的在孤立的组之间平衡有冲突的资源使用需求”</p>
<p>总结：Docker是一项容器技术，是一个开源项目</p>
<h3 id="从LXC从到Docker"><a href="#从LXC从到Docker" class="headerlink" title="从LXC从到Docker"></a>从LXC从到Docker</h3><p>Docker技术的主要实现参考的是Linux容器技术（Linux Containers LXC）</p>
<p>在LXC的基础之上，Docker进一步优化了容器的使用体验，让它进入了寻常百姓家。</p>
<p>优化项目：</p>
<p>首先，Docker提供了各种容器管理工具（如分发、版本、移植等），让用户无需关注底层的操作，可以简单明了地管理和使用容器。</p>
<p>其次，docker引入了<strong>分层文件系统构建和高效的镜像机制</strong>，降低了迁移难度极大地提升了用户体验。用户操作docker就像操作应用自身一样简单。</p>
<h3 id="使用Docker的好处"><a href="#使用Docker的好处" class="headerlink" title="使用Docker的好处"></a>使用Docker的好处</h3><p>在云时代，开发者创建的应用需要要很方便的在网络上传播，也就是说，应用必须要脱离底层物理硬件的限制，同时必须是“任何时间，任何地点”都可获取的。因此，开发者需要一种新型的创建分布式应用程序的方式，<strong>快速分发和部署</strong>，这正是docker所能够提供的最大优势。</p>
<p>举例来说，如果要部署LAMP平台，需要分别部署mysql，apache，php等，然后再进行一系列的配置，这样的配置非常繁琐并且容易出错。并且如果需要服务器迁移，往往需要重新部署。</p>
<p>docker提供了一种更为聪明的方式，通过容器来打包应用。解耦应用和运行平台。这意味着在进行应用迁移的时候，只需要再新的机器上面再启动容器就可以了，不需要再进行重新部署等操作。无论服务器是否是同一类型的平台架构。这节约了大量的时间，并降低了部署过程出现问题的风险。</p>
<h3 id="Docker在开发和运维中的优势"><a href="#Docker在开发和运维中的优势" class="headerlink" title="Docker在开发和运维中的优势"></a>Docker在开发和运维中的优势</h3><p>具体来说，Docker在开发和运维过程中，具有如下几个方面的优势：</p>
<ul>
<li>更快速的交付和部署</li>
</ul>
<p>使用镜像来快速构建一套标准环境，</p>
<ul>
<li>更高效的资源利用</li>
</ul>
<p>docker容器不需要额外的虚拟化管理程序支持，它是内核级别的虚拟化，可以实现更高的性能</p>
<ul>
<li>更轻松的迁移和扩展</li>
</ul>
<p>docker容器几乎可以在任何的平台上运行，包括物理机，虚拟机，公有云，私有云，个人电脑，服务器等。</p>
<ul>
<li>更简单的更新管理</li>
</ul>
<p>使用dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作，并且所有的修改都是以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</p>
<h3 id="Docker与虚拟机的比较"><a href="#Docker与虚拟机的比较" class="headerlink" title="Docker与虚拟机的比较"></a>Docker与虚拟机的比较</h3><ul>
<li><p>docker容器很快，启动和停止可以在秒级实现，而传统的虚拟机方式需要数分钟</p>
</li>
<li><p>docker容器对系统资源的需求很少，一台主机可以同时运行数千个docker容器</p>
</li>
<li><p>docker通过类似git设计理念的操作来方便用户获取，分发和应用镜像，存储复用，增量更新。</p>
</li>
<li><p>docker通过dockerfile支持灵活的自动化创建和部署机制，提高工作效率，使流程标准化。</p>
</li>
</ul>
<h3 id="Docker和核心价值"><a href="#Docker和核心价值" class="headerlink" title="Docker和核心价值"></a>Docker和核心价值</h3><p>docker的核心价值在于，他很有可能改变传统的软件“交付”方式和运行方式。传统的交付源码或者交付软件的方式的最大问题在于，软件运行期间所“依赖的环境”是无法控制的、不能标准化的，IT人员常常需要耗费很多精力来解决因为“依赖的环境”而导致软件运行出现的各种问题。</p>
<p>而docker将<strong>软件与其“依赖的环境”打包在一起</strong>，以镜像的方式交付，让软件运行在“标准的环境中”，这非常符合云计算的要求。这种变革一旦被IT人员接受，可能会对产业链带来很大的冲击，我们熟悉的apt-get、yum是否会逐渐被docker pull取代？</p>
<p>从这一点可以毫不夸张的说，docker是革命性的，它重新定义了软件开发、测试、交付和部署的流程。我们交付的不再是代码、配置文件、数据库定义等。而是整个应用程序运行环境：“OS+各种中间件、类库+应用程序代码”</p>
<p>有了标准化的运行环境，再加上对CPU、内存、磁盘、网络等动态资源的限制，docker构造了一个“轻量级虚拟环境”，传统虚拟机的绝大多数使用场景可以被docker取代，这将给IT基础设施带来一次更大的冲击；传统虚拟化（KVM、XEN、VMWare）将会何去何从？此外，docker秒级创建/删除虚拟机以及<strong>动态调整资源</strong>的能力，也非常契合云计算的“实例水平扩展”、“资源动态调整”的需求，docker很有可能成为云计算的基石。</p>
<h3 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h3><p>通过上面的介绍，可以总结出以下几个使用docker的场景</p>
<ul>
<li><p>业务高峰期通过启动大量容器进行横向扩展</p>
</li>
<li><p>应用需要经常迁移或者多环境运行</p>
</li>
</ul>
<h2 id="核心概念-名词解释"><a href="#核心概念-名词解释" class="headerlink" title="核心概念/名词解释"></a>核心概念/名词解释</h2><p>只有理解了这三个核心概念，才能顺利的理解Docker容器的整个生命周期。</p>
<p>docker的大部分操作都围绕着它的三个核心概念：<strong>镜像、容器和仓库</strong>展开。因此准确把握这三大核心概念对于掌握docker技术尤为重要。</p>
<h3 id="三剑客之镜像-Image"><a href="#三剑客之镜像-Image" class="headerlink" title="三剑客之镜像-Image"></a>三剑客之镜像-Image</h3><p>Docker镜像类似<strong>虚拟机镜像</strong>，可以将它理解为一个<strong>只读的模板</strong>。例如，一个镜像可以包含一个基本的操作系统环境，里面仅安装了apache应用程序（或者其他需要的程序），这个时候，可以把它称之为一个apache镜像。</p>
<p>镜像是创建Docker容器的基础。通过<strong>版本管理和增量的文件系统</strong>，Docker提供了一套十分简单的机制来<strong>创建和更新删除</strong>现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并且直接使用</p>
<p>功能总结</p>
<ul>
<li><p>只读的模板（包含OS+应用）</p>
</li>
<li><p>版本管理和增量文件系统的机制在其之上</p>
</li>
<li><p>操作：自行创建或网上下载、更新、删除</p>
</li>
</ul>
<h3 id="三剑客之容器-Container"><a href="#三剑客之容器-Container" class="headerlink" title="三剑客之容器-Container"></a>三剑客之容器-Container</h3><p>我们可以将Docker的容器理解为一种轻量级的沙盒（sanbox）。</p>
<p>Docker利用容器来<strong>运行和隔离</strong>应用（镜像）。</p>
<p>容器是从镜像创建的应用运行实例，可以将指定的镜像<strong>启动、开始、停止、删除</strong>。而这些容器都是彼此相互隔离的，互不可见的。【容器是镜像的隔离运行单元】</p>
<p>每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止都十分快速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。</p>
<p>每个容器都是一个操作系统实例</p>
<p><strong>容器的功能</strong></p>
<ul>
<li>通过容器打包运行应用</li>
</ul>
<p>解耦应用和运行平台。这意味着在进行应用迁移的时候，只需要再新的机器上面再启动容器就可以了，不需要再进行重新部署等操作。无论服务器是否是同一类型的平台架构。</p>
<ul>
<li>隔离应用</li>
</ul>
<p><strong>容器的组成结构</strong></p>
<ul>
<li><p>上层：实际应用</p>
</li>
<li><p>下层：操作系统环境（主要是内核+函数库）</p>
</li>
</ul>
<h3 id="三剑客之仓库-Repository"><a href="#三剑客之仓库-Repository" class="headerlink" title="三剑客之仓库-Repository"></a>三剑客之仓库-Repository</h3><p>docker仓库类似于代码仓库，它是docker集中存放镜像文件的场所</p>
<p>需要注意docker仓库和仓库注册服务器（Registry）的区别。</p>
<ul>
<li><p>仓库注册服务器是存放仓库的地方，其中往往存放着多个仓库。</p>
</li>
<li><p>每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的tag（标签）来进行区分。</p>
</li>
</ul>
<p>根据所存储的镜像公开与否，Docker仓库可以分为两种形式。目前，最大公开仓库是官方提供的docker Hub，其中存放了数量庞大的镜像供用户下载。国内不少云服务提供商（时速云，阿里云等）也提供了仓库的本地源，可以提供稳定的国内访问</p>
<p>docker也支持用户在本地网络内创建一个只能自己访问的私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到指定的公有或者私有仓库有。这样用户下次在另外一台机器上使用该镜像时，只需要将其从仓库上pull下来就可以。</p>
<h3 id="Docker-EE和Docker-CE"><a href="#Docker-EE和Docker-CE" class="headerlink" title="Docker-EE和Docker-CE"></a>Docker-EE和Docker-CE</h3><p>Docker Engine改为Docker CE（社区版）, Docker Community Edition</p>
<p>Docker Data Center改为Docker EE（企业版）, Docker Enterprise Edition</p>
<p>在Docker三个定价层增加了额外的支付产品和支持</p>
<p>Docker社区版（CE）是为了开发人员或小团队创建基于容器的应用,与团队成员分享和自动化的开发管道。docker-ce提供了简单的安装和快速的安装，以便可以立即开始开发。docker-ce集成和优化，基础设施。 </p>
<p>Docker企业版（EE）是专为企业的发展和IT团队建立谁。docker-ee为企业提供最安全的容器平台，以应用为中心的平台。</p>
<h1 id="第2章-安装配置"><a href="#第2章-安装配置" class="headerlink" title="第2章 安装配置"></a>第2章 安装配置</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>docker目前只能运行在64为平台上，并且要求内核版本不低于3.10，实际上内核越新越好，过低的内核版本容易造成功能不稳定。</p>
<h3 id="centos环境下安装docker"><a href="#centos环境下安装docker" class="headerlink" title="centos环境下安装docker"></a>centos环境下安装docker</h3><p>安装依赖包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \ device-mapper-persistent-data \lvm2</span><br></pre></td></tr></table></figure>
<p>添加yum源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum-config-manager \ --add-repo \</span><br><span class="line">https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>安装docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum -y install docker-ce</span><br></pre></td></tr></table></figure>
<h3 id="ubuntu环境安装docker"><a href="#ubuntu环境安装docker" class="headerlink" title="ubuntu环境安装docker"></a>ubuntu环境安装docker</h3><p><strong>卸载老旧版本的docker</strong></p>
<p>Older versions of Docker were called <code>docker</code> or <code>docker-engine</code>. If these are installed, uninstall them:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure>
<p><strong>安装软件源</strong></p>
<ol>
<li><p>Update the <code>apt</code> package index:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>
</li>
<li><p>Install packages to allow <code>apt</code> to use a repository over HTTPS:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>
</li>
<li><p>Add Docker’s official GPG key:</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>Verify that you now have the key with the fingerprint <code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code>, by searching for the last 8 characters of the fingerprint.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"></span><br><span class="line">pub   4096R/0EBFCD88 2017-02-22</span><br><span class="line">      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid                  Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   4096R/F273FCD8 2017-02-22</span><br></pre></td></tr></table></figure>
<ol>
<li>Use the following command to set up the <strong>stable</strong> repository. You always need the <strong>stable</strong> repository, even if you want to install builds from the <strong>edge</strong> or <strong>test</strong> repositories as well. To add the <strong>edge</strong> or <strong>test</strong> repository, add the word <code>edge</code> or <code>test</code> (or both) after the word <code>stable</code> in the commands below.</li>
</ol>
<blockquote>
<p><strong>Note</strong>: The <code>lsb_release -cs</code> sub-command below returns the name of your Ubuntu distribution, such as <code>xenial</code>. Sometimes, in a distribution like Linux Mint, you might have to change <code>$(lsb_release -cs)</code> to your parent Ubuntu distribution. For example, if you are using <code>Linux Mint Rafaela</code>, you could use <code>trusty</code>.</p>
</blockquote>
<ul>
<li>x86_64 / amd64</li>
<li>armhf</li>
<li>IBM Power (ppc64le)</li>
<li>IBM Z (s390x)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure>
<p><strong>安装docker-ce</strong></p>
<p>Install the latest version of Docker CE, or go to the next step to install a specific version. Any existing installation of Docker is replaced.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>
<p>On production systems, you should install a specific version of Docker CE instead of always using the latest. This output is truncated. List the available versions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">docker-ce | 17.09.0~ce-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages</span><br></pre></td></tr></table></figure>
<p>我这里的输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"> docker-ce | 18.06.1~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br><span class="line"> docker-ce | 18.06.0~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br><span class="line"> docker-ce | 18.03.1~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br></pre></td></tr></table></figure>
<p>The contents of the list depend upon which repositories are enabled. Choose a specific version to install. The second column is the version string. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by an equals sign (<code>=</code>):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce=&lt;VERSION&gt;</span><br></pre></td></tr></table></figure>
<p>The Docker daemon starts automatically.</p>
<ol>
<li><p>Verify that Docker CE is installed correctly by running the <code>hello-world</code> image.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>配置开机自启动</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br></pre></td></tr></table></figure>
<p><strong>卸载docker</strong></p>
<ol>
<li><p>Uninstall the Docker CE package:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure>
</li>
<li><p>Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>You must delete any edited configuration files manually.</p>
<h2 id="配置Docker服务"><a href="#配置Docker服务" class="headerlink" title="配置Docker服务"></a>配置Docker服务</h2><h3 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a><strong>权限配置</strong></h3><p>为了避免每次使用docker命令都需要sudo使用特权身份，可以将当前用户加入安装中自动创建的docker用户组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker [username]</span><br></pre></td></tr></table></figure>
<p>关于这部分的内容-查看：<a href="https://docs.docker.com/v17.09/engine/installation/linux/linux-postinstall/" target="_blank" rel="noopener">Post-installation steps for Linux</a></p>
<p>后续需要单独写一篇文章写docker的启动权限问题</p>
<h3 id="配置文件不存在问题"><a href="#配置文件不存在问题" class="headerlink" title="配置文件不存在问题"></a><strong>配置文件不存在问题</strong></h3><p>docker服务的默认配置文件为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu中：/etc/default/docker</span><br><span class="line">centos中：/etc/sysconfig/docker</span><br></pre></td></tr></table></figure>
<p>在该配置文件中，我们可以通过修改其中的<strong>DOCKER_OPTS</strong>来修改服务<strong>启动的参数</strong></p>
<p>但是实际情况，安装完docker之后，是没有改配置文件的</p>
<p>因此在docker的高版本之后，配置文件变成了：/etc/docker/key.json</p>
<p>官方参考配置文档：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd//#daemon-configuration-file</a></p>
<h2 id="cd-启动Docker服务"><a href="#cd-启动Docker服务" class="headerlink" title="cd 启动Docker服务"></a>cd 启动Docker服务</h2><p> 在Centos 7 中，我们可以使用如下命令启动docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># systemctl enable  docker</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload     #加载配置</span><br></pre></td></tr></table></figure>
<h1 id="第3章-使用Docker镜像"><a href="#第3章-使用Docker镜像" class="headerlink" title="第3章 使用Docker镜像"></a>第3章 使用Docker镜像</h1><p>镜像（image）是Docker三大核心概念中最为重要的，自Docker诞生之日起，“镜像”就是相关社区最为热门的关键词。</p>
<p>docker运行容器前需要本地存在对应的镜像，如果镜像没有保存在本地，docker会尝试先从默认镜像仓库下载（默认使用docker Hub公共注册服务器中的仓库），用户也可以通过配置，使用自定义的镜像仓库。</p>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>镜像是运行容器的前提，官方的docker Hub网站已经提供了数十万个镜像供大家开放下载。</p>
<p>可以使用docker pull命令直接从docker Hub 镜像源来下载镜像。该命令的格式为docker pull NAME[:TAG]。其中，NAME是镜像仓库的名称（用来区分镜像），TAG是镜像的标签（往往用来表示版本信息）。例如：ubuntu系统是NAME，14.04是TAG</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>注意：</strong></p>
<p>如果不显性的制定TAG，该命令会自动选择latest标签，这会下载仓库中最新版本的镜像。</p>
<p>镜像的latest标签意味着该镜像的内容会跟踪最新的非稳定版本而发布，内部是不稳定的。</p>
<p>在生产环境中禁止忽略镜像的标签信息或者使用默认的latest标签</p>
<hr>
<h3 id="镜像的分层特性"><a href="#镜像的分层特性" class="headerlink" title="镜像的分层特性"></a>镜像的分层特性</h3><p>镜像文件一般由若干层（layer）构成，每一层都有一个唯一的id（完整的id有256比特，由64个十六进制字符组成）。</p>
<p>使用docker pull命令下载时会获取并输出镜像的各层信息。<strong>当不同的镜像包括相同的层时，本地仅存储该层的一份内容，减少了需要的存储空间。</strong></p>
<h3 id="镜像的重名问题"><a href="#镜像的重名问题" class="headerlink" title="镜像的重名问题"></a>镜像的重名问题</h3><p>在使用不同的镜像仓库时，可能会出现镜像重名的情况？</p>
<p>严格来讲，镜像的仓库名称中还应该添加仓库地址（即仓库注册服务器（Registry））的地址作为前缀，默认我们使用的是docker Hub的服务，该前缀可以忽略不写。</p>
<p>例如：docker pull ubuntu:14.04 命令相当于docker pull registry.hub.docker.com/ubuntu:14.04命令。</p>
<h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>下载镜像到本地之后，即可随时使用该镜像，例如利用该镜像创建一个容器，在其中运行bash应用，执行ping localhost命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master yum.repos.d]# docker run -it ubuntu:14.04 bash</span><br></pre></td></tr></table></figure>
<h2 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h2><h3 id="使用images命令列出镜像"><a href="#使用images命令列出镜像" class="headerlink" title="使用images命令列出镜像"></a>使用images命令列出镜像</h3><p>使用docker images命令可以列出本地主机上已有镜像的基本信息。、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker images</span><br></pre></td></tr></table></figure>
<p>在列出的信息中，可以看到以下几个字段信息：</p>
<ul>
<li><p>来自于哪个仓库           REPOSITORY</p>
</li>
<li><p>镜像的TAG（标签）信息，标签知识标记，并不能识别镜像内容</p>
</li>
<li><p>镜像的ID（唯一标识镜像）。IMAGE ID</p>
</li>
<li><p>创建时间        CREATED</p>
</li>
<li><p>镜像大小               SIZE</p>
</li>
</ul>
<p>其中镜像的ID信息十分重要，它唯一标识了镜像。在使用镜像ID的时候，一般可以使用该ID的前若干个字符组成的可区分串来替代完整的ID。</p>
<p>镜像大小信息只是标识该镜像的逻辑体积的大小，实际上由于相同的镜像层本地只会存储一份，物理上占用的存储空间会小于各镜像的逻辑体积之和。</p>
<p>images支持的的选项参数：</p>
<ul>
<li><p>-a    –all=true|false         列出所有的镜像文件（包括临时文件），默认为否</p>
</li>
<li><p>–digests=true|false          列出镜像的数字摘要值，默认为否</p>
</li>
<li><p>-f    –filter=[]                过滤列出的镜像</p>
</li>
<li><p>…..</p>
</li>
</ul>
<p>具体可以通过man docker-images 进行查看。</p>
<h3 id="使用tag命令添加镜像标签"><a href="#使用tag命令添加镜像标签" class="headerlink" title="使用tag命令添加镜像标签"></a>使用tag命令添加镜像标签</h3><p>为了方便在后续的工作中使用特定镜像，还可以使用docker tag命令来为本地镜像任意添加新的标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker tag ubuntu:14.04 ubuntu:my14.04</span><br></pre></td></tr></table></figure>
<p>  注意：docker tag命令添加的标签实际上起到了类似链接的作用</p>
<h3 id="使用inspect命令查看详细信息"><a href="#使用inspect命令查看详细信息" class="headerlink" title="使用inspect命令查看详细信息"></a>使用inspect命令查看详细信息</h3><p>使用docker inspect命令可以获取该镜像的详细信息，包括制作者，使用架构，各层的数字摘要等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker inspect ubuntu:14.04</span><br></pre></td></tr></table></figure>
<p>返回的是一个JSON格式的消息，如果我们只要其中一项内容时，可以使用参数-f来指定，例如，获取镜像的Architecture参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker inspect ubuntu:14.04 -f &#123;&#123;&quot;.Architecture&quot;&#125;&#125;</span><br><span class="line">amd64</span><br></pre></td></tr></table></figure>
<h3 id="使用history命令查看镜像历史"><a href="#使用history命令查看镜像历史" class="headerlink" title="使用history命令查看镜像历史"></a>使用history命令查看镜像历史</h3><p>既然镜像由多个层组成，那么怎么知道各个层的内容具体是什么呢？这时候可以使用history子命令，该命令将列出各层的创建信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker history ubuntu:14.04</span><br><span class="line"></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line"></span><br><span class="line">a35e70164dfb        12 days ago         /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;do…   7B                  </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c sed -i &apos;s/^#\s(deb.universe)$…   2.76kB              </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c rm -rf /var/lib/apt/lists/*          0B                  </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /…   195kB               </span><br><span class="line"></span><br><span class="line">&lt;missing&gt;           12 days ago         /bin/sh -c #(nop) ADD file:3900b83a46e97708a…   222MB</span><br></pre></td></tr></table></figure>
<h2 id="搜寻镜像"><a href="#搜寻镜像" class="headerlink" title="搜寻镜像"></a>搜寻镜像</h2><p>使用docker search命令来搜索源端仓库中共享的镜像，默认搜索官方仓库中的镜像。</p>
<p>用法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search TERM</span><br></pre></td></tr></table></figure>
<p>支持的主要参数为：</p>
<ul>
<li><p>–automated=true|false：仅显示自动创建的镜像，默认为否。</p>
</li>
<li><p>–no-trubc=true|false：输出信息不截断显示，默认为否</p>
</li>
<li><p>-s     –starts=X：指定仅显示评价为指定星级以上的镜像，默认为0，即输出所有的镜像。</p>
</li>
</ul>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><h3 id="使用标签删除镜像"><a href="#使用标签删除镜像" class="headerlink" title="使用标签删除镜像"></a>使用标签删除镜像</h3><p>使用docker rmi命令可以删除镜像，命令格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi IMAGE [IMAGE…]</span><br><span class="line"></span><br><span class="line">其中IMAGE可以为标签或ID,例如：ubuntu:my14.04</span><br></pre></td></tr></table></figure>
<p>注意：当同一个镜像拥有多个标签的时候，docker rmi命令只是删除该镜像多个标签中的制定标签而已，并不影响镜像文件。因此上述操作相当于只是删除了镜像a35e70164dfb的一个标签而已。</p>
<p>但是，当镜像只是剩下一个标签的时候，此时再使用docker rmi 命令会彻底删除镜像。</p>
<h3 id="使用镜像ID删除镜像"><a href="#使用镜像ID删除镜像" class="headerlink" title="使用镜像ID删除镜像"></a>使用镜像ID删除镜像</h3><p>当使用docker rmi（remove image）命令，并且后面跟上镜像的ID（也可以是能进行区分的部分ID串前缀）时，会先尝试删除所有指向该镜像，然后再删除该镜像文件本身</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi xxxx(ID)</span><br></pre></td></tr></table></figure>
<p>注意：使用该命令可以彻底将该镜像删除，而不是只是删除对应的标签，请务必注意。</p>
<hr>
<p>注意：</p>
<p>当有该镜像创建的容器存在时，镜像文件默认是无法被删除的</p>
<p>试图删除该镜像，docker会提示有容器正在运行，无法删除</p>
<p>如果要强行删除镜像，可以使用-f参数</p>
<hr>
<h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>创建镜像的方法主要有三种：</p>
<ul>
<li><p>基于已有镜像的容器创建</p>
</li>
<li><p>基于本地模板导入</p>
</li>
<li><p>基于dockerfile创建</p>
</li>
</ul>
<h3 id="基于已有镜像的容器创建"><a href="#基于已有镜像的容器创建" class="headerlink" title="基于已有镜像的容器创建"></a>基于已有镜像的容器创建</h3><p>当运行一个容器后，内部发生了变化，我们可以把这个发生了变化的容器做成一个新的镜像。</p>
<p>该方法主要是通过docker commit命令。</p>
<p>命令格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [options] container [repository[:tag]]</span><br></pre></td></tr></table></figure>
<p>主要选项包括：</p>
<ul>
<li><p>-a     –author=””：作者信息</p>
</li>
<li><p>-c     –change=[]：提交的时候之心dockerfile指令，</p>
</li>
<li><p>-m   –message=””：提交消息</p>
</li>
<li><p>-p    –pause=true     提交时暂停容器运行</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -it ubuntu:14.04 /bin/bash</span><br><span class="line"></span><br><span class="line">root@fdbe2f28b1d6:/# touch test</span><br><span class="line"></span><br><span class="line">root@fdbe2f28b1d6:/# exit</span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line">[root@master ~]# docker commit -m &quot;add a new file&quot; -a &quot;wxh&quot; fdbe2f28b1d6 test:0.1</span><br><span class="line"></span><br><span class="line">sha256:cd9c21826184f9e65e11644f826fb97918d40d469aa5e3fd8827cbcac19351ed</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker images 查看</span><br></pre></td></tr></table></figure>
<p>I’m just </p>
<h3 id="基于本地模板导入"><a href="#基于本地模板导入" class="headerlink" title="基于本地模板导入"></a>基于本地模板导入</h3><p>这部分不常用，详见书籍《docker技术入门与实践》-p32</p>
<h3 id="基于dockerfile创建"><a href="#基于dockerfile创建" class="headerlink" title="基于dockerfile创建"></a>基于dockerfile创建</h3><h5 id="官方案例"><a href="#官方案例" class="headerlink" title="官方案例"></a>官方案例</h5><p>下面是docker官方案例，有一定的代表性</p>
<p>链接地址：<a href="https://docs.docker.com/v17.09/get-started/part2/#dockerfile" target="_blank" rel="noopener">https://docs.docker.com/v17.09/get-started/part2/#dockerfile</a></p>
<p><code>Dockerfile</code> will define what goes on in the environment inside your container. Access to resources like networking interfaces and disk drives is virtualized inside this environment, which is isolated from the rest of your system, so you have to map ports to the outside world, and be specific about what files you want to “copy in” to that environment. However, after doing that, you can expect that the build of your app defined in this <code>Dockerfile</code> will behave exactly the same wherever it runs.</p>
<p><strong><code>Dockerfile</code></strong></p>
<p>Create an empty directory. Change directories (<code>cd</code>) into the new directory, create a file called <code>Dockerfile</code>, copy-and-paste the following content into that file, and save it. Take note of the comments that explain each statement in your new Dockerfile.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to /app</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at /app</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Are you behind a proxy server?</p>
<p>Proxy servers can block connections to your web app once it’s up and running. If you are behind a proxy server, add the following lines to your Dockerfile, using the <code>ENV</code> command to specify the host and port for your proxy servers:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; # Set proxy server, replace host:port with values for your servers</span><br><span class="line">&gt; ENV http_proxy host:port</span><br><span class="line">&gt; ENV https_proxy host:port</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Add these lines before the call to <code>pip</code> so that the installation succeeds.</p>
</blockquote>
<p>This <code>Dockerfile</code> refers to a couple of files we haven’t created yet, namely <code>app.py</code> and <code>requirements.txt</code>. Let’s create those next.</p>
<p><strong>The app itself</strong></p>
<p>Create two more files, <code>requirements.txt</code> and <code>app.py</code>, and put them in the same folder with the <code>Dockerfile</code>. This completes our app, which as you can see is quite simple. When the above <code>Dockerfile</code> is built into an image, <code>app.py</code> and <code>requirements.txt</code> will be present because of that <code>Dockerfile</code>’s <code>ADD</code> command, and the output from <code>app.py</code> will be accessible over HTTP thanks to the <code>EXPOSE</code>command.</p>
<p><strong>requirements.txt</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure>
<p><strong>app.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure>
<p>Now we see that <code>pip install -r requirements.txt</code> installs the Flask and Redis libraries for Python, and the app prints the environment variable <code>NAME</code>, as well as the output of a call to <code>socket.gethostname()</code>. Finally, because Redis isn’t running (as we’ve only installed the Python library, and not Redis itself), we should expect that the attempt to use it here will fail and produce the error message.</p>
<blockquote>
<p><strong>Note</strong>: Accessing the name of the host when inside a container retrieves the container ID, which is like the process ID for a running executable.</p>
</blockquote>
<p>That’s it! You don’t need Python or anything in <code>requirements.txt</code> on your system, nor will building or running this image install them on your system. It doesn’t seem like you’ve really set up an environment with Python and Flask, but you have.</p>
<p><strong>Build the app</strong></p>
<p>We are ready to build the app. Make sure you are still at the top level of your new directory. Here’s what <code>ls</code> should show:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Dockerfile		app.py			requirements.txt</span><br></pre></td></tr></table></figure>
<p>Now run the build command. This creates a Docker image, which we’re going to tag using <code>-t</code> so it has a friendly name.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .</span><br></pre></td></tr></table></figure>
<p>Where is your built image? It’s in your machine’s local Docker image registry:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">REPOSITORY            TAG                 IMAGE ID</span><br><span class="line">friendlyhello         latest              326387cea398</span><br></pre></td></tr></table></figure>
<p><strong>Run the app</strong></p>
<p>Run the app, mapping your machine’s port 4000 to the container’s published port 80 using <code>-p</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure>
<p>You should see a message that Python is serving your app at <code>http://0.0.0.0:80</code>. But that message is coming from inside the container, which doesn’t know you mapped port 80 of that container to 4000, making the correct URL <code>http://localhost:4000</code>.</p>
<p>Go to that URL in a web browser to see the display content served up on a web page.</p>
<p>Now let’s run the app in the background, in detached mode:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure>
<p>You get the long container ID for your app and then are kicked back to your terminal. Your container is running in the background. You can also see the abbreviated container ID with <code>docker container ls</code> (and both work interchangeably when running commands):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED</span><br><span class="line">1fa4ab2cf395        friendlyhello       &quot;python app.py&quot;     28 seconds ago</span><br></pre></td></tr></table></figure>
<p>You’ll see that <code>CONTAINER ID</code> matches what’s on <code>http://localhost:4000</code>.</p>
<p>Now use <code>docker container stop</code> to end the process, using the <code>CONTAINER ID</code>, like so:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop 1fa4ab2cf395</span><br></pre></td></tr></table></figure>
<h2 id="载入和导出镜像"><a href="#载入和导出镜像" class="headerlink" title="载入和导出镜像"></a>载入和导出镜像</h2><p>用户可以使用docker save和docker load命令来存出和载入镜像</p>
<h3 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h3><p>如果要导出镜像到本地文件，可以使用docker save命令。例如导出本地的ubunt:14.04镜像为ubuntu_14.04.tar。如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker save -o ubuntu:14.04.tar ubuntu:14.04</span><br></pre></td></tr></table></figure>
<h3 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h3><p>可以使用docker load将导出的tar文件再导入到本地的镜像库，例如从上述文件导入镜像到本地镜像列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker load --input ubuntu\:14.04.tar</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker load &lt; ubuntu\:14.04.tar</span><br></pre></td></tr></table></figure>
<p>该命令将导入镜像及其相关的元数据信息（包括标签等）。导入成功之后，可以使用docker images命令进行查看。</p>
<h2 id="上传和下载镜像"><a href="#上传和下载镜像" class="headerlink" title="上传和下载镜像"></a>上传和下载镜像</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>首先在docker hub网站完成注册</p>
<p>可以通过执行 <strong>docker login</strong> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 <strong>docker logout</strong> 退出登录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:~$ sudo docker login</span><br><span class="line">[sudo] password for wxh:</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">Username: watchmen1992</span><br><span class="line">Password:</span><br><span class="line">WARNING! Your password will be stored unencrypted in /home/wxh/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">wxh@wxh-ThinkPad-E570:~$</span><br></pre></td></tr></table></figure>
<h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>可以使用docker push命令上传镜像到仓库，默认上传到docker Hub官方仓库（需要在前面进行登录）</p>
<p>在进行上传之前，我们需要将指定的image镜像打上tag标签</p>
<p>命令格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag image username/repository:tag</span><br><span class="line">docker push NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</span><br></pre></td></tr></table></figure>
<p>例如这里是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:~/.docker$ sudo docker images</span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">friendlyhello              latest              028a0a8d1a73        18 hours ago        132MB</span><br><span class="line">python                     2.7-slim            40792d8a2d6d        4 weeks ago         120MB</span><br><span class="line">hello-world                latest              2cb0d9787c4d        7 weeks ago         1.85kB</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker tag friendlyhello watchmen1992/get_started:part1</span><br></pre></td></tr></table></figure>
<p>然后push上传</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:~/.docker$ sudo docker push watchmen1992/get_started:part1</span><br><span class="line">The push refers to repository [docker.io/watchmen1992/get_started]</span><br><span class="line">88d851af045c: Pushed</span><br><span class="line">aa5497e6a355: Pushed</span><br><span class="line">d4f7cf378376: Pushed</span><br><span class="line">1ea4f6a807ba: Mounted from library/python</span><br><span class="line">fda4dc055a55: Mounted from library/python</span><br><span class="line">e8fc09a140cf: Mounted from library/python</span><br><span class="line">cdb3f9544e4c: Mounted from library/python</span><br><span class="line">part1: digest: sha256:ded675c46615053ef0a655b163228e50a0e58172003f78f319dad46ee09dac9a size: 1788</span><br></pre></td></tr></table></figure>
<p>上传之后，我们在docker hub的页面就可以看到新增内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 username/repository:tag</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wxh@wxh-ThinkPad-E570:~/.docker$ sudo docker run  -p 4000:80 watchmen1992/get_started:part1</span><br><span class="line"></span><br><span class="line">[sudo] password for wxh:</span><br><span class="line"> * Serving Flask app &quot;app&quot; (lazy loading)</span><br><span class="line"> * Environment: production</span><br><span class="line">   WARNING: Do not use the development server in a production environment.</span><br><span class="line">   Use a production WSGI server instead.</span><br><span class="line"> * Debug mode: off</span><br><span class="line"> * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)</span><br><span class="line"></span><br><span class="line">192.168.101.72 - - [30/Aug/2018 03:32:34] &quot;GET / HTTP/1.1&quot; 200 -</span><br></pre></td></tr></table></figure>
<p>在上传之后，我们就能直接调用仓库的镜像去启动容器</p>
<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><h1 id="第4章-使用Docker容器"><a href="#第4章-使用Docker容器" class="headerlink" title="第4章 使用Docker容器"></a>第4章 使用Docker容器</h1><p>容器是docker的另一个和细腻概念。简单来说，容器是镜像的一个运行实例。所不同的是，镜像是静态的只读文件，而容器带有运行时需要的可写文件层。</p>
<h2 id="创建启动容器"><a href="#创建启动容器" class="headerlink" title="创建启动容器"></a>创建启动容器</h2><h3 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h3><p>使用docker create命令新建一个容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：docker create -it ubuntu:latest</span><br></pre></td></tr></table></figure>
<p>注意：使用该命令新建的容器<strong>处于停止状态</strong>，可以使用docker start命令来启动它。</p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>使用docker start 命令来启动一个已经创建的容器，例如启动刚创建的ubuntu容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start af</span><br></pre></td></tr></table></figure>
<h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><p>除了创建容器后通过start命令来启动，也可以直接新建并启动容器。</p>
<p>所需要的命令主要为:docker run。等价于先执行docker create命令，再执行docker start命令</p>
<p>例如，下面的命令输出一个“hello world”之后容器终止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run ubuntu:14.04 /bin/echo &quot;hello,world&quot;</span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure>
<p>当利用docker run命令来创建并启动容器时，docker在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库中下载</li>
<li>利用镜像创建一个容器，并启动该容器</li>
<li>分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中</li>
<li>从网桥的地址池配置一个IP地址给容器</li>
<li>执行用户执行的应用程序</li>
<li>执行完毕后容器被自动终止</li>
</ul>
<p>下面命令启动一个bash终端，允许用户进行交互</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -it ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure>
<p>-t选项让docker分配一个伪终端，并绑定到容器的标准输入上，一则让容器的标准输入保持打开。更多的命令可以通过 man docker-run进行查看。</p>
<hr>
<p>注意：</p>
<p>对于所创建的bash容器，当使用exit命令退出之后，容器就自动处于退出状态了，这是因为对于docker容器来说，当运行的应用退出之后，容器也就没有继续运行的必要了</p>
<hr>
<h3 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h3><p>更多的时候，需要让docker容器在后台以守护态（daemonized）形式运行。此时可以添加-d参数来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d  ubuntu:14.04 /bin/bash -c &quot;while true;do echo hello,world;sleep 1;done&quot;</span><br></pre></td></tr></table></figure>
<p>此时，要获取容器的输出信息，可以使用如下的docker logs命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker logs 9e7</span><br></pre></td></tr></table></figure>
<p>退出错误代码</p>
<ul>
<li><p>125         docker daemon执行出错，例如指定了不支持的docker命令参数</p>
</li>
<li><p>126         所指定命令无法执行，例如权限出错</p>
</li>
<li><p>127         容器内命令无法找到</p>
</li>
</ul>
<p>当命令执行出错时，会默认返回错误码</p>
<h3 id="容器参数"><a href="#容器参数" class="headerlink" title="容器参数"></a>容器参数</h3><p>详见书籍《docker技术从入门到实践》p35-37</p>
<ul>
<li><p>–rm  容器在终止后会立刻删除</p>
</li>
<li><p>-d           守护态启动，注意—rm和-d不能同时使用</p>
</li>
</ul>
<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用docker stop来终止一个运行中的容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令格式为：docker stop -t|--time[=10]</span><br></pre></td></tr></table></figure>
<p>该命令首先向容器发送SIGTERM信号，等待一段超时时间（默认为10秒）后，再发送SIGKILL信号来终止容器</p>
<p>当容器中指定的应用终结时，容器也会自动终止。</p>
<p>处于终止状态的容器，可以通过start命令来重新启动</p>
<p>此外，docker restart 命令会将一个运行态的容器先终止，然后再重新启动它</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><h3 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h3><p>这种方法，同一时间只能有一个活动窗口。不建议</p>
<h3 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h3><p>通过exec命令对容器执行操作是最为推荐的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker start 9e708d44e39a</span><br><span class="line">9e708d44e39a</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker exec -it 9e7 /bin/bash</span><br><span class="line">root@9e708d44e39a:/#</span><br></pre></td></tr></table></figure>
<p>比较常用的参数有：</p>
<ul>
<li><p>-i            –interactive=true|false             打开标准输入接受用户输入命令，默认为false。</p>
</li>
<li><p>–privileged=true|false             是否给执行命令以最高权限，默认为false。</p>
</li>
<li><p>-t     –tty=true|false         分配伪终端，默认为false</p>
</li>
<li><p>-u    –user=””         执行命令的用户名或者ID</p>
</li>
</ul>
<h3 id="nsenter工具"><a href="#nsenter工具" class="headerlink" title="nsenter工具"></a>nsenter工具</h3><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><ul>
<li><p>docker ps               查看运行中的容器</p>
</li>
<li><p>docker ps  -a          查看所有容器，包括运行的与停止的</p>
</li>
<li><p>docker ps -qa          查看所有容器ID</p>
</li>
</ul>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用docker rm命令来删除处于终止或者退出状态的容器</p>
<p>命令格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f|--force [-v|--volumes] container [container…]</span><br></pre></td></tr></table></figure>
<p>主要支持的选项包括：</p>
<ul>
<li><p>-f            –force=false     是否强行终止并删除一个运行中的容器</p>
</li>
<li><p>-l            –link=false      删除容器的连接，但是保留容器</p>
</li>
<li><p>-v           –volumes=false       删除容器挂载的数据卷</p>
</li>
</ul>
<p>默认情况下，docker rm命令只能删除处于终止或者退出状态的容器，并不能删除还是处于运行状态的容器。</p>
<p>如果要删除一个运行中的容器，可以添加-f参数。该命令首先向容器发送SIGKILL信号给容器，终止其中的应用，之后强行删除。</p>
<h2 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker export -o test_for_run.tar ce5</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">docker export e81 &gt; test_for_stop.tar</span><br></pre></td></tr></table></figure>
<h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><p>导出的文件可以使用docker import命令导入变成镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import test_for_run.tar – test/ubuntu:v1.0</span><br></pre></td></tr></table></figure>
<p>实际上，既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以用docker import命令来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也更大。此外，从容器快照文件导入时可以重新制定标签等元数据信息</p>
<h1 id="第5章-访问docker仓库"><a href="#第5章-访问docker仓库" class="headerlink" title="第5章 访问docker仓库"></a>第5章 访问docker仓库</h1><p>仓库（repositroy）是集中存放镜像的地方，分为公共仓库和私有仓库。</p>
<p>注意：注册服务器是存放仓库的服务器</p>
<h2 id="docker-hub公共镜像市场"><a href="#docker-hub公共镜像市场" class="headerlink" title="docker hub公共镜像市场"></a>docker hub公共镜像市场</h2><p>默认使用的镜像来源都是docker  hub中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search lnmp</span><br></pre></td></tr></table></figure>
<h2 id="时速云镜像市场"><a href="#时速云镜像市场" class="headerlink" title="时速云镜像市场"></a>时速云镜像市场</h2><h2 id="搭建本地私有仓库"><a href="#搭建本地私有仓库" class="headerlink" title="搭建本地私有仓库"></a>搭建本地私有仓库</h2><h3 id="使用registry镜像创建私有仓库"><a href="#使用registry镜像创建私有仓库" class="headerlink" title="使用registry镜像创建私有仓库"></a>使用registry镜像创建私有仓库</h3><p>安装docker之后，可以通过官方提供的<strong>registry</strong>镜像来简单搭建一套本地私有仓库环境:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure>
<p>它将自动下载并且启动一个registry容器，创建本地的私有仓库服务</p>
<p>在默认情况下，会将仓库创建在容器的/tmp/registry目录下。可以通过-v参数来将镜像文件存放在本地的指定路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000  -v /opt/data/registry:/tmp/registry  registry</span><br></pre></td></tr></table></figure>
<h3 id="管理私有仓库-上传镜像"><a href="#管理私有仓库-上传镜像" class="headerlink" title="管理私有仓库-上传镜像"></a>管理私有仓库-上传镜像</h3><p>因为docker images中的字段，REPOSITORY表示仓库信息，因此，我们在创建了私有仓库之后，要使用镜像，需要对镜像进行tag标签的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker tag ubuntu:14.04 47.93.54.101:5000/test</span><br></pre></td></tr></table></figure>
<p>上述命令解释：</p>
<p>使用tag命令将ubuntu镜像标记为47.93.54.101:5000/test【也就是这个仓库下的】</p>
<p>47.93.54.101:5000是仓库注册服务器，test是仓库名称，test:[name]后面接的是tag信息，没有写的话，默认是latest</p>
<p>接下来使用docker push上传标记的镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker push 47.93.54.101:5000/test</span><br></pre></td></tr></table></figure>
<hr>
<p>注意：</p>
<p>客户端采用https，docker registry未采用https服务，由于服务端没有采用https方式，因此客户端无法使用默认的https形式pull镜像，因此我们要做一些操作</p>
<hr>
<ul>
<li>服务端：</li>
</ul>
<p>在/etc/docker/目录下，创建daemon.json文件。在文件中写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master docker]# cat daemon.json</span><br><span class="line"></span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;47.93.54.101:5000&quot;]&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端</li>
</ul>
<p>在/etc/docker/目录下，创建daemon.json文件。在文件中写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master docker]# cat daemon.json</span><br><span class="line"></span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;47.93.54.101:5000&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>注意：不光服务端要配置，客户端也需要配置</p>
<p>配置完毕之后，我们就可以看到客户端能够正常的拉取我们私有仓库中的镜像</p>
<h1 id="第6章-Docker数据管理"><a href="#第6章-Docker数据管理" class="headerlink" title="第6章 Docker数据管理"></a>第6章 Docker数据管理</h1><p>生产环境中使用docker的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。</p>
<p>容器中管理数据主要有2种方式</p>
<ul>
<li><p>数据卷（data volumes）：容器内数据直接映射到本地主机环境</p>
</li>
<li><p>数据卷容器（data volumes containers）：使用特定容器维护数据卷。</p>
</li>
</ul>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可以供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于linux的mount挂载操作。</p>
<p>数据卷可以提供很多有用的特性：</p>
<ul>
<li><p>数据卷可以在容器之间共享和重用，容器键传递数据将变得高效方便。</p>
</li>
<li><p>对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作。</p>
</li>
<li><p>对数据卷的更新不会影响镜像，解耦了应用和数据</p>
</li>
<li><p>卷会一直存在，直到没有容器使用，可以安全的卸载它。</p>
</li>
</ul>
<h3 id="在容器内创建一个数据卷"><a href="#在容器内创建一个数据卷" class="headerlink" title="在容器内创建一个数据卷"></a>在容器内创建一个数据卷</h3><p>在用docker run命令的时候，使用-v标记可以在容器内创建一个数据卷。多次重复使用-v标记可以创建多个数据卷。</p>
<p>下面使用 training/webapp镜像创建一个web容器，并创建一个数据卷挂载到容器的/webapp目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -P --name web -v /webapp training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>注意：这里是在容器内部创建一个目录，而不是宿主机上创建</p>
<p>-P是将容器服务暴露的端口，是自动映射到本地主机的临时端口       </p>
<h3 id="挂载宿主机目录作为数据卷"><a href="#挂载宿主机目录作为数据卷" class="headerlink" title="挂载宿主机目录作为数据卷"></a>挂载宿主机目录作为数据卷</h3><p>使用-v标记也可以指定挂载一个本地的已有目录到容器中去作为数据卷【推荐方式】</p>
<p>[root@master ~]# docker run -d -P –name web -v /src/webapp:/opt/webapp training/webapp python app.py</p>
<p>上述命令加载主机的/src/webapp目录到容器的/opt/webapp目录</p>
<p>本地目录的路径必须是绝对路径，如果目录不存在，docker会自动创建</p>
<p>注意：docker挂载数据卷的默认权限是读写（rw）,用户也可以通过ro指定为只读</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p><strong>设置为ro</strong>之后，容器内对所挂载数据卷内的数据就无法修改了。</p>
<p> 使用这个功能，在进行一些测试的时候十分方便，比如用户可以将一些程序或者数据放到本地目录中，然后再容器内运行和使用</p>
<h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p>-v标记也可以从主机挂载单个文件到容器中作为数据卷（对应容器中的某一个文件）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run –rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>注意：如果直接挂载一个文件到容器中，使用文件编辑工具，包括vi或者sed等，可能会造成文件inode的概念，从docker 1.1.0版本起，这会导致报错，所以推荐的方式是直接挂载目录。</p>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果用户需要再多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。</p>
<p>首先，创建一个数据卷容器dbdata，并在其中创建一个数据卷挂载到/dbdata：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /dbdata --name dbdata ubuntu</span><br></pre></td></tr></table></figure>
<p>【这个dbdata是在容器内部的一个目录，请注意】</p>
<p>作用是：定义一个数据卷</p>
<p>然后，可以在其他容器中使用–volumes-from来挂载dbdata容器中的数据卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from  dbdata --name db1 ubuntu</span><br></pre></td></tr></table></figure>
<p>在容器dbdata中查看，数据已经同步过来                        </p>
<p>可以多次使用 –volume-from参数来从多个容器挂载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷。</p>
<p>注意：如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时，显式使用docker rm -v命令来指定同时删除关联的容器。</p>
<p>使用数据卷容器可以让用户在容器之间自由地升级和移动数据卷。</p>
<h2 id="利用数据卷容器来迁移"><a href="#利用数据卷容器来迁移" class="headerlink" title="利用数据卷容器来迁移"></a>利用数据卷容器来迁移</h2><p>可以利用数据卷容器对其中的数据卷进行备份、恢复、以实现数据的迁移。</p>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>使用下面的命令来备份dbdata数据卷容器内的数据卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run --volumes-from  dbdata -v $(pwd):/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdata</span><br><span class="line"></span><br><span class="line">tar: Removing leading `/&apos; from member names</span><br><span class="line">/dbdata/</span><br><span class="line">/dbdata/a</span><br><span class="line">/dbdata/db1</span><br></pre></td></tr></table></figure>
<p>命令解析：</p>
<p>首先利用ubuntu镜像创建了一个容器worker，使用–volumes-from dbdata参数来让worker容器挂载dbdata容器的数据卷。</p>
<p>然后使用-v参数，挂载本地的当前目录到worker容器内部的/backup目录。</p>
<p>worker容器启动之后，使用tar命令，将/dbdata目录备份到容器内的/backup目录下，也就是宿主机的当前目录下。即可完成整个备份过程。</p>
<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>数据操作都需要借助容器来完成，需要借助容器来打通一个通道。</p>
<p>恢复数据的思路（这里指的是恢复数据到另一个没有数据的数据卷容器中）：</p>
<ul>
<li><p>创建一个新的数据卷容器</p>
</li>
<li><p>创建一个新的容器，挂载该容器（–volumes-from参数）</p>
</li>
<li><p>挂载本地的目录到/backup下（这时该目录下就会有本地的数据），然后解压其中的数据</p>
</li>
</ul>
<p>命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure>
<h1 id="第7章-端口映射与容器互联"><a href="#第7章-端口映射与容器互联" class="headerlink" title="第7章 端口映射与容器互联"></a>第7章 端口映射与容器互联</h1><p>在实际情况中，是需要多个服务组件容器共同协作的情况，因此往往需要多个容器之间能够互相访问到对方的服务。</p>
<p>除了通过网络来进行访问，docker还提供了两个功能满足服务访问的基本需求：</p>
<ul>
<li><p>一个是允许映射容器内应用的服务端口到本地宿主主机</p>
</li>
<li><p>另一个是互联机制实现多个容器键通过容器名称来来快速访问</p>
</li>
</ul>
<p>在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。</p>
<h2 id="端口映射实现访问容器"><a href="#端口映射实现访问容器" class="headerlink" title="端口映射实现访问容器"></a>端口映射实现访问容器</h2><h3 id="所有接口的随机端口"><a href="#所有接口的随机端口" class="headerlink" title="所有接口的随机端口"></a>所有接口的随机端口</h3><p>可以通过-P或者-p参数来指定端口映射。</p>
<ul>
<li>当使用-P时，映射一个49000-49900的端口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>可以通过docker logs -f [id]来查看应用信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker logs -f 4336a2dbe777</span><br></pre></td></tr></table></figure>
<h3 id="所有接口的指定端口"><a href="#所有接口的指定端口" class="headerlink" title="所有接口的指定端口"></a>所有接口的指定端口</h3><p>命令格式：hostport:containerport</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>使用该命令映射所有接口地址</p>
<p>此时绑定所有接口上的所有地址，将本地的5000端口映射搭配容器的5000端口</p>
<h3 id="指定地址的指定端口"><a href="#指定地址的指定端口" class="headerlink" title="指定地址的指定端口"></a>指定地址的指定端口</h3><p>命令格式：IP:hostport:containerport</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>指定使用本机的哪一个地址进行端口映射</p>
<h3 id="指定地址的任意端口"><a href="#指定地址的任意端口" class="headerlink" title="指定地址的任意端口"></a>指定地址的任意端口</h3><p>命令格式：IP::containerport</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>还可以使用udp标记来指定udp端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -d -p 127.0.0.1::5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure>
<h2 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h2><p>命令语法：docker port 容id  [port]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker port  4336a2dbe777</span><br><span class="line"></span><br><span class="line">5000/tcp -&gt; 0.0.0.0:32773</span><br><span class="line"></span><br><span class="line">[root@master ~]# docker port  4336a2dbe777 5000</span><br><span class="line"></span><br><span class="line">0.0.0.0:32773</span><br></pre></td></tr></table></figure>
<h2 id="互联机制实现便捷互访"><a href="#互联机制实现便捷互访" class="headerlink" title="互联机制实现便捷互访"></a>互联机制实现便捷互访</h2><p>容器的互联（link）是一种让多个容器中应用进行快速交互的方式。他会在源和接受容器之间创建连接关系，接受容器可以通过容器名称快速访问到源容器，而不用指定具体的IP地址。</p>
<h3 id="自定义容器名称"><a href="#自定义容器名称" class="headerlink" title="自定义容器名称"></a>自定义容器名称</h3><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>连接系统通过容器名称来执行，因此需要给每个容器都定义一个名称。</p>
<h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>使用—link参数可以让容器之间安全地进行交互</p>
<p>link参数格式为：–link name:alias</p>
<p>docker通过两种方式为容器公开连接信息。</p>
<ul>
<li><p>更新环境变量</p>
</li>
<li><p>更新/etc/hosts文件。</p>
</li>
</ul>
<p>以下为参考案例：</p>
<p>首先创建一个新的数据库容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master registry]# docker run -d --name db training/postgres</span><br></pre></td></tr></table></figure>
<p>创建一个新的web容器，并将它连接到db容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master registry]# docker run -d -P --name web --link db:db training/webapp python app.py</span><br></pre></td></tr></table></figure>
<p>查看容器之间的连接信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master registry]# docker run --rm --name web2 --link db:db training/webapp env</span><br></pre></td></tr></table></figure>
<p>查看hosts信息(cat /etc/hosts)</p>
<p>可以看到，hosts文件中包含db的信息和自身的配置信息。</p>
<p>以上都是单机中多容器之间的互联，后续还会涉及跨主机之间的容器通信。</p>
<h1 id="第8章-使用dockerfile创建镜像"><a href="#第8章-使用dockerfile创建镜像" class="headerlink" title="第8章 使用dockerfile创建镜像"></a>第8章 使用dockerfile创建镜像</h1><h1 id="第9章-docker网络"><a href="#第9章-docker网络" class="headerlink" title="第9章 docker网络"></a>第9章 docker网络</h1><h1 id="镜像仓库之-Harbor"><a href="#镜像仓库之-Harbor" class="headerlink" title="镜像仓库之-Harbor"></a>镜像仓库之-Harbor</h1><p>github主页：<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">https://github.com/goharbor/harbor</a></p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul>
<li><p><strong>Role based access control</strong>: Users and repositories are organized via ‘projects’ and a user can have different permission for images under a project.</p>
<blockquote>
<p>用户和镜像仓库是通过项目关联起来的，不同用户在该项目下拥有不同的权限</p>
</blockquote>
</li>
<li><p><strong>Policy based image replication</strong>: Images can be replicated (synchronized) between multiple registry instances, with auto-retry on errors. Great for load balancing, high availability, multi-datacenter, hybrid and multi-cloud scenarios.</p>
<blockquote>
<p>镜像将在多个注册实例中复制，实现高可用、负载均衡、多路选择等功能</p>
</blockquote>
</li>
<li><p><strong>Vulnerability Scanning</strong>: Harbor scans images regularly and warns users of vulnerabilities.</p>
<blockquote>
<p>高危扫描：harbor将会在规律的扫描镜像并且提醒用户相关的危险</p>
</blockquote>
</li>
<li><p><strong>LDAP/AD support</strong>: Harbor integrates with existing enterprise LDAP/AD for user authentication and management.</p>
<blockquote>
<p>harbor可以聚合企业现在的LDAP/AD等实现用户认证和管理</p>
</blockquote>
</li>
<li><p><strong>Image deletion &amp; garbage collection</strong>: Images can be deleted and their space can be recycled.</p>
<blockquote>
<p>镜像删除和垃圾收集</p>
</blockquote>
</li>
<li><p><strong>Notary</strong>: Image authenticity can be ensured.</p>
<blockquote>
<p>可以保证镜像的可靠性</p>
</blockquote>
</li>
<li><p><strong>Graphical user portal</strong>: User can easily browse, search repositories and manage projects.</p>
<blockquote>
<p>图形化的用户入口：可以浏览，检索，管理项目</p>
</blockquote>
</li>
<li><p><strong>Auditing</strong>: All the operations to the repositories are tracked.</p>
<blockquote>
<p>审计：所有的操作都可以被追踪</p>
</blockquote>
</li>
<li><p><strong>RESTful API</strong>: RESTful APIs for most administrative operations, easy to integrate with external systems.</p>
<blockquote>
<p>提供api</p>
</blockquote>
</li>
<li><p><strong>Easy deployment</strong>: Provide both an online and offline installer.</p>
<blockquote>
<p>部署简单，提供在线和离线两种安装方式</p>
</blockquote>
</li>
</ul>
<p>### </p>
<h2 id="Architecture-体系结构"><a href="#Architecture-体系结构" class="headerlink" title="Architecture-体系结构"></a>Architecture-体系结构</h2><p><img src="https://camo.githubusercontent.com/e0de62fb4f08efedd2c5abd44786410d3af06c7b/687474703a2f2f7777772e7468696e6b2d666f756e6472792e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30392f61727469636c65315f696d616765322e706e67" alt="img"></p>
<p>As depicted in the above diagram, Harbor comprises 6 components:</p>
<p><strong>Proxy:</strong> Components of Harbor, such as registry, UI and token services, are all behind a reversed proxy. The proxy forwards requests from browsers and Docker clients to various backend services.</p>
<blockquote>
<p>harbor使用代理结构，外部的客户端（浏览器或者docker client）访问调用是通过代理层去实现的</p>
</blockquote>
<p><strong>Registry:</strong> Responsible for storing Docker images and processing Docker push/pull commands. As Harbor needs to enforce access control to images, the Registry will direct clients to a token service to obtain a valid token for each pull or push request.</p>
<blockquote>
<p>注册部分：响应操作docker镜像的请求</p>
<p>harbor为了确保安全性，客户端在调用的时候，需要取得valid token才可以进行操作</p>
</blockquote>
<p><strong>Core services:</strong> Harbor’s core functions, which mainly provides the following services:</p>
<p><strong>UI:</strong> a graphical user interface to help users manage images on the Registry Webhook: Webhook is a mechanism configured in the Registry so that image status changes in the Registry can be populated to the Webhook endpoint of Harbor. Harbor uses webhook to update logs, initiate replications, and some other functions. Token service: Responsible for issuing a token for every docker push/pull command according to a user’s role of a project. If there is no token in a request sent from a Docker client, the Registry will redirect the request to the token service. Database: Database stores the meta data of projects, users, roles, replication policies and images.</p>
<blockquote>
<p>提供一个图形的用户入口，方便用户在注册钩子系统（registry webhook）中管理镜像。</p>
</blockquote>
<p><strong>Job services:</strong> used for image replication, local images can be replicated(synchronized) to other Harbor instances.</p>
<p><strong>Log collector:</strong> Responsible for collecting logs of other modules in a single place.</p>
<h2 id="安装配置harbor"><a href="#安装配置harbor" class="headerlink" title="安装配置harbor"></a>安装配置harbor</h2><p>参考文献：<a href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md" target="_blank" rel="noopener">https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md</a></p>
<h3 id="环境要求："><a href="#环境要求：" class="headerlink" title="环境要求："></a>环境要求：</h3><p>Harbor is deployed as several Docker containers, and, therefore, can be deployed on any Linux distribution that supports Docker. The target host requires Python, Docker, and Docker Compose to be installed.</p>
<p><strong>Hardware</strong></p>
<table>
<thead>
<tr>
<th>Resource</th>
<th>Capacity</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU</td>
<td>minimal 2 CPU</td>
<td>4 CPU is prefered</td>
</tr>
<tr>
<td>Mem</td>
<td>minimal 4GB</td>
<td>8GB is prefered</td>
</tr>
<tr>
<td>Disk</td>
<td>minimal 40GB</td>
<td>160GB is prefered</td>
</tr>
</tbody>
</table>
<p><strong>Software</strong></p>
<table>
<thead>
<tr>
<th>Software</th>
<th>Version</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python</td>
<td>version 2.7 or higher</td>
<td>Note that you may have to install Python on Linux distributions (Gentoo, Arch) that do not come with a Python interpreter installed by default</td>
</tr>
<tr>
<td>Docker engine</td>
<td>version 1.10 or higher</td>
<td>For installation instructions, please refer to: <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a></td>
</tr>
<tr>
<td>Docker Compose</td>
<td>version 1.6.0 or higher</td>
<td>For installation instructions, please refer to: <a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">https://docs.docker.com/compose/install/</a></td>
</tr>
<tr>
<td>Openssl</td>
<td>latest is prefered</td>
<td>Generate certificate and keys for Harbor</td>
</tr>
</tbody>
</table>
<p><strong>Network ports</strong></p>
<table>
<thead>
<tr>
<th>Port</th>
<th>Protocol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>443</td>
<td>HTTPS</td>
<td>Harbor UI and API will accept requests on this port for https protocol</td>
</tr>
<tr>
<td>4443</td>
<td>HTTPS</td>
<td>Connections to the Docker Content Trust service for Harbor, only needed when Notary is enabled</td>
</tr>
<tr>
<td>80</td>
<td>HTTP</td>
<td>Harbor UI and API will accept requests on this port for http protocol</td>
</tr>
</tbody>
</table>
<p>Installation Steps**</p>
<p>The installation steps boil down to the following</p>
<ol>
<li>Download the installer;</li>
<li>Configure <strong>harbor.cfg</strong>;</li>
<li>Run <strong>install.sh</strong> to install and start Harbor;</li>
</ol>
<p>实际操作：</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar xvf harbor-online-installer-&lt;version&gt;.tgz</span><br></pre></td></tr></table></figure>
<p>安装docker-ce</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils   device-mapper-persistent-data   lvm2</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager     --add-repo     https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>
<p>启动docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost tools]# systemctl start  docker</span><br><span class="line">[root@localhost tools]# systemctl enable  docker</span><br></pre></td></tr></table></figure>
<p>安装Docker Compose</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Configuration parameters are located in the file <strong>harbor.cfg</strong></p>
<p>There are two categories of parameters in harbor.cfg, <strong>required parameters</strong> and <strong>optional parameters</strong>.</p>
<ul>
<li><p><strong>required parameters</strong>: These parameters are required to be set in the configuration file. They will take effect if a user updates them in <code>harbor.cfg</code> and run the <code>install.sh</code> script to reinstall Harbor.</p>
</li>
<li><p><strong>optional parameters</strong>: These parameters are optional for updating, i.e. user can leave them as default and update them on Web UI after Harbor is started. If they are set in <code>harbor.cfg</code>, they only take effect in the first launch of Harbor. Subsequent update to these parameters in <code>harbor.cfg</code> will be ignored.</p>
<p><strong>Note:</strong> If you choose to set these parameters via the UI, be sure to do so right after Harbor is started. In particular, you must set the desired <strong>auth_mode</strong> before registering or creating any new users in Harbor. When there are users in the system (besides the default admin user), <strong>auth_mode</strong> cannot be changed.</p>
</li>
</ul>
<p>配置文件中有2种配置内容，一种是必须配置的参数，一种是可选参数</p>
<ul>
<li>可选参数：如果你将可选参数设置在配置文件里面，也可以在安装完毕只有在web UI上进行设置，如果在启动之前配置在配置文件里面，那么当启动之后再在web上修改，那么修改将会是无效的，不会被刷新到配置文件当中。</li>
<li>可选参数：可以再harbor启动之后，在web界面进行更新，如果这些参数是在在配置文件中的，那么不会即时生效。配置文件中的只会在启动之后生效</li>
</ul>
<p>修改完毕之后的配置如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@app028-dev harbor]# less harbor.cfg  | egrep -v &apos;^$|^#&apos;</span><br><span class="line">hostname = dhub-dev.dwbops.com</span><br><span class="line">ui_url_protocol = https</span><br><span class="line">max_job_workers = 3</span><br><span class="line">customize_crt = on</span><br><span class="line">ssl_cert = /data/cert/server.cer</span><br><span class="line">ssl_cert_key = /data/cert/server.key</span><br><span class="line">secretkey_path = /data</span><br><span class="line">admiral_url = NA</span><br><span class="line">log_rotate_count = 50</span><br><span class="line">log_rotate_size = 200M</span><br><span class="line">email_identity =</span><br><span class="line">email_server = smtp.mydomain.com</span><br><span class="line">email_server_port = 25</span><br><span class="line">email_username = sample_admin@mydomain.com</span><br><span class="line">email_password = abc</span><br><span class="line">email_from = admin &lt;sample_admin@mydomain.com&gt;</span><br><span class="line">email_ssl = false</span><br><span class="line">email_insecure = false</span><br><span class="line">harbor_admin_password = dHarbor12345</span><br><span class="line">auth_mode = db_auth</span><br><span class="line">ldap_url = ldaps://ldap.mydomain.com</span><br><span class="line">ldap_basedn = ou=people,dc=mydomain,dc=com</span><br><span class="line">ldap_uid = uid</span><br><span class="line">ldap_scope = 2</span><br><span class="line">ldap_timeout = 5</span><br><span class="line">ldap_verify_cert = true</span><br><span class="line">self_registration = on</span><br><span class="line">token_expiration = 30</span><br><span class="line">project_creation_restriction = everyone</span><br><span class="line">db_host = mysql</span><br><span class="line">db_password = root123</span><br><span class="line">db_port = 3306</span><br><span class="line">db_user = root</span><br><span class="line">redis_url =</span><br><span class="line">clair_db_host = postgres</span><br><span class="line">clair_db_password = password</span><br><span class="line">clair_db_port = 5432</span><br><span class="line">clair_db_username = postgres</span><br><span class="line">clair_db = postgres</span><br><span class="line">uaa_endpoint = uaa.mydomain.org</span><br><span class="line">uaa_clientid = id</span><br><span class="line">uaa_clientsecret = secret</span><br><span class="line">uaa_verify_cert = true</span><br><span class="line">uaa_ca_cert = /path/to/ca.pem</span><br><span class="line">registry_storage_provider_name = filesystem</span><br><span class="line">registry_storage_provider_config =</span><br></pre></td></tr></table></figure>
<p>自己做测试时，将url类型设置成为http，并且将域名设置成为：harbar.wxh.com</p>
<p>修改完配置之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./install.sh</span><br></pre></td></tr></table></figure>
<p>整个的安装过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost harbor]# ./install.sh</span><br><span class="line"></span><br><span class="line">[Step 0]: checking installation environment ...</span><br><span class="line"></span><br><span class="line">Note: docker version: 18.06.1</span><br><span class="line"></span><br><span class="line">Note: docker-compose version: 1.22.0</span><br><span class="line"></span><br><span class="line">[Step 1]: loading Harbor images ...</span><br><span class="line">651f69aef02c: Loading layer [==================================================&gt;]  135.8MB/135.8MB</span><br><span class="line">40a1aad64343: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">3fe2713e4072: Loading layer [==================================================&gt;]  12.16MB/12.16MB</span><br><span class="line">ba3a1eb0e375: Loading layer [==================================================&gt;]   17.3MB/17.3MB</span><br><span class="line">447427ec5e1a: Loading layer [==================================================&gt;]  15.87kB/15.87kB</span><br><span class="line">4ccb4026663c: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">16faa95946a1: Loading layer [==================================================&gt;]  29.46MB/29.46MB</span><br><span class="line">Loaded image: vmware/notary-server-photon:v0.5.1-v1.4.0</span><br><span class="line">fa7ba9fd42c9: Loading layer [==================================================&gt;]  10.95MB/10.95MB</span><br><span class="line">4e400f9ae23e: Loading layer [==================================================&gt;]   17.3MB/17.3MB</span><br><span class="line">2802fb27c88b: Loading layer [==================================================&gt;]  15.87kB/15.87kB</span><br><span class="line">e6367a4e1e1e: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">8ece8dfcdd98: Loading layer [==================================================&gt;]  28.24MB/28.24MB</span><br><span class="line">Loaded image: vmware/notary-signer-photon:v0.5.1-v1.4.0</span><br><span class="line">a7dd1a8afcaf: Loading layer [==================================================&gt;]  396.7MB/396.7MB</span><br><span class="line">05adebbe496f: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">86eb534949fa: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">d7f127c69380: Loading layer [==================================================&gt;]   7.68kB/7.68kB</span><br><span class="line">5ac1c4dc5ee9: Loading layer [==================================================&gt;]  1.536kB/1.536kB</span><br><span class="line">d0bec56b5b1a: Loading layer [==================================================&gt;]  9.728kB/9.728kB</span><br><span class="line">4bbe83860556: Loading layer [==================================================&gt;]   2.56kB/2.56kB</span><br><span class="line">e526f9e6769f: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">Loaded image: vmware/harbor-db:v1.4.0</span><br><span class="line">1cff102bbda2: Loading layer [==================================================&gt;]  154.1MB/154.1MB</span><br><span class="line">04c9f3e07de1: Loading layer [==================================================&gt;]  10.75MB/10.75MB</span><br><span class="line">7b6c7bf54f5c: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">42f8acdb7fe3: Loading layer [==================================================&gt;]  48.13kB/48.13kB</span><br><span class="line">5b6299d0a1df: Loading layer [==================================================&gt;]   10.8MB/10.8MB</span><br><span class="line">Loaded image: vmware/clair-photon:v2.0.1-v1.4.0</span><br><span class="line">6534131f457c: Loading layer [==================================================&gt;]  94.76MB/94.76MB</span><br><span class="line">73f582101e4b: Loading layer [==================================================&gt;]  6.656kB/6.656kB</span><br><span class="line">86d847823c48: Loading layer [==================================================&gt;]  6.656kB/6.656kB</span><br><span class="line">Loaded image: vmware/postgresql-photon:v1.4.0</span><br><span class="line">5cd250d5a352: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">ad3fd52b54f3: Loading layer [==================================================&gt;]  14.99MB/14.99MB</span><br><span class="line">13b1e24cc368: Loading layer [==================================================&gt;]  14.99MB/14.99MB</span><br><span class="line">Loaded image: vmware/harbor-adminserver:v1.4.0</span><br><span class="line">c26c69706710: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">223f6fe02cc8: Loading layer [==================================================&gt;]  23.45MB/23.45MB</span><br><span class="line">1fc843c8698a: Loading layer [==================================================&gt;]  7.168kB/7.168kB</span><br><span class="line">e09293610ee7: Loading layer [==================================================&gt;]  10.39MB/10.39MB</span><br><span class="line">d59f9780b1d8: Loading layer [==================================================&gt;]  23.44MB/23.44MB</span><br><span class="line">Loaded image: vmware/harbor-ui:v1.4.0</span><br><span class="line">dd4753242e59: Loading layer [==================================================&gt;]  73.07MB/73.07MB</span><br><span class="line">95aed61ca251: Loading layer [==================================================&gt;]  3.584kB/3.584kB</span><br><span class="line">1864f9818562: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">da2a19f80b81: Loading layer [==================================================&gt;]  4.096kB/4.096kB</span><br><span class="line">058531639e75: Loading layer [==================================================&gt;]  3.584kB/3.584kB</span><br><span class="line">a84e69fb619b: Loading layer [==================================================&gt;]  10.24kB/10.24kB</span><br><span class="line">Loaded image: vmware/harbor-log:v1.4.0</span><br><span class="line">b1056051f246: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">07678065e08b: Loading layer [==================================================&gt;]  19.19MB/19.19MB</span><br><span class="line">a2d9bdb8f5fb: Loading layer [==================================================&gt;]  19.19MB/19.19MB</span><br><span class="line">Loaded image: vmware/harbor-jobservice:v1.4.0</span><br><span class="line">7f58ce57cd5e: Loading layer [==================================================&gt;]  4.805MB/4.805MB</span><br><span class="line">Loaded image: vmware/nginx-photon:v1.4.0</span><br><span class="line">4c8965978b77: Loading layer [==================================================&gt;]  23.24MB/23.24MB</span><br><span class="line">1466c942edde: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">ac5c17331735: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">86824c7c466a: Loading layer [==================================================&gt;]  2.048kB/2.048kB</span><br><span class="line">fd3bd0e70d67: Loading layer [==================================================&gt;]   22.8MB/22.8MB</span><br><span class="line">b02195d77636: Loading layer [==================================================&gt;]   22.8MB/22.8MB</span><br><span class="line">Loaded image: vmware/registry-photon:v2.6.2-v1.4.0</span><br><span class="line">Loaded image: vmware/photon:1.0</span><br><span class="line">Loaded image: vmware/mariadb-photon:v1.4.0</span><br><span class="line">454c81edbd3b: Loading layer [==================================================&gt;]  135.2MB/135.2MB</span><br><span class="line">e99db1275091: Loading layer [==================================================&gt;]  395.4MB/395.4MB</span><br><span class="line">051e4ee23882: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">6cca4437b6f6: Loading layer [==================================================&gt;]  9.216kB/9.216kB</span><br><span class="line">1d48fc08c8bc: Loading layer [==================================================&gt;]   7.68kB/7.68kB</span><br><span class="line">0419724fd942: Loading layer [==================================================&gt;]  1.536kB/1.536kB</span><br><span class="line">526b2156bd7a: Loading layer [==================================================&gt;]  637.8MB/637.8MB</span><br><span class="line">9ebf6900ecbd: Loading layer [==================================================&gt;]  78.34kB/78.34kB</span><br><span class="line">Loaded image: vmware/harbor-db-migrator:1.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Step 2]: preparing environment ...</span><br><span class="line">Generated and saved secret to file: /data/secretkey</span><br><span class="line">Generated configuration file: ./common/config/nginx/nginx.conf</span><br><span class="line">Generated configuration file: ./common/config/adminserver/env</span><br><span class="line">Generated configuration file: ./common/config/ui/env</span><br><span class="line">Generated configuration file: ./common/config/registry/config.yml</span><br><span class="line">Generated configuration file: ./common/config/db/env</span><br><span class="line">Generated configuration file: ./common/config/jobservice/env</span><br><span class="line">Generated configuration file: ./common/config/log/logrotate.conf</span><br><span class="line">Generated configuration file: ./common/config/jobservice/app.conf</span><br><span class="line">Generated configuration file: ./common/config/ui/app.conf</span><br><span class="line">Generated certificate, key file: ./common/config/ui/private_key.pem, cert file: ./common/config/registry/root.crt</span><br><span class="line">The configuration files are ready, please use docker-compose to start the service.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Step 3]: checking existing instance of Harbor ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Step 4]: starting Harbor ...</span><br><span class="line">Creating network &quot;harbor_harbor&quot; with the default driver</span><br><span class="line">Creating harbor-log ... done</span><br><span class="line">Creating harbor-db          ... done</span><br><span class="line">Creating registry           ... done</span><br><span class="line">Creating harbor-adminserver ... done</span><br><span class="line">Creating harbor-ui          ... done</span><br><span class="line">Creating nginx              ... done</span><br><span class="line">Creating harbor-jobservice  ... done</span><br><span class="line"></span><br><span class="line">✔ ----Harbor has been installed and started successfully.----</span><br><span class="line"></span><br><span class="line">Now you should be able to visit the admin portal at http://harbar.wxh.com.</span><br><span class="line">For more details, please visit https://github.com/vmware/harbor .</span><br><span class="line"></span><br><span class="line">[root@localhost harbor]#</span><br></pre></td></tr></table></figure>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h5 id="Required-parameters"><a href="#Required-parameters" class="headerlink" title="Required parameters:"></a>Required parameters:</h5><ul>
<li><p><strong>hostname</strong>: The target host’s hostname, which is used to access the UI and the registry service. It should be the IP address or the fully qualified domain name (FQDN) of your target machine, e.g., <code>192.168.1.10</code> or <code>reg.yourdomain.com</code>. <em>Do NOT use localhost or 127.0.0.1 for the hostname - the registry service needs to be accessible by external clients!</em></p>
<blockquote>
<p><strong>hostname一般配置为域名</strong>,也就是整个harbor的入口</p>
</blockquote>
</li>
<li><p><strong>ui_url_protocol</strong>: (<strong>http</strong> or <strong>https</strong>. Default is <strong>http</strong>) The protocol used to access the UI and the token/notification service. If Notary is enabled, this parameter has to be <em>https</em>. By default, this is <em>http</em>. To set up the https protocol, refer to <strong>Configuring Harbor with HTTPS Access</strong>.</p>
<blockquote>
<p><strong>走HTT还是HTTPS</strong></p>
</blockquote>
</li>
<li><p><strong>db_password</strong>: The root password for the MySQL database used for <strong>db_auth</strong>. <em>Change this password for any production use!</em></p>
</li>
<li><p><strong>max_job_workers</strong>: (default value is <strong>3</strong>) The maximum number of replication workers in job service. For each image replication job, a worker synchronizes all tags of a repository to the remote destination. Increasing this number allows more concurrent replication jobs in the system. However, since each worker consumes a certain amount of network/CPU/IO resources, please carefully pick the value of this attribute based on the hardware resource of the host.</p>
<blockquote>
<p><strong>做复制工作的进程数量，默认3个，这些进程，将这些镜像同步到远端的存储中</strong></p>
<p>每个进程都需要消耗系统的资源，因此合理设置数量</p>
</blockquote>
</li>
<li><p><strong>customize_crt</strong>: (<strong>on</strong> or <strong>off</strong>. Default is <strong>on</strong>) When this attribute is <strong>on</strong>, the prepare script creates private key and root certificate for the generation/verification of the registry’s token. Set this attribute to <strong>off</strong> when the key and root certificate are supplied by external sources. Refer to <a href="https://github.com/goharbor/harbor/blob/master/docs/customize_token_service.md" target="_blank" rel="noopener">Customize Key and Certificate of Harbor Token Service</a> for more info.</p>
</li>
<li><p><strong>ssl_cert</strong>: The path of SSL certificate, it’s applied only when the protocol is set to https</p>
</li>
<li><p><strong>ssl_cert_key</strong>: The path of SSL key, it’s applied only when the protocol is set to https</p>
</li>
<li><p><strong>secretkey_path</strong>: The path of key for encrypt or decrypt the password of a remote registry in a replication policy.</p>
</li>
<li><p><strong>log_rotate_count</strong>: Log files are rotated <strong>log_rotate_count</strong> times before being removed. If count is 0, old versions are removed rather than rotated.</p>
</li>
<li><p><strong>log_rotate_size</strong>: Log files are rotated only if they grow bigger than <strong>log_rotate_size</strong> bytes. If size is followed by k, the size is assumed to be in kilobytes. If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G are all valid.</p>
</li>
</ul>
<h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><h3 id="上传镜像-1"><a href="#上传镜像-1" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>push的格式为：docker push reg.yourdomain.com/myproject/myrepo:mytag</p>
<p>注意首先需要登录</p>
<p>将要上传的镜像打上标志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag hello-world harbar.wxh.com/apps/hello-world</span><br><span class="line"></span><br><span class="line">docker push harbar.wxh.com/apps/hello-world</span><br></pre></td></tr></table></figure>
<p>这种上传的话，默认是打上latest的标志</p>
<p>打上指定的标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag hello-world harbar.wxh.com/apps/hello-world:v1</span><br><span class="line">docker push harbar.wxh.com/apps/hello-world:v1</span><br></pre></td></tr></table></figure>
<h2 id="harbor镜像删除"><a href="#harbor镜像删除" class="headerlink" title="harbor镜像删除"></a>harbor镜像删除</h2><p>在web页面上删除镜像实际上只是执行的软删除，因为镜像存在很强的文件系统依赖关系</p>
<p>Harbor的UI界面上先删除镜像，但这个操作并没有删除磁盘上存放的镜像文件，只是镜像文件manifest的映射关系，还需要通过GC来删除。</p>
<p><strong>CAUTION: If both tag A and tag B refer to the same image, after deleting tag A, B will also get deleted. if you enabled content trust, you need to use notary command line tool to delete the tag’s signature before you delete an image.</strong></p>
<p>注意，如果标签A和B都指向都一个镜像（比如hello-world的2个镜像），那么删除一个之后，另外一个也会消失</p>
<p>先停止Harbor：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure>
<p>通过带有–dry-run选项，可以<strong>查看</strong>到将要删除的镜像文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name gc --rm --volumes-from registry vmware/registry:2.6.2-photon garbage-collect --dry-run /etc/registry/config.yml1</span><br></pre></td></tr></table></figure>
<p>不带–dry-run选项，直接<strong>执行删除</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name gc --rm --volumes-from registry vmware/registry:2.6.2-photon garbage-collect /etc/registry/config.yml1</span><br></pre></td></tr></table></figure>
<p>再启动Harbor：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose start</span><br></pre></td></tr></table></figure>
<h3 id="使用harbor-go-client"><a href="#使用harbor-go-client" class="headerlink" title="使用harbor-go-client"></a>使用harbor-go-client</h3><p>项目地址：<a href="https://github.com/moooofly/harbor-go-client" target="_blank" rel="noopener">https://github.com/moooofly/harbor-go-client</a></p>
<p>操作步骤：</p>
<p>下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/moooofly/harbor-go-client</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>在执行make的时候，可能会存在很多的依赖关系</p>
<p>有以下依赖关系需要解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/alecthomas/gometalinter</span><br></pre></td></tr></table></figure>
<h3 id="镜像清理策略"><a href="#镜像清理策略" class="headerlink" title="镜像清理策略"></a>镜像清理策略</h3><p>需求：</p>
<ul>
<li><p>暂时不做删除 repo 的处理【这部分手动处理】</p>
</li>
<li><p>保留 60 天内创建的所有 tag ，在 60 天之前创建的 tag ，额外保留 10 个；</p>
</li>
<li><p>标签数只有 1的镜像，不清理</p>
</li>
<li>保留最后一次更新的tag，有些image比较稳定，有可能超过60天都没有修改，但是却一直在用</li>
<li>针对一些特殊的（比如每天5个tag的镜像，那么60天就有300个），这个单独特殊处理</li>
</ul>
<p>最终：</p>
<ul>
<li>针对 tag ：保留 60 天内创建的所有 tag ，在 60 天之前创建的 tag ，额外保留 10 个；</li>
<li>针对 repo ：暂时不做删除 repo 的处理（不太好确定 repo 是否还在使用，理论上讲每个 repo 下至少应该有一个 tag 是被需要的；若打算删除，则建议 repo 负责人自行进行删除操作）；</li>
<li>私有仓库暂时不做处理；</li>
</ul>
<p><strong>具体实现：</strong></p>
<ul>
<li>harbor 主要概念的关系：1 个 project -&gt; 每个 project 下具有 N 种不同的 repos &gt; 每个 repo 下具有 M 个 tags</li>
<li>project 有创建时间，但这个对我们的处理策略来说没有用处；</li>
<li>repo 有创建时间和 pull 时间，该 pull 时间对应 repo 下任意一个 tag ，最新一次，被拉取的那个时间</li>
<li>tag 有创建时间，但没有针对 tag 的 pull 时间（harbor 中定义的数据结构中不支持）；</li>
</ul>
<p>因此</p>
<ul>
<li>保留 60 天内的 tag”，这个根据 tag 的创建时间<ul>
<li>“60 天之外的看 pull 的数量，关注 60 天之外是不是被 pull 过”，由于 pull 数量是针对 repo 整体的，无法对应到具体的 tag ，即在 API 层面无法方便的知道哪些 tag 最近被 pull 过（当然如果一定要做，就只能沟通分析 log 来搞，性价比不高），所以，只能根据 tag 创建时间的先后，“武断”的认为，后创建的 tag 应该是用户最想保留的；</li>
</ul>
</li>
<li>“如果没有被 pull 过，则只保留最新 5 个 tag”，根据上一条的说明，某个 tag 是否被 pull 过是无法知道的，但目前可以做到根据 tag 的创建时间进行保留（满足保留最新 N 个需求）；</li>
</ul>
<h2 id="harbor镜像复制"><a href="#harbor镜像复制" class="headerlink" title="harbor镜像复制"></a>harbor镜像复制</h2><p>参考链接：<a href="https://github.com/goharbor/harbor/blob/master/docs/user_guide.md" target="_blank" rel="noopener">https://github.com/goharbor/harbor/blob/master/docs/user_guide.md</a></p>
<p>该功能是面向项目的，系统管理员设置之后，匹配了过滤规则的项目，在触发了事先定义好的触发条件之后，这些项目就会被复制到远程的另一个仓库中。</p>
<p>如果在远程镜像仓库中，改项目不存在，那么就会自动创建这个项目</p>
<p>如果在远程仓库中，这个项目已经存在，并且配置的用户对这个项目没有写的权限，那么这个操作将会失败</p>
<p>注意：用户信息不会被复制</p>
<p>因为网络的原因，在复制传输的过程中，可能会出现一些延迟。如果复制job是因为网络原因而导致失败的，那么这个任务将会在几分钟之后再次尝试，一直尝试，知道网络恢复正常。</p>
<p>注意：因为api等原因，不同版本的镜像复制可能会失败，所以尽量使用同一个版本。</p>
<h3 id="创建复制规则"><a href="#创建复制规则" class="headerlink" title="创建复制规则"></a>创建复制规则</h3><p>Click <code>NEW REPLICATION RULE</code> under <code>Administration-&gt;Replications</code></p>
<p>注意，在创建endpoint的时候，直接test connection是会报错：“harbor Failed to ping endpoint”</p>
<p>这是因为网络问题导致，在内网访问的时候，还需要额外的添加hosts文件，详见注意事项</p>
<p>注意：在创建完毕之后，默认不会执行同步，需要手动点击一下replication</p>
<h3 id="删除replication规则"><a href="#删除replication规则" class="headerlink" title="删除replication规则"></a>删除replication规则</h3><p>Only rules which have no pending/running/retrying jobs can be deleted.</p>
<p>只有当改规则下面没有正在运行或者等待运行或者正在重传的jobs时，才可以删除</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在创建endpoint的时候，如果事先没有再容器内存配置对端的地址，那么会报连接错误</p>
<p>官方的issues：<a href="https://github.com/goharbor/harbor/issues/2221" target="_blank" rel="noopener">https://github.com/goharbor/harbor/issues/2221</a></p>
<h2 id="Harborclient"><a href="#Harborclient" class="headerlink" title="Harborclient"></a>Harborclient</h2><p>详见页面：<a href="https://github.com/int32bit/python-harborclient/blob/master/README.zh.md" target="_blank" rel="noopener">https://github.com/int32bit/python-harborclient/blob/master/README.zh.md</a></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>1&gt; Why can not push image 192.168.0.1/hello-world:latest to Harbor?</p>
<p>[<strong>A</strong>] At least two namespaces are needed for repository name in Harbor, so tag the image as 192.168.0.1/project_name/hello-world:latest should fix this. (Create the project on the web page first)</p>
<p>也就是说，在上传镜像的时候，应该是下面这种格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.0.1/project_name/hello-world:latest</span><br></pre></td></tr></table></figure>
<p>因为在harbor中有项目的概念，也就是：访问地址/项目名称/镜像名称/版本标签</p>
<p>在使用dockerhub等进行镜像仓库的时候，用户名/id就是项目名称，因此不能创建多个项目名称，因为这种方式适合个人，但是不适用于企业。</p>
<p>企业中需要根据不同的项目类型进行分类存储，例如：apps、中间件等</p>
<h3 id="证书问题"><a href="#证书问题" class="headerlink" title="证书问题"></a>证书问题</h3><p>证书生成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -sha256 -x509 -days 365 -nodes -newkey rsa:4096 -keyout  harbar.wxh.com.key -out harbar.wxh.com.crt</span><br></pre></td></tr></table></figure>
<p>注意，一些name的字段要配置成为域名harbar.wxh.com</p>
<p>生成之后，将证书存放到指定位置，然后修改配置文件指向这些证书文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">less harbor.cfg  | egrep -v &quot;^$|^#&quot;</span><br><span class="line">ssl_cert = /data/cert/harbar.wxh.com.crt</span><br><span class="line">ssl_cert_key = /data/cert/harbar.wxh.com.key</span><br></pre></td></tr></table></figure>
<p>然后需要对docker进行一些配置</p>
<p>mkdir -p /etc/docker/certs.d/harbar.wxh.com</p>
<p>然后将上面的文件复制到这个目录之下，并将/data/cert/harbar.wxh.com.crt重命名为/data/cert/harbar.wxh.com.cert</p>
<h2 id="文件创建为目录问题"><a href="#文件创建为目录问题" class="headerlink" title="文件创建为目录问题"></a>文件创建为目录问题</h2><p>/data1/harbor/data/secretkey  </p>
<p>secretkey为文件，而不是目录，在一些时候可能会出现这种问题，当出现这种问题的时候，将该目录清空，然后重新安装即可</p>
<h1 id="汇总-docker常用命令"><a href="#汇总-docker常用命令" class="headerlink" title="汇总-docker常用命令"></a>汇总-docker常用命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyname .  # Create image using this directory&apos;s Dockerfile</span><br><span class="line">docker run -p 4000:80 friendlyname  # Run &quot;friendlyname&quot; mapping port 4000 to 80</span><br><span class="line">docker run -d -p 4000:80 friendlyname         # Same thing, but in detached mode</span><br><span class="line">docker container ls                                # List all running containers</span><br><span class="line">docker container ls -a             # List all containers, even those not running</span><br><span class="line">docker container stop &lt;hash&gt;           # Gracefully stop the specified container</span><br><span class="line">docker container kill &lt;hash&gt;         # Force shutdown of the specified container</span><br><span class="line">docker container rm &lt;hash&gt;        # Remove specified container from this machine</span><br><span class="line">docker container rm $(docker container ls -a -q)         # Remove all containers</span><br><span class="line">docker image ls -a                             # List all images on this machine</span><br><span class="line">docker image rm &lt;image id&gt;            # Remove specified image from this machine</span><br><span class="line">docker image rm $(docker image ls -a -q)   # Remove all images from this machine</span><br><span class="line">docker login             # Log in this CLI session using your Docker credentials</span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  # Tag &lt;image&gt; for upload to registry</span><br><span class="line">docker push username/repository:tag            # Upload tagged image to registry</span><br><span class="line">docker run username/repository:tag                   # Run image from a registry</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/wechatpay.jpg" alt="XiaoHua WANG 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/alipay.jpg" alt="XiaoHua WANG 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Docker/" rel="tag"># Docker</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/20/编程语言/Python/老男孩视频学习笔记/day06-面向对象编程/" rel="next" title="day06-面向对象编程">
                <i class="fa fa-chevron-left"></i> day06-面向对象编程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/26/IT科学技术知识体系结构-Linux运维方向/Linux基础知识/Linux系统管理/ubuntu设置ssh服务/" rel="prev" title="ubuntu设置ssh服务">
                ubuntu设置ssh服务 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzg1NC8xMDQwNw=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/touxiang.jpg"
                alt="XiaoHua WANG" />
            
              <p class="site-author-name" itemprop="name">XiaoHua WANG</p>
              <p class="site-description motion-element" itemprop="description">Focus on Linux operations and development.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">49</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第1章-基础知识"><span class="nav-number">1.</span> <span class="nav-text">第1章 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker介绍"><span class="nav-number">1.1.</span> <span class="nav-text">Docker介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有关虚拟化"><span class="nav-number">1.1.1.</span> <span class="nav-text">有关虚拟化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么docker"><span class="nav-number">1.1.2.</span> <span class="nav-text">什么docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从LXC从到Docker"><span class="nav-number">1.1.3.</span> <span class="nav-text">从LXC从到Docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Docker的好处"><span class="nav-number">1.1.4.</span> <span class="nav-text">使用Docker的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker在开发和运维中的优势"><span class="nav-number">1.1.5.</span> <span class="nav-text">Docker在开发和运维中的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker与虚拟机的比较"><span class="nav-number">1.1.6.</span> <span class="nav-text">Docker与虚拟机的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker和核心价值"><span class="nav-number">1.1.7.</span> <span class="nav-text">Docker和核心价值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker的应用场景"><span class="nav-number">1.1.8.</span> <span class="nav-text">Docker的应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心概念-名词解释"><span class="nav-number">1.2.</span> <span class="nav-text">核心概念/名词解释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三剑客之镜像-Image"><span class="nav-number">1.2.1.</span> <span class="nav-text">三剑客之镜像-Image</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三剑客之容器-Container"><span class="nav-number">1.2.2.</span> <span class="nav-text">三剑客之容器-Container</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三剑客之仓库-Repository"><span class="nav-number">1.2.3.</span> <span class="nav-text">三剑客之仓库-Repository</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-EE和Docker-CE"><span class="nav-number">1.2.4.</span> <span class="nav-text">Docker-EE和Docker-CE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第2章-安装配置"><span class="nav-number">2.</span> <span class="nav-text">第2章 安装配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装Docker"><span class="nav-number">2.1.</span> <span class="nav-text">安装Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#系统要求"><span class="nav-number">2.1.1.</span> <span class="nav-text">系统要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#centos环境下安装docker"><span class="nav-number">2.1.2.</span> <span class="nav-text">centos环境下安装docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ubuntu环境安装docker"><span class="nav-number">2.1.3.</span> <span class="nav-text">ubuntu环境安装docker</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置Docker服务"><span class="nav-number">2.2.</span> <span class="nav-text">配置Docker服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#权限配置"><span class="nav-number">2.2.1.</span> <span class="nav-text">权限配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置文件不存在问题"><span class="nav-number">2.2.2.</span> <span class="nav-text">配置文件不存在问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cd-启动Docker服务"><span class="nav-number">2.3.</span> <span class="nav-text">cd 启动Docker服务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第3章-使用Docker镜像"><span class="nav-number">3.</span> <span class="nav-text">第3章 使用Docker镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取镜像"><span class="nav-number">3.1.</span> <span class="nav-text">获取镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#镜像的分层特性"><span class="nav-number">3.1.1.</span> <span class="nav-text">镜像的分层特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#镜像的重名问题"><span class="nav-number">3.1.2.</span> <span class="nav-text">镜像的重名问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行镜像"><span class="nav-number">3.2.</span> <span class="nav-text">运行镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看镜像信息"><span class="nav-number">3.3.</span> <span class="nav-text">查看镜像信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用images命令列出镜像"><span class="nav-number">3.3.1.</span> <span class="nav-text">使用images命令列出镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用tag命令添加镜像标签"><span class="nav-number">3.3.2.</span> <span class="nav-text">使用tag命令添加镜像标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用inspect命令查看详细信息"><span class="nav-number">3.3.3.</span> <span class="nav-text">使用inspect命令查看详细信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用history命令查看镜像历史"><span class="nav-number">3.3.4.</span> <span class="nav-text">使用history命令查看镜像历史</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜寻镜像"><span class="nav-number">3.4.</span> <span class="nav-text">搜寻镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除镜像"><span class="nav-number">3.5.</span> <span class="nav-text">删除镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用标签删除镜像"><span class="nav-number">3.5.1.</span> <span class="nav-text">使用标签删除镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用镜像ID删除镜像"><span class="nav-number">3.5.2.</span> <span class="nav-text">使用镜像ID删除镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建镜像"><span class="nav-number">3.6.</span> <span class="nav-text">创建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于已有镜像的容器创建"><span class="nav-number">3.6.1.</span> <span class="nav-text">基于已有镜像的容器创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于本地模板导入"><span class="nav-number">3.6.2.</span> <span class="nav-text">基于本地模板导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于dockerfile创建"><span class="nav-number">3.6.3.</span> <span class="nav-text">基于dockerfile创建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#官方案例"><span class="nav-number">3.6.3.0.1.</span> <span class="nav-text">官方案例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#载入和导出镜像"><span class="nav-number">3.7.</span> <span class="nav-text">载入和导出镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#导出镜像"><span class="nav-number">3.7.1.</span> <span class="nav-text">导出镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#载入镜像"><span class="nav-number">3.7.2.</span> <span class="nav-text">载入镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上传和下载镜像"><span class="nav-number">3.8.</span> <span class="nav-text">上传和下载镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#登录"><span class="nav-number">3.8.1.</span> <span class="nav-text">登录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上传镜像"><span class="nav-number">3.8.2.</span> <span class="nav-text">上传镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下载镜像"><span class="nav-number">3.8.3.</span> <span class="nav-text">下载镜像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第4章-使用Docker容器"><span class="nav-number">4.</span> <span class="nav-text">第4章 使用Docker容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建启动容器"><span class="nav-number">4.1.</span> <span class="nav-text">创建启动容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#新建容器"><span class="nav-number">4.1.1.</span> <span class="nav-text">新建容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动容器"><span class="nav-number">4.1.2.</span> <span class="nav-text">启动容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新建并启动容器"><span class="nav-number">4.1.3.</span> <span class="nav-text">新建并启动容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#守护态运行"><span class="nav-number">4.1.4.</span> <span class="nav-text">守护态运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器参数"><span class="nav-number">4.1.5.</span> <span class="nav-text">容器参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终止容器"><span class="nav-number">4.2.</span> <span class="nav-text">终止容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进入容器"><span class="nav-number">4.3.</span> <span class="nav-text">进入容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#attach"><span class="nav-number">4.3.1.</span> <span class="nav-text">attach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exec命令"><span class="nav-number">4.3.2.</span> <span class="nav-text">exec命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nsenter工具"><span class="nav-number">4.3.3.</span> <span class="nav-text">nsenter工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看容器"><span class="nav-number">4.4.</span> <span class="nav-text">查看容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除容器"><span class="nav-number">4.5.</span> <span class="nav-text">删除容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#导入和导出容器"><span class="nav-number">4.6.</span> <span class="nav-text">导入和导出容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#导出容器"><span class="nav-number">4.6.1.</span> <span class="nav-text">导出容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导入容器"><span class="nav-number">4.6.2.</span> <span class="nav-text">导入容器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第5章-访问docker仓库"><span class="nav-number">5.</span> <span class="nav-text">第5章 访问docker仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#docker-hub公共镜像市场"><span class="nav-number">5.1.</span> <span class="nav-text">docker hub公共镜像市场</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时速云镜像市场"><span class="nav-number">5.2.</span> <span class="nav-text">时速云镜像市场</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搭建本地私有仓库"><span class="nav-number">5.3.</span> <span class="nav-text">搭建本地私有仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用registry镜像创建私有仓库"><span class="nav-number">5.3.1.</span> <span class="nav-text">使用registry镜像创建私有仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管理私有仓库-上传镜像"><span class="nav-number">5.3.2.</span> <span class="nav-text">管理私有仓库-上传镜像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第6章-Docker数据管理"><span class="nav-number">6.</span> <span class="nav-text">第6章 Docker数据管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据卷"><span class="nav-number">6.1.</span> <span class="nav-text">数据卷</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在容器内创建一个数据卷"><span class="nav-number">6.1.1.</span> <span class="nav-text">在容器内创建一个数据卷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#挂载宿主机目录作为数据卷"><span class="nav-number">6.1.2.</span> <span class="nav-text">挂载宿主机目录作为数据卷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#挂载一个本地主机文件作为数据卷"><span class="nav-number">6.1.3.</span> <span class="nav-text">挂载一个本地主机文件作为数据卷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据卷容器"><span class="nav-number">6.2.</span> <span class="nav-text">数据卷容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用数据卷容器来迁移"><span class="nav-number">6.3.</span> <span class="nav-text">利用数据卷容器来迁移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#备份"><span class="nav-number">6.3.1.</span> <span class="nav-text">备份</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#恢复"><span class="nav-number">6.3.2.</span> <span class="nav-text">恢复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第7章-端口映射与容器互联"><span class="nav-number">7.</span> <span class="nav-text">第7章 端口映射与容器互联</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#端口映射实现访问容器"><span class="nav-number">7.1.</span> <span class="nav-text">端口映射实现访问容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#所有接口的随机端口"><span class="nav-number">7.1.1.</span> <span class="nav-text">所有接口的随机端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#所有接口的指定端口"><span class="nav-number">7.1.2.</span> <span class="nav-text">所有接口的指定端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定地址的指定端口"><span class="nav-number">7.1.3.</span> <span class="nav-text">指定地址的指定端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定地址的任意端口"><span class="nav-number">7.1.4.</span> <span class="nav-text">指定地址的任意端口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看映射端口配置"><span class="nav-number">7.2.</span> <span class="nav-text">查看映射端口配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互联机制实现便捷互访"><span class="nav-number">7.3.</span> <span class="nav-text">互联机制实现便捷互访</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义容器名称"><span class="nav-number">7.3.1.</span> <span class="nav-text">自定义容器名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器互联"><span class="nav-number">7.3.2.</span> <span class="nav-text">容器互联</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第8章-使用dockerfile创建镜像"><span class="nav-number">8.</span> <span class="nav-text">第8章 使用dockerfile创建镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第9章-docker网络"><span class="nav-number">9.</span> <span class="nav-text">第9章 docker网络</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#镜像仓库之-Harbor"><span class="nav-number">10.</span> <span class="nav-text">镜像仓库之-Harbor</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Features"><span class="nav-number">10.1.</span> <span class="nav-text">Features</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Architecture-体系结构"><span class="nav-number">10.2.</span> <span class="nav-text">Architecture-体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装配置harbor"><span class="nav-number">10.3.</span> <span class="nav-text">安装配置harbor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#环境要求："><span class="nav-number">10.3.1.</span> <span class="nav-text">环境要求：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下载"><span class="nav-number">10.3.2.</span> <span class="nav-text">下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置"><span class="nav-number">10.3.3.</span> <span class="nav-text">配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置文件"><span class="nav-number">10.4.</span> <span class="nav-text">配置文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Required-parameters"><span class="nav-number">10.4.0.0.1.</span> <span class="nav-text">Required parameters:</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#镜像操作"><span class="nav-number">10.5.</span> <span class="nav-text">镜像操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#上传镜像-1"><span class="nav-number">10.5.1.</span> <span class="nav-text">上传镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#harbor镜像删除"><span class="nav-number">10.6.</span> <span class="nav-text">harbor镜像删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用harbor-go-client"><span class="nav-number">10.6.1.</span> <span class="nav-text">使用harbor-go-client</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#镜像清理策略"><span class="nav-number">10.6.2.</span> <span class="nav-text">镜像清理策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#harbor镜像复制"><span class="nav-number">10.7.</span> <span class="nav-text">harbor镜像复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建复制规则"><span class="nav-number">10.7.1.</span> <span class="nav-text">创建复制规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除replication规则"><span class="nav-number">10.7.2.</span> <span class="nav-text">删除replication规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项"><span class="nav-number">10.7.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Harborclient"><span class="nav-number">10.8.</span> <span class="nav-text">Harborclient</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见问题"><span class="nav-number">10.9.</span> <span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#证书问题"><span class="nav-number">10.9.1.</span> <span class="nav-text">证书问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件创建为目录问题"><span class="nav-number">10.10.</span> <span class="nav-text">文件创建为目录问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#汇总-docker常用命令"><span class="nav-number">11.</span> <span class="nav-text">汇总-docker常用命令</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XiaoHua WANG</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("mlSs9Cm0Xv2D9B7cFqbp25Df-gzGzoHsz", "alKheIFly9OVC81YCV7otTrf");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
